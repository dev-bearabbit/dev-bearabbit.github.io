<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>많이 늦은 『데이터 분석을 위한 줄리아』 번역 후기</title>
    <link href="/ko/Julia/julia-0/"/>
    <url>/ko/Julia/julia-0/</url>
    
    <content type="html"><![CDATA[<p>이번 글은 IT 도서 번역을 처음 시작하게 된 계기와 그 과정을 통해 느낀 점들을 정리하여 공유합니다. <span id="more"></span></p><hr /><h2 id="들어가며">들어가며</h2><p>사실 내가 번역한 책은 2024년 3월에 출간하였다. 너무 늦은 후기이지만 그동안 정신없었던 일상을 정리하면서 최근에서야 회고할 수 있는 여유가 생겼다. 내게 또 번역할 수 있는 기회가 올지는 모르겠지만 혹시나 하는 마음에 어려웠던 점과 좋았던 점을 남겨보려고 한다.</p><p>놀랍게도 처음 번역을 맡게된 것은 출판사에서 연락이 와서이다. 이전에 한참 <code>Julia</code>라는 언어에 빠져 공부하면서 블로그에 이런저런 글들을 정리해두었는데 아마 그걸 보시고 연락을 주신 것 같았다. 평소에 내가 IT 도서를 사서 보던 출판사였기에 너무 신기하기도 했고, 이렇게 좋은 기회를 거절할 이유가 전혀 없었다. 그동안 영어로 된 논문과 글만 얼마나 읽었는가! 번역은 어렵지 않을꺼라는 막연한 생각을 했었다. 그래서 나는 바로 출판사 팀장님께 진행해보고 싶다고 답장을 드렸다.</p><figure><img src="/images/197.jpeg" alt="멈추고 더 생각해" /><figcaption aria-hidden="true">멈추고 더 생각해</figcaption></figure><p>이때 생각을 더 했어야 했다.</p><h2 id="번역-시-어려웠던-점">번역 시 어려웠던 점</h2><p>처음에는 내가 공부하던 방식대로 하면 될 줄 알았다. 하지만 그것은 번역에 대해 아무것도 모르던 <code>무식의 힘</code>이었다.</p><p>먼저 번역을 한다는 것은 영어로 쓰여진 모든 기술 용어를 한국어로 변경하는 작업이었다. 여기서 첫 번째 문제가 발생한다. 나도 업계에서는 영어 그대로 쓰는 용어들이 너무 많았던 것이다. 예를 들어 에코 시스템, 네임드 튜플을 한국어로 어떻게 표현하는게 맞을까? 라는 고민부터 시작해서 parameter와 argument는 한국어로 뭐라고 정의하는게 맞지? 병기는 언제 해야할까? 등등 정말 기본적인 용어조차 뭐가 맞는건지 선택하는게 어려웠다.</p><p>두 번째로 어려웠던 점은 문맥을 그대로 옮기는 작업이었다. 영어 기반으로 작성된 글은 기본적으로 복합 문장이 많았다. 한국어의 경우 두 문장이나 3개의 문장으로 나눠서 적어야 더 깔끔할 수 있는데, 영어는 <code>which</code>나 <code>that</code>으로 모두 묶어서 쓰는 것이다. 또한 영어는 형용사가 뒤에서 명사를 수식하여 설명하는 경우가 많아 그대로 번역하면 흔히 <code>머리가 무거운 문장</code>들이 생겨났다. 그대로 번역하자니 문장이 너무 길어져서 의미가 헷갈려지고, 또 나누자니 원작자의 의도가 내 생각으로 재해석되는건 아닐까 두려워지는 것이다. 초반에 이게 무서워서 한 문장으로도 30분씩 고민했다. 하지만 점점 뒤로 갈수록 자연스레 나만의 방법과 규칙들이 생겨나긴 했다.</p><p>세 번째로는 직장인이라면 누구나 겪는 것! 바로 시간과의 싸움이다. 우리 회사는 재택이 베이스이기 때문에 사무실 출퇴근 시간이 세이브되고 나름 시간적인 여유가 많다고 생각했다. 하지만 직장인은 일과 가정만 운용해도 하루가 바쁘다. 일이 바쁠 때는 가정이 편안하다가도 또 일이 여유로워지면 가정에 사건사고가 터지곤 한다. 나 또한 다를 바 없었다. 일이 바쁠 때는 일감을 쳐내느라 정신이 없었고, 일을 끝내고 뒤돌아보니 가족이 아파 병간호를 하는 등 해결해야 할 또다른 이슈들이 존재했다. 번역은 생각보다 시간이 많이 필요한 작업이고 특성 상 한번에 오래 앉아서 챕터 별로 해야 문맥이 매끄럽게 연결된다. 마감일자의 압박 속에서 나는 이 모든 것들을 완료해야 했다.</p><h2 id="번역을-하며-얻은-것">번역을 하며 얻은 것</h2><p>하지만 번역 작업을 진행해서 후회하는가? 라고 묻는다면 당연히 아니다. 오히려 이런 기회가 내게 찾아와서 영광이라고 생각한다.</p><p>번역을 하면서 <code>기본적인 개념</code>들을 다시 한번 공부할 수 있었다. 업계 용어로 퉁쳐서 비교적 러프하게 알고 있던 개념들을 번역이라는 작업을 하면서 내 언어로 안착시키고 그게 결국 더 깊은 이해로 이어졌다. 역시 제대로 공부하려면 내 언어로 만들라는 말이 실제로 맞는 거구나라는 걸 느꼈다.</p><p>또 번역을 진행하면서 <code>Julia</code> 언어에 대한 이해도가 높아졌다. 이전에는 개념서만 보고 내 방식대로 개발을 진행했었는데 이 책은 줄리아 언어 생태계를 설명하고 실용적인 사용법을 정리해두었기에 새로 알게된 것들이 많았다. 주로 사용하던 2020년보다는 확실히 많이 발전했다는게 몸소 느껴져서 더욱 신기했다.</p><p>마지막으로 <code>번역</code>이라는 분야에 도전해볼 수 있어서 좋았다. 사실 아무에게나 주어지는 기회라고 생각하지 않는다. 책 번역 프로젝트가 어떻게 추진되고 계약이 이루어지는지 등 업계 프로세스에 대한 전반적인 과정들을 배울 수 있었다.</p><h2 id="마무리">마무리</h2><p>번역 경력도 없고, 어떻게 보면 주니어 커리어를 가진 내가 이런 경험을 할 수 있게 되어 너무 감사하다. 모든 면이 초보라서 답답한 부분도 많았을텐데 이 프로젝트를 함께해 주신 출판사 팀장님과 주변 분들께 감사드린다. 다음 번역 기회가 온다면, 그땐 더 좋은 번역을 할 수 있도록 평소에도 공부를 많이 해두어야겠다.</p><p>혹시나 번역한 책이 어떤건지 더 궁금한 분들을 위해 <a href="https://blog.naver.com/jeipubmarketer/223381130430">책 소개 페이지</a>를 첨부한다.</p>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>데이터분석</tag>
      
      <tag>julia</tag>
      
      <tag>translate</tag>
      
      <tag>번역</tag>
      
      <tag>데이터분석을위한줄리아</tag>
      
      <tag>book</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>데이터 웨어하우스를 만들어주세요, 제발</title>
    <link href="/ko/Engineering/engineering-5/"/>
    <url>/ko/Engineering/engineering-5/</url>
    
    <content type="html"><![CDATA[<p>데이터 엔지니어로서 일하면서 뼈저리게 느꼈던 데이터 웨어하우스의 중요성과 효과적인 구축 방법에 대해 공유합니다. <span id="more"></span></p><h2 id="시작하며-밑빠진-독에-물-붓기">시작하며: 밑빠진 독에 물 붓기</h2><p>벌써 데이터 엔지니어라는 이름으로 커리어를 시작한지 벌써 4년이 흘렀다. 지금 머물러 있는 회사에서 일한지는 거의 3년이 다 되어 간다. 처음 왔을 때는 RDS만 복제해서 데이터 프로덕트를 만들기 급급하던 구조였는데, 어느새 메달리온 아키텍처로 데이터 레이크를 안정적으로 구축하고 데이터 제품의 품질을 고민하는 위치까지 올라왔다. 이번 글에서는 2024년동안 데이터 웨어하우스를 구축하면서 데이터 품질을 높이기 위해 했던 노력들을 정리해보려고 한다.</p><p>주변에서 이야기를 들어 보면 다음과 같은 이유로 데이터 웨어하우스가 계륵같은 경우가 많았다.</p><ul><li>대부분 데이터팀은 소규모로 운영되기 때문에 너무 바쁘다.</li><li>제대로 구성하고 사용하려면 리소스가 상당히 많이 소요된다.</li><li>제품에 도달하기까지 하나의 레이어가 추가되는 것이라서 상당히 번거롭다.</li><li>들어가는 리소스 대비 그게 왜 필요한지 아직 잘 모르겠다는 사람들도 있었다.</li></ul><p>그래서 아예 없는 회사도 있었고, 그냥 OBT(One Big Table)로 구성하거나 자주 사용되는 테이블의 데이터 타입을 전처리 정도만 해두고 데이터 웨어하우스라고 칭하는 경우가 대부분이었다.</p><p>우리 회사도 마찬가지였다. 그 상태로 대시보드나 지표 산정을 각각의 사람들이 진행하다보니 매번 제품마다 값이 달랐고, 기술부채는 날로 쌓여갔다. 이런 환경에서 유지보수만 계속 하는 건 마치 <code>밑빠진 독에 물 붓기</code>였다.</p><figure><img src="/images/196.png" alt="다소용없어!" /><figcaption aria-hidden="true">다소용없어!</figcaption></figure><h2 id="데이터-웨어하우스가-필요한-이유">데이터 웨어하우스가 필요한 이유</h2><p>데이터 웨어하우스가 존재하지 않으면 생기는 문제들을 크게 정리해보면 다음과 같다.</p><ol type="1"><li><p>데이터 품질 관리가 어렵다.</p><ul><li>동일 지표 조건이 개발자마다 달라서 혼동이 온다.</li><li>백엔드팀에서의 로직 변경 사항이 전달되지 않아 구 버전 로직이 사용되는 경우도 생긴다.</li><li>로직이 변경되었을 때 수정해줘야 하는 범위를 확인하기 어렵다.</li></ul></li><li><p>파이프라인 코드 관리가 어려워진다.</p><ul><li>각자 자유롭게 파이프라인을 생성하다 보니, 퇴사자가 발생하면 유지보수가 불가능하다.</li><li>어떤 제품이 존재하는지조차 데이터팀 내에서 공유되지 않는다.</li><li>매번 유지보수에 지나치게 많은 시간과 비용이 소모된다.</li></ul></li></ol><p>데이터 웨어하우스는 데이터 품질 관리와 효율적인 코드 관리의 중심 역할을 한다. 예를 들어, 우리 회사의 GMV를 정의한다고 할 때 어떤 사람은<code>pay_time</code>을 기준으로 데이터를 추출하고 또 다른 사람은 주문의 <code>create_time</code>을 기준으로 추출하는 경우가 자주 발생한다. 이처럼 지표 정의가 사용자마다 달라지면 데이터의 신뢰성과 일관성이 훼손된다. 따라서 GMV 산식 기준이 정해지면 이를 바탕으로 웨어하우스에 GMV 컬럼이 추가된 테이블을 생성하고 모든 제품에서 GMV 값을 여기서 가져가도록 설계한다. 이렇게 설계하면 만약 나중에 GMV 산식이 변경되더라도 웨어하우스의 파이프라인만 변경하면 모든 지표들이 업데이트 된다.</p><p>또한 백엔드에서 주요 로직이 변경되거나 서버 장애 등으로 정합성 이슈가 발생한 경우, 웨어하우스 담당자만 해당 작업을 반영하면 빠르게 조치가 가능하다. 만약 각각의 데이터 제품이 서로 다른 파이프라인을 사용하면 수정해야 할 작업량이 기하급수적으로 늘어나고 유지보수가 불가능한 상태에 빠진다. 결국 몇 번의 퇴사와 입사를 거치면서 대규모 레거시가 쌓이며, 이는 마치 박물관의 유물처럼 트러블슈팅만을 위한 존재로 전락하게 되는 것이다. 데이터 웨어하우스는 이런 문제들을 막을 수 있는 훌륭한 수단이다.</p><p>우리 회사 또한 위와 같은 문제를 해결하기 위해, 데이터 웨어하우스를 구축하기로 결정했다.</p><h2 id="데이터-웨어하우스-구축-방법">데이터 웨어하우스 구축 방법</h2><p>자 이제 데이터 웨어하우스를 만들어보자. 뭐부터 해야 할까? 처음에는 <code>서비스 도메인들을 이해</code>해야 한다. 우리 회사의 경우도 큰 서비스 내에 여러 개의 도메인이 분리되어 있다보니 각 도메인마다 비즈니스 로직이 달랐다. 비즈니스 로직을 이해해야 데이터 모델링 시 범주를 산정할 수 있다.</p><p>그 다음으로는 비즈니스 로직에 연결된 <code>운영 데이터를 이해</code>하는 것이다. 분석 데이터는 기본은 결국 서비스에서 생성되는 데이터이다. 따라서 서비스 DB 로직을 모른다면 웨어하우스를 만들 수 없다. 운영 데이터를 이해하려면 백엔드팀에 여쭤보기도 하고 히스토리 문서를 읽기도 하고 직접 스키마 확인하면서 쿼리해보는 수밖에 없다.</p><p>그렇게 어느정도 데이터에 대한 공부가 끝나면 이제 개발 단계로 나아갈 수 있다.</p><p>먼저 <code>데이터 모델링 설계</code>이다. 해당 작업에서는 비즈니스 로직과 데이터를 바탕으로 <code>스타 스키마</code> 또는 <code>눈송이 스키마</code> 구조를 선택하여 데이터 모델을 설계한다. 스타 스키마와 눈송이 스키마를 자세히 알고 싶다면 <a href="https://dev-bearabbit.github.io/ko/Engineering/engineering-4/">해당 글</a>을 참고하길 바란다. 스키마 선택 외에도 몇 가지 알아두면 좋은 요소들은 다음과 같다.</p><ul><li>공통 지표를 먼저 정의하고 그에 맞게 모델링 구성하기</li><li>테이블 통합 시 사용할 논리 PK를 따로 구성하기</li><li>데이터 정합성 라벨링하기: VALID, BAD_DATA, INVALID 등</li><li>데이터 모델링 시 문서를 최대한 자세히 써두기</li><li>INSERT, UPDATE 시간을 따로 컬럼으로 추가해두기</li></ul><p>데이터 모델링 작업이 끝나면 다음으로는 <code>ETL/ELT 파이프라인을 설계</code>하는 것이다. 파이프라인의 경우 모델링 결과에 따라 <code>INSERT</code>나 <code>UPDATE</code> 구조로 구성된다. 따라서 <code>UPSERT</code>를 지원하는 플랫폼을 사용하는게 좋다. 우리 팀에서는 Spark에 오픈소스 Delta Lake 라이브러리를 추가하여 UPSERT를 구현하고 있다. 또한 Airflow에 일배치로 구성하여 메일 최신 데이터가 업데이트 또는 추가 되도록 구성하였다. 매번 Dag를 구성하는게 귀찮을 때는 템플릿을 만들어 사용하면 편하다.</p><p>그 다음에는 웨어하우스에 있는 테이블 스키마를 정리하고 공유하는 환경을 구성해야 한다. 보통 <code>데이터 카탈로그 플랫폼을 구성</code>하여 공유한다. 우리 팀의 경우에는 데이터허브(datahub)를 구축하여 사용하고 있다. 처음 테이블을 모델링하고 생성할 때 바로 카탈로그에 적어두지 않으면 나중에 눈덩이처럼 불어난 일감을 만나게 될 것이다.</p><p>마지막으로는 <code>품질 관리와 테스트 시스템을 구성</code>하는 것이다. 웨어하우스에 있는 데이터는 품질이 보장된다는 것을 전제로 한다. 따라서 웨어하우스를 유지보수하는 엔지니어는 언제나 품질 관리와 테스트를 고민하게 될 것이다. 품질 관리에 포함되는 요소는 아래과 같다.</p><ul><li>데이터 정합성 테스트</li><li>NULL 값 체크</li><li>중복 데이터 제거</li><li>과거 데이터 변동 및 이상치 확인</li></ul><p>사실 서비스를 운영하다보면 비즈니스 로직이나 운영 데이터 로직은 계속 변화한다. 결국 데이터 품질 관리란 이러한 변화를 사람이 인지하고 이해하여 꾸준히 반영해주는 작업이다. 이러한 이유로 데이터 웨어하우스를 구축하고 관리하는 데는 더 많은 리소스가 소요된다. 하지만 이런 여과기를 갖추지 않고 제품을 만든다면, 규모가 확장되는 어느 순간에는 되돌리기 어려운 기술부채를 쌓아가는 양산소가 될 가능성이 크다.</p><p>위 내용을 정리해보면 아래와 같다.</p><ol type="1"><li>공부 단계<ul><li>서비스 도메인 별 비즈니스 로직을 이해한다.</li><li>서비스 운영 데이터 DB 로직을 이해한다.</li></ul></li><li>개발 단계<ul><li>데이터 모델링을 설계한다.</li><li>ETL/ELT 파이프라인 설계 및 개발한다.</li><li>데이터 카탈로그를 구축한다.</li><li>품질 관리 및 테스트 시스템을 구축한다.</li></ul></li></ol><h2 id="결론-제발-데이터-웨어하우스를-만들어주세요">결론: 제발 데이터 웨어하우스를 만들어주세요</h2><p>데이터 웨어하우스는 데이터팀의 기반을 튼튼히 다지는 플랫폼으로, 데이터 품질과 코드 유지보수를 책임지는 핵심 역할을 한다. 앞서 언급한 문제점과 목표를 해결한다면, 데이터팀의 생산성과 효율성은 크게 향상될 것이다. 데이터 웨어하우스는 단순히 데이터를 쌓아두는 저장소가 아니라, 데이터를 체계적으로 관리하고 신뢰할 수 있는 정보를 제공하는 데이터팀의 심장이라고도 볼 수 있다. 제품 규모가 비교적 관리가 가능할 때 미리미리 해당 인프라를 구성해두지 않는다면 그 데이터팀은 아마 유지보수 지옥이 될 가능성이 상당히 높다. 그러니 이 글의 결론은, 제발 초기 플랫폼을 구성할 때 데이터 웨어하우스를 구축해서 이런 혼란을 방지했으면 좋겠다.</p>]]></content>
    
    
    <categories>
      
      <category>BigData</category>
      
      <category>engineering</category>
      
    </categories>
    
    
    <tags>
      
      <tag>데이터웨어하우스</tag>
      
      <tag>warehouse</tag>
      
      <tag>빅데이터</tag>
      
      <tag>DW</tag>
      
      <tag>데이터품질</tag>
      
      <tag>quality</tag>
      
      <tag>파이프라인</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>직장인 개발자의 학점은행제 수강 및 등록 후기</title>
    <link href="/ko/Academic/academic-1/"/>
    <url>/ko/Academic/academic-1/</url>
    
    <content type="html"><![CDATA[<p>대학원 진학을 준비하는 과정에서 컴퓨터공학 전공수업 학점은행제를 수강했던 과정을 공유합니다. <span id="more"></span></p><hr /><h2 id="시작하며">시작하며</h2><p><a href="https://dev-bearabbit.github.io/ko/Academic/academic-0/">이전 글</a>에서 대학원 준비를 위해 학점은행제 수업을 수강신청 했다는 내용을 공유했다. 이번 글에서는 성적과 이후 학점을 등록하는 방법에 대해서 설명하려고 한다. 우선 성적부터 시원하게 공개하고 넘어가겠다.</p><figure><img src="/images/191.png" alt="2024년 2학기 성적표" /><figcaption aria-hidden="true">2024년 2학기 성적표</figcaption></figure><p>회사 다니면서 나름 열심히 수업을 들었다. 특히 한국기술교육대학교에서는 맥북으로는 시험을 볼 수 없어서 급하게 친구한테 윈도우 랩탑을 빌려서 시험을 보기도 했다. 혹시 해당 학교에서 수업을 듣고 싶다면 무조건 <code>윈도우 OS</code>가 탑재된 데스크탑이나 랩탑이 필요하다는 점을 알려주고 싶다. AWS EC2 서버를 켜서 원격으로 접속도 해봤는데 해당 페이지 보안프로그램에 mac 주소를 잡아서 소용이 없었다.</p><h2 id="학점-등록하는-방법">학점 등록하는 방법</h2><p>나는 한국기술교육대학교에서 수업을 들었지만 학점등록은 <a href="https://www.cb.or.kr/creditbank/base/nMain.do">학점은행제 홈페이지</a>에서 신청해야 했다.</p><figure><img src="/images/192.png" alt="학점은행제 홈페이지" /><figcaption aria-hidden="true">학점은행제 홈페이지</figcaption></figure><p>해당 사이트에서 <code>학점인정 신청</code>으로 들어오면 아래 사진처럼 신청할 수 있는 학점이 보인다.</p><figure><img src="/images/193.png" alt="학점인정 신청" /><figcaption aria-hidden="true">학점인정 신청</figcaption></figure><p>등록하기 전에는 몰랐는데 알고 보니 학점을 등록하는 것도 돈을 지불해야 했다. 한 수업 당 4,000원 비용이 부과된다. 나의 경우 총 4개의 강의를 신청해야 했기에 12,000원을 결제했다.</p><figure><img src="/images/194.png" alt="결제 진행" /><figcaption aria-hidden="true">결제 진행</figcaption></figure><p>결제를 완료하면 카톡으로 신청이 완료되었다는 안내가 온다. 이렇게 학점 등록까지 완료해야 진짜 컴퓨터공학 학점을 얻게 되는 것이다.</p><figure><img src="/images/195.png" alt="등록 완료 안내" /><figcaption aria-hidden="true">등록 완료 안내</figcaption></figure><p>이렇게 2024년 하반기에 진행했던 한 챕터를 마무리 하였다. 사실 16주차를 매번 수업 8개씩 듣는 건 쉽지 않았다. 한 수업 당 2~3시간씩 소요되는데 토요일 4개, 일요일 4개 들으면 주말이 사라졌다. 비록 직장을 다니다보니 최선을 다하지는 못했지만 나름 노력했는데 괜찮은 성적을 받게 되어 만족스럽다. 앞으로도 계속 노력하자.</p><h2 id="이후-계획들">이후 계획들</h2><p>내가 속한 업계가 격변의 순간에 직면해 있다보니 요즘 더 고민이 많다. 빠르게 새로운 기술들이 등장하고 있으며, 회사에서는 도전해볼 수 있는 과업들도 계속 눈에 밟힌다.그래서 이번 년도에 계획했던 대학원 진학을 내년으로 미뤄둘까 한다. 업계에 속해 있을 때 최대한 경험할 수 있는 것들을 누리고 내 자산으로 만들어보고 싶다.</p><p>일단 2025년 상반기에는 <code>Coursera 강의</code>를 들으면서 지금 배우고 싶은 것들을 배우고자 한다. 회사에서 지원해주는 교육비로 1년 등록을 해두었기 때문에 영어 공부할 겸, 실무에 필요한 기술도 공부할 겸, 겸사겸사이다. 공부하는 내용들은 블로그에 꾸준히 기록하고자 한다. 영어 블로그도 오픈했기에 이것도 열심히 운영해볼 계획이다. 2025년, 열심히 살아보자.</p>]]></content>
    
    
    <categories>
      
      <category>etc.</category>
      
      <category>academic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>직장인</tag>
      
      <tag>엔지니어</tag>
      
      <tag>개발자</tag>
      
      <tag>대학원</tag>
      
      <tag>학위</tag>
      
      <tag>학점은행제</tag>
      
      <tag>컴퓨터공학</tag>
      
      <tag>비전공</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AWS Personalize 비용, 이렇게 계산하면 망한다</title>
    <link href="/ko/Lesson/lesson-0/"/>
    <url>/ko/Lesson/lesson-0/</url>
    
    <content type="html"><![CDATA[<p>이번 글에서는 AWS Personalize를 사용하면서 예상치 못한 비용 폭탄을 맞은 이유와 배운 점을 정리합니다. SaaS의 함정을 피하고 싶은 이들에게 작은 도움이 되길 바랍니다.</p><span id="more"></span><hr /><h2 id="사건-발단">사건 발단</h2><p>나는 CRM 발송 모수를 추출하는 도구를 개발하고 테스트하고 있다. 이 과정에서 당연히 personalize 가격을 비교해보고 예상 소요 비용까지 컨플루언스 문서로 정리하여 리드께 보고드렸으며, 비용 확인 후 기존 방식과 모델 모수와의 A/B 테스트를 진행하고 있었다. 참고로 내가 사용한 레시피는 아이템-유저 세그멘테이션을 위한 <code>aws-item-affinity</code> 였다.</p><p>하지만 오늘 아침에 갑자기 personalize 비용이 확 증가했다는 알림을 받았다. 분명 내가 계산한 대로라면 미미한 금액인데 어떻게 비용 폭탄을 맞게 되었을까..? 등골이 너무 서늘했다. 아직 원인은 전혀 모르지만 무언가 단단히 잘못된 느낌...급격히 불안해진 나는 빠르게 상황을 분석하기 시작했다.</p><figure><img src="/images/188.png" alt="이게무슨일이야" /><figcaption aria-hidden="true">이게무슨일이야</figcaption></figure><p>그렇게 오전 근무 시간 내내 <a href="https://aws.amazon.com/ko/personalize/pricing/">aws personalize 요금 페이지</a>만 보면서 사용량에 따른 비용만 계속 계산해보았다. 그렇다가 마침내 원인으로 파악되는 부분을 찾았다.</p><h2 id="원인-파악">원인 파악</h2><p>원인은 바로 배치 추론 job에 있었다. 사실 데이터셋 비용과 훈련 비용은 단일 건수이기도 하고 그렇게까지 부담스러운 비용이 아니었는데 배치 추론 비용에서 폭탄을 맞게 된 것이었다. 그렇다면 일단 AWS 공식 홈페이지에 있는 요금 설명을 확인해보자.</p><figure><img src="/images/189.png" alt="배치추론가격표" /><figcaption aria-hidden="true">배치추론가격표</figcaption></figure><p>위 사진에 있는 표가 배치 추론 생성 시 발생하는 비용을 계산하는 기준이다. 여기서 나는 <code>Users in dataset</code>의 개념을 요청하는 사용자 수라고 이해했다. 즉, 10만명의 요청까지는 세그먼트 요청 당 <code>$0.016</code>이며 10만명부터 90만명 요청까지는 <code>$0.008</code>이라고 이해한 것이다. 그래서 만약 내가 총 10개의 아이템에 대한 유저를 각각 1만명씩 추출해달라고 요청한다면 비용은 아래와 같이 계산된다고 생각했다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">10000</span>/<span class="hljs-number">1000</span> * <span class="hljs-number">0.016</span> * <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>하지만 저 <code>Users in dataset</code>은 <code>Total Users in dataset</code>이었다. 내가 아이템 당 몇명을 추론 요청을 하던 그와 상관없이 내가 훈련 시 사용한 모든 유저의 수를 기준으로 측정해야 했던 것이다. 나는 1년 데이터를 기준으로 했기에 대략 60만명이었다. 따라서 위 예시에 대한 정확한 값은 다음과 같다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">Tier_1 = <span class="hljs-number">100000</span>/<span class="hljs-number">1000</span> * <span class="hljs-number">0.016</span> * <span class="hljs-number">10</span><br>Tier_2 = <span class="hljs-number">500000</span>/<span class="hljs-number">1000</span> * <span class="hljs-number">0.008</span> * <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>내가 처음 이해했던 계산식에서는 <code>$1.6</code> 였는데 실제 청구되는 비용은 <code>$56</code> 였던 것이다. 물론 제대로 확인하지 않은 100% 내 잘못이다. 지금 생각해보면 너무 저렴했던 것도 이상하고 다시 한번 확인해봤으면 좋았을 걸 싶다. 하지만 동시에 저 계산표 일부러 헷갈리게 만든 것인가 싶고 괜스레 AWS에 뒤통수 맞은 기분이었다. 추론 시에 요청하는 사용자 수가 아예 비용 계산식에 안들어갈꺼라고는 생각도 못했다.</p><figure><img src="/images/190.png" alt="이전으로돌아갈래" /><figcaption aria-hidden="true">이전으로돌아갈래</figcaption></figure><p>그렇다. 클라우드 생태계에서 SaaS 사용 시 비용계산을 잘못한다면 앱은 정상작동할지라도 엄청난 멍청비용을 지불하게 될 것이다. 개발자로 일하면서 비용으로 인해 처음 포스트모템 문서를 작성했다. 오랜만에 실수해서 그런지 조금 많이 착잡했다. 혹시나 비용계산 시 나같이 헷갈리는 사람이 있을까봐 수치스럽지만 블로그에 남겨둔다.</p><h2 id="배운-점">배운 점</h2><ul><li>클라우드는 비용이 진짜진짜진짜 무섭다. 차라리 서버가 터지는게 맘편한가..아니야..그것도 지옥이야...</li><li>AWS 문서를 꼼꼼히 읽는 습관의 중요성을 기르자. 나말고 다른 분들과도 더블체크를 꼭 하자.</li><li>personalize 사용 시 추론 비용을 자세히 확인하자. 훈련 데이터셋 정보가 사용된다.</li></ul>]]></content>
    
    
    <categories>
      
      <category>etc.</category>
      
      <category>lessons</category>
      
    </categories>
    
    
    <tags>
      
      <tag>aws</tag>
      
      <tag>personalize</tag>
      
      <tag>pricing</tag>
      
      <tag>mistake</tag>
      
      <tag>aws-item-affinity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo에서 다국어(multilingual) 블로그로 커스텀하기</title>
    <link href="/ko/AboutHexo/about-hexo-5/"/>
    <url>/ko/AboutHexo/about-hexo-5/</url>
    
    <content type="html"><![CDATA[<p>Hexo 블로그에서 여러 언어를 지원하는 구조로 커스텀 하는 방법을 공유합니다.</p><span id="more"></span><hr /><h2 id="현재-상황">현재 상황</h2><p>현재 기술 블로그 상황은 아래와 같다.</p><ul><li>Hexo와 Fluid 테마를 사용 중이다.</li><li>Fluid 테마는 기본적으로 다국어를 지원하지 않는다.</li><li>다국어 지원을 위해 커스텀 개발이 필요했다.</li></ul><h2 id="커스텀-조건">커스텀 조건</h2><p>내가 원했던 커스텀 조건은 아래와 같다.</p><ul><li>기본 루트 url은 한국어로 두고, 영어만 <code>/en/</code> 경로로 리다이렉트 되도록 진행한다.</li><li>각 포스트는 독립적으로 작성되며, 언어별 카테고리나 태그도 언어 포스트에 맞게 구성되어야 한다.</li><li>Navbar에 언어 선택 드롭다운을 추가해 언어를 전환할 수 있어야 한다.</li></ul><h2 id="커스텀-설정">커스텀 설정</h2><p>커스텀 방법은 간단했다. 동일한 테마를 사용하는 <strong>2개의 hexo 블로그</strong>를 만들어서 navbar만 살짝 변경해주는 것이다. 위 조건을 만족하기 위해 블로그 배포 폴더와 소스코드 폴더를 아래와 같이 구성했다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">drwxr-xr-x  18 ryu  staff   576  1  2 06:33 deploy<br>drwxr-xr-x  13 ryu  staff   416  1  2 05:22 en-blog<br>drwxr-xr-x  11 ryu  staff   352  1  3 01:47 ko-blog<br></code></pre></td></tr></table></figure><ul><li><code>en-blog</code>: 영어 블로그 소스 코드 폴더</li><li><code>ko-blog</code>: 한국어 블로그 소스 코드 폴더</li><li><code>deploy</code>: 배포할 최종 파일만 모아두는 폴더</li></ul><p>처음 시작하는 경우, 아래의 명령어를 사용해 각각의 블로그 소스 코드를 생성할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init ko-blog<br>hexo init en-blog<br></code></pre></td></tr></table></figure><p>그 후에 각각의 블로그 폳더로 들어가서 원하는 테마를 다운받은 후 기본값을 셋팅해야 한다. 각각 독립적인 hexo 블로그이기 떄문에 셋팅도 각각 해주어야 한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 한국어 버전</span><br><span class="hljs-built_in">cd</span> ko-blog<br>npm install --save hexo-theme-fluid<br><br><span class="hljs-comment"># 영어 버전</span><br><span class="hljs-built_in">cd</span> en-blog<br>npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><p>나의 경우 한국어 버전을 root url로 사용할 예정이었기 떄문에 hexo <code>_config.yml</code>을 다음과 같이 설정하였다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 한국어 버전: /ko-blog/_config.yml</span><br>language: ko<br>url: https://dev-bearabbit.github.io<br>root: /<br>permalink: :lang/:title/<br><br><br><span class="hljs-comment"># 영어 버전: /en-blog/_config.yml</span><br>language: en<br>root: /en/<br>permalink: :lang/:title/<br></code></pre></td></tr></table></figure><p>이렇게 설정하면 <code>permalink</code>에 언어가 포함되기 때문에 포스트 작성 시 아래와 같이 <code>lang</code>을 꼭 작성해주어야 한다. 따라서 포스트 기본 레이아웃에 <code>lang</code>을 추가한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 한국어 버전: /ko-blog/scaffolds/post.md</span><br>---<br>title: &#123;&#123; title &#125;&#125;<br>lang: ko<br><span class="hljs-built_in">date</span>: &#123;&#123; <span class="hljs-built_in">date</span> &#125;&#125;<br>tags:<br>categories:<br>---<br><br><span class="hljs-comment"># 영어 버전: /en-blog/scaffolds/post.md</span><br>---<br>title: &#123;&#123; title &#125;&#125;<br>lang: en<br><span class="hljs-built_in">date</span>: &#123;&#123; <span class="hljs-built_in">date</span> &#125;&#125;<br>tags:<br>categories:<br>---<br></code></pre></td></tr></table></figure><p>다음으로는 각 테마의 소스코드에 들어가서 <code>navbar</code>에 언어를 변경할 수 있는 드랍다운을 추가한다. 여기서 사용중인 테마 <code>fluid</code>는 <code>layout/_partials/header/navigation.ejs</code>에서 추가할 수 있다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 한국어 버전: /ko-blog/themes/fluid/layout/_partials/header/navigation.ejs --&gt;</span><br><span class="hljs-comment">&lt;!-- 영어 버전: /en-blog/themes/fluid/layout/_partials/header/navigation.ejs --&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dropdown-menu&quot;</span> <span class="hljs-attr">aria-labelledby</span>=<span class="hljs-string">&quot;languageDropdown&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dropdown-item&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;</span>한국어<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dropdown-item&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/en/&quot;</span>&gt;</span>English<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>그 다음 선택된 언어 <code>navbar</code>에 나타나도록 하기 위해서 아래 스크립트도 추가해주었다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-comment">// 현재 언어를 URL 기반으로 감지</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> path = <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">pathname</span>;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> currentLang = path.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;/en/&#x27;</span>) ? <span class="hljs-string">&#x27;English&#x27;</span> : <span class="hljs-string">&#x27;한국어&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 선택된 언어를 버튼에 표시</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> currentLangElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;current-lang&#x27;</span>);</span><br><span class="language-javascript">    currentLangElement.<span class="hljs-property">textContent</span> = currentLang;</span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>마지막으로 <code>head.ejs</code>에 링크값을 추가한다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 한국어 버전: /ko-blog/themes/fluid/layout/_partials/head.ejs --&gt;</span><br><span class="hljs-comment">&lt;!-- 영어 버전: /en-blog/themes/fluid/layout/_partials/head.ejs --&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;alternate&quot;</span> <span class="hljs-attr">hreflang</span>=<span class="hljs-string">&quot;ko&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://dev-bearabbit.github.io/&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;alternate&quot;</span> <span class="hljs-attr">hreflang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://dev-bearabbit.github.io/en/&quot;</span> /&gt;</span>  <br></code></pre></td></tr></table></figure><p>이렇게 하면 설정은 완료된다.</p><h2 id="블로그-배포">블로그 배포</h2><p>현재 해당 블로그는 Github Page를 사용하여 배포되고 있다. 각각의 폴더에 들어가서 배포 파일을 만들어주자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 한국어 버전: ko-blog</span><br><span class="hljs-comment"># 영어 버전: en-blog</span><br>hexo clean<br>hexo generate<br></code></pre></td></tr></table></figure><p>위 명령어를 입력하면 아마 아래 폴더에 정적으로 컴파일된 배포 파일이 들어 있을 것이다.</p><ul><li>한국어 버전 배포파일: ko-blog/public/</li><li>영어 버전 배포파일: eo-blog/public/</li></ul><p>폴더에 들어있는 파일을 모두 <code>deploy</code> 폴더로 옮겨준다. <strong>여기서 중요한 핵심</strong>은 루트 url을 사용할 한국어 버전은 <code>deploy</code>에 바로 옮겨주고 /en/을 사용할 영어 버전은 <code>deploy/en/</code> 폴더에 옮겨주어야 한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -rf deploy/*<br><br><span class="hljs-built_in">mv</span> ko-blog/public/* deploy/<br><span class="hljs-built_in">mkdir</span> -p deploy/en/ &amp;&amp; <span class="hljs-built_in">mv</span> en-blog/public/* deploy/en/<br></code></pre></td></tr></table></figure><p>모두 옮겼다면 해당 <code>deploy</code> 폴더 파일만 깃허브에 배포한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 초반에만 셋팅</span><br><span class="hljs-built_in">cd</span> deploy<br>git init<br>git remote add origin https://github.com/&lt;username&gt;/&lt;repository&gt;.git<br><br><span class="hljs-comment"># deploy 폴더에서 배포진행</span><br>git add .<br>git commit -m <span class="hljs-string">&quot;Deploy folder initial commit&quot;</span><br>git push origin main<br></code></pre></td></tr></table></figure><p>그러면 다국어를 지원하는 hexo 블로그를 만들 수 있다.</p>]]></content>
    
    
    <categories>
      
      <category>etc.</category>
      
      <category>about hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>blog</tag>
      
      <tag>multilingual</tag>
      
      <tag>다국어</tag>
      
      <tag>영어 블로그</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>직장인 4년차, 미래를 준비하는 법</title>
    <link href="/ko/Academic/academic-0/"/>
    <url>/ko/Academic/academic-0/</url>
    
    <content type="html"><![CDATA[<p>4년차 직장인으로 부족한 부분을 채우기 위해 대학원 진학을 결정하고 준비하는 과정을 기록한 글입니다. <span id="more"></span></p><hr /><h2 id="시작하며">시작하며</h2><p>벌써 직장인 개발자로 일한지 3년이 지났다. 아직 아무것도 모르는 주니어 개발자이지만 그래도 마냥 모른다고만 넘길 수 없는 년차가 되었고, 또 어영부영 맡은 일들을 해내는 년차가 되었다. 신입 때는 이쯤되면 커리어 방향이 어느정도 결정될 거라고 생각했었는데 아직도 내 커리어는 한치 앞도 안보인다. 그나마 다행인건 계속 데이터 업계에 몸담고 있다는 것이다.</p><p>개발 경험이 쌓일수록 내게 부족한 부분들이 보였고 신경이 쓰였고 배움이 고파졌다. 이전에는 무엇을 모르는지 모르는 메타인지가 부족한 상태였다면 지난 3년의 경험이 내게 무엇이 부족한지 인지시켜 주었다. 눈만 돌리면 부족함 투성이라 아주 몸둘 바를 모르겠는 요즘이다. 그래서 나도 처음부터 하나하나 벽돌을 쌓아 튼튼한 집을 만들어가는 과정을 경험하고 싶어졌다. 그런 내게 주어진 선택지는 단 하나, 학업을 다시 이어가는 것이었다.</p><h2 id="왜-대학원인가">왜 대학원인가</h2><p>사실 다시 대학교를 가는 방법도 있다. 어차피 나는 유사전공도 아닌 완벽한 비전공자이고 대학교부터 시작하면 더 제대로 배울 수 있을 것이다. 나 또한 이 업계에 들어와서 수많은 사람들에게 방통대 컴공과를 추천받았기 때문에 더 고민이 되었다. 그래서 학업을 통해 내가 얻고 싶은게 무엇인지를 정리해보기로 했다.</p><ul><li>컴퓨터에 대한 깊은 이해</li><li>컴공 지식 습득</li><li>외국계 회사에 지원할 수 있는 학위</li><li>실무적 능력 향상</li><li>영어 공부</li></ul><p>그리고 요즘 내 전문상담가인 GPT 선생님께 물어보았다.</p><figure><img src="/images/186.png" alt="ques" /><figcaption aria-hidden="true">ques</figcaption></figure><p>선생님의 답변은 <code>대학원 진학</code>이었다. 나 또한 소요되는 시간이나 현실적인 조건을 따져봤을 때 대학원이 가장 적합한 선택지라는 생각이 들었다.</p><figure><img src="/images/187.png" alt="ans" /><figcaption aria-hidden="true">ans</figcaption></figure><p>하지만 직장인 신분으로 생계를 유지해가면서 대학원을 다니는 것은 쉽지 않은 선택이다. 그리고 좀 찾아보니 비용이 어마무시하게 들었다. 외국 대학원에 비해 한국 대학원이 좀 더 저렴할 줄 알았으나 천만의 말씀, 오히려 더 비쌌다. 직장과 병행할 수 있는 한국 대학원은 가격이 학기 당 평균 500만원에서 900만원 선이었다. 이건 내 예상과 많이 달랐다. 그리고 찾아 본 후기도 썩 좋지 못했다. 대부분 공부하고 싶다면 Coursera, edX, Udacity 같은 플랫폼을 추천했다.</p><p>기왕 돈을 주고 배우는 거라면 영어 공부도 할 겸 나를 낭떠러지에 밀어서 제대로 훈련하고 싶어졌다. 그래서 외국 대학원으로 눈을 돌렸다. 다행히 한국의 많은 개발자들이 외국 대학원 석사 온라인 코스를 진학하여 학업을 이어나가고 있었고, 그들이 남겨준 정보로 나 또한 준비를 시작하게 되었다.</p><h2 id="준비해야-하는-것들">준비해야 하는 것들</h2><p>확실히 외국 대학원은 한국같지(?) 않다. 후기를 보니 온오프라인 선발 방법론만 다른거지 수업도 엄청 빡세고 졸업도 쉽지 않다고 한다. 물론 입학을 위한 준비 과정도 꽤나 복잡했다. 먼저 필수로 준비해야 할 것들은 다음과 같다.</p><ul><li>공인어학성적</li><li>컴퓨터공학 강의 수강기록</li><li>대학교 성적증명서</li><li>이력서 및 경력기술서</li><li>직장동료나 교수님의 추천서 3개</li></ul><p>나는 위 목록에서 가지고 있는게 성적증명서와 이력서밖에 없었다. 다행히 추천서는 교수님과 직장동료분께 부탁드릴 수 있을 것 같지만 컴퓨터공학 수업은 들어본 적도 없으며, 공인어학성적도 만료된지 오래였다. 아마 영어 실력도 만료되지 않았을까 싶다. 그래서 내년 가을학기 지원을 목표로 1년간 천천히 준비하기로 했다. 공인어학성적은 그나마 이전에 경험이 있던 TOEFL 100점 이상을 목표로 공부하고, 컴퓨터공학 강의는 학점은행제를 통해 수강하는 것이다. 그렇게 1년간의 여정이 시작되었다.</p><h2 id="피터지는-수강신청">피터지는 수강신청</h2><p>학점은행제의 경우 먼저 <a href="https://www.cb.or.kr/creditbank/base/nMain.do">학점은행</a>에서 학습자 등록을 하고 학점을 획득할 수 있는 평생교육원에서 수업을 듣는 방식이다. 한국 대부분의 대학교에는 평생교육원이 있고, 컴퓨터공학 수업은 비교적 꽤 있었다. 하지만 한 강의 당 최소 7만원에서 30만원 정도 하기 때문에 여러 강의를 듣기에는 경제적 부담이 있다. 그래서 이것저것 찾아보던 찰나 한국기술교육대학교 평생교육원의 경우 무료로 수강이 가능하다는 것을 알게 되었다. 다만 한 학기 당 최대 4개의 강의만 수강이 가능하며, 수강 신청을 위해서는 정성스런 학업 계획서를 작성하여 교수님께 간택되어야만 한다는 것도 알게 되었다. 나는 기초로 듣기 좋은 수업을 4개 골라 2024년 9월 학기에 지원하였다. 학업 계획서는 대학시절 쓰던 레포트 경험을 살려 최대한 정성스럽게 작성하였다.</p><figure><img src="/images/184.png" alt="yeah" /><figcaption aria-hidden="true">yeah</figcaption></figure><p>내 간절함이 교수님께 닿은 걸까, 4강의 모두 들을 수 있게 되었다. 나를 선택해주신 교수님께 다시 한번 감사를 드린다.</p><figure><img src="/images/185.png" alt="acc" /><figcaption aria-hidden="true">acc</figcaption></figure><p>누구보다 빠르게 수강신청을 완료하였다. 이제 9월 수업이 열리기만을 기다리면 된다. 오랜만에 수업을 듣는다는 사실 하나로 참 마음이 설렌다.</p><h2 id="이후-계획들">이후 계획들</h2><p>올해는 아마 컴공 수업 듣고 TOEFL 시험을 준비하면 끝날 것 같다. 내년 상반기에 4과목을 추가로 수강하여 24학점을 만들고, 영어성적도 100점 이상을 만들 예정이다. 또 지금 실무도 열심히 해서 경력기술서를 좀 더 매력적으로 만들고 싶다. 내년 이맘때쯤은 대학원 합격 소식을 블로그에 올릴 수 있었으면 좋겠다.</p>]]></content>
    
    
    <categories>
      
      <category>etc.</category>
      
      <category>academic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>직장인</tag>
      
      <tag>엔지니어</tag>
      
      <tag>개발자</tag>
      
      <tag>대학원</tag>
      
      <tag>학위</tag>
      
      <tag>외국계</tag>
      
      <tag>학점은행제</tag>
      
      <tag>TOEFL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>요즘 유행하는 ChatGPT로 슬랙봇 만들기 2편</title>
    <link href="/ko/DeepLearning/deeplearning-1/"/>
    <url>/ko/DeepLearning/deeplearning-1/</url>
    
    <content type="html"><![CDATA[<p>LLM을 사용하여 사내가이드 슬랙봇 만드는 방법을 정리합니다. <span id="more"></span></p><hr /><h2 id="시작하며">시작하며</h2><p>1편 뒤에 바로 2편을 쓴다고 다짐했었지만 게으름과 귀찮음에 사로잡혀 이제서야 글을 써본다. 마음속의 내 모습은 갓생 사는 직장인인데, 현생에서는 그냥 일에 치이고 스트레스가 통제되지 않는 망나니에 가깝다. 언제나 스스로에게 실망하지만 포기하지 않고 끝까지 글을 써본다. 경험들을 하나씩 저장해두면 나중에 큰 자산이 될 것이라고 일단 믿어본다.</p><h2 id="설계도면">설계도면</h2><p>이번에 만든 슬랙봇 설계도는 다음과 같다.</p><ol type="1"><li>일배치로 원천 데이터를 업데이트 한다.</li><li>원천 데이터가 업데이트 된다면 Vector DB도 업데이트 한다.</li><li>Vector DB에는 문서 요약본과 문장(청크)이 구성되어 있다.</li><li>유사도 분석은 문장 단위로 진행된다.</li><li>질문에 가장 유사한 문장이 속한 문서 요약본을 GPT에 전달한다.</li><li>질문과 문서 요약본을 보내 정리된 답을 받은 후 슬랙봇을 통해 전달한다.</li><li>슬랙봇은 <code>@</code> 태그를 하거나 특정 채널에 글이 올라오면 쓰레드로 답변을 달아준다.</li></ol><h2 id="준비물">준비물</h2><p>슬랙봇을 만들기 위해서는 여러가지 준비물이 필요하다.</p><ul><li>VectorDB를 만들 원천 데이터</li><li>Slack 앱</li><li>OpenAi 토큰</li><li>응답을 반환해줄 서버</li><li>약간의 돈 (또는 회사의 지원)</li></ul><h2 id="개발-순서">개발 순서</h2><h3 id="원천-데이터를-수집-및-가공하기">1. 원천 데이터를 수집 및 가공하기</h3><p>우리 회사에서는 주요한 가이드를 모두 컨플루언스에 저장하고 관리하고 있었다. 따라서 개인 계정에서 API token을 하나 발급받아서 크롤링을 하면 된다. 크롤링은 빠르게 python의 requests 라이브러리를 사용하여 개발할 수 있다.</p><p>나의 경우 먼저 가져오려는 space 이름으로 <code>space id</code>를 가져온 후 해당 스페이스에 있는 모든 <code>page</code> 데이터를 가져왔다. <code>page</code> 데이터의 경우 사용자가 추가하거나 업데이트 할 수 있기에 일배치로 실행하였다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># space 이름으로 아이디 가져오기</span><br>url = <span class="hljs-string">&quot;https://&#123;your-domain&#125;/wiki/api/v2/spaces&quot;</span><br><br><span class="hljs-comment"># 특정 space id에 있는 모든 페이지 데이터 가져오기</span><br>url = <span class="hljs-string">&quot;https://&#123;your-domain&#125;/wiki/api/v2/spaces/&#123;id&#125;/pages&quot;</span><br></code></pre></td></tr></table></figure><p>API 관련된 자세한 설명은 <a href="https://developer.atlassian.com/cloud/confluence/rest/v2/intro/#about">컨플루언스 공식 페이지</a>에서 확인할 수 있다. token의 경우 요청을 날릴 때 <code>HTTPBasicAuth</code>를 사용하여 랩핑한 후 같이 보냈다. 아래 코드는 공식 API 가이드에 있는 예제 코드이다. 공식 페이지에 언어별로 잘 정리되어 있으니 참고하기 바란다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> requests.auth <span class="hljs-keyword">import</span> HTTPBasicAuth<br><br>auth = HTTPBasicAuth(<span class="hljs-string">&quot;email@example.com&quot;</span>, <span class="hljs-string">&quot;&lt;api_token&gt;&quot;</span>)<br><br>headers = &#123;<br>  <span class="hljs-string">&quot;Accept&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span><br>&#125;<br><br>response = requests.request(<br>   <span class="hljs-string">&quot;GET&quot;</span>,<br>   url,<br>   headers=headers,<br>   auth=auth<br>)<br></code></pre></td></tr></table></figure><h3 id="vector-db-생성하기">2. Vector DB 생성하기</h3><p>원천 데이터가 준비 완료되었다면 Vector DB를 생성한다. Vector DB를 생성하는 구조는 다음과 같다.</p><ol type="1"><li>원천 데이터 가져오기</li><li>요약본 만들기</li><li>임베딩하기</li><li>S3에 저장하기</li></ol><p>요약본을 생성하는 것은 랭체인(langchain)의 <code>TokenTextSplitter</code>를 사용하여 <code>Document</code>에 맞게 청크를 생성한 후 각각의 청크를 요약하고 이를 합치는 구조로 만들었다. 특히 <code>load_summarize_chain</code>를 사용할 때 chain_type을 <code>map_reduce</code>로 쓰지 않았는데 이는 테스트해보니 너무 많은 부분이 요약되었기 때문이다. 이 요약본의 목적은 이후 GPT에게 답변을 생성할 때 보내지는 데이터이다.</p><p>그 다음 <code>UnstructuredHTMLLoader</code>를 사용하여 HTML 구조의 데이터를 문장 별로 쪼개 train set을 만들었다. 이 문장들을 임베딩하여 이후 유사도 분석에서 사용한다. 임베딩의 경우 OpenAI의 임베더를 사용하였으며, 모델은 <code>text-embedding-3-large</code>를 사용하였다. OpenAI의 임베더의 경우 한번에 처리할 수 있는 문자의 길이가 8192이기 때문에 한 문장이 이를 넘는다면 쪼개서 작업해야 한다.</p><p>이렇게 하여 생성된 Vector DB의 컬럼은 다음과 같다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;version&quot;</span>, <span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;train&quot;</span>, <span class="hljs-string">&quot;summary&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>]<br></code></pre></td></tr></table></figure><p><code>id</code>나 <code>version</code>을 추가한 이유는 업데이트 로직을 위함이다. 사용자가 해당 컨플루언스 페이지를 업데이트하면 API로 데이터를 가져올 때 Version 매트릭이 +1 된다. 이를 이용하여 Vector DB도 변동값이 있는 페이지만 다시 생성하는 것이다. 이렇게 작업한 이유는 간단하다. 임베딩에는 돈이 들어간다. 이미 임베딩이 된 페이지를 다시 진행할 필요는 없기 때문이다.</p><p><code>url</code>의 경우에는 슬랙봇이 참고한 컨플루언스 URL을 같이 첨부해서 주기 때문이다. 이렇게 기획한 이유는 할루시네이션 이슈도 있고 더 자세한 정보를 알고 싶은 사용자에게 더 많은 데이터를 주기 위함도 있다.</p><p>참고로 요약 요청 시 보내는 프롬프트의 경우 매우 간단하게 설정하였다.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">너는 긴 문서를 정리하는 요약 도우미야. <br>내용 무엇도 제외하지 말고 최대한 요약해줘.<br>그리고 다음 규칙을 무조건 지켜야해.<br>규칙0. 글에 예외사항이나 Q&amp;A가 있는 경우에는 무조건 가져와줘<br>규칙1. 글에 시간, 증명자료, 지원여부 관련 설명이 있다면 무조건 가져와줘.<br></code></pre></td></tr></table></figure><p>이렇게 만들어진 Vector DB는 S3에 parquet 파일로 저장해둔다.</p><h3 id="유사도-분석-로직-개발하기">3. 유사도 분석 로직 개발하기</h3><p>이제 요리를 위한 재료 준비는 모두 끝났다. 조리 방법만 잘 정하면 된다. Vector DB를 다룰 수 있는 다양한 라이브러리들이 존재하지만 나는 FAISS를 사용했다. 특히 ChromaDB와 FAISS 중 무엇을 쓸지 고민했었는데 FAISS를 사용한 이유로는 다음과 같다.</p><ul><li>인덱싱이 빠르다.</li><li>코드를 유연하게 개발할 수 있다.</li><li>CPU 모드를 지원한다.</li><li>확장성이 좋다.</li></ul><p>나는 이 분야의 전문가가 아니라서 최대한 고수준 API나 기능들을 제공해주는 라이브러리를 쓰고 싶었는데 ChromaDB는 너무 무겁고 생각보다 사용성이 편리하지 않았다. 특히 지금처럼 간단한 인덱싱 작업을 할꺼라면 차라리 FAISS로 개발하는게 훨씬 편한 것 같았다. 이렇게 사용할 라이브러리는 대충 정해졌다. 빠르게 개발을 시작한다.</p><p>유사도 측정 알고리즘은 간단하게 내적을 이용하였다. 문장이 길지 않거니와 질문에 대한 정확한 답을 가져오는게 가장 우선시되었기 때문이다. 자세한 내용은 <a href="https://dev-bearabbit.github.io/2024/04/21/Package/pack-3/#more">해당 문서</a>에서 확인할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">index = faiss.IndexIDMap(faiss.IndexFlatIP(encoded_data.shape[<span class="hljs-number">1</span>]))<br></code></pre></td></tr></table></figure><h3 id="응답을-생성할-백엔드-서버-구축하기">4. 응답을 생성할 백엔드 서버 구축하기</h3><p>RAG 아키텍처에 맞춰서 질문과 함께 요청이 들어오면 다음과 같이 진행한다.</p><ol type="1"><li>질문을 임베딩하고 메모리에 올라가 있는 Vector DB에서 유사도 분석을 진행한다.</li><li>유사도가 가장 높은 20개의 요약본을 GPT에게 보내 최대 3개까지 질문에 대한 답이 있는 문서 ID를 달라고 요청한다.</li><li>GPT가 뽑아준 문서 ID의 원본을 다시 GPT에게 보내 사용자에게 반환될 응답을 생성한다.</li><li>슬랙 API로 응답을 보낸다.</li></ol><p>이는 간단한 fastapi 앱으로 개발하였다. 백엔드 서버의 경우 데이터팀이 구축 및 관리하고 있는 인프라 클러스터가 있어서 그 위에 살짝 올려두었으며, 매일 Vector DB가 업데이트 되면 다시 parquet 파일을 읽도록 설정해두었다. 이렇게 하면 Vector DB 사이즈가 작은 경우에는 따로 복잡한 미들웨어를 추가할 필요 없이 사용이 가능하다.</p><h3 id="슬랙-앱-생성하기">5. 슬랙 앱 생성하기</h3><p>마지막으로 직접적으로 사용자에게 제공할 인터페이스를 만든다. 슬랙 앱을 사용하는 방법은 <a href="https://slack.com/intl/ko-kr/help/articles/13345326945043-Slack-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%8F%84%EA%B5%AC%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%B4-%EC%95%B1-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0">slack 홈페이지</a>에도 잘 나와있다.</p><p>슬랙의 앱 디렉토리로 가서 새로 앱을 생성한 후 설정에 들어가서 몇 가지 조작만 해주면 된다. 나의 경우 Event Subscription 기능을 사용하여 특정 이벤트가 발생한 경우 백엔드 서버로 요청이 올 수 있도록 설정하였다. Event Subscription 기능에 대해서는 <a href="https://api.slack.com/apis/events-api#challenge">공식 문서</a>에서 자세히 확인할 수 있다.</p><h2 id="개발-후기">개발 후기</h2><p>처음 시작했을 때는 큰 기대 없이 호기심을 해결할 겸 공부할 겸 그렇게 겸사겸사 시작했었다. 하지만 생각보다 좋은 성능을 보여줬고, 사내에서도 반응이 꽤나 좋았다. 가장 잊어버리기 쉬운 와이파이 비밀번호나 프린터 사용법, 근무 규칙 등등의 질문들을 잘 답변해주었고 때로는 특정 업무의 담당자가 누구인지도 잘 설명해주었다. 아직 부족한 부분들도 보이지만 프로토 타입치고는 성능이 좋았다. 다음에는 시간되면 해당 슬랙봇의 성능을 높이기 위한 시도들도 해봐야겠다.</p>]]></content>
    
    
    <categories>
      
      <category>MachineLearning</category>
      
      <category>deep learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DeepLearning</tag>
      
      <tag>LLM</tag>
      
      <tag>ChatGPT</tag>
      
      <tag>RAG</tag>
      
      <tag>Prompt</tag>
      
      <tag>프롬프트</tag>
      
      <tag>AI</tag>
      
      <tag>인공지능</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>파이썬과 비교하며 배우는 러스트 프로그래밍 리뷰 1편</title>
    <link href="/ko/Rust/rust-12/"/>
    <url>/ko/Rust/rust-12/</url>
    
    <content type="html"><![CDATA[<p>『파이썬과 비교하며 배우는 러스트 프로그래밍』을 읽으며 기억해두면 좋을 것 같은 러스트 지식들을 정리합니다. <span id="more"></span></p><h2 id="파이썬-개발자-러스트를-배워야-하는-이유">파이썬 개발자 러스트를 배워야 하는 이유</h2><ul><li>파이썬의 연산 속도를 개선한다. pandas나 numpy는 이미 C++로 작성되어 있음.</li><li>멀티스레딩 구현이 훨씬 쉽다. 파이썬은 GIL(Global Interpreter Lock)로 멀티스레딩 성능이 좋지 못함.</li><li>개발도구가 매우 편리하다.</li></ul><p><strong>GIL(Global Interpreter Lock)란</strong><br />여러 스레드가 파이썬 코드를 동시에 싱행하지 못하도록 파이썬 객체들에 접근을 못하게 하는 뮤텍스.</p><h2 id="러스트가-많이-사용되는-분야">러스트가 많이 사용되는 분야</h2><ul><li>커맨드라인(CLI) 앱</li><li>고성능 네트워크가 필요한 분야</li><li>웹어셈블리</li><li>임베디드</li></ul><p><strong>웹어셈블리란</strong><br />자바스크립트가 아닌 다른 다양한 프로그래밍 언어로 작성한 코드를 웹 브라우저에서 직접 실행할 수 있게 하는 기술.</p><h2 id="러스트-기초-지식">러스트 기초 지식</h2><h3 id="cargo-사용법">Cargo 사용법</h3><ul><li>rust에서 빌드는 기본적으로 디버그 모드이다. 만약 릴리즈 모드로 컴파일하고 싶다면 옵션 <code>--release</code>를 붙여야 한다.</li><li><code>cargo fmt</code> 명령어를 사용하면 공백이나 줄바꿈 등 포맷을 한번에 정리할 수 있고, <code>cargo clippy</code> 명령어를 사용하면 린트를 확인할 수 있다.</li></ul><h3 id="코드-컨벤션">코드 컨벤션</h3><p>코드를 개발할 때 변수와 함수는 스네이크 표기법, 구조체는 파스칼 표기법, 상수는 스트리밍 스네이크 표기법 사용한다.</p><ul><li>스네이크 표기법: 소문자 + 언더바(_) (my_function)</li><li>파스칼 표기법: 첫글자 대문자 + 붙여쓰기 (MyStruct)</li><li>스트리밍 스네이크 표기법: 대문자 + 언더바(_) (MY_CONST)</li></ul><h2 id="데이터-타입">데이터 타입</h2><ul><li>러스트 자체 원시타입</li></ul><table><thead><tr class="header"><th>이름</th><th>타입</th></tr></thead><tbody><tr class="odd"><td>{n}비트 정수</td><td>i8, i16, i32, i64, i128</td></tr><tr class="even"><td>부호없는 {n}비트 정수</td><td>u8, u16, u32, u64, u128</td></tr><tr class="odd"><td>아키텍처</td><td>isize, usize</td></tr><tr class="even"><td>{n}비트 부동소수점 실수</td><td>f32, f64</td></tr><tr class="odd"><td>불리언</td><td>bool</td></tr><tr class="even"><td>문자</td><td>Char</td></tr></tbody></table><p>isize, usize는 컴퓨터가 32비트인지 64비트인지에 따라 값이 결정되는 기본 포인터 크기이다.</p><ul><li>std 라이브러리에서 제공되는 타입</li></ul><table><thead><tr class="header"><th>이름</th><th>타입</th></tr></thead><tbody><tr class="odd"><td>문자열</td><td>String</td></tr><tr class="even"><td>문자열 슬라이스</td><td>str</td></tr></tbody></table><p><strong>개인적인 의견</strong><br />책에는 문자열 슬라이스인 str이 원시타입에 들어있고 char이 없었는데 이 부분은 의아하다. 내가 알기로는 str은 std 라이브러리에서 제공하는 타입이고 char이 원시타입이었는데 말이다. 해당 진위여부는 나중에 좀 더 찾아봐야겠다 (내가 잘못 알고 있는 것일 수도 있다)</p><h2 id="익명함수-클로저">익명함수: 클로저</h2><ul><li>파이썬의 람다함수와 동일한 역할.</li><li>람다 함수는 반드시 한 줄로 작성해야 하지만 클로저는 중괄호로 묶으면 여러 줄 작성 가능함.</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//예시코드 1</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">my_func</span> = |x| x + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">my_func</span>(<span class="hljs-number">3</span>));<br>&#125;<br><br><span class="hljs-comment">//예시코드 2</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">my_func</span> = |x:<span class="hljs-type">i32</span>| <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123; x + <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">my_func</span>(<span class="hljs-number">3</span>));<br>&#125;<br><br><span class="hljs-comment">//예시코드 3</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">my_func</span> = |x:<span class="hljs-type">i32</span>| <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>        x = x + <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,x);<br>    &#125;;<br>    <span class="hljs-title function_ invoke__">my_func</span>(<span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="매크로">매크로</h2><ul><li>파이썬의 매크로는 매개변수 개수가 가변적임.</li><li>러스트에서는 token tree를 사용하여 받을 매개변수를 미리 정해두어야 함.</li></ul>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>rust</tag>
      
      <tag>book</tag>
      
      <tag>review</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FAISS 사용법 및 예제 코드</title>
    <link href="/ko/Package/pack-3/"/>
    <url>/ko/Package/pack-3/</url>
    
    <content type="html"><![CDATA[<p>다양한 인덱싱 방법을 제공하는 faiss 라이브러리에 대해서 알아보고 사용법을 정리합니다. <span id="more"></span></p><h2 id="faiss-란">FAISS 란</h2><p>FAISS(Facebook AI Similarity Search)는 페이스북에서 개발한 라이브러리로, 효율적인 유사도 검색과 대량의 벡터 클러스터링을 목적으로 개발되었다. 특히 고차원 공간에서의 벡터 검색에 최적화되어 있기에 이미지, 비디오, 텍스트 등의 데이터에서 유사한 아이템을 빠르게 찾을 수 있다.</p><p>FAISS의 주요 특징은 다음과 같다.</p><ul><li>효율성: 고차원 벡터의 유사성 검색을 빠르고 메모리 효율적으로 수행할 수 있도록 설계</li><li>확장성: 억 단위의 벡터와 같은 매우 큰 데이터셋도 처리할 수 있으며, 이는 대규모 시스템에서 유용하다.</li><li>유연성: 다양한 유사도 분석 방법과 인덱싱 방법을 제공한다.</li><li>이식성: C++로 작성되었으며 Python 인터페이스도 제공한다. 또한 GPU 버전을 설치하면 GPU에서도 사용 가능하다.</li></ul><h2 id="faiss의-동작-원리">FAISS의 동작 원리</h2><p>벡터 데이터를 기반으로 FAISS가 동작하는 방식은 다음과 같다.</p><ul><li>임베딩을 통해 유사도를 검색할 전체 데이터를 벡터 형태로 생성한다.</li><li>인덱스를 구축하고, 전체 데이터 벡터를 인덱스에 추가한다.</li><li>검색문장을 임베딩하고 유사도 검색을 진행한다.</li></ul><h3 id="인덱싱-방법">인덱싱 방법</h3><p>인덱싱(Indexing)이란 벡터 데이터를 효율적으로 관리하고 검색하기 위해 어떻게 구성하고 저장할지에 대한 방법론이다. 즉, 데이터를 어떻게 분할하고 어떤 구조로 저장할지에 대한 전략이다. 따라서 인덱싱은 "정확한" 유사 데이터를 반환하는 것보다는 빠르게 검색 결과를 반환할 수 있도록 검색 성능을 높이는 데 초점이 맞춰져 있다. faiss에서 제공하는 인덱싱 방법은 크게 flat, Quantization 2가지이다.</p><table><thead><tr class="header"><th>이름</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>Flat Index</td><td>- 데이터를 아무런 압축이나 구조 변경 없이 메모리에 그대로 저장한다. <br> - 검색 시 모든 벡터와의 거리를 계산(브루트-포스 방식)하여 가장 가까운 벡터를 찾는다. <br> - 정확도는 가장 높지만 벡터의 양이 많을 때는 매우 성능이 매우 떨어질 수 있다. <br> - 규모가 작고 정확도가 중요한 경우 사용</td></tr><tr class="even"><td>Product Quantization(PQ)</td><td>- 고차원 벡터를 여러 개의 하위 벡터로 분할하고, 각 하위 벡터를 독립적으로 양자화한다. <br> - 각 하위 벡터에 대해 독립적인 양자화 코드북을 생성한다. <br> - 벡터를 압축하여 메모리 사용을 줄이면서 검색 속도를 높인다. <br> - 대규모 고차원 데이터셋의 유사도 검색에서 많이 사용</td></tr><tr class="odd"><td>Scalar Quantization(SQ)</td><td>- 각 차원의 데이터를 독립적으로 양자화한다. <br> - 벡터를 스칼라로 전부 분해한 후 미리 정의한 더 작은 구간(bin)에 맞춰 값들을 변경한다.<br> - 신호 처리에서 많이 사용</td></tr><tr class="even"><td>Vector Quantization(VQ)</td><td>- 전체 데이터 공간을 여러 개의 벡터 클러스터로 나눈다. <br> - 각 클러스터는 하나의 대표 벡터(코드워드)로 표현된다. <br> - 이미지 압축, 음성 인식 등에서 많이 사용</td></tr></tbody></table><h3 id="검색-알고리즘">검색 알고리즘</h3><p>검색 알고리즘은 저장되어 있는 수많은 벡터 중에서 가장 유사한 벡터를 어떻게 찾을지에 대한 논리구조이다.</p><table><thead><tr class="header"><th>이름</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>유클리디안 거리 (L2)</td><td>- 두 점 사이의 최단 직선 거리를 측정하는 방식. <br> - 직관적이고 간단하여 이해하기 쉽다. <br> - 고차원에서의 성능 저하(차원의 저주) 존재한다.</td></tr><tr class="even"><td>내적 (IP, Inner Product)</td><td>- 두 벡터의 각 성분의 곱을 모두 더하는 방식. <br> - 각도와 방향성을 기반으로 한 유사성 측정에 적합하다. <br> - 벡터 크기를 고려하지 않아 스케일링에 민감할 수 있다.</td></tr></tbody></table><p>유사도 분석에서 사용되는 검색 알고리즘에 대한 자세한 내용은 <a href="https://dev-bearabbit.github.io/2024/04/11/Mathematic/mathematic-4/#more">해당 글</a>에서 확인할 수 있다.</p><h3 id="인덱싱-검색-알고리즘">인덱싱 + 검색 알고리즘</h3><p>faiss에서는 특정 상황에 최적화된 인덱싱 구조와 검색 알고리즘을 결합하여 제공한다.</p><table><thead><tr class="header"><th>이름</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>IVF (Inverted File)</td><td>- 전체 벡터를 중심점을 가진 여러 개의 클러스터로 나누어 저장하는 방식. <br> - 검색 시 가장 유사한 클러스터를 먼저 검색 후 클러스터 내 데이터로만 유사도 검색을 수행한다. <br> - 대규모 데이터셋에서 효율적인 검색이 가능하지만 초반의 클러스터링을 통해 검색 범위가 제한된다. <br> - 따라서 클러스터링의 품질에 크게 의존하며, 초기 인덱싱 시간이 많이 소요될 수 있다.</td></tr><tr class="even"><td>HNSW (Hierarchical Navigable Small World)</td><td>- 그래프 기반의 접근 방식. <br> - 계층적 그래프 구조를 통해 고차원 데이터에서 효과적으로 근접 이웃을 찾아서 반환한다. <br> - 고차원 데이터에서 뛰어난 검색 성능을 가지며, 복잡한 데이터 분포에도 강하다. <br> - 메모리 사용량이 상대적으로 높으며, 구현과 튜닝이 복잡할 수 있다.</td></tr></tbody></table><h3 id="결론">결론</h3><p>FAISS에서 제공되는 방법들은 보통 인덱싱 방법과 검색 알고리즘을 최적화하여 결합된 형태이다. 더 많은 종류와 자세한 내용은 <a href="https://github.com/facebookresearch/faiss/wiki/Faiss-indexes">공식 깃허브 페이지</a>에서 확인할 수 있다.</p><h2 id="기초-사용법-및-예제-코드">기초 사용법 및 예제 코드</h2><p>이제부터 간단한 예제를 통해 기초 사용법을 알아보자.</p><h3 id="faiss-설치">faiss 설치</h3><p>이번 글에서는 CPU 버전을 사용하여 예제를 진행할 예정이다. 설치하는 코드는 다음과 같다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">pip 사용하는 경우</span><br>pip3 install faiss-cpu<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">conda 사용하는 경우</span><br>conda install -c pytorch faiss-cpu<br></code></pre></td></tr></table></figure><p>설치가 완료되었다면 python에서 faiss 라이브러리를 임포트한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> faiss<br></code></pre></td></tr></table></figure><p>따로 예제 데이터가 없다면 아래 라이브러리도 설치 및 임포트하자.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">예제 데이터 임베딩을 위한 설치</span><br>pip3 install sentence_transformers<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 예제 데이터 임베딩을 위한 임포트</span><br><span class="hljs-keyword">from</span> sentence_transformers <span class="hljs-keyword">import</span> SentenceTransformer<br></code></pre></td></tr></table></figure><h3 id="예제-데이터-준비">예제 데이터 준비</h3><p>다음으로는 인덱싱에 사용할 예제 데이터를 준비한다. 당연히 데이터 구조는 벡터여야 한다. 따라서 텍스트 데이터를 임베딩해주자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">texts = [<br>    <span class="hljs-string">&quot;날씨가 좋네요&quot;</span>,<br>    <span class="hljs-string">&quot;오늘 기분이 별로에요&quot;</span>,<br>    <span class="hljs-string">&quot;점심은 뭐 먹을까요?&quot;</span>,<br>    <span class="hljs-string">&quot;어떤 메뉴 좋아하세요?&quot;</span>,<br>    <span class="hljs-string">&quot;사과가 맛있네요&quot;</span>,<br>    <span class="hljs-string">&quot;배고파요&quot;</span>,<br>    <span class="hljs-string">&quot;지금 몇 시에요?&quot;</span>,<br>    <span class="hljs-string">&quot;좋은 하루 되세요 :)&quot;</span><br>]<br><br>model = SentenceTransformer(<span class="hljs-string">&#x27;jhgan/ko-sbert-multitask&#x27;</span>)<br><br>vectors = model.encode(texts)<br></code></pre></td></tr></table></figure><p>데이터 준비는 끝났다.</p><h3 id="인덱싱-작업">인덱싱 작업</h3><p>이 단계에서 인덱싱 방법과 검색 알고리즘을 골라야 한다. 예제 케이스는 개수가 적어 편하게 flat + 내적 조합을 사용한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 벡터 차원</span><br>d = vectors.shape[<span class="hljs-number">1</span>]<br><br><span class="hljs-comment"># 내적을 사용하는 Flat 인덱스</span><br>index = faiss.IndexFlatIP(d)<br><br><span class="hljs-comment"># 인덱스에 벡터 추가</span><br>index.add(vectors)<br></code></pre></td></tr></table></figure><h3 id="유사도-검색">유사도 검색</h3><p>이제 위에서 만든 벡터 DB에 유사도 검색을 테스트해보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">query = <span class="hljs-string">&quot;밥 관련 문장 찾아줘&quot;</span><br>query_vector = model.encode([query])<br><br>k = <span class="hljs-number">3</span>  <span class="hljs-comment"># 찾을 유사 항목의 수</span><br>D, I = index.search(query_vector, k)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Query:&quot;</span>, query[<span class="hljs-number">0</span>])<br><span class="hljs-keyword">for</span> i, idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(I[<span class="hljs-number">0</span>]):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Top <span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span>: &#x27;<span class="hljs-subst">&#123;texts[idx]&#125;</span>&#x27; with score <span class="hljs-subst">&#123;D[<span class="hljs-number">0</span>][i]&#125;</span>&quot;</span>)<br>Query: 밥 관련 문장 찾아줘<br>Top <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;점심은 뭐 먹을까요?&#x27;</span> <span class="hljs-keyword">with</span> score <span class="hljs-number">176.64100646972656</span><br>Top <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;어떤 메뉴 좋아하세요?&#x27;</span> <span class="hljs-keyword">with</span> score <span class="hljs-number">167.53936767578125</span><br>Top <span class="hljs-number">3</span>: <span class="hljs-string">&#x27;배고파요&#x27;</span> <span class="hljs-keyword">with</span> score <span class="hljs-number">158.5279541015625</span><br></code></pre></td></tr></table></figure><p>밥과 관련된 문장들을 반환하였다.</p>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>package</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>유사도분석</tag>
      
      <tag>package</tag>
      
      <tag>library</tag>
      
      <tag>인덱싱</tag>
      
      <tag>indexing</tag>
      
      <tag>index</tag>
      
      <tag>FAISS</tag>
      
      <tag>사용법</tag>
      
      <tag>similarity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>여러가지 유사도 분석 방법들</title>
    <link href="/ko/Mathematic/mathematic-3/"/>
    <url>/ko/Mathematic/mathematic-3/</url>
    
    <content type="html"><![CDATA[<p>유사도 분석에 사용되는 여러 방법들을 정리합니다. <span id="more"></span></p><hr /><h2 id="유사도-분석이란">유사도 분석이란</h2><p>유사도 분석은 주어진 데이터나 객체 간의 유사성을 평가하고 비교하는 것을 의미한다. 이는 다음와 같은 분야에서 보통 사용된다.</p><ul><li>자연어 처리 (Natural Language Processing, NLP): 문서나 문장 간의 유사도를 측정하여 정보 검색, 문서 분류, 텍스트 요약 등에 활용된다. 코사인 유사도, 유클리드 거리 등의 방법을 사용하여 문장 간의 유사도를 측정할 수 있다.</li><li>이미지 처리 (Image Processing): 이미지 간의 유사성을 측정하여 객체 인식, 이미지 분류, 이미지 검색 등에 활용된다. 이미지의 특징을 추출하여 이를 기반으로 유사도를 계산하는 방법이 사용된다.</li><li>추천 시스템 (Recommendation Systems): 사용자의 선호도를 파악하여 유사한 항목을 추천하는 시스템에서 사용할 수 있다. 사용자 간의 유사도(협업 필터링 추천 시스템)나 제품 간의 유사도(콘텐츠 기반 추천 시스템)를 측정하여 추천하는데 활용된다.</li><li>패턴 인식 (Pattern Recognition): 데이터의 패턴을 분석하여 유사성을 파악하는 분야에서도 중요한 역할을 한다.</li></ul><h2 id="유사도-계산-방법">유사도 계산 방법</h2><p>유사도를 구하는 방법은 다양하게 존재한다. 어떤 데이터를 사용하는지, 어떤 기준의 유사도를 얻고 싶은지에 따라 선택할 수 있는 적합한 방법은 모두 다르며, 이번 글에서는 대표적인 방법만 간단하게 정리하려고 한다.</p><h3 id="자카드-계수">자카드 계수</h3><p>자카드 계수는 비교 데이터의 합집합과 교집합을 사용하여 유사도를 계산하는 방식이다. 수식은 다음과 같다.</p><p><span class="math display">\[ J(A,B) =  \frac{|A \cap B|}{|A \cup B|} = \frac{|A \cap B|}{|A| + |B| - |A \cap B|}\]</span></p><p>위 수식을 해석해보면 특정 기준으로 데이터를 비교했을 때 동일하게 가진 원소의 개수와 서로 다른 원소 개수를 나눠 비율을 구하는 방식이다. 즉, 유사도의 기준은 "서로 얼마나 같은 데이터를 포함하고 있는가"이다. 해당 방법으로 유사도를 구한다면 최대값은 1이며, 최소값은 0이다.</p><p>자카드 계수가 적합한 조건은 다음과 같다.</p><ul><li>간단하게 유사도를 구하고 싶을 때</li><li>특정 단어 기준으로 유사도를 구하고 싶을 때</li><li>임베딩(벡터화)를 진행할 수 없을 때</li><li>비교 데이터의 길이 또는 개수가 일정하지 않을 때</li></ul><p>반대로 자카드 계수가 지닌 단점은 다음과 같다.</p><ul><li>데이터의 빈도를 고려하지 않는다.</li><li>어휘의 유사성을 고려하지 않는다.</li><li>음의 상관 관계를 담지 못한다.</li></ul><h3 id="유클리드-거리">유클리드 거리</h3><p>유클리드 거리는 L2 거리라고도 불리며, 다차원 공간에서 두 점 사이의 최단 거리를 구한다. 수식은 다음과 같다.</p><p><span class="math display">\[L_{2} = {\sqrt{\sum_{i=1}^n (p_{i} - q_{i})^2}}\]</span></p><p>여기서 유사도의 기준은 n차원 공간에서의 최단 거리이며, 각 차원의 성분값의 차이의 제곱을 모두 더한 후에 제곱근을 취한 값으로 계산된다. 이는 피타고라스의 정리를 응용하여 계산하는 방식이며, 결과값이 작을수록 두 벡터는 유사하다고 볼 수 있다. 수식 자체가 벡터 성분 차이의 합이기에 벡터의 크기가 다른 경우 제대로된 유사도 결과를 도출할 수 없다. 또한 특정 차원의 값이 이상하게 큰 경우에도 의도하지 않은 가중치가 적용되어 잘못된 유사도를 계산할 가능성이 높다.</p><figure><img src="/images/182.jpeg" alt="euclide" /><figcaption aria-hidden="true">euclide</figcaption></figure><p>따라서 보통 유클리드 거리를 사용할 때는 정규화 과정을 거치며, 많이 사용되는 정규화 방법은 다음과 같다.</p><table><thead><tr class="header"><th>이름</th><th>설명</th><th>수식</th></tr></thead><tbody><tr class="odd"><td>표준화 <br> (Standardization)</td><td>데이터의 각 차원을 해당 차원의 평균으로 빼고, 표준편차로 나누어 데이터를 평균이 0이고 표준편차가 1인 분포로 변환한다.</td><td><span class="math inline">\(z = \frac{x - \mu}{\sigma}\)</span></td></tr><tr class="even"><td>최소-최대 정규화 <br> (Min-Max Normalization)</td><td>각 차원을 해당 차원의 최솟값으로 빼고, 최댓값에서 최솟값을 뺀 값을 나눠 모든 차원의 데이터를 [0, 1] 범위로 변환한다.</td><td><span class="math inline">\(z = \frac{x - \min(x)}{\max(x) - \min(x)}\)</span></td></tr></tbody></table><p>결론적으로 유클리드 거리가 사용되기 적합한 조건은 다음과 같다.</p><ul><li>데이터의 차원이 동일할 때 (벡터의 길이가 동일할 때)</li><li>데이터의 차원이 상대적으로 낮을 때</li><li>데이터의 분포가 균일할 때</li><li>클러스터링(군집화)가 필요할 때</li></ul><h3 id="맨해튼-거리">맨해튼 거리</h3><p>맨해튼 거리는 L1 거리라고도 불리며, 도시의 블록처럼 가로와 세로로만 이동하여 이동 거리를 측정하는 것과 유사하다. 수식은 다음과 같다.</p><p><span class="math display">\[ L_{1} = \sum_{i=1}^n |p_{i} - q_{i}| \]</span></p><p>여기서 유사도의 기준은 n차원 공간에서의 가로 방향과 세로 방향으로의 이동 거리이며, 각 차원의 성분 차이의 절대값을 모두 합한 값이다.</p><figure><img src="/images/183.png" alt="manhattan" /><figcaption aria-hidden="true">manhattan</figcaption></figure><p>위 사진처럼 유클리드 거리는 각 점의 직선거리라면 맨해튼 거리는 오로지 가로와 세로로만 이동한 거리이다. 이런 방식은 특정 방향으로 이동하면서 얼마나 다른지를 측정하는 데 유용하며, 이미지 유사도나 패턴 분석 등의 데이터에 사용할 수 있다.</p><p>결론적으로 다음과 같은 상황일 때는 맨해튼 거리를 사용하는 것이 적합하다.</p><ul><li>데이터(객체)의 이동 경로를 비교하고 분석할 때</li><li>도시의 도로 네트워크나 지리 정보와 관련된 데이터일 때</li><li>텍스트 단어의 빈도, 출현 패턴을 비교할 때</li><li>그래픽스나 이미지 데이터를 처리할 때</li></ul><h3 id="코사인-유사도">코사인 유사도</h3><p>코사인 유사도는 벡터 형태인 비교 데이터의 사잇각을 통해 유사도를 계산하는 방식이다. 수식은 다음과 같다.</p><p><span class="math display">\[ cos(\theta) = \frac{A \cdot B}{\lVert A \rVert \lVert B \rVert} = \frac{A \cdot B}{\sqrt{\sum_{i=1}^n (A_{i})^2} \times \sqrt{\sum_{i=1}^n (B_{i})^2}}\]</span></p><p>여기서 잠깐 벡터 내적과 벡터 크기를 모르는 사람들을 위해 간단하게 정리해보자.</p><table><thead><tr class="header"><th>정의</th><th>설명</th><th>예시</th></tr></thead><tbody><tr class="odd"><td>벡터 내적 <br> <span class="math inline">\(A \cdot B\)</span></td><td>각 성분별로 곱해서 더한 값이며, 벡터 간의 방향성을 나타낸다. <br> 두 벡터가 비슷한 방향을 향하고 있다면 각 성분끼리의 곱이 양수가 되며, 다른 방향을 향하고 있다면 각 성분끼리의 곱이 음수가 된다. <br> 따라서 결과값이 최대값이라면 완전히 같은 방향이며, 0이라면 수직, 음수라면 반대 방향임을 알 수 있다.</td><td><span class="math inline">\(A=(3,4), B=(2,2)\)</span> 일 때, <br> <span class="math inline">\(A \cdot B=(3×2)+(4×2)=14\)</span></td></tr><tr class="even"><td>벡터 크기 <br> <span class="math inline">\(\lVert A \rVert, \lVert B \rVert\)</span></td><td>벡터의 크기는 벡터의 길이를 의미하며, 해당 벡터의 성분을 제곱하여 더한 후 제곱근을 취한 값이다. <br> 만약 <span class="math inline">\(n\)</span>차원 벡터라면 n개의 성분을 제곱하여 더한 후 제곱근을 적용하면 된다. 여기서 제곱을 하는 이유는 길이라는 개념이 무조건 양수라서 음수를 제거하기 위함이다.</td><td><span class="math inline">\(A=(3,4), B=(2,2)\)</span> 일 때, <br> <span class="math inline">\(\lVert A \rVert=\sqrt{3^{2}+4^{2}}=5\)</span> <br> <span class="math inline">\(\lVert B \rVert=\sqrt{2^{2}+2^{2}}=2\sqrt{2}\)</span></td></tr></tbody></table><p>위 설명에 따라 수식을 해석해보면 두 벡터의 내적을 두 벡터 크기의 곱으로 나눈 값이다. 벡터의 내적은 "두 벡터의 방향성"을 의미하고, 두 벡터 크기의 곱은 "두 벡터의 최대 크기"를 의미한다. 따라서 두 수를 나누면 "정규화된 벡터 유사도" 결과가 도출되는 것이다. 이는 벡터 크기에 유사도가 영향을 받지 않도록 하는 정규화 과정이라고 볼 수 있다.</p><p>위 수식의 결과값에 대한 자세한 해석은 다음 그림에서 확인할 수 있다.</p><figure><img src="/images/181.jpeg" alt="consine" /><figcaption aria-hidden="true">consine</figcaption></figure><p>코사인 유사도는 방향으로도 표현되기 때문에 단순히 유사한 정도뿐만이 아니라 서로 반대된 데이터인지도 확인이 가능하다. 또한 각도를 기반으로 유사도를 평가하기 때문에 실제 벡터의 크기에는 큰 영향을 받지 않는다.</p><p>결론적으로 코사인 유사도 방법으로 계산한 결과값을 해석한다면 1과 가까울수록 유사한 데이터, 0에 가깝다면 서로 독립된 데이터, -1에 가깝다면 서로 반대의 의미를 가진 데이터라는 것이다.</p><p>코사인 유사도가 적합한 조건은 다음과 같다.</p><ul><li>벡터의 크기가 크지 않을 때</li><li>벡터의 크기가 다양할 때</li><li>임베딩 시 벡터 크기의 정규화가 안될 때</li><li>다양한 차원의 데이터를 사용할 때</li></ul><h3 id="피어슨-유사도">피어슨 유사도</h3><p>피어슨 유사도는 두 벡터 간의 선형 상관 관계를 측정하는 방법 중 하나이다. 수식은 다음과 같다.</p><p><span class="math display">\[ \text{Pearson similarity}(A, B)= \frac{\sum_{i=1}^{n} (A_i - \bar{A})(B_i - \bar{B})} {\sqrt{\sum_{i=1}^{n} (A_i - \bar{A})^2 \sum_{i=1}^{n} (B_i - \bar{B})^2}}\]</span></p><p>여기서 잠깐 상관 관계를 모르는 사람들을 위해 간단하게 정리해보자.</p><p><strong>상관 관계란</strong><br />상관 관계는 두 변수 간의 관련성이 얼마나 강한지를 나타내는 지표이다. 만약 양의 상관 관계라면 한 벡터의 값이 증가할 때 다른 벡터의 값도 증가하며, 이는 두 벡터가 비슷한 방향으로 움직인다는 것을 의미한다. 반대로 음의 상관 관계라면 한 벡터의 값이 증가할 때 다른 벡터의 값은 감소하며, 이는 두 벡터가 반대 방향으로 움직인다는 것을 의미한다.</p><p>위 수식은 n차원 두 벡터의 유사도를 구하며, <span class="math inline">\(\bar{A}\)</span>와 <span class="math inline">\(\bar{B}\)</span>는 각각 벡터 <span class="math inline">\(A\)</span>와 <span class="math inline">\(B\)</span>의 평균값이다. 위 수식에서 분자는 두 벡터가 얼마나 비슷한 방향으로 움직이는지(상관 관계)를 나타내며, 사실상 피어슨 유사도의 핵심 값이다. 분자의 값이 양수라면 양의 상관 관계, 분자의 값이 음수라면 음의 상관 관계를 도출하기 떄문이다. 분모는 두 벡터의 크기 차이가 유사도에 영향을 미치는 것을 방지하기 위한 역할을 한다.</p><p>수식을 잘 보면 코사인 유사도와 비슷한 것을 알 수 있다. 코사인 유사도에서는 벡터 값을 바로 사용했다면 피어슨 유사도에서는 편차를 사용한다. 즉, 각 차원의 평균편차 값을 곱함으로써 방향성을 구하며, 각 벡터 편차들의 크기로 결과값을 조정한다. 따라서 피어슨 유사도는 보통 -1과 1사이의 값을 가진다. 결과값이 1에 가까울수록 두 벡터의 높은 양의 상관 관계를 의미하고, -1에 가까울수록 음의 상관 관계를, 0은 선형적인 관계가 없음을 의미한다.</p><p>결론적으로 피어슨 유사도는 다음과 같은 조건에서 사용하면 좋다.</p><ul><li>연속형 변수 간의 관계를 분석할 때</li><li>데이터가 정규 분포를 따를 때</li><li>데이터의 이상치 규모가 작을 때</li><li>두 벡터의 길이가 다르거나 부분적으로 누락되어 있을 때</li><li>벡터의 요소가 동일 값일 수 있을 때</li></ul>]]></content>
    
    
    <categories>
      
      <category>MachineLearning</category>
      
      <category>mathematics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>머신러닝</tag>
      
      <tag>유사도</tag>
      
      <tag>유사도분석</tag>
      
      <tag>자카드계수</tag>
      
      <tag>유클리드거리</tag>
      
      <tag>맨해튼거리</tag>
      
      <tag>코사인유사도</tag>
      
      <tag>피어슨유사도</tag>
      
      <tag>추천알고리즘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>요즘 유행하는 ChatGPT로 슬랙봇 만들기 1편</title>
    <link href="/ko/DeepLearning/deeplearning-0/"/>
    <url>/ko/DeepLearning/deeplearning-0/</url>
    
    <content type="html"><![CDATA[<p>LLM을 사용하여 사내가이드 슬랙봇 만드는 방법을 정리합니다. <span id="more"></span></p><hr /><h2 id="시작하며">시작하며</h2><p>ChatGPT 등장 이후 AI 업계는 큰 변화를 맞이한 것 같다. 딥러닝이 주전공은 아니지만 데이터 업계에 몸담고 있는 이상 어느 정도는 알아야 할 것 같아 사내에서 스터디를 진행하였다. 스터디를 진행하면서 뭐라도 하나 만들어보고 싶던 찰나에 컨플루언스 검색엔진 성능이 너무 좋지 못하다는 의견이 나왔다 (우리 회사는 대부분의 문서를 컨플루언스에서 관리한다). 원하는 정보를 찾기 위해 키워드 기반으로 검색해도 전혀 다른 문서들이 더 많이 반환된다는 것이다.</p><p>바로 이거다. 슬랙에서 물어보면 컨플루언스 문서를 보고 알아서 답해주는 비서가 있으면 편할 것 같다. 바로 만들어보자.</p><h2 id="무엇을-하려고-하는가">무엇을 하려고 하는가</h2><p>간단하게 사내에서 사용할 사내가이드 슬랙봇을 만들고자 한다. 구조는 다음과 같다.</p><ol type="1"><li>질문 들어온 내용과 유사한 글들을 몇 개 선정</li><li>선정된 글을 ChatGPT에게 보내 질문에 해당하는 내용만 요약</li><li>슬랙 API로 요약내용과 글 링크 전달</li></ol><p>이를 위해 해야 하는 일들은 다음과 같다.</p><ul><li>사용할 데이터 수집 및 전처리하기</li><li>미리 임베딩해서 Vector Database 생성하기</li><li>유사도 분석 로직 개발하기</li><li>프롬프트 생성하기</li><li>슬랙 앱 만들기</li></ul><p>본격적으로 개발하기 전에 간단하게 필요한 지식들을 먼저 정리하자. 아래 내용은 중요하다고 생각한 최소한의 설명만을 정리한 것이다.</p><h2 id="llm이란-무엇인가">LLM이란 무엇인가</h2><ul><li>Large Language Model, 거대언어모델이라고 불림</li><li>엄청난 양의 훈련 데이터, 파라미터 셋으로 훈련시킨 모델 -&gt; 엄청난 비용과 에너지 요구됨</li><li>특정 분야에 최적화된 것이 아니라 대부분의 질문에도 답변을 생성할 수 있음</li><li>프롬프트를 어떻게 작성하느냐에 따라 답변이 다르게 도출됨</li><li>파인튜닝(Fine-tuning)을 하면 특정 작업에 더 적합하도록 구성할 수 있음</li><li>파인튜닝은 훈련 리소스 비용이 방대한 반면 RAG는 가성비로 성능을 높일 수 있음.</li></ul><h2 id="rag란-무엇인가">RAG란 무엇인가</h2><figure><img src="/images/180.png" alt="rag" /><figcaption aria-hidden="true">rag</figcaption></figure><ul><li>Retrieval Augmented Generation, 검색증강생성이라고도 불림</li><li>질문에 적합한 데이터들을 LLM에게 전달하여 이를 기반으로 답변을 도출할 수 있도록 하는 아키텍처</li><li>보통 검색로직과 답변생성로직, 2개로 나눠짐</li><li>검색로직: 질문과 Vector Database에 있는 데이터와의 유사도 분석으로 적합한 데이터를 추출</li><li>답변생성로직: 적합한 데이터 + 프롬프트를 활용하여 LLM 모델로부터 원하는 답변 도출</li></ul><h2 id="vector-database란-무엇인가">Vector Database란 무엇인가</h2><ul><li>임베딩된 벡터를 저장하고 쿼리하는 데이터베이스. 핵심 키워드는 인덱스와 임베딩</li><li>인덱스: PQ, LSH, HNSW 같은 알고리즘들을 사용하여 유사한 벡터를 빨리 쿼리할 수 있도록 만든 자료구조</li><li>임베딩: 텍스트, 이미지, 오디오 등의 고차원 데이터를 저차원의 벡터 형태로 변환</li><li>학습 데이터를 임베딩으로 변환하여 저장한 후 질문과 유사도를 계산하여 적합한 데이터를 도출할 수 있음</li></ul><h2 id="프롬프트란-무엇인가">프롬프트란 무엇인가</h2><ul><li>LLM에게 적합한 답변을 얻어내고 잘못된 사용을 제한하기 위한 가이드</li><li>프롬프트를 제대로 작성하지 않으면 기밀을 유출하거나 잘못된 답변을 도출하기도 함</li><li>역할을 명확하게 부여하는 방식이 깔끔한 결과를 도출할 수 있음</li></ul><h2 id="결론">결론</h2><p>이제 프로젝트를 진행할만큼의 기본 개념은 알게된 것 같다. 다음 글에서는 본격적으로 슬랙봇을 만들어보자.</p>]]></content>
    
    
    <categories>
      
      <category>MachineLearning</category>
      
      <category>deep learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DeepLearning</tag>
      
      <tag>LLM</tag>
      
      <tag>ChatGPT</tag>
      
      <tag>RAG</tag>
      
      <tag>Prompt</tag>
      
      <tag>프롬프트</tag>
      
      <tag>AI</tag>
      
      <tag>인공지능</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>분석 테이블 기본 구조</title>
    <link href="/ko/Engineering/engineering-4/"/>
    <url>/ko/Engineering/engineering-4/</url>
    
    <content type="html"><![CDATA[<p>글을 시작하기에 앞서 해당 글은 니시다 케이스케의 저서인 『빅데이터를 지탱하는 기술』 을 바탕으로 요약 및 정리한 글임을 알려드립니다. <span id="more"></span></p><h2 id="정규화와-비정규화">정규화와 비정규화</h2><p>보통 일반적인 RDB는 정규화된 데이터 구조를 가지고 있으며, 크게 트랜잭션 데이터와 마스터 데이터로 구분한다. <code>트랜잭션(Transaction) 데이터</code>란 시간과 함께 생성되는 데이터를 순서대로 모두 기록하는 것을 의미하며, 트랜잭션 데이터에서 참고하는 각종 정보가 담긴 데이터를 <code>마스터(master) 데이터</code>라고 한다. 트랜잭션 데이터는 한 번 쓰이면 변화하지 않지만, 마스터 데이터는 상황에 따라 다시 쓰인다.</p><p>이와 같이 데이터를 구분하여 중복값을 최소화하는 과정을 <code>정규화(nomalization)</code>라고 한다. 정규화를 진행하면 데이터의 무결성을 유지할 수 있으며, 저장되는 데이터 크기도 최적화가 가능하다.</p><p>하지만 분석에 사용하는 테이블은 보통 이와 반대의 작업인 비정규화를 진행한다. 여기서 <code>비정규화(denomalization)</code>란 트랜잭션 데이터와 마스터 데이터를 분석에 용이하도록 다시 합치는 것이다. 분석에 사용되는 디멘전 테이블을 작성하려면 정규화에 의해 분해된 테이블을 최대한 결합하여 하나의 테이블로 정리한다. 그 결과로 데이터가 중복되어도 괜찮다.</p><h2 id="다차원-모델">다차원 모델</h2><p>다차원 모델이란 말 그대로 데이터를 여러 차원으로 쪼개는 형태를 의미한다. 보통 일반적으로 데이터라고 하면 행과 열이 있는 2차원 모델을 떠올린다. 하지만 실제 운영 데이터들은 훨씬 복잡한 구조로 얽혀있기 때문에 2차원으로 간단하게 나타내기 힘들다. 오히려 2차원으로 만들고자 한다면 엄청난 중복 데이터와 끝도 없는 컬럼 개수에 시달릴 수 있다.</p><p>다차원 모델을 업계 용어로 정의해보면 실제 데이터를 나타내는 <code>팩트 테이블</code>과 구분값인 <code>디멘전 테이블</code>로 나누어 설계하는 것을 의미한다. 이는 각 차원별로 테이블을 구분하므로서 중복값을 최소화하고 사용자도 비교적 쉽게 데이터 범위를 이해할 수 있도록 도와준다.</p><p>보통 확인하고자 하는 매트릭에 맞추어 다차원 모델을 설계한다. 반면 MPP 데이터베이스에서는 다차원 모델의 개념이 없기 떄문에 비정규화 테이블을 사용한다.</p><h2 id="팩트-테이블과-디멘전-테이블">팩트 테이블과 디멘전 테이블</h2><p>트랜잭션과 같이 사실이 기록된 것을 <code>팩트(fact) 테이블</code>이라고 하며, 이에 참고되는 마스터 데이터 등을 <code>디멘전(dimension) 테이블</code>이라고 한다. 예를 들어 집계의 기반이 되는 숫자 데이터는 팩트 테이블에 기록되고 디멘전 테이블은 이를 분류하기 위한 속성값으로 사용된다.</p><p>데이터 양이 증가함에 따라 팩트 테이블은 디멘전 테이블보다도 훨씬 커져 해당 데이터 양이 집계 완료 시간을 좌우한다. 팩트 테이블을 가능한 작게 하는 것이 고속화에 있어서 중요하며, 팩트 테이블에는 ID와 같은 키만을 남겨두고 그 외의 나머지는 디멘전 테이블로 옮긴다.</p><h2 id="스타-스키마와-눈송이-스키마">스타 스키마와 눈송이 스키마</h2><p>스타 스키마란 팩트 테이블을 중심으로 여러 디멘젼 테이블을 결합한 구조이다. 하나의 팩트 테이블에 여러 디멘전 테이블이 연결되어 있으며 디멘전 테이블은 계층적 구조 없이 단일로 존재한다. 다음 사진은 스타스키마 구조이다.</p><figure><img src="/images/178.png" alt="star schema" /><figcaption aria-hidden="true">star schema</figcaption></figure><p>눈송이 스키마는 스타 스키마에서 디멘젼 테이블이 하위 디멘전을 계층적으로 가질 수 있는 구조이다. 즉, 스타 스키마보다 더 강하게 정규화를 진행한 구조라고 볼 수 있다. 다음 사진은 눈송이 스키마 구조이다.</p><figure><img src="/images/179.png" alt="snowflake schmea" /><figcaption aria-hidden="true">snowflake schmea</figcaption></figure><p>스타 스키마와 눈송이 스키마를 비교하면 다음과 같다.</p><table><thead><tr class="header"><th>비교</th><th>스타 스키마</th><th>눈송이 스키마</th></tr></thead><tbody><tr class="odd"><td>장점</td><td>- 데이터 구조, 쿼리가 비교적 간단하다. <br></td><td>- 데이터 중복, 저장공간을 최소화할 수 있다. <br> - 중복이 없기 때문에 유지보수가 비교적 쉽다.</td></tr><tr class="even"><td>단점</td><td>- 디멘전 테이블에 중복이 발생할 수 있다. <br> - 저장공간을 비교적 많이 사용한다.</td><td>- 많은 JOIN이 요구되어 성능 상 이슈가 발생할 수 있다. <br> - 데이터 구조가 비교적 복잡하다.</td></tr></tbody></table><p>보통 눈송이 스키마는 데이터 웨어하우스에 적합하며, 스타 스키마는 데이터 마트에 적합하다고 알려져 있다.</p><h2 id="열-기반-스토리지-등장과-비정규화-테이블">열 기반 스토리지 등장과 비정규화 테이블</h2><p>컬럼 단위로 데이터가 저장되는 열 기반 스토리지가 등장하면서 요즘은 사정이 바뀌었다. 컬럼의 숫자가 증가해도 쿼리 엔진 성능에 영향을 받지 않으며, 컬럼 단위로 압축도 진행되므로 디스크 I/O의 증가는 억제된다. 그렇기에 굳이 디멘젼 테이블로 분리할 필요가 없어졌으며, 하나의 거대한 팩트 테이블만 있어도 충분해졌다.</p><p>스타 스키마에서 좀 더 비정규화를 진행하여 모든 테이블을 결합한 팩트 테이블을 <code>비정규화 테이블</code>이라고 한다. 데이터 웨어하우스의 테이블 구조로는 스타 스키마가 우수하다. 데이터를 축적하는 단계에서는 팩트 테이블과 디멘전 테이블로 분리해두고 마트로 만들 때는 결합헤 비정규화 테이블을 만든다.</p>]]></content>
    
    
    <categories>
      
      <category>BigData</category>
      
      <category>engineering</category>
      
    </categories>
    
    
    <tags>
      
      <tag>데이터웨어하우스</tag>
      
      <tag>빅데이터</tag>
      
      <tag>bigdata</tag>
      
      <tag>데이터마트</tag>
      
      <tag>datawarehouse</tag>
      
      <tag>datamart</tag>
      
      <tag>스타스키마</tag>
      
      <tag>눈송이스키마</tag>
      
      <tag>비정규화테이블</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>빅데이터의 기초 지식</title>
    <link href="/ko/Engineering/engineering-3/"/>
    <url>/ko/Engineering/engineering-3/</url>
    
    <content type="html"><![CDATA[<p>글을 시작하기에 앞서 해당 글은 니시다 케이스케의 저서인 『빅데이터를 지탱하는 기술』 을 바탕으로 요약 및 정리한 글임을 알려드립니다. <span id="more"></span></p><h2 id="빅데이터의-배경">빅데이터의 배경</h2><p>빅데이터가 어려운 이유는 데이터 분석 방법을 모른다는 것, 데이터 처리에 수고와 시간이 걸린다는 것 크게 두 가지이다. 이 두 가지는 빅데이터에서 가치있는 정보를 얻기 위한 필요조건이다.</p><p>하둡(Hadoop)은 다수의 컴퓨터에서 대량의 데이터를 처리하기 위한 시스템이다. 하둡은 구글에서 개발된 분산처리 프레임워크인 맵리듀스(MapReduce)를 참고하여 제작되었다.</p><p>NoSQL은 기존 RDB의 제약을 제거하기 위해 등장하였다. 대표적인 종류는 다음과 같다.</p><ul><li>키밸류 스토어: 다수의 키와 값을 관련지어 저장 (Redis)</li><li>도큐먼트 스토어: JSON과 같은 복잡한 데이터 구조를 저장 (MongoDB)</li><li>와이드 컬럼 스토어: 여러 키를 사용하여 높은 확장성을 제공 (Cassandra)</li></ul><p>하둡과 NoSQL의 조합으로 현실적인 비용으로도 빅데이터를 처리 및 저장할 수 있게 되었으며, 현대 사회에서는 더 많은 도구들이 등장하였다.</p><h2 id="빅데이터의-기술">빅데이터의 기술</h2><ul><li>데이터 파이프라인: 데이터 수집부터 워크플로우 관리까지 데이터가 흘러가는 시스템을 의미한다.</li><li>데이터 수집: 여러 저장소에 모인 데이터 전송을 통해 수집한다. 데이터 전송에는 벌크형과 스트리밍형이 있다.</li><li>스트림 처리와 배치 처리: 스트림은 이벤트 기반으로 데이터를 수집하는 처리이며, 배치는 벌크형 데이터를 한번에 수집하는 처리이다.</li><li>분산 스토리지: 수집한 데이터를 분산된 스토리지에 저장한다. 하둡의 HDFS나 객체 스토리지인 S3가 대표적이다. NoSQL도 많이 사용된다.</li><li>분산 데이터 처리: MapReduce나 spark 같은 프레임워크를 사용하여 대규모 데이터를 사용하기 쉽게 처리한다.</li><li>워크플로우 관리: 전체 데이터 파이프라인의 동작을 확인하기 위해 해당 기술을 사용한다. airflow가 대표적이다.</li></ul><p>데이터 엔지니어의 역할은 데이터를 수집하고 워크플로우를 관리하며 BI 도구를 지원 등 시스템의 구축 및 운용, 자동화를 담당한다. 데이터 분석가는 데이터 엔지니어가 구축한 시스템 내에서 가치 있는 정보를 추출한다.</p><h2 id="빅데이터의-목적">빅데이터의 목적</h2><ul><li>데이터 검색: 특정 데이터가 언제 어떻게 필요할지 모르기 때문에 발생하는 모든 데이터를 일정기간 보관한다. 또한 보관한 데이터를 조회할 수 있는 검색 기능도 구현되어 있어야 한다.</li><li>데이터 가공: 업무 시스템의 일부로서 데이터 처리 결과를 이용하고 싶을 때 데이터 파이프라인을 설계한다. 데이터 가공에는 자동화가 필수적이다.</li><li>데이터 시각화: 데이터를 시각적으로 봄으로써 알고 싶은 정보를 얻을 수 있다.</li></ul><p>컴퓨터 시스템은 보통 "기간계 시스템"과 "정보계 시스템"으로 구분된다. 기간계는 비즈니스에 관련된 중요한 시스템이므로 완벽하게 테스트를 반복하고 신중하게 운용한다. 반면 정보계는 보통 사내에서 사용되는 시스템으로 기간계만큼 엄격하게 운영되지는 않는다.</p><p>프로젝트 현황을 파악하기 위한 숫자로 업계마다 중요한 지표인 KPI(Key Performance Indicator)가 자주 이용된다. 웹 서비스의 경우 DAU(Daliy Active User), Retention, ARPPU(Average Revenue Per Paid User) 등이 있다. 온라인 광고의 경우 CTR(Click Through Rate), CPC(Cost Per Click), CPA(Cost Per Acquisition) 등이 있다.</p>]]></content>
    
    
    <categories>
      
      <category>BigData</category>
      
      <category>engineering</category>
      
    </categories>
    
    
    <tags>
      
      <tag>빅데이터</tag>
      
      <tag>bigdata</tag>
      
      <tag>basic</tag>
      
      <tag>hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023년 상반기 회고</title>
    <link href="/ko/Reviews/2023/"/>
    <url>/ko/Reviews/2023/</url>
    
    <content type="html"><![CDATA[<p>해당 글은 개인적으로 그냥 쓰는 글입니다. 큰 의미도 내용도 없으니 보시지 않는 것을 추천드립니다. <span id="more"></span></p><hr /><h2 id="그냥-쓰는-글">그냥 쓰는 글</h2><p>분명 올해 초에 2022년 회고를 해야겠다고 마음을 먹었다. 하지만 쓰지 못했다. 변명을 해보자면 진짜 바빴다. 운좋게 번역 제안이 들어와서 태어나서 처음으로 기술서 번역에 도전했고, 회사도 이직한지 반년이 되면서 본격적으로 여러 프로젝트에 참여하게 되었다. 또 코로나 이후 처음으로 하는 오프라인 파이콘을 준비하다보니 정말 정신이 없었다. 그 와중에 나와 10년을 넘게 함께 살아주신 우리 냥님들의 건강에 이상신호가 왔고, 갑작스럽게 가족 건강에도 빨간불이 울렸다.</p><p>정말 굵직한 일들만 쓴 건데도 저렇다. 이렇게 나열해보니 스스로도 2023년은 정말 정신이 없었겠다 싶다. 내가 가진 역할과 책임감의 폭풍우가 지나간 자리에는 뒤늦게 회고를 쓰는 병든 내가 남았다. 최근에 나는 놀랍게도 여름 감기에 걸렸다. 감기는 약 없어도 3일이면 낫는다고 생각하던 내가 2주가 넘도록 기침을 달고 산다. 이것이 늙어가는건가 싶다.</p><p>현실이 바쁠 때는 밀려오는 일들을 쳐내는 것만으로도 허덕였는데 이제는 제법 미래를 다시 공상할 시간이 남았다. 나는 정확히 2년 6개월동안 (정규직으로서) 밥벌이를 했고, 벌써 3년차 데이터 엔지니어가 되었다. 1년 전만에도 낭떠러지 앞에 놓여진 아기사자가 된 것 마냥 "성장"하지 않으면 "실패"한 사람이 되는 거라고 스스로를 압박했다. 생각해보면 참 이분법적인 논리이다. "성장하지 않음 == 실패"을 의미하는게 아닌데 올바르게 쉴 줄 몰랐다.</p><p>그래서인가 정신을 문득 차리니 내 세상은 일과 데이터와 코드로 범벅이었다. 부전공으로 철학을 선택할 정도로 남의 고수준 공상 읽기를 좋아하던 내가 IT분야 외 도서를 쳐다보지 않았고, 개발자나 엔지니어인 나는 있지만 그냥 나는 없었다. 주변 사람들도 같은 분야 종사자들이 대부분이었다. 내가 무엇을 좋아했고 무엇에 관심이 있었고 무엇을 추구했는지를 잃어버렸다. 3년만에 완벽한 K-직장인이 되었다.</p><p>그렇다고 내 상황을 비관하는 것은 아니다. 난 오히려 내게 주어진 기회들이 감사하다. 비관하고 싶은 건 내 실력 정도일까. 주어진 기회들을 내가 부족하여 놓친다는 느낌을 받을 때마다 눈 앞에 다시 낭떠러지가 아른거린다. 컨디션 난조로 침대에 누워있어도 왠지 게으르고 싶어 스스로에게 변명하는 것 같은 기분을 느낄 때도 있다. 약 먹고 일에 집중이 된다면 괜찮은 것이라고 생각했다. 누군가 이 글을 읽고 동의했다면 몸, 정신 여러모로 괜찮은게 아니라고 전하고 싶다.</p><p>주저리 썼지만 2023년 상반기 회고는 간단하다. 건강도 챙기고 힘들면 좀 쉬면서 달리자. 인생이 길수도 있다. 사람 인생은 모르는거니까 무조건 길다고 단언하고 싶지는 않다. 알고보니 내 인생이 남들에 비해 2배속일 수도 있는 것 아닌가? 아니, 아무말은 각설하고 이제 하반기를 어떻게 보낼지를 고민해야 한다.</p><p>이제 번역 초안도 끝났고, 파이콘도 끝났고, 주변 이들의 건강도 어느정도 안정화 되었다. 다시 공상을 시작해보자. 나는 어떻게 2023년 하반기를 마무리할 것인가? 2024년의 나는 어떤 모습이었으면 하는가?</p><p>일단 첫 번역서 교정을 최선을 다해 진행하고 성공적으로 출간되었으면 좋겠다. 최선을 다해도 뒤돌면 아쉬운게 당연하다지만 첫 번역서라서 애정이 깊다. 최선을 다하고 싶다.</p><p>다음으로는 IT분야 외 책을 10권 이상 읽고 싶다. 그렇게라도 압박속에서 벗어나 자유롭게 공상하고 싶다. 벌써 1권을 다 읽고 2권째 읽고 있는데 점점 이전의 내 모습을 찾는 기분이라 묘하다. 애초에 기술 블로그에 이런 글을 쓰고 있는 내 모습부터가 신기하다.</p><p>또 운동을 꾸준히 계속하고 싶다. 어떤 상황에서라도 운동을 포기하지 않아야 그나마 체력이 유지되는 것 같다. 시간은 유한하고 할 일이 넘쳐나도 운동은 1순위로 챙기고 싶다.</p><p>마지막으로 사이드 프로젝트에 집중하고 싶다. 아무래도 하고 싶은 개발할 때가 가장 재밌는거 아니겠는가? 번아웃으로 이 업계를 손절하기 전에 내가 하고 싶었던 것들을 맘 편하게 개발하면서 다시 애정을 키우고 싶다.</p><p>사실 그 외에도 혼자 당일여행 가기, 좋아하는 음식 찾기, 영어 스피킹 연습하기 등등 자잘한 계획들도 머리속에 돌아다닌다. 앞으로 블로그 글도 다시 활발하게 작성하고 싶다. 이제는 기술 뿐만 아니라 개인사도 곁들인. 2023년, 4개월 남았는데 역시 인간은 욕심이 끝없는 존재인가 보다.</p><p>쇼펜하우어에 따르면 열심히 살아야 하는 이유는 그래야 죽음이 빨리 다가오기 때문이라고 한다. 삶은 투쟁이고 죽음은 영원한 안식인데, 삶을 누구보다 열심히 살면 상대성 이론의 원리처럼 시간이 빠르게 흘러 죽음이 어느 순간 내 앞에 당도한다는 것이다. 그러니까 열심히 살라고 한다. 진정한 염세주의자가 깊은 고민 끝에 내린 결론은 삶을 똑바로 바라보라는 것이다.</p><p>나이가 들수록 머릿속은 점점 복잡해지지만 이제는 그냥 실행해보려고 한다. 호기심에 도전하고 즐거움에 지속하며 결과에 연연하지 않던 나로 돌아오고 싶다.</p>]]></content>
    
    
    <categories>
      
      <category>etc.</category>
      
      <category>reviews</category>
      
    </categories>
    
    
    <tags>
      
      <tag>엔지니어</tag>
      
      <tag>개발자</tag>
      
      <tag>회고</tag>
      
      <tag>주니어</tag>
      
      <tag>소프트웨어</tag>
      
      <tag>3년차</tag>
      
      <tag>데이터엔지니어</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Apache Ranger 설치 in Docker (2)</title>
    <link href="/ko/Hadoop/hadoop-12/"/>
    <url>/ko/Hadoop/hadoop-12/</url>
    
    <content type="html"><![CDATA[<p>하둡 에코시스템 중 하나인 Apache Ranger 설치 방법을 정리합니다. <span id="more"></span></p><h2 id="ranger-admin-setup">Ranger Admin Setup</h2><p>이전 글에서 Ranger Admin 도커 이미지 빌드까지 성공하였다. 이번 글에서는 admin 서버를 셋팅하고 웹페이지 접속할 것이다.</p><h3 id="container">Container</h3><p>먼저 빌드한 이미지로 컨테이너를 올려보자. 아래 명령어로 컨테이너를 구동할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -it  -d -p 6080:6080 ranger-admin:2.4.0<br></code></pre></td></tr></table></figure><p>명령어를 잠깐 살펴보면 이미지 <code>ranger-admin:2.4.0</code>로 컨테이너를 실시하며, 포트는 6080으로 할당하라는 의미이다. <code>-d</code>는 컨테이너를 백그라운드로 실행하라는 의미이다.</p><p>정상적으로 실행되었는지 확인하기 위해서는 아래 명령어를 입력한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker ps | grep ranger<br>&lt;container-id&gt;   ranger-admin:2.4.0      <span class="hljs-string">&quot;/bin/bash&quot;</span>      2 days ago    Up 2 days    0.0.0.0:6080-&gt;6080/tcp, :::6080-&gt;6080/tcp<br></code></pre></td></tr></table></figure><h3 id="configuration">Configuration</h3><p>다음으로는 해당 컨테이너에 접속해서 config 값을 수정한 후 웹서버를 활성화해야 한다. 아래 명령어로 컨테이너에 접속한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker <span class="hljs-built_in">exec</span> -it &lt;container-id&gt; /bin/bash<br></code></pre></td></tr></table></figure><p>접속한 후 <code>ll</code>을 입력하면 아래와 같은 목록이 보일 것이다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">drwxr-xr-x 1 ranger ranger   107 Apr  7 07:59 bin<br>-r-xr--r-- 1 ranger ranger  4321 Apr  7 07:59 changepasswordutil.py<br>-r-xr--r-- 1 ranger ranger  5173 Apr  7 07:59 changeusernameutil.py<br>lrwxrwxrwx 1 root   root      55 Apr 10 03:16 conf -&gt; /opt/ranger-2.4.0-admin/ews/webapp/WEB-INF/classes/conf<br>drwxrwxr-x 1 ranger ranger    97 Apr  7 07:59 contrib<br>drwxr-xr-x 1 ranger ranger    17 Apr  9 07:43 cred<br>drwxrwxr-x 1 ranger ranger    85 Apr  7 07:59 db<br>-r-xr--r-- 1 ranger ranger 77697 Apr  7 07:59 db_setup.py<br>-r-xr--r-- 1 ranger ranger 89187 Apr 10 03:15 dba_script.py<br>-r-xr--r-- 1 ranger ranger  9960 Apr  7 07:59 deleteUserGroupUtil.py<br>drwxrwxr-x 1 ranger ranger   189 Apr 10 03:16 ews<br>-rwx------ 1 ranger ranger  9431 Apr 10 03:06 install.properties<br>drwxr-xr-x 1 ranger ranger    17 Apr  9 07:43 jisql<br>-rw-r--r-- 1 ranger ranger  9097 Apr 10 03:16 logfile<br>-r-xr--r-- 1 ranger ranger  3056 Apr  7 07:59 ranger_credential_helper.py<br>-r-xr--r-- 1 ranger ranger 17942 Apr  7 07:59 restrict_permissions.py<br>-r-xr--r-- 1 ranger ranger  6549 Apr  7 07:59 rolebasedusersearchutil.py<br>-r-xr--r-- 1 ranger ranger  3990 Apr  7 07:59 set_globals.sh<br>-r-xr--r-- 1 ranger ranger 66437 Apr  7 07:59 setup.sh<br>-r-xr--r-- 1 ranger ranger  2855 Apr  7 07:59 setup_authentication.sh<br>drwxr-xr-x 1 ranger ranger    27 Apr  7 07:59 stability-tests<br>drwxr-xr-x 1 ranger ranger    70 Apr  9 07:43 templates-upgrade<br>-r-xr--r-- 1 ranger ranger  3452 Apr  7 07:59 updateUserAndGroupNamesInJson.py<br>-r-xr--r-- 1 ranger ranger  1921 Apr  7 07:59 update_property.py<br>-r-xr--r-- 1 ranger ranger  1247 Apr  7 07:59 upgrade.sh<br>-r-xr--r-- 1 ranger ranger 13928 Apr  7 07:59 upgrade_admin.py<br>-r--r--r-- 1 ranger ranger     5 Apr  7 09:31 version<br></code></pre></td></tr></table></figure><p>위 목록에서 <code>install.properties</code>을 수정해야 한다. <code>vim</code> 명령어로 해당 파일을 열어 아래 config 값들을 수정한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#DB_FLAVOR=MYSQL|ORACLE|POSTGRES|MSSQL|SQLA</span><br>DB_FLAVOR=MYSQL<br><br><span class="hljs-comment">#SQL_CONNECTOR_JAR=/usr/share/java/ojdbc6.jar</span><br><span class="hljs-comment">#SQL_CONNECTOR_JAR=/usr/share/java/mysql-connector-java.jar</span><br><span class="hljs-comment">#SQL_CONNECTOR_JAR=/usr/share/java/postgresql.jar</span><br><span class="hljs-comment">#SQL_CONNECTOR_JAR=/usr/share/java/sqljdbc4.jar</span><br><span class="hljs-comment">#SQL_CONNECTOR_JAR=/opt/sqlanywhere17/java/sajdbc4.jar</span><br>SQL_CONNECTOR_JAR=/opt/mysql-connector-java.jar<br><br>db_root_user=&lt;DB_ADMIN&gt;<br>db_root_password=&lt;DB_ADMIN_PWD&gt;<br>db_host=&lt;DB_HOSTNAME&gt;<br><span class="hljs-comment">#SSL config</span><br>db_ssl_enabled=<span class="hljs-literal">false</span><br>db_ssl_required=<span class="hljs-literal">false</span><br>db_ssl_verifyServerCertificate=<span class="hljs-literal">false</span><br><br><span class="hljs-comment"># DB UserId used for the Ranger schema</span><br>db_name=ranger<br>db_user=rangeradmin<br>db_password=rangeradmin<br></code></pre></td></tr></table></figure><p>여기서 주의해야 할 점이 있다. 보통 RDS를 사용하면 <code>DB_HOSTNAME</code>이 <strong>매우</strong> 길다. 너무 긴 호스트 이름은 Mysql을 DB로 사용하는 경우 유저 생성 시 호스트 이름이 잘린 채로 추가된다. 이렇게 잘못된 사용자가 생성되면 나중에 문제가 발생하니 RDS를 사용하는 사람은 <code>Route53</code>을 사용하여 DB에 도메인을 붙여주는 것을 추천한다.</p><p>시스템 DB 정보를 모두 입력했다면 살짝 내려가서 audit store로 사용할 검색엔진 정보도 추가하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#Source for Audit Store. Currently solr, elasticsearch and cloudwatch logs are supported.</span><br><span class="hljs-comment"># * audit_store is solr</span><br>audit_store=elasticsearch<br><br><span class="hljs-comment"># * audit_solr_url Elasticsearch Host(s). E.g. 127.0.0.1</span><br>audit_elasticsearch_urls=&lt;OPENSEARCH_VPC_ENDPOINT&gt;<br>audit_elasticsearch_port=80<br>audit_elasticsearch_protocol=https<br>audit_elasticsearch_user=<br>audit_elasticsearch_password=<br>audit_elasticsearch_index=ranger_audits<br>audit_elasticsearch_bootstrap_enabled=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>모든 값을 입력했다면 <code>:wq</code>로 저장한다.</p><h3 id="db-migrations">DB Migrations</h3><p>이제 ranger-admin이 사용할 DB와 Table을 만들어줄 것이다. 다시 <code>ll</code>을 입력하여 목록을 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">drwxr-xr-x 1 ranger ranger   107 Apr  7 07:59 bin<br>-r-xr--r-- 1 ranger ranger  4321 Apr  7 07:59 changepasswordutil.py<br>-r-xr--r-- 1 ranger ranger  5173 Apr  7 07:59 changeusernameutil.py<br>lrwxrwxrwx 1 root   root      55 Apr 10 03:16 conf -&gt; /opt/ranger-2.4.0-admin/ews/webapp/WEB-INF/classes/conf<br>drwxrwxr-x 1 ranger ranger    97 Apr  7 07:59 contrib<br>drwxr-xr-x 1 ranger ranger    17 Apr  9 07:43 cred<br>drwxrwxr-x 1 ranger ranger    85 Apr  7 07:59 db<br>-r-xr--r-- 1 ranger ranger 77697 Apr  7 07:59 db_setup.py<br>-r-xr--r-- 1 ranger ranger 89187 Apr 10 03:15 dba_script.py<br>-r-xr--r-- 1 ranger ranger  9960 Apr  7 07:59 deleteUserGroupUtil.py<br>drwxrwxr-x 1 ranger ranger   189 Apr 10 03:16 ews<br>-rwx------ 1 ranger ranger  9431 Apr 10 03:06 install.properties<br>drwxr-xr-x 1 ranger ranger    17 Apr  9 07:43 jisql<br>-rw-r--r-- 1 ranger ranger  9097 Apr 10 03:16 logfile<br>-r-xr--r-- 1 ranger ranger  3056 Apr  7 07:59 ranger_credential_helper.py<br>-r-xr--r-- 1 ranger ranger 17942 Apr  7 07:59 restrict_permissions.py<br>-r-xr--r-- 1 ranger ranger  6549 Apr  7 07:59 rolebasedusersearchutil.py<br>-r-xr--r-- 1 ranger ranger  3990 Apr  7 07:59 set_globals.sh<br>-r-xr--r-- 1 ranger ranger 66437 Apr  7 07:59 setup.sh<br>-r-xr--r-- 1 ranger ranger  2855 Apr  7 07:59 setup_authentication.sh<br>drwxr-xr-x 1 ranger ranger    27 Apr  7 07:59 stability-tests<br>drwxr-xr-x 1 ranger ranger    70 Apr  9 07:43 templates-upgrade<br>-r-xr--r-- 1 ranger ranger  3452 Apr  7 07:59 updateUserAndGroupNamesInJson.py<br>-r-xr--r-- 1 ranger ranger  1921 Apr  7 07:59 update_property.py<br>-r-xr--r-- 1 ranger ranger  1247 Apr  7 07:59 upgrade.sh<br>-r-xr--r-- 1 ranger ranger 13928 Apr  7 07:59 upgrade_admin.py<br>-r--r--r-- 1 ranger ranger     5 Apr  7 09:31 version<br></code></pre></td></tr></table></figure><p>위 목록에서 우리는 <code>dba_script.py</code>와 <code>setup.sh</code>을 사용할 것이다. 먼저 <code>dba_script.py</code>을 실행한다.</p><p>참고로 Mysql을 사용하는 경우 실행 전에 작은 버그 하나를 확인해야 한다. Mysql은 5.5버전 이후부터는 JDBC 연결 기본 값이 SSL 활성화로 변경되었는데 해당 스크립트에는 반영이 안되어서 바로 진행하면 SSL 에러가 발생한다. 이걸 해결하기 위해 코드를 살짝 수정해야 한다. 해당부분은 일단 ranger에 <a href="https://github.com/apache/ranger/pull/244">PR</a>을 올려두었다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MysqlConf</span>(<span class="hljs-title class_ inherited__">BaseDB</span>):<br>    .<br>    .<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_jisql_cmd</span>(<span class="hljs-params">self, user, password ,db_name</span>):<br><span class="hljs-comment">#<span class="hljs-doctag">TODO:</span> User array for forming command</span><br>path = RANGER_ADMIN_HOME<br>db_ssl_param=<span class="hljs-string">&#x27;&#x27;</span><br>db_ssl_param=<span class="hljs-string">&#x27;?useSSL=false&#x27;</span> <span class="hljs-comment">#change default value</span><br>db_ssl_cert_param=<span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.db_ssl_enabled == <span class="hljs-string">&#x27;true&#x27;</span>:<br>db_ssl_param=<span class="hljs-string">&quot;?useSSL=%s&amp;requireSSL=%s&amp;verifyServerCertificate=%s&quot;</span> %(<span class="hljs-variable language_">self</span>.db_ssl_enabled,<span class="hljs-variable language_">self</span>.db_ssl_required,<span class="hljs-variable language_">self</span>.db_ssl_verifyServerCertificate)<br></code></pre></td></tr></table></figure><p>이 다음 스크립트를 실행하면 DB 관련 정보를 입력받는다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python3 dba_script.py <br>2023-04-12 14:23:22,797  [I] Running DBA setup script. QuiteMode:False<br>2023-04-12 14:23:22,798  [I] Using Java:/usr/lib/jvm/java-openjdk/bin/java<br>2023-04-12 14:23:22,799  Enter db flavour&#123;MYSQL|ORACLE|POSTGRES|MSSQL|SQLA&#125; :<br>MYSQL<br>2023-04-12 14:23:27,291  [I] DB FLAVOR:MYSQL<br>2023-04-12 14:23:27,291  Enter JDBC connector file <span class="hljs-keyword">for</span> :MYSQL<br>/opt/mysql-connector-java.jar<br>2023-04-12 14:23:38,116  Enter DB Host :<br>&lt;HOST&gt;<br>2023-04-12 14:23:46,890  [I] DB Host:&lt;HOST&gt;<br>2023-04-12 14:23:46,890  Enter db root user:<br>admin<br>2023-04-12 14:23:50,127  Enter db root password:<br>Enter db root password:<br>2023-04-12 14:23:53,487  Enter DB Name :<br>ranger<br>2023-04-12 14:23:56,159  Enter db user name:<br>rangeradmin<br>2023-04-12 14:24:01,899  Enter db user password:<br>Enter db user password:<br></code></pre></td></tr></table></figure><p>스크립트 실행이 끝난 후 DB에 접속해보면 ranger DB와 사용자가 생겼을 것이다. 그 다음 <code>setup.sh</code>을 실행한다.</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">2023</span><span class="hljs-number">-04</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">41</span>:<span class="hljs-number">23</span>,<span class="hljs-number">722</span>  [I] Checking <span class="hljs-keyword">connection</span> passed.<br><span class="hljs-number">2023</span><span class="hljs-number">-04</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">41</span>:<span class="hljs-number">23</span>,<span class="hljs-number">723</span>  [I] RANGER_ADMIN_ENV_PATH : /opt/ranger_admin<br><span class="hljs-number">2023</span><span class="hljs-number">-04</span><span class="hljs-number">-12</span> <span class="hljs-number">14</span>:<span class="hljs-number">41</span>:<span class="hljs-number">23</span>,<span class="hljs-number">723</span>  [I] env_file_path : /opt/ranger_admin/ranger-<span class="hljs-keyword">admin</span>-env*.sh<br>Installation <span class="hljs-keyword">of</span> Ranger PolicyManager Web Application <span class="hljs-keyword">is</span> completed.<br></code></pre></td></tr></table></figure><p>모든 것이 성공적으로 완료되었다면 셋팅은 끝난 것이다.</p><h3 id="web-server-start">Web Server Start</h3><p>마지막으로 ranger-admin 웹서버를 활성화한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ranger-admin start<br></code></pre></td></tr></table></figure><p>그 다음 <code>&lt;instance IP&gt;:6080</code>으로 접속하면 아래와 같이 로그인 페이지가 보일 것이다. 로그인은 아이디와 패스워드 모두 <code>admin</code>이다.</p><figure><img src="/images/177.png" alt="rangeradmin" /><figcaption aria-hidden="true">rangeradmin</figcaption></figure><p>로그인하면 본격적으로 정책을 관리할 수 있는 페이지가 보인다.</p><figure><img src="/images/174.png" alt="rangeradmin" /><figcaption aria-hidden="true">rangeradmin</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>BigData</category>
      
      <category>hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>apache</tag>
      
      <tag>compose</tag>
      
      <tag>ranger</tag>
      
      <tag>authentication</tag>
      
      <tag>ldap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Apache Ranger 설치 in Docker (1)</title>
    <link href="/ko/Hadoop/hadoop-11/"/>
    <url>/ko/Hadoop/hadoop-11/</url>
    
    <content type="html"><![CDATA[<p>하둡 에코시스템 중 하나인 Apache Ranger 설치 방법을 정리합니다. <span id="more"></span></p><h2 id="apache-ranger">Apache Ranger</h2><p>레인저(ranger)는 하둡 에코시스템에서 종합적인 데이터 보안을 활성화하고 관리할 수 있는 도구이다. 특정 그룹과 사용자에 따라 데이터 접근 권한을 관리하고 감사 로그를 관리할 수 있다. Ldap 프로토콜로 Directory 서비스에서 그룹/사용자 정보를 가져올 수 있으며, 정책 또한 Tag 기반 관리가 가능하다.</p><p>아래 사진은 레인저 아키텍처이다.</p><figure><img src="/images/175.png" alt="ranger" /><figcaption aria-hidden="true">ranger</figcaption></figure><h3 id="ranger-admin">Ranger admin</h3><p>ranger-admin은 엑세스 정책을 생성 및 관리하는 UI 인터페이스이다. 아래 사진처럼 다양한 플랫폼에 플러그인을 설치하여 어드민 웹페이지에서 관리할 수 있다.</p><figure><img src="/images/174.png" alt="rangeradmin" /><figcaption aria-hidden="true">rangeradmin</figcaption></figure><p>또한 audit 페이지에서는 로그인 이력이나 엑세스 로그 뿐만 아니라 ranger-usersync에서 전달해주는 사용자 목록도 확인할 수 있다.</p><figure><img src="/images/176.png" alt="adminaudit" /><figcaption aria-hidden="true">adminaudit</figcaption></figure><h3 id="ranger-usersync">Ranger usersync</h3><p>ranger-usersync는 유저정보를 생성 및 관리하여 ranger-admin에게 전달하는 프로세스이다. 기본 설정에서는 ranger-usersync서버에 있는 Unix 계정을 사용자로 전달하며, AD와 연동하여 그룹/사용자 정보를 가져오도록 변경할 수도 있다.</p><h2 id="설치-가이드">설치 가이드</h2><p>이번 설치 가이드에서는 현재 최신버전인 <strong>Ranger 2.4.0 버전</strong>을 설치하고자 한다. 해당 버전의 경우 dockerhub에 도커 이미지가 없어서 소스 코드를 다운로드 받아 직접 이미지를 빌드하고 실행할 것이다. 또한 Ranger를 사용하기 위해서는 시스템 매트릭을 저장하는 RDB와 audit을 저장 및 관리하는 검색엔진이 필요하다. 따라서 이번 설치 가이드에서는 아래 조건을 바탕으로 진행된다.</p><ul><li>Ranger 올릴 서버(AWS EC2)<ul><li>OS: Linux 기반</li><li>Docker 설치</li><li>Git 설치 (선택)</li></ul></li><li>RDB: Mysql(AWS RDS)</li><li>AUDIT: Elasticsearch(AWS OpenSearch)</li><li>LDAP: AD(AWS simple AD)</li></ul><p>위 목록을 바탕으로 구성된 아키텍처는 다음과 같다.</p><figure><img src="/images/173.png" alt="architecture" /><figcaption aria-hidden="true">architecture</figcaption></figure><h3 id="ranger-소스코드-다운로드">Ranger 소스코드 다운로드</h3><p>먼저 소스 코드를 다운로드 받는다. 소스코드를 다운받는 방법은 크게 3가지가 있다.</p><ol type="1"><li>git clone으로 다운로드 받기 가장 간단한 방법은 <a href="https://github.com/apache/ranger">깃허브</a>에 레파지토리를 clone해오는 것이다.</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> --depth 1 --branch release-ranger-2.4.0 https://github.com/apache/ranger.git<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><code>wget</code> 명령어로 다운로드 받기 두 번째 방법으로는 <a href="https://ranger.apache.org/download.html">apache 페이지</a>에서 wget으로 다운로드 파일을 가져오는 것이다.</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ wget https://downloads.apache.org/ranger/2.4.0/apache-ranger-2.4.0.tar.gz<br></code></pre></td></tr></table></figure><p>이렇게 다운받은 경우 <code>tar.gz</code>로 묶여있기 때문에 압축을 해제해야 한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 압축 해제 후 폴더 이름 변경</span><br>$ tar xzvf apache-ranger-2.4.0.tar.gz &amp;&amp; <span class="hljs-built_in">mv</span> apache-ranger-2.4.0 ranger<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>apache 페이지에서 직접 다운로드 받기 폐쇄망처럼 <code>wget</code>으로 바로 다운받기 힘든 경우 <a href="https://ranger.apache.org/download.html">apache 페이지</a>에서 버전에 맞게 소스코드를 다운받을 수 있다.</li></ol><h3 id="소스코드를-다운로드-받는-이유">소스코드를 다운로드 받는 이유</h3><p>보통은 로컬에 코드를 다운로드 하지 않고 <code>dockerfile</code>에서 다운 받아 바로 빌드할 수 있도록 한다. 하지만 레인저의 경우 소스코드 내에 수많은 플러그인이 존재하는데 이 모든 것을 빌드할 필요도 없으며, 유지보수가 안되는 플러그인은 종종 빌드 에러의 원인이 된다.</p><p>버전 2.4.0의 경우에도 소스코드를 바로 빌드했더니 아래와 같은 에러가 발생했다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">[INFO] ------------------------------------------------------------------------<br>[INFO] Reactor Summary <span class="hljs-keyword">for</span> ranger 2.4.0:<br>[INFO]<br>[INFO] ranger ............................................. SUCCESS [ 14.037 s]<br>[INFO] Jdbc SQL Connector ................................. SUCCESS [  9.003 s]<br>[INFO] Credential Support ................................. SUCCESS [04:17 min]<br>[INFO] Audit Component .................................... SUCCESS [03:43 min]<br>[INFO] ranger-plugin-classloader .......................... SUCCESS [  3.238 s]<br>.<br>.<br>.<br>[INFO] Ranger Examples - SampleApp ........................ SUCCESS [  2.758 s]<br>[INFO] Ranger Examples - Ranger Plugin <span class="hljs-keyword">for</span> SampleApp ...... SUCCESS [  4.129 s]<br>[INFO] sample-client ...................................... SUCCESS [  4.387 s]<br>[INFO] Apache Ranger Examples Distribution ................ SUCCESS [  3.275 s]<br>[INFO] Ranger Tools ....................................... SUCCESS [ 18.098 s]<br>[INFO] Kylin Security Plugin .............................. FAILURE [07:55 min]<br>[INFO] Kylin Security Plugin Shim ......................... SKIPPED<br>[INFO] Elasticsearch Security Plugin Shim ................. SKIPPED<br>[INFO] Elasticsearch Security Plugin ...................... SKIPPED<br>[INFO] Apache Ranger Distribution ......................... SKIPPED<br>[INFO] Unix Native Authenticator .......................... SKIPPED<br>[INFO] ------------------------------------------------------------------------<br>[INFO] BUILD FAILURE<br>[INFO] ------------------------------------------------------------------------<br>[INFO] Total <span class="hljs-keyword">time</span>:  02:08 h<br>[INFO] Finished at: 2023-04-06T06:03:07Z<br>[INFO] ------------------------------------------------------------------------<br>[ERROR] Failed to execute goal on project ranger-kylin-plugin: Could not resolve dependencies <span class="hljs-keyword">for</span> project org.apache.ranger:ranger-kylin-plugin:jar:2.4.0: Failed to collect dependencies at org.apache.kylin:kylin-server-base:jar:3.1.3 -&gt; org.apache.kylin:kylin-query:jar:3.1.3 -&gt; org.apache.kylin:kylin-datasource-sdk:jar:3.1.3 -&gt; org.apache.calcite:calcite-linq4j:jar:1.16.0-kylin-r5: Failed to <span class="hljs-built_in">read</span> artifact descriptor <span class="hljs-keyword">for</span> org.apache.calcite:calcite-linq4j:jar:1.16.0-kylin-r5: Could not transfer artifact org.apache.calcite:calcite-linq4j:pom:1.16.0-kylin-r5 from/to spring-snapshots (https://repo.spring.io/libs-snapshot): Authentication failed <span class="hljs-keyword">for</span> https://repo.spring.io/libs-snapshot/org/apache/calcite/calcite-linq4j/1.16.0-kylin-r5/calcite-linq4j-1.16.0-kylin-r5.pom 401 Unauthorized -&gt; [Help 1]<br></code></pre></td></tr></table></figure><p><code>Kylin</code>이란 플랫폼 플러그인에서 발생하는 에러였고 나는 해당 플러그인이 필요하지 않았다. 그래서 <code>pom.xml</code>에서 해당 플러그인을 삭제하였다.</p><h3 id="ranger-base-docker-images-빌드">ranger-base docker images 빌드</h3><p>이제 하나씩 빌드해보자. 먼저 내려받은 ranger 소스코드를 maven으로 빌드하려고 한다.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos:centos7 as base<br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum update -y \</span><br><span class="language-bash">    &amp;&amp; yum -y install vim wget rpm-build <span class="hljs-built_in">which</span> tar git gcc java-1.8.0-openjdk-devel \</span><br><span class="language-bash">    &amp;&amp; yum clean all -y \</span><br><span class="language-bash">    &amp;&amp; yum install python3 -y</span><br><br><span class="hljs-keyword">ENV</span> JAVA_HOME /usr/lib/jvm/java-openjdk<br><span class="hljs-keyword">ENV</span> RANGER_HOME /opt/ranger<br><span class="hljs-keyword">ENV</span> MAVEN_HOME /opt/maven<br><span class="hljs-keyword">ENV</span> RANGER_VERSION <span class="hljs-number">2.4</span>.<span class="hljs-number">0</span><br><span class="hljs-keyword">ENV</span> MAVEN_VERSION <span class="hljs-number">3.6</span>.<span class="hljs-number">3</span><br><br><span class="hljs-keyword">ENV</span> MAVEN_OPTS <span class="hljs-string">&quot;-Xmx2048m -XX:MaxMetaspaceSize=512m&quot;</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> <span class="hljs-variable">$MAVEN_HOME</span> \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">export</span> http_proxy=<span class="hljs-variable">$http_proxy</span> \</span><br><span class="language-bash">    &amp;&amp; wget -P <span class="hljs-variable">$MAVEN_HOME</span> https://dlcdn.apache.org/maven/maven-3/<span class="hljs-variable">$MAVEN_VERSION</span>/binaries/apache-maven-<span class="hljs-variable">$MAVEN_VERSION</span>-bin.tar.gz \</span><br><span class="language-bash">    &amp;&amp; tar -xzvf <span class="hljs-variable">$MAVEN_HOME</span>/apache-maven-<span class="hljs-variable">$MAVEN_VERSION</span>-bin.tar.gz -C <span class="hljs-variable">$MAVEN_HOME</span> \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">rm</span> -f <span class="hljs-variable">$MAVEN_HOME</span>/apache-maven-<span class="hljs-variable">$MAVEN_VERSION</span>-bin.tar.gz</span><br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ranger /opt/ranger</span><br><br><span class="hljs-comment"># Or you can use the binary from the official site: https://ranger.apache.org/download.html (currently no pre-built available)</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">cd</span> /opt/ranger \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-variable">$MAVEN_HOME</span>/apache-maven-<span class="hljs-variable">$MAVEN_VERSION</span>/bin/mvn -Pall -DskipTests=<span class="hljs-literal">true</span> clean compile package install \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">rm</span> -rf ~/.m2 \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">ls</span> | grep -v target | xargs <span class="hljs-built_in">rm</span> -rf \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">rm</span> -rf target/*.zip</span><br><br><span class="hljs-keyword">FROM</span> base<br><br><span class="hljs-keyword">ENV</span> MYSQL_CONNECTOR_JAVA_VERSION <span class="hljs-number">5.1</span>.<span class="hljs-number">41</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum update -y \</span><br><span class="language-bash">    &amp;&amp; yum -y install mysql \</span><br><span class="language-bash">    &amp;&amp; yum clean all -y</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> wget -P /opt https://dev.mysql.com/get/Downloads/Connector-J/mysql-connector-java-<span class="hljs-variable">$MYSQL_CONNECTOR_JAVA_VERSION</span>.tar.gz \</span><br><span class="language-bash">    &amp;&amp; tar -zxvf /opt/mysql-connector-java-<span class="hljs-variable">$MYSQL_CONNECTOR_JAVA_VERSION</span>.tar.gz -C /opt \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">rm</span> -f /opt/mysql-connector-java-<span class="hljs-variable">$MYSQL_CONNECTOR_JAVA_VERSION</span>.tar.gz \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">ln</span> -s /opt/mysql-connector-java-<span class="hljs-variable">$MYSQL_CONNECTOR_JAVA_VERSION</span>/mysql-connector-java-<span class="hljs-variable">$MYSQL_CONNECTOR_JAVA_VERSION</span>-bin.jar /opt/mysql-connector-java.jar</span><br><br></code></pre></td></tr></table></figure><p>위 도커파일을 그대로 레인저 서버에 옮긴 후 도커 이미지로 빌드한다.</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker">$ docker build  . -t ranger-base:<span class="hljs-number">2.4</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>빌드는 대략 2-3시간 정도 소요된다. 그렇기에 가능하면 백그라운드로 실행하는 것을 추천한다.</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker">$ nohup docker build . -t ranger-base:<span class="hljs-number">2.4</span>.<span class="hljs-number">0</span> &gt;&gt; build.log &amp;<br></code></pre></td></tr></table></figure><h3 id="ranger-admin-docker-images-빌드">ranger-admin docker images 빌드</h3><p>다음으로는 아래 도커파일로 ranger-admin 이미지를 빌드한다.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ranger-base:<span class="hljs-number">2.4</span>.<span class="hljs-number">0</span><br><br><span class="hljs-keyword">ENV</span> RANGER_ADMIN_HOME /opt/ranger_admin<br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> tar -zxvf <span class="hljs-variable">$RANGER_HOME</span>/target/ranger-<span class="hljs-variable">$RANGER_VERSION</span>-admin.tar.gz -C /opt \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">ln</span> -s /opt/ranger-<span class="hljs-variable">$RANGER_VERSION</span>-admin <span class="hljs-variable">$RANGER_ADMIN_HOME</span> \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">rm</span> -rf <span class="hljs-variable">$RANGER_HOME</span></span><br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> <span class="hljs-variable">$RANGER_ADMIN_HOME</span></span><br></code></pre></td></tr></table></figure><p>이건 금방 빌드되기 떄문에 바로 실행해도 괜찮다.</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker">$ docker build  . -t ranger-admin:<span class="hljs-number">2.4</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="ranger-usersync-docker-images-빌드">ranger-usersync docker images 빌드</h3><p>마지막으로 AD와의 연동을 위한 anger-usersync 이미지를 빌드한다.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ranger-base:<span class="hljs-number">2.4</span>.<span class="hljs-number">0</span><br><br><span class="hljs-keyword">ENV</span> RANGER_USERSYNC_HOME /opt/ranger_usersync<br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> tar -zxvf <span class="hljs-variable">$RANGER_HOME</span>/target/ranger-<span class="hljs-variable">$RANGER_VERSION</span>-usersync.tar.gz -C /opt \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">ln</span> -s /opt/ranger-<span class="hljs-variable">$RANGER_VERSION</span>-usersync <span class="hljs-variable">$RANGER_USERSYNC_HOME</span> \</span><br><span class="language-bash">    &amp;&amp; <span class="hljs-built_in">rm</span> -rf <span class="hljs-variable">$RANGER_HOME</span></span><br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> <span class="hljs-variable">$RANGER_USERSYNC_HOME</span></span><br></code></pre></td></tr></table></figure><p>도커파일 저장을 완료했다면 아래 명령어로 빌드하자.</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker">$ docker build  . -t ranger-usersync:<span class="hljs-number">2.4</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>이제 기본적인 작업은 끝났다. 다음 글에서는 ranger-admin 구성하고 올리는 방법에 대해 알아볼 것이다.</p>]]></content>
    
    
    <categories>
      
      <category>BigData</category>
      
      <category>hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>apache</tag>
      
      <tag>compose</tag>
      
      <tag>ranger</tag>
      
      <tag>authentication</tag>
      
      <tag>ldap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. Polars란</title>
    <link href="/ko/OpenSource/polars-0/"/>
    <url>/ko/OpenSource/polars-0/</url>
    
    <content type="html"><![CDATA[<p>오픈소스 프로젝트인 <a href="https://github.com/pola-rs/polars">Polars</a>에서 기여하는 과정을 정리합니다.</p><span id="more"></span><h2 id="polar란">Polar란</h2><p><code>polars</code>는 <a href="https://arrow.apache.org/docs/format/Columnar.html">Apache Arrow Columnar Format</a> 메모리 모델을 바탕으로 개발된 DataFrames 라이브러리이며, Rust로 작성되었다. 데이터 분석 시에 사용되는 <code>pandas</code> 라이브러리와 많이 비교된다.</p><h2 id="polars-장점">Polars 장점</h2><ul><li>매우 빠르다. 다른 라이브러리와의 벤치마킹 결과를 <a href="https://www.pola.rs/benchmarks.html">이 페이지</a>에서 확인할 수 있다.</li><li>가볍다. Dependency가 거의 없고 Import 속도도 매우 빠르다.</li><li>RAM보다 큰 데이터도 핸들링할 수 있다. 메모리보다 큰 데이터가 있는 경우 쿼리를 스트리밍 방식으로 처리하여 메모리 요구량이 줄어든다.</li></ul><h2 id="사용-방법-예시">사용 방법 예시</h2><p>자세한 사용 방법은 <a href="https://pola-rs.github.io/polars-book/user-guide/index.html">유저 가이드</a> 에서 확인할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> polars <span class="hljs-keyword">as</span> pl<br><br><span class="hljs-comment"># 데이터프레임 생성</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>df = pl.DataFrame(<br><span class="hljs-meta">... </span>    &#123;<br><span class="hljs-meta">... </span>        <span class="hljs-string">&quot;A&quot;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>],<br><span class="hljs-meta">... </span>        <span class="hljs-string">&quot;fruits&quot;</span>: [<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>],<br><span class="hljs-meta">... </span>        <span class="hljs-string">&quot;B&quot;</span>: [<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>],<br><span class="hljs-meta">... </span>        <span class="hljs-string">&quot;cars&quot;</span>: [<span class="hljs-string">&quot;beetle&quot;</span>, <span class="hljs-string">&quot;audi&quot;</span>, <span class="hljs-string">&quot;beetle&quot;</span>, <span class="hljs-string">&quot;beetle&quot;</span>, <span class="hljs-string">&quot;beetle&quot;</span>],<br><span class="hljs-meta">... </span>    &#125;<br><span class="hljs-meta">... </span>)<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>df<br>shape: (<span class="hljs-number">5</span>, <span class="hljs-number">4</span>)<br>┌─────┬────────┬─────┬────────┐<br>│ A   ┆ fruits ┆ B   ┆ cars   │<br>│ --- ┆ ---    ┆ --- ┆ ---    │<br>│ i64 ┆ <span class="hljs-built_in">str</span>    ┆ i64 ┆ <span class="hljs-built_in">str</span>    │<br>╞═════╪════════╪═════╪════════╡<br>│ <span class="hljs-number">1</span>   ┆ banana ┆ <span class="hljs-number">5</span>   ┆ beetle │<br>│ <span class="hljs-number">2</span>   ┆ banana ┆ <span class="hljs-number">4</span>   ┆ audi   │<br>│ <span class="hljs-number">3</span>   ┆ apple  ┆ <span class="hljs-number">3</span>   ┆ beetle │<br>│ <span class="hljs-number">4</span>   ┆ apple  ┆ <span class="hljs-number">2</span>   ┆ beetle │<br>│ <span class="hljs-number">5</span>   ┆ banana ┆ <span class="hljs-number">1</span>   ┆ beetle │<br>└─────┴────────┴─────┴────────┘<br><br>    <span class="hljs-comment"># &quot;fruits&quot;기준으로 정렬</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>df.sort(<span class="hljs-string">&quot;fruits&quot;</span>).select(<br><span class="hljs-meta">... </span>    <span class="hljs-string">&quot;fruits&quot;</span>,  <span class="hljs-comment"># &quot;fruits&quot; 컬럼</span><br><span class="hljs-meta">... </span>    <span class="hljs-string">&quot;cars&quot;</span>,  <span class="hljs-comment"># &quot;cars&quot; 컬럼</span><br><span class="hljs-meta">... </span>    pl.lit(<span class="hljs-string">&quot;fruits&quot;</span>).alias(<span class="hljs-string">&quot;literal_string_fruits&quot;</span>),<br><span class="hljs-meta">... </span>    pl.col(<span class="hljs-string">&quot;B&quot;</span>).<span class="hljs-built_in">filter</span>(pl.col(<span class="hljs-string">&quot;cars&quot;</span>) == <span class="hljs-string">&quot;beetle&quot;</span>).<span class="hljs-built_in">sum</span>(),<br><span class="hljs-meta">... </span>    pl.col(<span class="hljs-string">&quot;A&quot;</span>).<span class="hljs-built_in">filter</span>(pl.col(<span class="hljs-string">&quot;B&quot;</span>) &gt; <span class="hljs-number">2</span>).<span class="hljs-built_in">sum</span>().over(<span class="hljs-string">&quot;cars&quot;</span>).alias(<span class="hljs-string">&quot;sum_A_by_cars&quot;</span>),<br><span class="hljs-meta">... </span>    pl.col(<span class="hljs-string">&quot;A&quot;</span>).<span class="hljs-built_in">sum</span>().over(<span class="hljs-string">&quot;fruits&quot;</span>).alias(<span class="hljs-string">&quot;sum_A_by_fruits&quot;</span>),<br><span class="hljs-meta">... </span>    pl.col(<span class="hljs-string">&quot;A&quot;</span>).reverse().over(<span class="hljs-string">&quot;fruits&quot;</span>).alias(<span class="hljs-string">&quot;rev_A_by_fruits&quot;</span>),<br><span class="hljs-meta">... </span>    pl.col(<span class="hljs-string">&quot;A&quot;</span>).sort_by(<span class="hljs-string">&quot;B&quot;</span>).over(<span class="hljs-string">&quot;fruits&quot;</span>).alias(<span class="hljs-string">&quot;sort_A_by_B_by_fruits&quot;</span>),<br><span class="hljs-meta">... </span>)<br>shape: (<span class="hljs-number">5</span>, <span class="hljs-number">8</span>)<br>┌──────────┬──────────┬──────────────┬─────┬─────────────┬─────────────┬─────────────┬─────────────┐<br>│ fruits   ┆ cars     ┆ literal_stri ┆ B   ┆ sum_A_by_ca ┆ sum_A_by_fr ┆ rev_A_by_fr ┆ sort_A_by_B │<br>│ ---      ┆ ---      ┆ ng_fruits    ┆ --- ┆ rs          ┆ uits        ┆ uits        ┆ _by_fruits  │<br>│ <span class="hljs-built_in">str</span>      ┆ <span class="hljs-built_in">str</span>      ┆ ---          ┆ i64 ┆ ---         ┆ ---         ┆ ---         ┆ ---         │<br>│          ┆          ┆ <span class="hljs-built_in">str</span>          ┆     ┆ i64         ┆ i64         ┆ i64         ┆ i64         │<br>╞══════════╪══════════╪══════════════╪═════╪═════════════╪═════════════╪═════════════╪═════════════╡<br>│ <span class="hljs-string">&quot;apple&quot;</span>  ┆ <span class="hljs-string">&quot;beetle&quot;</span> ┆ <span class="hljs-string">&quot;fruits&quot;</span>     ┆ <span class="hljs-number">11</span>  ┆ <span class="hljs-number">4</span>           ┆ <span class="hljs-number">7</span>           ┆ <span class="hljs-number">4</span>           ┆ <span class="hljs-number">4</span>           │<br>│ <span class="hljs-string">&quot;apple&quot;</span>  ┆ <span class="hljs-string">&quot;beetle&quot;</span> ┆ <span class="hljs-string">&quot;fruits&quot;</span>     ┆ <span class="hljs-number">11</span>  ┆ <span class="hljs-number">4</span>           ┆ <span class="hljs-number">7</span>           ┆ <span class="hljs-number">3</span>           ┆ <span class="hljs-number">3</span>           │<br>│ <span class="hljs-string">&quot;banana&quot;</span> ┆ <span class="hljs-string">&quot;beetle&quot;</span> ┆ <span class="hljs-string">&quot;fruits&quot;</span>     ┆ <span class="hljs-number">11</span>  ┆ <span class="hljs-number">4</span>           ┆ <span class="hljs-number">8</span>           ┆ <span class="hljs-number">5</span>           ┆ <span class="hljs-number">5</span>           │<br>│ <span class="hljs-string">&quot;banana&quot;</span> ┆ <span class="hljs-string">&quot;audi&quot;</span>   ┆ <span class="hljs-string">&quot;fruits&quot;</span>     ┆ <span class="hljs-number">11</span>  ┆ <span class="hljs-number">2</span>           ┆ <span class="hljs-number">8</span>           ┆ <span class="hljs-number">2</span>           ┆ <span class="hljs-number">2</span>           │<br>│ <span class="hljs-string">&quot;banana&quot;</span> ┆ <span class="hljs-string">&quot;beetle&quot;</span> ┆ <span class="hljs-string">&quot;fruits&quot;</span>     ┆ <span class="hljs-number">11</span>  ┆ <span class="hljs-number">4</span>           ┆ <span class="hljs-number">8</span>           ┆ <span class="hljs-number">1</span>           ┆ <span class="hljs-number">1</span>           │<br>└──────────┴──────────┴──────────────┴─────┴─────────────┴─────────────┴─────────────┴─────────────┘<br></code></pre></td></tr></table></figure><p>위 예시 중에서 몇 가지 문법을 간단하게 해석해보자.</p><ul><li><code>pl.lit("fruits").alias("literal_string_fruits")</code>: fruits라는 문자열을 데이터로 literal_string_fruits 컬럼 생성</li><li><code>pl.col("B").filter(pl.col("cars") == "beetle").sum()</code>: cars 컬럼이 beetle인 B 요소만 더한 값</li><li><code>pl.col("A").filter(pl.col("B") &gt; 2).sum().over("cars").alias("sum_A_by_cars")</code>: B 컬럼 값이 2보다 큰 A 컬럼을 cars 기준으로 더한 값</li><li><code>pl.col("A").sum().over("fruits").alias("sum_A_by_fruits")</code>: A 컬럼을 fruits 기준으로 더한 값</li><li><code>pl.col("A").reverse().over("fruits").alias("rev_A_by_fruits")</code>: fruits 기준으로 A 컬럼 값을 반전</li><li><code>pl.col("A").sort_by("B").over("fruits").alias("sort_A_by_B_by_fruits")</code>: fruits 기준으로 A 컬럼을 B 값으로 정렬</li></ul><h2 id="컨트리뷰션-가이드">컨트리뷰션 가이드</h2><p>오픈소스에 기여하기 위해서는 <a href="https://github.com/pola-rs/polars/blob/master/CONTRIBUTING.md">컨트리뷰션 가이드</a>를 먼저 읽어보는 것이 좋다. 만약 다른 컨트리뷰터와 소통하고 싶다면 <a href="https://discord.com/invite/4UfP5cfBE7">디스코드</a>에서 만날 수 있다.</p><h3 id="해결하고-싶은-이슈-고르기">1. 해결하고 싶은 이슈 고르기</h3><p>먼저 해결하고 싶은 이슈를 골라야 한다. open된 이슈 목록은 <a href="https://github.com/pola-rs/polars/issues">이슈 페이지</a>에서 확인할 수 있으며, 처음 도전하는 경우 <code>label</code>에서 <code>good first issue</code>로 필터링해서 골라도 된다.</p><figure><img src="/images/172.png" alt="issue" /><figcaption aria-hidden="true">issue</figcaption></figure><p>만약 좀 더 주요한 이슈를 고르고 싶다면 <code>label</code>에서 <code>help wanted</code>로 필터링하면 목록을 볼 수 있다.</p><h3 id="로컬-환경-구성하기">2. 로컬 환경 구성하기</h3><p>polars는 크게 Rust, Python, Node.js로 구성되어 있다. <a href="https://github.com/pola-rs/polars">polars</a>의 경우 Rust와 Python 환경이 필요하며, Node.js에 기여를 하고 싶다면 [nodejs-polars]](https://github.com/pola-rs/nodejs-polars)를 살펴보자. 이 글에서는 <a href="https://github.com/pola-rs/polars">polars</a> 저장소를 기준으로 한다.</p><p>개발을 위한 로컬 환경을 구성해야 한다. 먼저 polars repo를 내 계정으로 fork 한다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git clone git@github.com:&lt;username&gt;/polars.git<br>cd polars<br></code></pre></td></tr></table></figure><p>그 다음 Rust와 python을 설치한다. Rust의 경우 <a href="https://www.rust-lang.org/tools/install">rustup</a>을 사용하여 다운로드 받기를 추천한다. 설치가 끝났다면 아래 명령어를 입력하여 <code>toolchain</code>도 설치한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rustup toolchain install nightly --component miri<br></code></pre></td></tr></table></figure><p>마지막으로 python은 <code>pyenv</code> 환경을 구성한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> py-polars<br><span class="hljs-built_in">source</span> .venv/bin/activate<br>make <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>테스트가 정상적으로 완료되었다면 아래 코드를 사용하여 린트 도구도 정상 작동하는지 확인한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make pre-commit<br></code></pre></td></tr></table></figure><p>모든 것이 완료되었다면 커밋할 준비가 된 것이다.</p><h3 id="이슈-해결하기">3. 이슈 해결하기</h3><p>로컬 레파지토리에서 새로운 브랜치를 하나 생성해서 코딩을 시작한다. 코어 코드들은 <code>polars</code> 디렉토리에 있고, Python 코드들은 <code>py-polars</code> 디렉토리에 있다. 두 디렉토리에 모두 유용한 명령어가 포함된 <code>Makefile</code>이 포함되어 있다.</p><ul><li><code>make test</code>: <a href="https://github.com/pola-rs/polars/blob/main/py-polars/tests/README.md">다양한 테스트</a>를 실행.</li><li><code>make pre-commit</code>: 포메팅과 린트 이슈를 확인.</li></ul><p>이슈 해결을 진행할 때 아래 사항들을 유의해야 한다.</p><ul><li>위 두 개의 <code>make</code> 명령어가 실패하면 작업한 내용을 병합할 수 없다.</li><li>테스트가 필요한 코드를 추가했다면 꼭 테스트도 추가해주어야 한다.</li><li>Public API를 변경하는 경우 문서를 업데이트 해야 한다.</li></ul><h3 id="pr-올리기">4. PR 올리기</h3><p>문제를 해결했다면 PR(Pull Request)을 올릴 수 있다. PR은 아래 가이드라인을 준수해야 한다.</p><ul><li>PR 제목은 <a href="https://www.conventionalcommits.org/en/v1.0.0/">커밋 컨벤션</a>에 맞춰 작성해야 한다. 올바르게 작성된 제목은 변경이력에 기여내용을 남기는 데 도움이 된다. 범위는 기여도에 따라 Rust 또는 Python이 될 수 있다.</li><li>제목에 변경에 대한 설명을 포함해야 한다. 이 텍스트는 변령이력에 포함된다.</li><li>PR 설명에 작업 중인 이슈에 대한 링크를 추가해야 한다.</li><li>설명에 메인테이너가 코드를 검토하는 데 도움이 될 수 있는 관련 정보를 추가해야 한다.</li><li>지금 브랜치가 최신 버전에 대해 rebase가 되어 있는지 확인해야 한다.</li><li>모든 Github 작업 확인을 통과했는지 확인해야 한다.</li></ul><p>PR을 열면 메인테이너가 이를 검토하고 몇 가지 의견을 남길 수 있다. 모든 문제가 해결되면 메인테이너가 PR을 병합하고 기여한 내용이 다음 polars 릴리즈에 포함될 것이다.</p><p>해결이 막히거나 확실하지 않은 경우 PR 드래프트를 열어 도움을 요청할 수도 있다.</p>]]></content>
    
    
    <categories>
      
      <category>OpenSource</category>
      
      <category>polars</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>rust</tag>
      
      <tag>dataframe</tag>
      
      <tag>polars</tag>
      
      <tag>pandas</tag>
      
      <tag>numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>If(kakao)dev2022 세션 리뷰</title>
    <link href="/ko/Reviews/sesson-0/"/>
    <url>/ko/Reviews/sesson-0/</url>
    
    <content type="html"><![CDATA[<p>해당 글은 2022년 카카오에서 진행한 기술세션을 보고 알게된 정보나 개인적으로 느꼈던 점들을 정리한 글입니다. <span id="more"></span></p><hr /><h2 id="카카오페이-mlops-적용기-feat.-aws">카카오페이 MLOps 적용기 (feat. AWS)</h2><p>나 또한 회사에서 MLOps 플랫폼 개발 프로젝트에 참여할 예정이라서 집중해서 들었다. 나중에 참고해야 할 수 있으니 여기에 <a href="https://if.kakao.com/2022/session/67">세션 링크</a>를 남겨두자.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">- 카카오페이에는 개인신용평가, 이상거래탐지, 유저프로파일 등을 위한 모델이 운영되고 있다.<br>- `Feature 데이터` -&gt; `ML 모델` -&gt; `모델 서빙` 구조는 모델 업데이트가 필요할 때마다 파이프라인을 다시 구축해야 하며 생산성이 저하된다.<br>- 표준화된 MLOps 컴포넌트 정의(모델 학습 파이프라인, Feature Store, 모델 서빙) 후 인프라 구축을 진행하였다.<br>- AWS Step Function은 SageMaker와 연동하여 모델학습 파이프라인을 쉽게 구축할 수 있다.<br>- 모델 관리 서비스는 MLflow와 SageMaker Model Registry 중 비교 후 운영난이도가 낮은 Model Registry 선택하였다.<br>- 학습 파이프라인: 개발 -&gt; S3 -&gt; Lambda -&gt; Step Function -&gt; Model Registry -&gt; 승인 후 모델 배포<br>- Feature Store: 오프라인 스토어(훈련할 Feature 데이터 보관)와 온라인 스토어(실제 예측모델에서 사용하는 Feature 보관)<br>- Feature Store 후보군: Feast, SageMaker Feature Store -&gt; PoC 후 Feast 선택<br>- 메타 관리나 트러블 슈팅 등의 편의성을 비교한 결과 Feast를 선택하였으며, 물리 스토리지로는 오프라인 스토어로 S3 + Athena, 온라인 스토어로 redis를 선택하였다.<br>- 모델 서빙 아키텍처: 모델 프록시(Spring MVC) + 모델 인터페이스(ONNX, FastAPI)<br></code></pre></td></tr></table></figure><h2 id="카카오-하둡-플랫폼의-아키텍처와-개발운영에-대한-이야기">카카오 하둡 플랫폼의 아키텍처와 개발/운영에 대한 이야기</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">- 하둡 클러스터 140개 이상 / 노드는 약 1만대 정도 운영 중이다.<br>- 2019년까지만 해도 외부 솔루션을 사용하여 클러스터 운영 -&gt; 서버비용 증가 및 새로운 기능 도입 어려움의 문제점 존재<br>- 차세대 카카오 하둡 플랫폼(KHP)을 개발하기로 결정하였다.<br>- KHP 구성요소: 배포판, 배포툴, 관리에이전트, 관리서버, 로그서비스<br>- 에이전트는 kafka와 druid를 사용하여 매트릭을 가져왔으며, druid SQL를 통해 Grafana로 대시보드를 생성하였다.<br>- 로그서비스는 filebeat으로 수집하고 kafka와 logstash를 통해 가져온 후 es에 색인 및 저장, kibana로 시각화하였다.<br>- 외부 솔루션을 사용하다가 자체 개발 솔루션을 도입한 결과 유지보수나 비용적인 측면에서 많이 개선되었다.<br>- 오픈소스를 사용하다보니 소스 코드 자체에 대한 버그도 다수 존재했으며, 이를 하나씩 수정하고 컨트리뷰트도 진행하였다.<br>- ranger를 도입했는데 소스 코드에 많은 버그들이 있었고 문서도 별로 없어서 고생했다.<br></code></pre></td></tr></table></figure><h2 id="sequential-recommendation-system-카카오-서비스-적용기">Sequential Recommendation System 카카오 서비스 적용기</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">- 시퀀스 추천 모델은 웹툰과 같이 아이템 업데이트와 소비가 시간/요일에 dependency를 가지는 경우 적합하다.<br>- 세션에서 소개된 모델은 BERT4Rec과 SMLP(Sequence-Aware MLP)이며, BERT4Rec에 비해 SMLP가 가볍다.<br>- 추천 모델은 AB 테스트를 통해 CTR(클릭률, Click-Through Rate)과 CVR(전환율, Conversion Rate) 지표를 확인하여 실험하였다.<br>- 개인화 추천은 Diversity와 Cold start 이슈가 존재한다.<br>- Diversity는 이미 소비한 아이템을 다시 추천하게 되는 경우이며, Cold start는 새로 진입한 아이템의 경우 추천에서 제외되는 경우를 의미한다.<br></code></pre></td></tr></table></figure><h2 id="ai로-난치병을-치료할-수-있을까요">AI로 난치병을 치료할 수 있을까요?</h2><p>흥미로운 주제라서 지나칠 수 없었다. 신약 개발할 때 전임상이나 임상 시 동물실험 대신 AI 시뮬레이터로 시험을 하는 시대가 왔으면 좋겠다고 생각했던 적이 있었기 때문이다. 세션에서 얻은 정보를 몇가지 적어두자.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">- PubChem은 저분자화합물 데이터베이스이며 대략 1억개 데이터를 보관하고 있고, Protein Data Bank는 20만개의 단백질 구조 정보를 가지고 있다.<br>- 인실리코는 계산화학 또는 계산생물학 방법론을 바탕으로 분석하는 도구이며 이를 통해 많은 신약 개발이 이루어지고 있다.<br>- 알파폴드2 모델이 등장하여 정확도 평균 92%를 달성하였다. 이는 사람 정확도 90%보다 높다.<br>- 구글과 딥마인드가 알파폴드2를 바탕으로 Isomorphic Labs라는 회사를 만들었다.<br>- 딥마인드는 알파폴드2를 통해 얻은 2억개의 단백질 구조 데이터를 공개하였다.<br>- 신약 개발 업계에서도 Large-scale AI가 많이 사용되고 있으며, 매우 강력한 도구 중 하나이다.<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>etc.</category>
      
      <category>reviews</category>
      
    </categories>
    
    
    <tags>
      
      <tag>엔지니어</tag>
      
      <tag>개발자</tag>
      
      <tag>빅데이터</tag>
      
      <tag>주니어</tag>
      
      <tag>소프트웨어</tag>
      
      <tag>세션</tag>
      
      <tag>플랫폼</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS 캐시와 분산</title>
    <link href="/ko/Infra/infra-3/"/>
    <url>/ko/Infra/infra-3/</url>
    
    <content type="html"><![CDATA[<p>글을 시작하기에 앞서 해당 글은 이토 나오야, 다나카 신지의 저서인 『웹 개발자를 위한 대규모 서비스를 지탱하는 기술』 를 바탕으로 요약 및 정리한 글임을 알려드립니다. <span id="more"></span></p><p>OS 캐시를 사용하면 대규모의 데이터도 효율적으로 처리할 수 있다. 이번 글에서는 OS 캐시 작동원리에 대해서 간단하게 살펴보고 어떻게 구성해야 효율적인지 방법들을 이야기하고자 한다.</p><h2 id="os-캐시란">OS 캐시란</h2><p>리눅스에서는 페이지 캐시라고 하는 캐시 구조를 가지고 있다. 이를 설명하기 위해서는 리눅스의 가상메모리 원리에 대해서 이해해야 한다.</p><p>가상 메모리란 하드웨어 물리 메모리 어드레스를 OS에서 추상화한 구조를 의미한다. 만약 K 프로세스가 A라는 파일을 읽어야 한다고 요청하면 OS는 A 파일을 메모리에 올린 후 해당 메모리 어드레스를 직접 프로세스에게 넘기는 것이 아니라 일단 커널 내에서 추상화하여 전달한다. 이렇게 하는 이유는 여러가지가 있지만 일단 페이지 캐시 또한 이유에 포함된다. OS는 K 프로세스가 A 파일을 다 읽어서 더이상 필요 없어도 물리 메모리 할당을 해제하지 않는다. 그렇게 메모리에 올려두면 또 다른 프로세스가 A 파일을 요청할 때 디스크 I/O 없이 바로 전달할 수 있기 때문이다. 이것이 OS캐시의 기본원리이다.</p><p>가상 메모리는 메모리 영역을 4KB 블록 단위로 관리하며, 이 블록을 <code>페이지</code>라고 한다. 그렇기에 4GB 메모리를 가진 서버도 8GB의 파일을 일부 캐싱할 수 있다. 캐싱은 파일단위로 이루어지는 것이 아니며, 해당 파일의 i노드 번호와 위치를 나타내는 오프셋 값을 키로 캐싱하기 때문이다.<br />또한 리눅스는 비어있는 메모리에 모두 캐싱을 진행하며, 프로세스 요청으로 메모리가 필요한 경우에는 가장 오래된 캐싱을 제거(LRU)하여 메모리를 확보해준다.</p><h2 id="캐시를-사용하여-io-부하-줄이는-법">캐시를 사용하여 I/O 부하 줄이는 법</h2><p>그렇기에 OS 캐시를 사용하면 OS가 더이상 디스크로 접근할 필요성이 낮아지기에 I/O 부하는 줄어들 수 있다. 그래서 데이터가 많아졌을 때 부하를 줄이는 가장 빠른 방법은 메모리를 추가하여 OS캐시가 더 많이 일어나도록 환경을 만들어주는 것이다. 특히 서버에 존재하는 데이터를 모두 캐싱할 수 있다면 이는 모든 데이터를 메모리에 올려두고 사용하는 것과 동일하다. 따라서 데이터 파일들을 적절하게 압축하여 저장한다면 더 많은 데이터들을 캐싱하여 사용할 수 있을 것이다.</p><p>하지만 메모리를 추가하는 것은 여러가지 이유로 한계가 있다. 실제 물리 서버에 추가할 수 있는 메모리 슬롯이 제한되어 있다는 점, 서비스 규모가 커질수록 스케일 업이 어렵다는 점 등이다. 따라서 하나의 서버 캐싱으로 해결할 수 없는 경우에는 스케일 아웃을 진행해야 한다.</p><h2 id="locality를-살리는-분산">locality를 살리는 분산</h2><p>스케일 아웃을 진행할 때는 물리적인 서버 수만 늘리는 것이 아니라 데이터에 대한 액세스 패턴을 고려해서 분산시켜야 한다. 그렇게 설계하면 특정 엑세스마다 필요한 데이터가 모든 서버에 캐싱된 형태로 실행될 수 있다. 이런 분산 처리를 locality 방법이라고 한다.</p><p>locality 방법은 크게 파티셔닝과 요청 패턴에 따른 분할 두 가지가 있다. 파티셔닝 중 대표적인 방법은 테이블에 따른 분할이다. 이는 엑세스가 같이 발생하는 테이블들을 묶어서 같은 DB 서버에 저장해두는 방식이다. 이렇게 분할하면 각 DB 서버마다 모든 데이터가 캐싱되면서 데이터 요청 시 하나의 DB 서버에서 처리할 수 있다.<br />그 외에도 테이블 데이터에 따른 파티셔닝도 있다. 이 방법은 특정 테이블 하나를 여러 개의 작은 테이블로 분할하여 각각의 DB 서버로 나눠 저장하는 것이다. 에를 들어 회원정보 테이블이라면 ID a~c 범위는 1번 DB 서버에 저장하고 d~f 범위는 2번 DB서버에 저장해서 엑세스 요청이 들어올 때마다 ID를 확인해서 해당하는 DB서버로 요청을 전달하는 방식이다.</p><p>마지막으로 볼 방법은 요청 패턴에 따른 분할이다. 보통 웹서비스를 운영하다보면 일단 사용자 요청, API 요청, 봇 크롤링 요청 등 다양한 트래픽을 볼 수 있다. 이런 트래픽에 따라서 DB서버를 분할하여 처리하는 방법이다. 봇 크롤링 같은 경우에는 특성 상 매우 오래된 페이지에도 엑세스하며, 범위도 광범위하다. 그래서 캐싱데이터를 관리하기 어렵지만 봇에게는 빠르게 응답 처리를 진행할 필요가 없다. 반면 사용자 요청의 경우에는 최신 업데이트된 페이지로의 엑세스 요청이 대부분이며 이런 경우에는 최신 데이터들을 캐싱해두면 된다. 이런 식으로 요청자 분류에 따라서 다르게 대처할 수 있도록 분할할 수 있다.</p>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>infrastructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>데이터</tag>
      
      <tag>인프라</tag>
      
      <tag>분산처리</tag>
      
      <tag>대규모데이터</tag>
      
      <tag>데이터구조</tag>
      
      <tag>서버</tag>
      
      <tag>OS</tag>
      
      <tag>운영체제</tag>
      
      <tag>캐시</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>대규모 데이터 처리 입문</title>
    <link href="/ko/Infra/infra-2/"/>
    <url>/ko/Infra/infra-2/</url>
    
    <content type="html"><![CDATA[<p>글을 시작하기에 앞서 해당 글은 이토 나오야, 다나카 신지의 저서인 『웹 개발자를 위한 대규모 서비스를 지탱하는 기술』 를 바탕으로 요약 및 정리한 글임을 알려드립니다. <span id="more"></span></p><h2 id="왜-대규모-데이터-처리는-어려울까">왜 대규모 데이터 처리는 어려울까?</h2><p><code>대규모</code>라는 단어는 참 애매하다. 숫자로 정확한 기준을 정의할 수 없기 때문이다. 보통 모든 IT 인프라는 서비스 성장에 따라 규모도 변하는데 아래의 조건을 신경써야 한다면 규모 단위를 변경해야 한다는 시그널이다.</p><ul><li>부하분산: 엑세스 빈도가 더이상 현재 서버로는 처리할 수 없다. 부하를 분산하기 위해서 서버의 스케일 아웃이나 스케일 업이 필요하다.</li><li>다중성: 다루는 서버가 많아질수록 에러률도 올라간다. 특정 서버가 고장난다고 서비스 운영에 지장이 있는 구조를 벗어나야 한다.</li><li>효율적인 운용: 더이상 관리하는 서버 IP를 외울 수 없다. 클러스터로 묶어서 한번에 관리해주는 툴이 필요하다.</li><li>개발자 수와 개발방법: 이 많은 일을 나 혼자 다해야한다니 지옥이다. 개발자를 더 뽑고 코딩 규약을 정해서 표준화 하자.</li></ul><p>위 조건들은 그나마 비교적 처리가 수월하다. 사람을 더 뽑고 플랫폼을 도입하고 웹서버 분산 셋팅은 비교적 어렵지 않기 때문이다. 사실 규모가 커질수록 가장 큰 어려움은 바로 대용량의 데이터 처리이다. 데이터를 분산시켜 처리하는 것은 여러모로 복잡하기 때문이다.</p><p>왜 많은 양의 데이터를 처리하면 시간이 오래걸릴까? 또 분산처리는 왜 어려울까? 이 부분에 대해서 정리해보자.</p><h2 id="메모리와-디스크">메모리와 디스크</h2><p>메모리와 디스크 중에 데이터 처리에 있어 메모리가 더 빠르다는 사실은 대부분 알고 있다. 하지만 <code>왜</code> 더 빠른지에 대해 설명할 수 있는가?<br />먼저 디스크는 원반 모양의 데이터를 직접 저장하는 부분인 플래터와 데이터를 읽어드리는 부분인 헤드가 존재한다. 만약 유저가 어떤 데이터 엑세스를 요청한다면 플래터는 회전을 하고 헤드는 해당 데이터 위치의 자성을 파악하여 데이터를 읽는다. 즉 플래터가 회전을 하고 헤드가 해당 부분까지 이동을 하는 물리적인 이동 시간이 소요되는 것이다. 플래터의 회전속도(RPM, Revolution Per Minute)가 아무리 빨라도 1회 탐색 당 밀리초 정도가 소요된다.<br />반면 메모리는 물리적인 이동 없이 전기 신호로 모든 것들을 처리하며, 그렇기에 데이터 저장 위치에 따른 속도 차이가 없다. 메모리는 보통 1회 탐색하는데 마이크로초 정도가 소요된다. 비교해보면 1초에 디스크는 1000번, 메모리는 1000000번 데이터 탐색이 가능한 것이다.<br />이 외에도 CPU와 연결된 버스(Bus)의 데이터 전송속도가 꽤 다르다. 해당 부분은 아래 실습에서 더 자세히 살펴보자.<br />요즘 보조기억장치로 HDD 대신 SSD를 많이 사용한다. SSD는 물리적인 회전이 아니기에 탐색은 비교적 빠르지만 버스의 전송속도나 구조 등의 문제로 메모리보다는 빠르지 않다.</p><h2 id="규모조정과-확장성">규모조정과 확장성</h2><p>규모 조정은 크게 스케일 업과 스케일 아웃으로 나뉜다. 하지만 두 전략 중에 보편적으로 선택하는 것은 스케일 아웃 전략이다. 보통 하드웨어는 가격 상승과 성능이 비례로 올라가지 않기 때문이다. 새로나온 좋은 하드웨어가 성능은 2배가 되었지만 가격은 10배가 되는 현상은 주변에서 쉽게 찾아볼 수 있다. 또한 스케일 업과 스케일 아웃은 확장성에서도 큰 차이를 가진다. 스케일 업은 현재까지 상품화된 성능이 가장 좋은 하드웨어를 사용하면 그 이상 확장할 수 없지만 스케일 아웃은 프로그램이 매니징만 가능하다면 계속 하드웨어를 추가할 수 있기 때문이다.<br />보통 우리가 규모를 조정해야 한다고 느끼는 이유는 크게 2가지이다. 바로 CPU 부하와 I/O 부하이다. 두가지의 부하를 웹서비스 아키텍처를 기반으로 살펴보자.</p><blockquote><p>웹 애플리케이션 구조에는 프록시, AP 서버, DB가 있고 보통 프록시를 통해 요청이 들어오고 이를 위해 AP서버가 DB에 필요한 데이터를 요청한다. 즉 프록시 -&gt; AP -&gt; DB 순으로 요청이 이루어지는 것이다. DB는 AP서버가 요청한 데이터를 찾아서 이를 반환하는데 이 과정에서 I/O가 발생하고 AP서버는 받은 데이터를 바탕으로 필요한 형태로 변환하여 클라이언트로 응답을 보낸다. 이 구조에서는 보통 DB가 I/O부하 발생률이 높으며, AP서버는 CPU 부하 발생률이 높다.</p></blockquote><p>서비스가 성장하면서 두 부하가 발생한다면 보통 스케일 아웃 전략에 따라 서버를 추가한다. CPU 부하의 경우 비교적 스케일 아웃이 쉽다. 앞에 로드밸런서를 붙여 들어오는 일감을 여러 AP서버에 나눠주면 되기 때문이다. 하지만 I/O부하는 조금 다르다. 하나의 서비스는 동일한 시간에 동일한 데이터를 유지해야 한다. 만약 사용자 A는 코드가 123로 보이는데 사용자 B는 동일한 코드가 456으로 보인다면 이는 데이터 정합성 문제로 이어진다. 따라서 여러 DB서버는 실시간으로 동기화가 이루어져야 한다. 이 부분이 확장성에 많은 어려움을 보여준다.</p><h2 id="대규모를-위한-준비">"대규모"를 위한 준비</h2><p>대규모 데이터를 다루기 위한 준비로는 아래와 같다.</p><ul><li>최대한 메모리에서 처리를 끝내기: 디스크 탐색 횟수를 최소환하기, 국소성을 활용한 분산실현</li><li>데이터량 증가에 강한 알고리즘 데이터 구조: 선형검색 -&gt; 이분검색</li><li>데이터 압축, 정보검색기술</li></ul><p>마지막으로 위와 같은 프로그램을 개발하기 위해서는 아래의 3가지를 알고 있어야 한다.</p><ul><li>OS 캐시</li><li>분산을 고려한 RDBMS 운용</li><li>알고리즘과 데이터 구조</li></ul><h2 id="실제-사용툴">실제 사용툴</h2><p>Docker에서 직접 Centos7 서버를 셋팅해서 실습해보자. 먼저 실습할 환경에 Docker가 설치되어 있어야 한다. 만약 설치되어 있지 않다면 <a href="https://docs.docker.com/get-docker/">Docker 홈페이지</a>에서 설치파일을 다운받아 설치해야 한다. 도커 환경이 구성되었다면 아래의 명령어로 간단한 Centos7 컨테이너 하나를 생성하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">❯ docker pull images centos:7<br>❯ docker run --privileged -d --name centos-test centos:7 /sbin/init<br></code></pre></td></tr></table></figure><p>그후 컨테이너를 조회해보면 생성된 것을 확인할 수 있다. 그후에 옵션 <code>-it</code>룰 사용하여 해당 컨테이너에 접속하면 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 생성 확인 및 컨테이너 ID 복사</span><br>❯ docker ps<br>CONTAINER ID   IMAGE      COMMAND        CREATED         STATUS         PORTS     NAMES<br>&#123;containerid&#125; centos:7   <span class="hljs-string">&quot;/sbin/init&quot;</span>   9 minutes ago   Up 9 minutes             centos-test<br><br><span class="hljs-comment"># 터미널 접속</span><br>❯ docker <span class="hljs-built_in">exec</span> -it &#123;containerid&#125; /bin/bash<br></code></pre></td></tr></table></figure><p>이렇게 컨테이너에 접속했다면 실습 준비가 완료된 것이다.</p><h3 id="top">top</h3><p>top 명령어는 내장되어 있기 때문에 터미널에서 바로 명령어를 입력하면 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; top<br><br>top - 01:55:28 up  9:59,  0 <span class="hljs-built_in">users</span>,  load average: 0.02, 0.05, 0.02<br>Tasks:   8 total,   1 running,   7 sleeping,   0 stopped,   0 zombie<br>%Cpu(s):  0.3 us,  0.6 sy,  0.0 ni, 99.2 <span class="hljs-built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<br>KiB Mem :  2035400 total,   927040 free,   400924 used,   707436 buff/cache<br>KiB Swap:  1048572 total,  1040332 free,     8240 used.  1078700 avail Mem <br><br>  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                                                                <br>    1 root      20   0   43356   5236   4104 S   0.0  0.3   0:00.47 systemd                                                                                                                                <br>   23 root      20   0   39076   4180   3892 S   0.0  0.2   0:00.37 systemd-journal                                                                                                                        <br>   61 root      20   0   24276   2784   2524 S   0.0  0.1   0:00.07 systemd-logind                                                                                                                         <br>   63 dbus      20   0   58148   4308   3728 S   0.0  0.2   0:00.10 dbus-daemon                                                                                                                            <br>   65 root      20   0    9940   1712   1580 S   0.0  0.1   0:00.00 agetty                                                                                                                                 <br>  165 root      20   0   34980   3128   2732 S   0.0  0.2   0:00.00 systemd-udevd                                                                                                                          <br>  255 root      20   0   11820   2968   2568 S   0.0  0.1   0:00.04 bash                                                                                                                                   <br>  270 root      20   0   56200   3844   3252 R   0.0  0.2   0:00.05 top   <br></code></pre></td></tr></table></figure><p>여기서 주요하게 볼 부분은 <code>load average</code>이다. <code>load average</code>는 시스템 전체 부하상황을 나타내며, 위에서 봤던 CPU 부하와 I/O부하를 합쳐서 나타낸다. 따라서 해당 인자값이 높은 경우는 현재 서버에 부하가 있다는 의미이다. 하지만 <code>load average</code>는 둘 중 어떤 부하가 발생한건지 자세하게 보여주지는 않는다. 좀 더 정확하게 판단하기 위해서 <code>sar</code> 명령어를 사용해보자.</p><h3 id="sar">sar</h3><p>먼저 sar 패키지를 아래의 명령어로 설치한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install sysstat<br></code></pre></td></tr></table></figure><p>그다음 아래의 명령어로 프로세스를 시작한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start sysstat<br></code></pre></td></tr></table></figure><p>그 다음 아래의 명령어를 입력해서 CPU 정보들을 출력한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sar -u 2 5<br></code></pre></td></tr></table></figure><p>옵션 <code>-u</code>는 정보를 프린트하라는 의미이며, 뒤의 2는 2초 간격으로 5는 행을 나타낸다. 위 명령어로 출력된 결과는 아래와 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">Linux 5.10.25-linuxkit (d2efd0bffa79) 10/19/22 _x86_64_(4 CPU)<br><br>10:53:01        CPU     %user     %<span class="hljs-built_in">nice</span>   %system   %iowait    %steal     %idle<br>10:53:03        all      0.13      0.00      0.51      0.00      0.00     99.37<br>10:53:05        all      0.13      0.00      0.51      0.00      0.00     99.37<br>10:53:07        all      0.00      0.00      0.51      0.00      0.00     99.49<br>10:53:09        all      0.13      0.00      0.63      0.00      0.00     99.24<br>10:53:11        all      0.38      0.00      0.76      0.00      0.00     98.86<br>Average:        all      0.15      0.00      0.58      0.00      0.00     99.27<br></code></pre></td></tr></table></figure><p>위 인자값 중에서 <code>%iowait</code>이 CPU가 디스크 I/O 대기를 기다린 시간 비율이다. 여기서 I/O 이슈를 확인할 수 있다.</p><h3 id="hdparm">hdparm</h3><p>hdparm 패키지 또한 아래의 명령어로 설치한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install hdparm<br></code></pre></td></tr></table></figure><p>설치가 끝났다면 <code>hdparm</code> 명령어를 통해 메모리와 디스크 버스 throughput을 측정할 수 있다. 먼저 측정할 디스크를 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; <span class="hljs-built_in">df</span><br>Filesystem     1K-blocks     Used Available Use% Mounted on<br>overlay         61255492 17056332  41057836  30% /<br>tmpfs              65536        0     65536   0% /dev<br>tmpfs            1017700        0   1017700   0% /sys/fs/cgroup<br>shm                65536        0     65536   0% /dev/shm<br>/dev/vda1       61255492 17056332  41057836  30% /etc/hosts<br>tmpfs            1017700     8436   1009264   1% /run<br></code></pre></td></tr></table></figure><p>현재 환경에서는 디스크가 <code>/dev/vda1</code>에 마운트되어 있다. 해당 Path를 가지고 아래의 명령어를 입력해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hdparm -tT /dev/vda1<br></code></pre></td></tr></table></figure><p>위 명령어에서 <code>-t</code>는 디스크 드라이브의 읽는 속도를 체크하고 <code>-T</code>는 디스크 드라이브에 대한 캐시데이터 읽는 속도를 체크한다. 디스크 캐시는 메모리에 올라가기 때문에 이를 디스크와 메모리의 속도 차이로 추산할 수 있다.</p>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>infrastructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>데이터</tag>
      
      <tag>인프라</tag>
      
      <tag>메모리</tag>
      
      <tag>대규모</tag>
      
      <tag>분산처리</tag>
      
      <tag>대규모데이터</tag>
      
      <tag>데이터구조</tag>
      
      <tag>서버</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>단일 스레드 웹서버 구현 (2)</title>
    <link href="/ko/Rust/rust-11/"/>
    <url>/ko/Rust/rust-11/</url>
    
    <content type="html"><![CDATA[<p>단일 스레드 웹서버를 러스트로 구현하는 과정을 정리합니다. <span id="more"></span></p><p>이전 글에서 HTTP 요청을 읽어오는 것까지 살펴보았다. 이번 글에서는 그 이후 요청을 분석하여 응답을 작성 및 보내는 과정에 대해서 정리하고자 한다.</p><p><a href="https://dev-bearabbit.github.io/2022/06/26/Rust/rust-10/">이전 글 보러가기</a></p><h2 id="http-요청-분석-및-검증하기">HTTP 요청 분석 및 검증하기</h2><p>요청을 분석하기 위해서는 HTTP 통신에 대해서 알아야 한다. 기본적으로 HTTP는 텍스트 기반 프로토콜로 클라이언트 요청 정보를 형식에 맞춰서 전달하는 방식이다. HTTP의 요쳥 규약은 다음과 같다.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">Method Request-URI HTTP-Version CRLF<br>headers CRLF<br>message-body<br></code></pre></td></tr></table></figure><p>첫 번째 줄은 요청 줄(request line)이라고 하며 요청 종류, URI, 프로토콜 버전 등 요청 자체에 대한 정보를 담고 있다. URI는 Uniform Resource Identifier의 줄임말로 요청하는 데이터 위치를 담고 있는 고유식별자이다. 만약 클라이언트가 <a href="https://dev-bearabbit.github.io/" class="uri">https://dev-bearabbit.github.io/</a> 을 입력하면 서버는 /에 해당하는 응답 결과를 보내고, <a href="https://dev-bearabbit.github.io/categories/" class="uri">https://dev-bearabbit.github.io/categories/</a> 를 입력하면 /categories/에 해당하는 응답을 보낼 것이다. 정리하면 URI는 서버에서 어떤 리소스를 보내야 할지를 구분하는 식별자이다.<br />그리고 뒤에 붙는 <code>CRLF</code>는 CR과 LF가 합쳐진 문자로 줄바꿈을 나타낼 때 쓰이는 용어이다. CR은 Carriage Return로 커서를 맨 앞으로 보내는 것이고 LF는 Line Feed로 커서를 한 줄 아래로 내리는 것이다. 따라서 <code>CRLF</code>는 한줄 내리고 커서를 맨 앞으로 가져오는 줄바꿈이다.</p><p>두번째 줄은 헤더로 요청을 보낸 클라이언트 및 연결에 대한 정보을 담고 있다. 헤더는 크게 요청(request), 응답(response), 엔티티(entity), 공통(general) 헤더로 구분된다. 헤더에 대한 자세한 내용은 다른 글에서 정리하고자 한다.</p><p>마지막 줄은 전달할 데이터를 담는 공간인데 GET 요청에는 따로 내용은 없다. 말그대로 GET은 오로지 데이터를 받아가기 위한 요청이기 때문이다.</p><p>이제 위 내용들을 바탕으로 아래의 HTTP 요청을 분석해보자.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">request: GET / HTTP/1.1<br>Host: localhost:7878<br>Connection: keep-alive<br>sec-ch-ua: &quot; Not A;Brand&quot;;v=&quot;99&quot;, &quot;Chromium&quot;;v=&quot;101&quot;, &quot;Google Chrome&quot;;v=&quot;101&quot;<br>sec-ch-ua-mobile: ?0<br>sec-ch-ua-platform: &quot;macOS&quot;<br>Upgrade-Insecure-Requests: 1<br>User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.64 Safari/537.36<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9<br>Sec-Fetch-<br></code></pre></td></tr></table></figure><p>먼저 GET 요청이고 URI는 <code>\</code>이며 프로토콜 버전은 1.1이다. 헤더를 확인해보니 IP는 localhost이고 포트는 7878이다. 연결 상태는 유지하고 있으며, 클라이언트의 프로그램 버전들과 처리 가능한 파일 타입 등을 알려주고 있다.</p><h2 id="요청-분석에-따른-응답-작성하기">요청 분석에 따른 응답 작성하기</h2><p>이제 위 요청에 보낼 응답을 작성해보자. HTTP 응답 규약은 다음과 같은 형식이다.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">HTTP-Version Status-Code Reason-Phrase CRLF<br>headers CRLF<br>message-body<br></code></pre></td></tr></table></figure><p>첫 번째 줄은 상태 줄(status line)이라고 하며 HTTP 버전과 상태 코드, 상태에 대한 설명 등이 포함된다. 그 다음에는 요청 규약과 동일하게 헤더와 메세지 본문으로 구성된다. 이제 서버가 정상적으로 요청을 받았다는 답변을 작성해보자.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">handle_connection</span>(<span class="hljs-keyword">mut</span> stream: TcpStream) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">buffer</span> = [<span class="hljs-number">0</span>; <span class="hljs-number">512</span>];<br>    stream.<span class="hljs-title function_ invoke__">read</span>(&amp;<span class="hljs-keyword">mut</span> buffer).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-comment">//println!(&quot;request: &#123;&#125;&quot;, String::from_utf8_lossy(&amp;buffer[..]));</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">response</span> = <span class="hljs-string">&quot;HTTP/1.1 200 OK\r\n\r\n&quot;</span>;<br>    stream.<span class="hljs-title function_ invoke__">write</span>(response.<span class="hljs-title function_ invoke__">as_bytes</span>()).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    stream.<span class="hljs-title function_ invoke__">flush</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>위 코드는 클라이언트에 정상적으로 연결이 되었다는 응답을 보내주는 코드이다. 하나씩 본다면 <code>reponse</code> 변수에 헤더와 본문 없이 상태 코드 200과 설명 OK를 담은 문자열을 할당하고 이를 바이트로 변환하여 스트림에 직접 보내는 구조이다. <code>write</code> 메서드는 버퍼에 해당 내용을 작성하며 <code>flush</code> 메서드는 버퍼에 작성된 데이터가 도착지까지 도달할 수 있도록 한다.</p><h2 id="응답-보내기">응답 보내기</h2><p>이제 마지막으로 응답을 보내기 위해서 프로그램을 실행해보자.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">cargo run<br></code></pre></td></tr></table></figure><p>그 다음 <a href="http://localhost:7878/" class="uri">http://localhost:7878/</a>에 접속해보면 "연결할 수 없음"이라는 에러 대신 아무것도 없는 하얀 브라우저 창을 만날 수 있다.</p><figure><img src="/images/171.png" alt="200" /><figcaption aria-hidden="true">200</figcaption></figure><p>동시에 프로그램에서는 연결되었다는 출력이 나오고 있을 것이다. 성공적으로 연결되었다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">connected<br>connected<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
      <tag>webserver</tag>
      
      <tag>웹서버</tag>
      
      <tag>스레드</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>단일 스레드 웹서버 구현 (1)</title>
    <link href="/ko/Rust/rust-10/"/>
    <url>/ko/Rust/rust-10/</url>
    
    <content type="html"><![CDATA[<p>단일 스레드 웹서버를 러스트로 구현하는 과정을 정리합니다. <span id="more"></span></p><h2 id="시작하기-전에">시작하기 전에</h2><p>본격적으로 시작하기 전에 알아야 할 개념들을 간략히 정리해보자.</p><table><thead><tr class="header"><th>단어</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>스레드</td><td>프로세스가 할당받은 자원을 이용하는 실행의 단위.</td></tr><tr class="even"><td>웹서버</td><td>웹 브라우저와 같은 클라이언트로부터 HTTP 요청을 받아들이고, HTML 문서와 같은 웹 페이지를 반환하는 컴퓨터 프로그램.</td></tr><tr class="odd"><td>HTTP</td><td>HyperText Transfer Protocol의 약자로 클라이언트와 서버 사이에 이루어지는 요청/응답(request/response) 프로토콜. HTTP를 통해 전달되는 자료는 http:로 시작하는 URL로 조회할 수 있다.</td></tr><tr class="even"><td>TCP</td><td>Transmission Control Protocol의 약자로 네트워크의 정보 전달을 통제하여 인터넷을 이루는 핵심 프로토콜. 웹 브라우저들이 서버에 연결할 때 사용되거나 이메일 및 파일 전송에도 사용된다.</td></tr><tr class="odd"><td>소켓</td><td>네트워크로 데이터를 내보내거나 받을 때 사용되는 창구. 소켓은 크게 프로토콜, IP, 포트로 구성되며 프로세스가 데이터를 주고받기 위해서는 반드시 소켓을 열어야 한다.</td></tr></tbody></table><h2 id="웹서버-작동원리">웹서버 작동원리</h2><p>웹서버를 구현하기 위해서는 웹서버가 어떤 순서로 일을 진행하는지를 알아야 한다. 웹서버는 개념에서 간단하게 살펴봤듯이 클라이언트와 연결되어 요청을 받고 이에 맞는 응답을 제공해주는 프로그램이다. 웹서버가 작동하는 순서는 아래와 같다.</p><ol type="1"><li>소켓으로 TCP 연결 대기하기</li><li>HTTP 요청 읽기</li><li>HTTP 요청 분석 및 검증하기</li><li>요청 분석에 따른 응답 작성하기</li><li>응답 보내기</li></ol><p>이제 위 순서대로 하나씩 러스트로 구현해보자.</p><h2 id="시작-전-준비">시작 전 준비</h2><p>먼저 이번에 사용할 새로운 프로젝트를 생성하자. 원하는 경로에서 아래의 코드를 입력하여 새로운 프로젝트를 만든다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo new &lt;project name&gt;<br></code></pre></td></tr></table></figure><p>그러면 아래와 같은 디렉토리 구조를 가진 프로젝트 폴더가 생성된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">Cargo.lock<br>Cargo.toml<br>src<br> ㄴmain.rs<br>target<br> ㄴ.rustc_info.json<br> ㄴCACHEDIR.TAG<br> ㄴdebug<br></code></pre></td></tr></table></figure><p>웹서버 개발을 위한 모든 준비가 완료되었다.</p><h2 id="소켓으로-tcp-연결-대기하기">소켓으로 TCP 연결 대기하기</h2><p>웹서버는 클라이언트에서 TCP 연결을 시도할때까지 대기해야 한다. 해당 코드는 모듈 <code>std::net</code>을 사용하면 쉽게 구현할 수 있다. 아래의 코드를 <code>src/main.rs</code>에 작성해보자.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::net::TcpListener;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">listener</span> = TcpListener::<span class="hljs-title function_ invoke__">bind</span>(<span class="hljs-string">&quot;127.0.0.1:7878&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">stream</span> <span class="hljs-keyword">in</span> listener.<span class="hljs-title function_ invoke__">incoming</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">stream</span> = stream.<span class="hljs-title function_ invoke__">unwrap</span>();<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;connected&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>위 코드는 "127.0.0.1:7878" 주소로 Tcp 연결을 받을 수 있도록 작성한 것이다. 먼저 <code>TcpListener</code>의 <code>Bind()</code>를 사용하여 연결 요청을 기다린다. 네트워크에서 바인드(Bind)란 특정 포트에서 대기하다가 들어오는 요청을 서버 프로그램에 연결해주는 것을 의미하며, 여기서도 동일한 기능을 하는 함수이다. <code>listener</code>의 값을 출력해보면 아래와 같은 TcpListener 인스턴스를 생성한 것을 알 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">TcpListener &#123; addr: 127.0.0.1:7878, fd: 3 &#125;<br></code></pre></td></tr></table></figure><p>문제없이 포트에 바인딩에 성공했다면 위와 같이 TcpListener 인스턴스가 생성되어 클라이언트의 연결을 대기한다.</p><p>이제 클라이언트에서 연결을 시도해보자. 웹 브라우저에 접속해서 URL 창에 "127.0.0.1:7878"을 입력한다. 그러면 브라우저에서는 "사이트에 연결할 수 없음"이라고 나오지만 우리가 만든 프로그램에서는 "connected"가 계속 출력될 것이다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">connected<br>connected<br>connected<br></code></pre></td></tr></table></figure><p>클라이언트에 연결이 시도되면 TcpListener 인스턴스는 <code>incoming</code>이라는 메서드를 통해 스트림을 읽어온다. 여기서 스트림은 클라이언트가 요청하고 이를 서버가 읽어 적합한 응답을 생성한 뒤 보내는 일련의 과정을 통칭한다. 즉, 위 코드에서 보자면 for loop 한번이 스트림 하나라고 보면 된다. 따라서 현재 우리가 만든 프로그램은 연결 요청은 받았지만 응답을 보내지 않기 때문에 웹 브라우저에서는 연결 이슈로 나오는 것이다. <code>incoming</code> 메서드로 읽어온 스트림은 아래와 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">TcpStream &#123; addr: 127.0.0.1:7878, peer: 127.0.0.1:53614, fd: 4 &#125;<br></code></pre></td></tr></table></figure><p>웹 브라우저에서 접속을 한번 시도했음에도 계속 연결을 시도하는 이유는 여러가지가 있을 수 있다. 클라이언트가 서버에게 여러 자원에 대한 요청을 해야하는 경우도 있고, 또 연결에 실패했을 경우 재시도하도록 설계된 경우도 있다.</p><h2 id="http-요청-읽기">HTTP 요청 읽기</h2><p>이제 스트림의 요청을 읽어보는 코드를 추가해보자. <code>handle_connection()</code>이라는 함수를 작성하고 이를 <code>main()</code>에 추가한다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::&#123;net::&#123;TcpListener, TcpStream&#125;, io::Read&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">listener</span> = TcpListener::<span class="hljs-title function_ invoke__">bind</span>(<span class="hljs-string">&quot;127.0.0.1:7878&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">stream</span> <span class="hljs-keyword">in</span> listener.<span class="hljs-title function_ invoke__">incoming</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">stream</span> = stream.<span class="hljs-title function_ invoke__">unwrap</span>();<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;connected&quot;</span>);<br><br>        <span class="hljs-title function_ invoke__">handle_connection</span>(stream);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">handle_connection</span>(<span class="hljs-keyword">mut</span> stream: TcpStream) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">buffer</span> = [<span class="hljs-number">0</span>; <span class="hljs-number">512</span>];<br>    stream.<span class="hljs-title function_ invoke__">read</span>(&amp;<span class="hljs-keyword">mut</span> buffer).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;request: &#123;&#125;&quot;</span>, <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from_utf8_lossy</span>(&amp;buffer[..]));<br>&#125;<br></code></pre></td></tr></table></figure><p><code>handle_connection()</code>은 TcpStream 데이터를 출력하는 함수이다. 첫번째 줄에서는 <code>buffer</code>라는 변수를 만들고, 두번째 줄에서는 해당 변수에 스트림 데이터를 입력한다. 여기서 스트림 데이터는 모두 바이트 타입의 데이터이다. 마지막으로 <code>String::ffrom_utf8_lossy()</code>을 사용하여 스트림 데이터를 문자열로 변환하여 출력한다. 출력한 결과는 다음과 같다.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">connected<br>request: GET / HTTP/1.1<br>Host: localhost:7878<br>Connection: keep-alive<br>sec-ch-ua: &quot; Not A;Brand&quot;;v=&quot;99&quot;, &quot;Chromium&quot;;v=&quot;101&quot;, &quot;Google Chrome&quot;;v=&quot;101&quot;<br>sec-ch-ua-mobile: ?0<br>sec-ch-ua-platform: &quot;macOS&quot;<br>Upgrade-Insecure-Requests: 1<br>User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.64 Safari/537.36<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9<br>Sec-Fetch-<br></code></pre></td></tr></table></figure><p>위 요청이 정확히 무엇인지는 다음 글에서 더 자세히 살펴보자.</p>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
      <tag>webserver</tag>
      
      <tag>웹서버</tag>
      
      <tag>스레드</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hue 설치 in Docker</title>
    <link href="/ko/Hadoop/hadoop-10/"/>
    <url>/ko/Hadoop/hadoop-10/</url>
    
    <content type="html"><![CDATA[<p>하둡 에코시스템 중 하나인 Hue 설치 방법을 정리합니다. <span id="more"></span></p><h2 id="hue">Hue</h2><p>휴(Hue)는 보통 하둡 기반의 플랫폼에서 많이 사용하는 사용자 인터페이스이다. 오픈소스로 코드가 공개되어 있으며, 필요한 사람은 누구나 사용할 수 있다. 휴는 하이브나 임팔라, 스파크, 트리노 등 빅데이터 SQL 엔진과의 연동을 지원하며 그 외에 일반적인 RDB와도 연동할 수 있다. 그래서 사용자에게 다양한 SQL 환경을 제공하기에 적합한 플랫폼이라고 생각한다. 또 쿼리 뿐만 아니라 테이블 스키마나 작업(Job) 현황 확인도 가능하다. 자세한 내용은 <a href="https://gethue.com/">공식 홈페이지</a>에서 확인할 수 있다.</p><h2 id="설치-가이드">설치 가이드</h2><p>이번 설치 가이드에서는 휴를 도커 컨테이너에 올리는 과정을 정리하고자 한다. 따라서 아래의 사전 조건이 준비되어야 한다.</p><ul><li>OS 종류: Linux 기반</li><li>Docker 설치 완료</li><li>Git 설치 완료 (선택)</li></ul><h3 id="소스코드-가져오기">소스코드 가져오기</h3><p>설치를 하기 위해서 먼저 <a href="https://github.com/cloudera/hue">휴 깃허브 레파지토리</a>에서 소스코드를 클론해오자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/cloudera/hue.git<br></code></pre></td></tr></table></figure><p>만약 Git 사용이 아예 불가능할 경우에는 깃허브 페이지에서 zip으로 다운로드 받을 수 있다.</p><p>그다음 아래의 경로로 이동한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> hue/tools/docker/hue<br></code></pre></td></tr></table></figure><p>그러면 아래와 같은 파일들이 보인다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">drwxrwxr-x 2 ec2-user ec2-user   64 Jun 23 11:04 conf<br>drwxrwxr-x 2 ec2-user ec2-user   49 Jun 23 09:39 conf3<br>-rw-rw-r-- 1 ec2-user ec2-user  720 Jun 23 10:54 docker-compose.yml<br>-rw-rw-r-- 1 ec2-user ec2-user 2445 Jun 23 05:41 Dockerfile<br>-rw-rw-r-- 1 ec2-user ec2-user 1777 Jun 23 05:41 Dockerfile.py2<br>-rw-rw-r-- 1 ec2-user ec2-user   91 Jun 23 05:41 Dockerfile.py2.dockerignore<br>drwxr-xr-x 2 root     root        6 Jun 23 10:08 hue.ini<br>-rw-rw-r-- 1 ec2-user ec2-user  109 Jun 23 09:21 init.sql<br>-rw-rw-r-- 1 ec2-user ec2-user 5909 Jun 23 05:41 README.md<br>-rwxrwxr-x 1 ec2-user ec2-user   66 Jun 23 05:41 startup.sh<br></code></pre></td></tr></table></figure><p>휴는 메타데이터를 저장하고 관리하는 RDB가 필요하다. 그래서 도커 환경에서는 <code>docker-compose</code>를 통해 휴가 사용할 RDB와 웹 서버 2개의 컨테이너를 생성한다. RDB의 경우 sqlite3, mysql, postgesql 이렇게 3가지가 가능한데 개인적으로는 mysql을 추천한다. 왜냐하면 이미 누군가 mysql을 같이 설치하는 파일을 개발해두었기 때문이다. (변경도 어렵지는 않다. 그냥 <code>docker-compose.yml</code> 파일을 수정해주면 된다.)</p><h3 id="소스코드-수정하기">소스코드 수정하기</h3><p>이 글에서도 mysql을 그대로 사용할 예정이다. 현재 오픈소스에 올라가 있는 mysql 셋업 환경을 확인해보자. 그리고 컨테이너를 올리기 전에 조금 수정해야 할 사항들이 있다. 먼저 <code>docker-compose.yml</code> 파일에 mysql 계정 비밀번호를 수정한다.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">cloudera:</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">gethue/hue:latest</span><br>      <span class="hljs-attr">hostname:</span> <span class="hljs-string">hue</span><br>      <span class="hljs-attr">container_name:</span> <span class="hljs-string">hue</span><br>      <span class="hljs-attr">dns:</span> <span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span><br>      <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8888:8888&quot;</span><br>      <span class="hljs-attr">volumes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">./hue.ini:/usr/share/hue/desktop/conf/z-hue.ini</span><br>      <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;database&quot;</span><br>  <span class="hljs-attr">database:</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7</span><br>      <span class="hljs-attr">ports:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;33061:3306&quot;</span><br>      <span class="hljs-attr">command:</span> <span class="hljs-string">--init-file</span> <span class="hljs-string">/data/application/init.sql</span><br>      <span class="hljs-attr">volumes:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">data:/var/lib/mysql</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">./init.sql:/data/application/init.sql</span><br>      <span class="hljs-attr">environment:</span><br>          <span class="hljs-attr">MYSQL_ROOT_USER:</span> <span class="hljs-string">root</span><br>          <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">&lt;사용할</span> <span class="hljs-string">비밀번호&gt;</span><br>          <span class="hljs-attr">MYSQL_DATABASE:</span> <span class="hljs-string">hue</span><br>          <span class="hljs-attr">MYSQL_USER:</span> <span class="hljs-string">hue</span><br>          <span class="hljs-attr">MYSQL_PASSWORD:</span> <span class="hljs-string">&lt;사용할</span> <span class="hljs-string">비밀번호&gt;</span><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">data:</span><br></code></pre></td></tr></table></figure><p>다음으로 <code>init.sql</code> 파일을 열어서 아래의 내용을 추가하자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> hue;<br><span class="hljs-comment">-- 아래의 코드를 추가</span><br><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">on</span> hue.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;hue&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;사용할 비밀번호&#x27;</span>;<br></code></pre></td></tr></table></figure><p>추가하는 부분은 휴와 RDB를 연동할 때 사용할 유저에게 권한을 주는 코드이다. 여기까지 추가해준 뒤 본격적으로 컨테이너를 올려보자.</p><h3 id="컨테이너-생성하기">컨테이너 생성하기</h3><p>아래의 명령어를 입력하여 컨테이너를 생성한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose up -d<br></code></pre></td></tr></table></figure><p>그러면 사용할 도커 이미지들을 다운로드 받고 컨테이너가 올라간다. 아래의 명령어로 컨테이너가 올라왔는지 확인할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">❯ docker-compose ps<br>     Name                   Command               State                           Ports                        <br>---------------------------------------------------------------------------------------------------------------<br>hue              ./startup.sh                     Up      0.0.0.0:8888-&gt;8888/tcp,:::8888-&gt;8888/tcp             <br>hue_database_1   docker-entrypoint.sh --ini ...   Up      0.0.0.0:33061-&gt;3306/tcp,:::33061-&gt;3306/tcp, 33060/tcp<br></code></pre></td></tr></table></figure><p>정상적으로 컨테이너들이 올라왔다.</p><h3 id="메타데이터-마이그레이션하기">메타데이터 마이그레이션하기</h3><p>휴는 기본적으로 sqlite3를 RDB로 사용하도록 설정되어 있다. 따라서 컨테이너 내부에 접속해서 같이 올려둔 mysql로 메타데이터 마이그레이션을 진행한다. 휴 컨테이너에 접속한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -itu 0 &lt;container ID&gt; /bin/bash<br></code></pre></td></tr></table></figure><p>그다음 conf 파일을 수정하기 위해서 vim을 설치해준다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt-get update<br>apt-get install vim -y<br></code></pre></td></tr></table></figure><p>설치가 완료되면 <code>desktop/conf/hue.ini</code> 파일에서 아래의 내용을 수정해준다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash">[[database]]<br><span class="hljs-comment"># Database engine is typically one of:</span><br><span class="hljs-comment"># postgresql_psycopg2, mysql, sqlite3 or oracle.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Note that for sqlite3, &#x27;name&#x27;, below is a path to the filename. For other backends, it is the database name</span><br><span class="hljs-comment"># Note for Oracle, options=&#123;&quot;threaded&quot;:true&#125; must be set in order to avoid crashes.</span><br><span class="hljs-comment"># Note for Oracle, you can use the Oracle Service Name by setting &quot;host=&quot; and &quot;port=&quot; and then &quot;name=&lt;host&gt;:&lt;port&gt;/&lt;service_name&gt;&quot;.</span><br><span class="hljs-comment"># Note for MariaDB use the &#x27;mysql&#x27; engine.</span><br><span class="hljs-comment"># 주석을 풀고 아래의 내용을 수정한다.</span><br>engine=mysql<br>host=database <span class="hljs-comment"># docker-compose.yml에 database로 설정되어 있기 때문에 그대로 사용한다.</span><br>port=3306<br>user=hue<br>name=hue<br>password=&lt;사용한 패스워드&gt;<br><span class="hljs-comment"># conn_max_age option to make database connection persistent value in seconds</span><br><span class="hljs-comment"># https://docs.djangoproject.com/en/1.11/ref/databases/#persistent-connections</span><br><span class="hljs-comment">## conn_max_age=0</span><br><span class="hljs-comment"># Execute this script to produce the database password. This will be used when &#x27;password&#x27; is not set.</span><br><span class="hljs-comment">## password_script=/path/script</span><br><span class="hljs-comment">## name=desktop/desktop.db</span><br><span class="hljs-comment">## options=&#123;&#125;</span><br><span class="hljs-comment"># Database schema, to be used only when public schema is revoked in postgres</span><br><span class="hljs-comment">## schema=public</span><br><br><span class="hljs-comment"># Configuration options for specifying the Desktop session.</span><br><span class="hljs-comment"># For more info, see https://docs.djangoproject.com/en/1.4/topics/http/sessions/</span><br><span class="hljs-comment"># ------------------------------------------------------------------------</span><br></code></pre></td></tr></table></figure><p>수정이 완료되었다면 아래의 명령어를 사용하여 마이그레이션을 진행한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./build/env/bin/pip install mysqlclient<br>./build/env/bin/hue migrate<br></code></pre></td></tr></table></figure><p>마이그레이션이 완료되었다면 확인을 위해 휴 서버에서 나온 뒤 mysql 컨테이너에 접속한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 컨테이너 접속</span><br>docker <span class="hljs-built_in">exec</span> -it &lt;container ID&gt; /bin/bash<br><span class="hljs-comment"># mysql 접속</span><br>mysql -u hue -p&lt;사용한 패스워드&gt;<br></code></pre></td></tr></table></figure><p>그다음 휴 서버에서 사용할 테이블을 정상적으로 이관했는지 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql&gt; use hue<br>mysql&gt; show tables;<br></code></pre></td></tr></table></figure><p>정상적으로 테이블 리스트가 나오는 걸 확인할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">+--------------------------------+<br>| Tables_in_hue                  |<br>+--------------------------------+<br>| auth_group                     |<br>| auth_group_permissions         |<br>| auth_permission                |<br>               .<br>               .<br>               .<br>| pig_pigscript                  |<br>| useradmin_grouppermission      |<br>| useradmin_huepermission        |<br>| useradmin_ldapgroup            |<br>| useradmin_userprofile          |<br>+--------------------------------+<br></code></pre></td></tr></table></figure><p>마지막으로 휴에 접속해보자.</p><figure><img src="/images/170.png" alt="hue" /><figcaption aria-hidden="true">hue</figcaption></figure><p>위 사진과 같은 페이지가 보인다면 성공적으로 설치된 것이다.</p>]]></content>
    
    
    <categories>
      
      <category>BigData</category>
      
      <category>hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>Hue</tag>
      
      <tag>guide</tag>
      
      <tag>apache</tag>
      
      <tag>UI</tag>
      
      <tag>compose</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>데이터 웨어하우스와 데이터 레이크</title>
    <link href="/ko/Engineering/engineering-2/"/>
    <url>/ko/Engineering/engineering-2/</url>
    
    <content type="html"><![CDATA[<p>데이터 웨어하우스와 데이터 레이크에 대해 공부한 내용들을 정리합니다. <span id="more"></span></p><h2 id="시작하며">시작하며</h2><p>데이터 분석에 가장 중요한 부분은 <strong>데이터</strong>이다. 하지만 일반적으로 운영 서비스에서 사용되는 데이터들은 분석에 적합한 형태가 아닌 경우가 많고 또 민감정보로 인해 분석으로 사용할 수 없는 경우도 있다. 따라서 데이터 분석을 위한 데이터 저장소가 필요하다. 그렇게 데이터 웨어하우스가 등장했고 하드웨어가 급속도로 발전하면서 데이터 레이크라는 개념도 등장했다. 이번 글에서는 두 저장소의 개념과 장단점에 대해서 정리해보고자 한다.</p><h2 id="data-warehouse">Data Warehouse</h2><p>데이터 웨어하우스(Data Warehouse, DW)는 분석에 필요한 데이터를 정제하여 적재하는 저장소이다. 운영 서비스 여기저기 흩뿌려져 있는 원천 데이터들을 분석에 필요한 카테고리 별로 정리하여 RDB 형태로 정리해둔 구조라고 보면 될 것 같다.</p><figure><img src="/images/167.png" alt="DW" /><figcaption aria-hidden="true">DW</figcaption></figure><p>위 그림에서 알 수 있듯이 DW에 저장하기 전에 변환(Transform) 작업을 통해 데이터를 정제한다. 그 이유는 크게 데이터 품질 유지, 쿼리 속도 개선, 데이터 접근 제한 등이 있다.</p><ul><li>데이터 품질 유지: 원천 데이터 스키마나 데이터 타입 변경 시 ETL 파이프라인만 수정해주면 기존 DW 데이터 변환 없이 일관적으로 데이터를 적재할 수 있다.</li><li>쿼리속도 개선: 카테고리 별로 정리하여 RDB 구조로 적재한 형태이기에 비교적 간단한 쿼리로 빠르게 원하는 결과를 얻을 수 있다.</li><li>데이터 접근 제한: 원천 데이터 자체를 모두가 접근할 수 있다면 개인정보나 민감정보 이슈가 존재하게 되며 이는 법적 이슈가 될 수 있다. 또한 원천 데이터는 언제나 생각하는 것보다 기상천외하기에 일반 사용자들이 인사이트를 도출하기에는 어려움이 따를 수밖에 없다.</li></ul><p>데이터 웨어하우스는 데이터 관리가 편하고 사용자 또한 비교적 쉽게 이해한다는 장점이 있지만 이를 유지하기 위해서는 복잡한 ETL 파이프라인을 구축하고 유지보수 해야 한다. 또한 데이터 레이크에 비해 데이터 적재 작업에 하드웨어 리소스가 많이 사용되고 시간도 오래걸린다.</p><h2 id="data-lake">Data Lake</h2><p>데이터 레이크(Data Lake, DL)는 운영 서비스에서 생성되는 원천 데이터를 정제 없이 저장하여 보관하는 방식의 저장소이다. 즉, 데이터 웨어하우스처럼 복잡한 변환(Transform)없이 바로 저장하는 구조이다.</p><figure><img src="/images/168.png" alt="DL" /><figcaption aria-hidden="true">DL</figcaption></figure><p>위 그림처럼 원천에서 그대로 가져와서 저장되기에 수집이 간단하고 리소스 매니징만 제대로 이루어지면 적재에는 문제가 없다는 장점이 있다. 또한 데이터 변환을 사용자가 진행하기에 테이블 스키마나 비즈니스 로직이 자주 변경되는 환경에서는 사용하기 용이하다.</p><p>하지만 DW에 비해 많은 양의 데이터가 저장되고 무슨 데이터인지 한번에 파악하기도 어렵다는 단점이 있다. 적재되는 데이터 타입이 다양하기에 데이터 관리도 어렵고 아무도 쓰지 않는 정크 데이터가 하드웨어 리소스만 차지하고 있는 경우도 존재하기 쉽다. 따라서 데이터 레이크를 보다 효율적으로 잘 운영하기 위해서는 데이터 거버넌스 툴을 통해 메타데이터를 잘 관리해야 한다.</p><p>데이터 레이크는 사용자에게 많은 자유도를 제공함으로써 다양한 분석 및 머신러닝 설계가 가능하지만 그만큼 데이터 처리가 사용자의 역할로 넘어가기에 DW보다는 더 많은 개발 실력이 요구된다.</p><h2 id="비교">비교</h2><p>뭐든 장점이 있다면 단점도 있다. 표로 정리해보자.</p><table><thead><tr class="header"><th>비교</th><th>데이터 웨어하우스</th><th>데이터 레이크</th></tr></thead><tbody><tr class="odd"><td>데이터 타입</td><td>정형</td><td>정형/비정형/반정형</td></tr><tr class="even"><td>스키마</td><td>schema on write/read</td><td>schema on read</td></tr><tr class="odd"><td>데이터 처리</td><td>필요</td><td>불필요</td></tr><tr class="even"><td>데이터 양</td><td>비교적 적음</td><td>비교적 많음</td></tr><tr class="odd"><td>데이터 관리</td><td>용이</td><td>난해</td></tr></tbody></table><h2 id="사용방식">사용방식</h2><p>보통 대부분의 기업들이 둘 다 사용하는 것 같다. 먼저 데이터 레이크를 구축하여 원천 데이터들을 일괄 적재한 후에 ETL 작업을 거쳐서 데이터 웨어하우스를 구축하는 방식이다. 이를 도식화하면 아래 그림과 같다.</p><figure><img src="/images/169.png" alt="DWDL" /><figcaption aria-hidden="true">DWDL</figcaption></figure><p>위 구조로 사용하는 이유는 데이터를 사용하는 유저들의 폭이 넓어졌기 때문이다. 마케팅팀이나 기획팀에서도 데이터 기반 의사결정을 위해 필요한 데이터를 간단한 쿼리를 통해 가져가기도 하며, 운영 서비스에 연동되는 추천시스템 등을 구축하기 위해 사용하기도 한다. 두 가지의 케이스를 모두 매니징하기 위해서는 위 구조가 가장 적합한 것 같다.</p>]]></content>
    
    
    <categories>
      
      <category>BigData</category>
      
      <category>engineering</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data</tag>
      
      <tag>데이터웨어하우스</tag>
      
      <tag>데이터레이크</tag>
      
      <tag>warehouse</tag>
      
      <tag>lake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PyO3란</title>
    <link href="/ko/Package/pack-2/"/>
    <url>/ko/Package/pack-2/</url>
    
    <content type="html"><![CDATA[<p>rust를 python에서 바인딩하여 사용할 수 있도록 도와주는 PyO3에 대해서 정리합니다. 해당 글은 <a href="https://pyo3.rs/v0.16.4/index.html">PyO3 공식문서</a>를 바탕으로 작성되었습니다. <span id="more"></span></p><h2 id="사용목적">사용목적</h2><p>현재 러스트로 작성하고 있는 프로젝트인 <a href="https://github.com/tossicat/tossicat-core">tossicat</a>를 파이썬에서도 사용할 수 있도록 패키지를 생성하고자 한다.</p><h2 id="pyo3란">PyO3란</h2><p>PyO3은 러스트 코드를 파이썬으로 바인딩하는 모듈이다. 해당 <a href="https://github.com/PyO3/pyo3">깃허브</a>에 접속해보면 알겠지만 모듈 대부분이 rust로 개발되고 있으며, 자세한 내용은 <a href="https://docs.rs/pyo3/latest/pyo3/">Rust crate 문서</a>나 <a href="https://pyo3.rs/v0.16.4/">공식 가이드</a>에서 찾아볼 수 있다. 해당 모듈을 사용하여 Rust에서 기본 Python 모듈을 작성하거나 Python을 Rust 프로그램에서 실행할 수 있다.</p><h2 id="maturin-사용법">maturin 사용법</h2><p>maturin이란 PyO3를 통해서 러스트 코드를 보다 편리하게 파이썬 패키지로 빌드할 수 있도록 도와주는 도구이다. maturin은 기본적으로 virtualenv에서 작동한다. 아래는 maturin에서 기본적으로 사용하는 명령어이다.</p><ul><li><code>maturin init</code>: 튜토리얼에서 사용할 예시 코드를 가져온다.</li><li><code>maturin new</code>: 새로운 cargo 프로젝트를 생성한다.</li><li><code>maturin develop</code>: 러스트 코드를 파이썬 패키지로 빌드하고 virtualenv에 바로 설치한다.</li><li><code>maturin build</code>: target/wheels(default) 경로에 파이썬 패키지 wheel파일로 빌드한다.</li><li><code>maturin publis</code>: 작성한 러스트 코드를 파이썬 패키지로 빌드하고 PyPi에 배포한다.</li></ul><h2 id="pyo3-튜토리얼">PyO3 튜토리얼</h2><p>공식문서의 튜토리얼을 따라해보자. 원하는 경로에서 아래의 코드를 순서대로 입력한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 먼저 사용할 폴더 만들기</span><br>$ <span class="hljs-built_in">mkdir</span> string_sum<br><span class="hljs-comment"># 폴더로 이동</span><br>$ <span class="hljs-built_in">cd</span> string_sum<br><span class="hljs-comment"># 파이썬 가상환경 생성</span><br>$ python3 -m venv .<span class="hljs-built_in">env</span><br><span class="hljs-comment"># 생성한 가상환경으로 접속</span><br>$ <span class="hljs-built_in">source</span> .<span class="hljs-built_in">env</span>/bin/activate<br><span class="hljs-comment"># 필요한 패키지 설치</span><br>$ pip3 install maturin<br></code></pre></td></tr></table></figure><p>완료되었다면 필요한 환경설정은 끝났다. 다음으로 아래의 코드를 입력한 후 pyo3를 선택한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ maturin init<br><br>? 🤷 Which kind of bindings to use? ›<br>❯ pyo3<br>  rust-cpython<br>  cffi<br>  bin<br></code></pre></td></tr></table></figure><p>그러면 아래와 같이 프로젝트가 생성되었다는 안내가 출력된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">✨ Done! Initialized project &#123;PATH&#125;/string_sum<br></code></pre></td></tr></table></figure><p>튜토리얼을 진행하면 바로 패키지 개발을 테스트 해볼 수 있는 코드들이 <code>/src/lib.rs</code>, <code>cargo.toml</code>에 작성되어 있다. 아래의 명령어를 입력해서 테스트 해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ maturin develop<br><br>🔗 Found pyo3 bindings<br>🐍 Found CPython 3.9 at &#123;PATH&#125;/string_sum/.env/bin/python<br>   Compiling target-lexicon v0.12.4<br>   Compiling once_cell v1.12.0<br>    .<br>    .<br>   Compiling pyo3-macros v0.16.5<br>   Compiling string_sum v0.1.0 (&#123;PATH&#125;/string_sum)<br>    Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 19.69s<br>📦 Built wheel <span class="hljs-keyword">for</span> CPython 3.9 to &#123;PATH&#125;/string_sum-0.1.0-cp39-cp39-macosx_10_7_x86_64.whl<br>🛠  Installed string_sum-0.1.0<br></code></pre></td></tr></table></figure><p>가상환경에 해당 패키지가 파이썬 모듈로 설치되었다. 파이썬에 직접 접속해서 빌드한 <code>string_sum</code>패키지를 사용해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python3<br>&gt;&gt;&gt; import string_sum<br>&gt;&gt;&gt; string_sum.sum_as_string(10,5)<br><span class="hljs-string">&#x27;15&#x27;</span><br></code></pre></td></tr></table></figure><p>정상적으로 작동하는 것을 확인할 수 있다. 만약 러스트 코드를 수정해야 한다면 수정 후 다시 <code>maturin develop</code>을 입력하여 컴파일 후 테스트 해볼 수 있다. 또한 아래의 명령어를 사용하여 패키지<code>wheel</code>파일로 저장할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">maturin build<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>package</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>rust</tag>
      
      <tag>package</tag>
      
      <tag>library</tag>
      
      <tag>pyo3</tag>
      
      <tag>PyO3</tag>
      
      <tag>binding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>String과 str 차이</title>
    <link href="/ko/Rust/rust-9/"/>
    <url>/ko/Rust/rust-9/</url>
    
    <content type="html"><![CDATA[<p>러스트의 String과 str의 차이점에 대해 정리합니다. <span id="more"></span></p><h2 id="string">String</h2><p><code>String</code>은 u8타입 벡터(Vector)를 포함한 구조체이다. <a href="https://github.com/rust-lang/rust/blob/master/library/alloc/src/string.rs">Rust 오픈소스 페이지</a>에서 아래의 코드를 확인할 수 있다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">String</span> &#123;<br>    vec: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>String</code>은 <code>str</code>과 달리 할당된 데이터의 소유권을 가지고 있으며 변수에 대한 정보는 스택(stack) 메모리에, 데이터는 힙(heap) 메모리에 저장된다. 예시는 아래 그림과 같다.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs text">                     buffer<br>                   /   capacity<br>                 /   /  length<br>               /   /   /<br>            +–––+–––+–––+<br>stack frame │ • │ 8 │ 6 │ &lt;- my_name: String<br>            +–│–+–––+–––+<br>              │<br>            [–│–––––––– capacity –––––––––––]<br>              │<br>            +–V–+–––+–––+–––+–––+–––+–––+–––+<br>       heap │ P │ a │ s │ c │ a │ l │   │   │<br>            +–––+–––+–––+–––+–––+–––+–––+–––+<br><br>            [––––––– length ––––––––]<br><br>[출처]https://blog.thoughtram.io/string-vs-str-in-rust/<br></code></pre></td></tr></table></figure><p>만약 문자열에 데이터를 추가한다면 스택 프레임에서는 capacity와 length만 변동하며, 실제 데이터는 힙 메모리에 추가된다.</p><h2 id="str">str</h2><p><code>str</code>은 러스트에서 기본적으로 제공하는 데이터 타입 중 하나이며, '문자열 리터럴'이라고도 불린다.</p><p><strong>NOTE</strong><br />리터럴(Literal)이란?<br />리터럴은 변수에 할당되는 데이터 그 자체를 의미한다. 예를 들어 프로그램에서 <code>a = 100</code> 코드는 <code>a</code>라는 변수에 <code>100</code>이라는 값이 할당된다. 여기서 <code>100</code>은 주소나 특정 의미를 내포한 개념이 아니라 그 자체 숫자로의 100을 의미하며, 이런 데이터 값들을 리터럴이라고 한다. 리터럴의 경우 데이터 세그먼트 영역에 저장되기에 불가변적이다. 예시는 아래 그림과 같다.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">            my_name: &amp;str<br>            [–––––––––––]<br>            +–––+–––+<br>stack frame │ • │ 6 │ <br>            +–│–+–––+<br>              │                 <br>              +––+                <br>                 │<br> preallocated  +–V–+–––+–––+–––+–––+–––+<br> read-only     │ P │ a │ s │ c │ a │ l │<br> memory        +–––+–––+–––+–––+–––+–––+<br><br> [출처]https://blog.thoughtram.io/string-vs-str-in-rust/<br></code></pre></td></tr></table></figure><p>문자열 리터럴이란 문자(char)들의 시퀀스 또는 문자열 슬라이스를 의미한다. 슬라이스란 String의 일부를 참조하는 방식이며, 데이터에 대한 소유권이 없다. (슬라이스에 대해서 더 자세히 알고 싶다면 <a href="https://dev-bearabbit.github.io/2021/09/18/Rust/rust-2/">슬라이스 타입</a>을 참고할 수 있다.) 문자열 리터럴로 변수를 생성하는 방법은 아래와 같다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 문자들의 시퀀스</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">v_str</span> = <span class="hljs-string">&quot;This is str&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">t_str</span> = <span class="hljs-string">&quot;This is str&quot;</span>;<br><span class="hljs-comment">// 문자열 슬라이스</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">string</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;This is str&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;string[<span class="hljs-number">0</span>..<span class="hljs-number">8</span>];<br></code></pre></td></tr></table></figure><p>문자열 리터럴인 변수 'v_str'의 타입은 <code>&amp;str</code>으로 데이터 세그먼트에 저장된 값을 참조하는 방식이다. 그렇기 때문에 똑같은 값을 가진 다른 변수 't_str'을 생성하면 동일한 메모리 주소를 가진다는 것을 확인할 수 있다. 반면 <code>String</code>으로 생성된 변수 'string'을 문자열 슬라이스로 가져온 'slice'는 메모리 값이 다른 것을 확인할 수 있다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v_str</span> = <span class="hljs-string">&quot;This is str&quot;</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, v_str);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, v_str <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> _);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">t_str</span> = <span class="hljs-string">&quot;This is str&quot;</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, t_str);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, t_str <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> _);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;This is str&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;string[..];<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, slice);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, slice <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> _);<br>&#125;<br><span class="hljs-comment">//동일한 메모리 값을 가져온다.</span><br><span class="hljs-string">&quot;This is str&quot;</span><br><span class="hljs-number">0x55e7e918c141</span><br><span class="hljs-string">&quot;This is str&quot;</span><br><span class="hljs-number">0x55e7e918c141</span><br><span class="hljs-comment">//내용은 동일하지만 다른 메모리 값을 가져온다.</span><br><span class="hljs-string">&quot;This is str&quot;</span><br><span class="hljs-number">0x55e7e9b00ad0</span><br></code></pre></td></tr></table></figure><p>그 이유는 문자열(string)의 경우 힙(heap) 메모리에 데이터를 올려두며 이를 참조해가기 때문이다. 이를 그림으로 나타내면 아래와 같다.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text">            my_name: String   last_name: &amp;str<br>            [––––––––––––]    [–––––––]<br>            +–––+––––+––––+–––+–––+–––+<br>stack frame │ • │ 16 │ 13 │   │ • │ 6 │ <br>            +–│–+––––+––––+–––+–│–+–––+<br>              │                 │<br>              │                 +–––––––––+<br>              │                           │<br>              │                           │<br>              │                         [–│––––––– str –––––––––]<br>            +–V–+–––+–––+–––+–––+–––+–––+–V–+–––+–––+–––+–––+–––+–––+–––+–––+<br>       heap │ P │ a │ s │ c │ a │ l │   │ P │ r │ e │ c │ h │ t │   │   │   │<br>            +–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+<br><br> [출처]https://blog.thoughtram.io/string-vs-str-in-rust/<br></code></pre></td></tr></table></figure><h2 id="비교">비교</h2><p>아래의 표는 지금까지 살펴봤던 <code>str</code>, <code>String</code>을 비교 및 정리한 것이다.</p><table><thead><tr class="header"><th>비교</th><th>str</th><th>String</th></tr></thead><tbody><tr class="odd"><td>타입</td><td>원시 타입 <Br> (Primitive Type)</td><td>구조체</td></tr><tr class="even"><td>소유권</td><td>없음</td><td>있음</td></tr><tr class="odd"><td>형태</td><td>String의 슬라이스</td><td>확장가능한 배열</td></tr><tr class="even"><td>사이즈</td><td>컴파일 시 확인 가능</td><td>컴파일 시 확인 불가</td></tr><tr class="odd"><td>메모리</td><td>데이터 세그먼트에 저장</td><td>힙(heap)에 저장</td></tr><tr class="even"><td>할당</td><td>&amp;로 참조하여 할당</td><td>바로 할당</td></tr></tbody></table><h2 id="str-vs.-string">&amp;str vs. &amp;String</h2><p>함수를 작성하다보면 문자열 참조를 파라미터로 받을 때 두 옵션 중에 헷갈릴 수 있다. 아래 예시 코드를 보자.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Understanding the String concept?&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v_str</span> = <span class="hljs-string">&quot;This is str&quot;</span>;<br><br>    <span class="hljs-title function_ invoke__">print_data</span>(&amp;string);<br>    <span class="hljs-title function_ invoke__">print_data</span>(v_str);<br>&#125;<br><br><span class="hljs-keyword">fn</span>  <span class="hljs-title function_">print_data</span>(data: &amp;<span class="hljs-type">str</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;printing data &#123;&#125; &quot;</span>, data);<br>&#125;<br></code></pre></td></tr></table></figure><p>위 코드는 <code>main()</code>에서 'string'이라는 <code>String</code>타입의 데이터를 생성하고 이를 문자열 슬라이스로 참조하여 <code>print_data()</code>로 넘겨준다. 러스트에서 문자열 변수의 참조는 자동으로 문자열 슬라이스로 전환한다. 따라서 <code>print_data()</code>은 'string'도 받을 수 있고, 'v_str'도 인자값으로 받을 수 있다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Understanding the String concept?&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v_str</span> = <span class="hljs-string">&quot;This is str&quot;</span>;<br><br>    <span class="hljs-title function_ invoke__">print_data</span>(&amp;string);<br>    <span class="hljs-title function_ invoke__">print_data</span>(v_str);<br>&#125;<br><br><span class="hljs-keyword">fn</span>  <span class="hljs-title function_">print_data</span>(data: &amp;<span class="hljs-type">String</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;printing data &#123;&#125; &quot;</span>, data);<br>&#125;<br></code></pre></td></tr></table></figure><p>반면 위 코드는 아래와 같은 에러를 출력한다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust">error[E0308]: mismatched types<br> -<span class="hljs-punctuation">-&gt;</span> src/main.rs:<span class="hljs-number">6</span>:<span class="hljs-number">16</span><br>  |<br><span class="hljs-number">6</span> |     <span class="hljs-title function_ invoke__">print_data</span>(v_str);<br>  |                ^^^^^ expected <span class="hljs-keyword">struct</span> `<span class="hljs-type">String</span>`, found `<span class="hljs-type">str</span>`<br>  |<br>  = note: expected reference `&amp;<span class="hljs-type">String</span>`<br>             found reference `&amp;<span class="hljs-type">str</span>`<br><br>For more information about this error, <span class="hljs-keyword">try</span> `rustc --explain E0308`.<br>error: could not compile `playground` due to previous error<br></code></pre></td></tr></table></figure><p>그 이유는 <code>&amp;String</code>이 <code>&amp;str</code>을 포함하고 있지 않기 때문이다. <code>&amp;String</code>은 힙 메모리에 올라간 데이터를 참조하고자 하기에 문자열 리터럴로 저장된 'v_str'은 받지 못한다. 따라서 해당 코드가 작동하려면 <code>.to_string()</code>을 통해 힙 메모리로 올려야 하는데 참조만 할 변수에 사용하기에는 리소스 낭비라고도 볼 수 있다.</p><h2 id="참고문헌">참고문헌</h2><p>이 글은 아래의 블로그들을 참고하여 작성되었다.</p><p><a href="https://blog.thoughtram.io/string-vs-str-in-rust/">https://blog.thoughtram.io/string-vs-str-in-rust/</a><br /><a href="https://www.becomebetterprogrammer.com/rust-string-vs-str/">https://www.becomebetterprogrammer.com/rust-string-vs-str/</a></p>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
      <tag>str</tag>
      
      <tag>string</tag>
      
      <tag>type</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github Action으로 스크래핑 자동화하기</title>
    <link href="/ko/Git/git-0/"/>
    <url>/ko/Git/git-0/</url>
    
    <content type="html"><![CDATA[<p>Github에서 제공하는 Action 기능을 통해 데이터 스크래핑 및 적재를 자동화합니다. <span id="more"></span></p><hr /><p>이번 글은 깃허브에서 무료로 사용할 수 있는 액션이라는 기능을 사용하여 데이터 적재를 자동화하는 과정을 공유하고자 한다.</p><h2 id="github-action">Github Action</h2><p>깃허브 액션은 모든 레파지토리에서 사용할 수 있다. 보통은 레파지토리의 상단 바에서 <code>Actions</code>이라는 카테고리를 찾을 수 있다. 만약 <code>Actions</code>이 없다면 Settings &gt; Action &gt; General &gt; 'Disable Actions' 선택되어 있는지 확인하고 'Allow all actions and reusable workflows'로 변경해주면 아래 사진처럼 보일 것이다.</p><figure><img src="/images/164.png" alt="action bar" /><figcaption aria-hidden="true">action bar</figcaption></figure><p>액션 카테고리로 들어로면 워크플로우를 생성하는 첫 페이지가 보일 것이다. 깃허브에서는 장고, 패키지 생성, 파이린트 등 상황에 따라서 사용할 수 있는 여러 워크플로우 템플릿을 제공한다.</p><figure><img src="/images/163.png" alt="action" /><figcaption aria-hidden="true">action</figcaption></figure><p>이번에는 템플릿 사용 없이 직접 워크플로우를 생성할 것이기에 'set up a workflow yourself'을 선택한다. 그럼 설명과 같이 yaml 파일을 작성하는 페이지가 나온다.</p><figure><img src="/images/165.png" alt="action page" /><figcaption aria-hidden="true">action page</figcaption></figure><p>이제 여기에 코드를 알맞게 입력하고 commit 입력하면 작업(Job)이 생성된다.</p><h2 id="workflow-작성">Workflow 작성</h2><p>이번에 작성할 워크플로우의 조건은 아래와 같다.</p><ul><li>하루에 한번 작동하기</li><li>데이터를 가져와서 DB서버에 Insert하기</li><li>작업 실패 시 수동으로 재시도 가능하게 하기</li></ul><p>위 조건을 바탕으로 워크플로우를 작성하려고 한다. 먼저 액션에서 사용되는 yaml 파일의 레이아웃은 아래와 같다.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 워크플로우 이름 설정</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">여기에</span> <span class="hljs-string">작성한</span> <span class="hljs-string">이름이</span> <span class="hljs-string">액션</span> <span class="hljs-string">작업의</span> <span class="hljs-string">이름이</span> <span class="hljs-string">된다.</span><br><br><span class="hljs-comment"># 워크플로우가 작동되는 조건 설정</span><br><span class="hljs-attr">on:</span><br>  <span class="hljs-comment"># 자동으로 언제 작동하는지 설정</span><br>  <span class="hljs-attr">schedule:</span><br>  <span class="hljs-comment"># 수동으로 워크플로우를 작동할 수 있도록 설정</span><br>  <span class="hljs-attr">workflow_dispatch:</span> <br><br><span class="hljs-comment"># 워크플로우에서 작업할 내용들 설정</span><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-comment"># 작업이 진행될 환경 설정</span><br>  <span class="hljs-attr">build-linux:</span><br>  <span class="hljs-comment"># 작업 내용 설정</span><br>  <span class="hljs-attr">steps:</span><br></code></pre></td></tr></table></figure><p>위 레이아웃을 기준으로 필요한 작업들을 하나씩 작성해보자.</p><h3 id="schedule">schedule</h3><p>먼저 매일 특정 시간에 작업이 실행되도록 설정하고자 한다. 액션에서는 리눅스 <code>cron</code>을 지원한다.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">schedule:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">cron:</span> <span class="hljs-string">&#x27;40 4 * * *&#x27;</span><br></code></pre></td></tr></table></figure><p>액션에서 작동하는 <code>cron</code>은 UTC 기준이기 때문에 시간을 잘 맞춰주어야 한다. UTC는 9시간을 더해야 한국 시간이며, 따라서 위 시간은 한국시간으로 13시 40분이다.</p><h3 id="workflow_dispatch">workflow_dispatch</h3><p>이제 수동으로 작업을 실행할 수 있는 코드도 작성해보자. 보통 테스트를 해야하거나 작업이 실패했을 시 수동으로 작업을 실행하기 위해서 해당 코드도 추가한다.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">workflow_dispatch:</span><br></code></pre></td></tr></table></figure><p>그러면 액션에서 아래처럼 수동으로 실행할 수 있는 트리거가 생성된다.</p><figure><img src="/images/166.png" alt="action2" /><figcaption aria-hidden="true">action2</figcaption></figure><h3 id="build-linux">build-linux</h3><p>이제 작업이 실행될 리눅스 환경을 설정한다. <code>max-parallel</code>은 병렬로 처리하려는 작업의 개수를 지정하며, <code>matrix</code>는 작업을 실행할 언어 버전을 지원한다. 아래 코드는 파이썬 3.9 버전에서 작동되도록 설정한 것이다.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">build-linux:</span><br>  <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>  <span class="hljs-attr">strategy:</span><br>    <span class="hljs-attr">max-parallel:</span> <span class="hljs-number">1</span><br>    <span class="hljs-attr">matrix:</span><br>      <span class="hljs-attr">python-version:</span> [<span class="hljs-number">3.9</span>]<br></code></pre></td></tr></table></figure><p>위 코드는 ubuntu 운영체제를 바탕으로 파이썬 3.9 버전을 병렬처리 없이 1개의 환경에서 진행된다는 의미이다.</p><h3 id="steps">steps</h3><p>이제 본격적으로 작업내용을 작성해보자. 일단 스크래핑을 자동화하는 방법은 다음과 같다.</p><ol type="1"><li>사용할 코드 가져오기 (actions/checkout@v2)</li><li>파이썬 설치하기 (Set up Python)</li><li>필요한 패키지 설치하기(Install python package)</li><li>크롬드라이버 설치하기 (Setup Chromedriver)</li><li>파이썬 스크립트 실행하기 (Build)</li></ol><p>위에서 사용되는 파이썬 스크립트는 데이터를 스크래핑해서 DB에 저장하는 코드를 작성한 것이다.</p><h2 id="최종-스크립트">최종 스크립트</h2><p>위 내용들을 바탕으로 작성한 최종 스크립트는 아래와 같다.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">name:</span> <span class="hljs-string">auto-scraping</span> <span class="hljs-string">KBOdata</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">schedule:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">cron:</span> <span class="hljs-string">&#x27;40 4 * * *&#x27;</span><br>    <span class="hljs-comment"># UTC가 default. 한국 시간으로 오후 1시 40분 실행</span><br>  <span class="hljs-attr">workflow_dispatch:</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build-linux:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">strategy:</span><br>      <span class="hljs-attr">max-parallel:</span> <span class="hljs-number">1</span><br>      <span class="hljs-attr">matrix:</span><br>        <span class="hljs-attr">python-version:</span> [<span class="hljs-number">3.9</span>]<br><br>    <span class="hljs-attr">steps:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Set</span> <span class="hljs-string">up</span> <span class="hljs-string">Python</span> &#123;&#123; <span class="hljs-string">matrix.python-version</span> &#125;&#125;<br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-python@v1</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">python-version:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.python-version</span> <span class="hljs-string">&#125;&#125;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">python</span> <span class="hljs-string">package</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        pip install kbodata</span><br><span class="hljs-string">        pip install -r requirements.txt</span><br><span class="hljs-string"></span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">Chromedriver</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">nanasess/setup-chromedriver@v1.0.1</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        cd kbo_data</span><br><span class="hljs-string">        python action.py $&#123;&#123; secrets.DB_INFO &#125;&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
      <category>git/github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Action</tag>
      
      <tag>yml</tag>
      
      <tag>자동화</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>입양 시각 구하기(2) 해설</title>
    <link href="/ko/Sql/sql-6/"/>
    <url>/ko/Sql/sql-6/</url>
    
    <content type="html"><![CDATA[<p>프로그래머스 문제 중 하나인 입양 시각 구하기(2) 풀이를 정리합니다. <span id="more"></span></p><hr /><p>해당 문제는 프로그래머스에 가입이 되어 있다면 <a href="https://programmers.co.kr/learn/courses/30/lessons/59413">이 페이지</a>에서 직접 풀어볼 수 있다.</p><h2 id="문제-정보">문제 정보</h2><p>ANIMAL_OUTS 테이블은 동물 보호소에서 입양 보낸 동물의 정보를 담은 테이블이다. ANIMAL_OUTS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, NAME, SEX_UPON_OUTCOME는 각각 동물의 아이디, 생물 종, 입양일, 이름, 성별 및 중성화 여부를 나타낸다.</p><table><thead><tr class="header"><th>NAME</th><th>TYPE</th><th>NULLABLE</th></tr></thead><tbody><tr class="odd"><td>ANIMAL_ID</td><td>VARCHAR(N)</td><td>FALSE</td></tr><tr class="even"><td>ANIMAL_TYPE</td><td>VARCHAR(N)</td><td>FALSE</td></tr><tr class="odd"><td>DATETIME</td><td>DATETIME</td><td>FALSE</td></tr><tr class="even"><td>NAME</td><td>VARCHAR(N)</td><td>TRUE</td></tr><tr class="odd"><td>SEX_UPON_OUTCOME</td><td>VARCHAR(N)</td><td>FALSE</td></tr></tbody></table><p>보호소에서는 몇 시에 입양이 가장 활발하게 일어나는지 알아보려 한다. 0시부터 23시까지, 각 시간대별로 입양이 몇 건이나 발생했는지 조회하는 SQL문을 작성해라. 이때 결과는 시간대 순으로 정렬해야 한다.</p><h2 id="정답-코드">정답 코드</h2><p>먼저 정답은 아래와 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>    T.HOUR,<br>    IFNULL(D.COUNTS,<br>    <span class="hljs-number">0</span>) <span class="hljs-keyword">AS</span> COUNT<br><span class="hljs-keyword">FROM</span><br>    (<span class="hljs-keyword">SELECT</span><br>        <span class="hljs-variable">@N</span>:<span class="hljs-operator">=</span><span class="hljs-variable">@N</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AS</span> <span class="hljs-keyword">HOUR</span> <br>    <span class="hljs-keyword">FROM</span><br>        ANIMAL_OUTS,<br>        (<span class="hljs-keyword">SELECT</span><br>            <span class="hljs-variable">@N</span>:<span class="hljs-operator">=</span><span class="hljs-number">-1</span> <br>        <span class="hljs-keyword">FROM</span><br>            DUAL) NN LIMIT <span class="hljs-number">24</span>) <span class="hljs-keyword">AS</span> T<br>    <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span><br>        (<br>            <span class="hljs-keyword">SELECT</span><br>                <span class="hljs-keyword">HOUR</span>(DATETIME) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">HOUR</span>,<br>                <span class="hljs-built_in">COUNT</span>(ANIMAL_ID) <span class="hljs-keyword">AS</span> COUNTS<br>            <span class="hljs-keyword">FROM</span><br>                ANIMAL_OUTS <br>            <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span><br>                <span class="hljs-keyword">HOUR</span> <br>            <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><br>                <span class="hljs-keyword">HOUR</span><br>        ) <span class="hljs-keyword">AS</span> D     <br>            <span class="hljs-keyword">ON</span> T.HOUR <span class="hljs-operator">=</span>  D.HOUR<br></code></pre></td></tr></table></figure><h2 id="문제-해설">문제 해설</h2><p>일단 문제를 크게 3개로 나눠서 생각했다.</p><ul><li>시간대 필드 생성 쿼리</li><li>입양 건수를 세는 쿼리</li><li>최종 도출 쿼리</li></ul><p>각각의 쿼리를 분석해보자.</p><h3 id="시간대-필드-생성-쿼리">시간대 필드 생성 쿼리</h3><p>위 문제는 데이터가 없는 시간대도 쿼리 상에서 결과를 같이 도출해야 한다. 예를 들어 1시에 입양 건수가 없어도 이를 레코드로 가져와야 한다. 따라서 0 ~ 23을 레코드로 가지는 필드를 생성한다. 해당 쿼리는 아래와 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>    <span class="hljs-variable">@N</span>:<span class="hljs-operator">=</span><span class="hljs-variable">@N</span><span class="hljs-operator">+</span><span class="hljs-number">1</span> <span class="hljs-keyword">AS</span> <span class="hljs-keyword">HOUR</span> <br><span class="hljs-keyword">FROM</span><br>    ANIMAL_OUTS,<br>    (<span class="hljs-keyword">SELECT</span><br>        <span class="hljs-variable">@N</span>:<span class="hljs-operator">=</span><span class="hljs-number">-1</span> <br>    <span class="hljs-keyword">FROM</span><br>        DUAL) NN LIMIT <span class="hljs-number">24</span>)<br></code></pre></td></tr></table></figure><p><code>DUAL</code>은 함수에 따른 결과값을 도출하고 싶을 때 사용하는 임시 더미 테이블이다. 변수 <code>N</code>에 <code>-1</code>을 할당하여 더미 테이블을 생성한다. 생성된 더미 테이블은 아래와 같다.</p><table><thead><tr class="header"><th><span class="citation" data-cites="N">@N</span>:=-1</th></tr></thead><tbody><tr class="odd"><td>-1</td></tr></tbody></table><p>위 더미와 ANIMAL_OUTS을 조인한 결합 테이블에서 1씩 더해지는 변수 <code>N</code>을 조회하여 가져온다. <code>LIMIT</code> 으로 24로 제한을 두어 0부터 23까지 레코드가 도출되도록 한다. 위 쿼리의 결과는 아래와 같다.</p><table><thead><tr class="header"><th>HOUR</th></tr></thead><tbody><tr class="odd"><td>0</td></tr><tr class="even"><td>1</td></tr><tr class="odd"><td>...</td></tr><tr class="even"><td>22</td></tr><tr class="odd"><td>23</td></tr></tbody></table><h3 id="입양-건수를-세는-쿼리">입양 건수를 세는 쿼리</h3><p>이 쿼리는 ANIMAL_ID의 개수를 확인하여 각 시간별로의 입양 건수를 가져온다. 해당 쿼리는 아래와 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>    <span class="hljs-keyword">HOUR</span>(DATETIME) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">HOUR</span>,<br>    <span class="hljs-built_in">COUNT</span>(ANIMAL_ID) <span class="hljs-keyword">AS</span> COUNTS<br><span class="hljs-keyword">FROM</span><br>    ANIMAL_OUTS <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span><br>    <span class="hljs-keyword">HOUR</span> <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><br>    <span class="hljs-keyword">HOUR</span><br></code></pre></td></tr></table></figure><p><code>ANIMAL_OUTS</code>라는 테이블에는 DATETIME 타입의 날짜 및 시간 필드가 있다. 해당 필드에서 <code>HOUR()</code>을 사용하여 시간만을 도출하고 이를 <code>GROUP BY</code> 대상으로 사용하여 각 시간대별로 입양 건수가 합쳐져서 반환될 수 있도록 한다. 다음으로 <code>ORDER BY</code>하여 시간대 별로 정렬한다. 위 쿼리의 결과는 아래와 같다.</p><table><thead><tr class="header"><th>HOUR</th><th>COUNTS</th></tr></thead><tbody><tr class="odd"><td>7</td><td>3</td></tr><tr class="even"><td>8</td><td>1</td></tr><tr class="odd"><td>...</td><td>...</td></tr><tr class="even"><td>18</td><td>16</td></tr><tr class="odd"><td>19</td><td>2</td></tr></tbody></table><p>위 결과에서 입양 건수가 있는 시간대만 반환되는 것을 볼 수 있다.</p><h3 id="최종-도출-쿼리">최종 도출 쿼리</h3><p>이제 위 두개의 쿼리를 하나로 합쳐서 가져오면 된다. 먼저 쿼리의 구조를 살펴보자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>    T.HOUR,<br>    IFNULL(D.COUNTS,<br>    <span class="hljs-number">0</span>) <span class="hljs-keyword">AS</span> COUNT<br><span class="hljs-keyword">FROM</span><br>    (시간대 쿼리) <span class="hljs-keyword">AS</span> T<br>    <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span><br>    (입양건수 쿼리) <span class="hljs-keyword">AS</span> D     <br>            <span class="hljs-keyword">ON</span> T.HOUR <span class="hljs-operator">=</span>  D.HOUR<br></code></pre></td></tr></table></figure><p>위 쿼리는 두 테이블의 HOUR 필드를 기준으로 <code>LEFT JOIN</code>하여 시간 테이블인 <code>T</code>의 HOUR 필드와 입양건수 테이블인 <code>D</code>의 COUNT 필드의 값을 가져온다. 또한 <code>T</code>의 HOUR 필드 값이 <code>D</code>에 없는 경우 발생하는 NULL은 <code>IFNULL()</code>을 통해 0으로 변경한다. 위 쿼리의 결과는 아래와 같으며, 이는 정답 예시와 동일하다.</p><table><thead><tr class="header"><th>HOUR</th><th>COUNT</th></tr></thead><tbody><tr class="odd"><td>0</td><td>0</td></tr><tr class="even"><td>1</td><td>0</td></tr><tr class="odd"><td>...</td><td>...</td></tr><tr class="even"><td>22</td><td>0</td></tr><tr class="odd"><td>23</td><td>0</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>sql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql</tag>
      
      <tag>programmers</tag>
      
      <tag>question</tag>
      
      <tag>groupby</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Schema on Read란</title>
    <link href="/ko/Engineering/engineering-1/"/>
    <url>/ko/Engineering/engineering-1/</url>
    
    <content type="html"><![CDATA[<p>Hive에서 주로 언급되는 Schema on Read에 대해서 정리합니다. <span id="more"></span></p><h2 id="시작하기-전에">시작하기 전에</h2><p>보통 데이터를 관리하는 시스템들은 크게 Schema on Read, Schema on Write 2가지 타입의 구조를 가진다. 두 타입은 데이터 프로세싱 과정에서 언제 스키마를 정의할 것인지에 따라 나눠지며 일반적으로 사용하는 RDB의 경우 Schema on Write, Hive는 Schema on Read에 해당한다. 두 용어에 대해서 자세히 알아보자.</p><h2 id="schema-on-write">Schema on Write</h2><p>Schema on Write는 데이터를 적재하기 전에 스키마를 먼저 생성해야 하는 방식을 말한다. 이를 그림으로 나타내면 아래와 같다.</p><figure><img src="/images/161.png" alt="SW" /><figcaption aria-hidden="true">SW</figcaption></figure><p>이 방식은 일반 RDB처럼 데이터를 저장하기 위해서는 먼저 스키마를 생성해야 하고 그 다음 데이터를 추가할 수 있는 구조이다. 따라서 스키마에 정의된 데이터 타입이 아닌 데이터를 추가하려고 한다면 에러가 발생한다.</p><h2 id="schema-on-read">Schema on Read</h2><p>하지만 하둡 기반의 빅데이터 플랫폼은 구조가 다르다. HDFS라는 파일분산시스템을 통해 데이터를 적재하고 이를 SQL엔진인 Hive가 RDB형태로 가져오는 구조이기 때문이다. 따라서 Hive는 자연스레 Schema on Read 구조를 따를 수 밖에 없다.</p><figure><img src="/images/162.png" alt="SR" /><figcaption aria-hidden="true">SR</figcaption></figure><p>이 방식은 Raw 데이터를 일단 저장한 후 차후에 필요한 스키마를 생성함으로써 데이터를 읽어온다. 따라서 정의된 스키마 데이터 타입과 실제 저장된 데이터 형식은 일치하지 않을 수 있다. 또한 동일한 데이터를 가지고 여러 개의 스키마를 정의할 수도 있다.</p><h2 id="비교">비교</h2><p>두 구조는 각각의 특징이 존재하며, 이를 정리하면 아래와 같다.</p><table><thead><tr class="header"><th>타입</th><th>Schema on Write</th><th>Schema on Read</th></tr></thead><tbody><tr class="odd"><td>데이터 확인</td><td>적재 전</td><td>읽기 전</td></tr><tr class="even"><td>적재 속도</td><td>비교적 느림</td><td>비교적 빠름</td></tr><tr class="odd"><td>읽는 속도</td><td>비교적 빠름</td><td>비교적 느림</td></tr><tr class="even"><td>오류 빈도</td><td>비교적 낮음</td><td>비교적 높음</td></tr><tr class="odd"><td>유연성</td><td>비교적 낮음</td><td>비교적 높음</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>BigData</category>
      
      <category>engineering</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hive</tag>
      
      <tag>Schema</tag>
      
      <tag>RDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ETL과 ELT</title>
    <link href="/ko/Engineering/engineering-0/"/>
    <url>/ko/Engineering/engineering-0/</url>
    
    <content type="html"><![CDATA[<p>ETL과 ELT에 대해서 공부한 내용들을 정리합니다. <span id="more"></span></p><h2 id="시작하기-전에">시작하기 전에</h2><p>데이터 엔지니어링을 경험해봤다면 누구나 들어봤을 용어가 바로 ETL, ELT이다. 해당 용어들은 Extract(추출), Transform(변환), Load(적재)의 약자로 데이터 처리를 어떤 순서로 진행하는지를 나타낸다. 본격적으로 공부하기에 앞서 각 과정들이 어떤 작업인지 살펴보자.</p><table><thead><tr class="header"><th>단어</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>Extract(추출)</td><td>원본 데이터베이스 또는 데이터 소스에서 소스 데이터를 가져오는 과정</td></tr><tr class="even"><td>Transform(변환)</td><td>대상 데이터가 나머지 데이터와 통합할 수 있도록 구조를 변경하는 과정</td></tr><tr class="odd"><td>Load(적재)</td><td>데이터를 스토리지 시스템에 저장하는 과정</td></tr></tbody></table><p>그럼 우리는 왜 위와 같은 작업들을 진행하는 걸까? 바로 데이터 분석을 하기 위해서는 의미있고 정제된 데이터들이 필요하기 때문이다. 우리가 일상적으로 수집할 수 있는 데이터들은 대부분 정형화되어 있지 않다. 따라서 원천 데이터베이스에서 필요한 데이터만 추출하여 분석에 사용될 형태로 변환하고 이를 적재하여 분석가에게 전달하는 것이다.</p><h2 id="etl">ETL</h2><p>ETL은 추출 &gt; 변환 &gt; 적재 순으로 데이터를 처리한다. 추출 단계에서는 원천 데이터베이스에서 필요한 데이터를 추출하고 이를 스테이징 영역에 임시 보관한다. 그다음 왜 바로 적재하지 않고 변환을 먼저해야 할까? 그 이유는 OLAP 데이터 웨어하우스는 관계형 SQL 기반 데이터 구조를 사용하기 때문이다.</p><p><strong>NOTE</strong><br />OLAP 데이터 웨어하우스란?<br />OLAP란 Online Analytical Processing의 약자로 데이터 웨어하우스와 같은 대규모 데이터에 최종 사용자가 직접 접근하여 대화식으로 정보를 분석하고 의사결정을 지원하는 처리 방식이다. 즉, 분석가가 필요한 정보들을 데이터 웨어하우스에 직접 요청하고 받는 구조이다.<br />데이터 웨어하우스(DW)란 데이터 분석, 데이터 마이닝 등을 지원하기 위해 서로 다른 위치의 데이터를 카테고리 별로 통합하여 적재한 데이터 저장소이다.</p><p>따라서 데이터 웨어하우스에 적재(Load)되기 이전에 변환(Transform)을 거쳐 필요없는 데이터를 삭제하거나 데이터 타입을 변환하거나 민감정보에 필터링, 마스킹 등을 진행한 후에 적재로 넘어간다. 이렇게 구축된 데이터 웨어하우스는 분석가 등의 사용자들에게 지원된다.</p><h2 id="elt">ELT</h2><p>ELT는 추출 &gt; 적재 &gt; 변환 순으로 데이터를 처리한다. 원천 데이터베이스에서 필요한 데이터를 추출한 후 이를 어떠한 정제과정 없이 바로 데이터 레이크(DataLake)에 적재를 진행하며 이후 필요하다고 요청된 데이터만 변환 저리를 하여 제공한다.</p><p><strong>NOTE</strong><br />데이터 레이크란?<br />데이터 레이크는 데이터 웨어하우스와 달리 정형, 비정형, 반정형 데이터를 모두 저장할 수 있는 특별한 저장소이다. 그렇기에 데이터 웨어하우스처럼 데이터를 적재하기 위해서 특정 포맷에 맞춰 변환할 필요가 없으며 원천의 Raw 데이터를 한번에 저장한다. 또한 데이터 레이크에 있는 데이터는 분석을 위해 필요할 때 변환되며 이러한 경우 스키마가 적용되어 데이터 분석이 가능해진다.</p><p>따라서 ELT에서는 스테이징 단계를 거치지 않으며, 변환 또한 필요한 일부 데이터만 이루어지기에 상대적으로 유연하게 데이터를 처리할 수 있다.</p><h2 id="비교">비교</h2><p>ETL과 ELT를 비교하면 다음과 같다.</p><table><thead><tr class="header"><th></th><th>ETL</th><th>ELT</th></tr></thead><tbody><tr class="odd"><td>순서</td><td>추출 &gt; 변환 &gt; 적재</td><td>추출 &gt; 적재 &gt; 변환</td></tr><tr class="even"><td>데이터 저장소</td><td>데이터 웨어하우스</td><td>데이터 레이크</td></tr><tr class="odd"><td>데이터 형태</td><td>관계형 SQL 기반 구조</td><td>모든 데이터 타입(정형, 반정형, 비정형)</td></tr><tr class="even"><td>장점</td><td>- 효율적이고 안정적인 데이터 분석 가능 <br> - 개인 정보 보호 및 보호 규정을 준수 가능 <br> - 정교한 데이터 변환 수행 가능</td><td>- 모든 데이터 타입 활용 가능 <br> - 대규모의 데이터 수집 가능 <br> - 데이터 적재 시간이 상대적으로 짧음</td></tr><tr class="odd"><td>단점</td><td>- 데이터 변환 과정의 시간이 다소 소요 <br> - 구축 초기 비용이 높고 유지보수가 필요</td><td>- 개인 정보 보호 및 보호 규정을 준수 어려움 <br> - 데이터 접근 관련 보안 이슈 존재</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>BigData</category>
      
      <category>engineering</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data</tag>
      
      <tag>ETL</tag>
      
      <tag>ELT</tag>
      
      <tag>dataflow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>하드웨어의 기초</title>
    <link href="/ko/Infra/infra-1/"/>
    <url>/ko/Infra/infra-1/</url>
    
    <content type="html"><![CDATA[<p>글을 시작하기에 앞서 해당 글은 야마자키 야스시, 미나와 케이코, 아제카츠 요헤이, 사토 타카히코의 저서인 『그림으로 공부하는 IT 인프라 구조』 를 바탕으로 요약 및 정리한 글임을 알려드립니다. <span id="more"></span></p><hr /><h2 id="cpu">CPU</h2><p>CPU는 Central Processing Unit의 약자이며 흔히 코어(Core)라고도 불린다. CPU는 명령을 받아 연산을 실행하고 결과를 반환하는 연산 처리를 담담하며, 이때 사용되는 명령과 데이터는 기억 장치인 메모리나 입출력 장치인 저장소를 통해 전달된다. 그렇다면 CPU에 명령을 내리는 건 무엇일까? 바로 운영체제(OS)이다. 운영체제는 프로세스와 키보드, 마우스와 같은 입력 등을 통해 명령을 받아 이를 CPU에 전달한다. CPU는 연산 과정에서 대량의 전기신호를 처리하기 때문에 발열이 심하며 이를 제어하기 위해 냉각기도 같이 구성된다.</p><h2 id="메모리">메모리</h2><p>메모리(RAM)는 컴퓨터의 기억 영역을 담당하여 CPU에 전달할 데이터를 저장하거나 처리 결과를 보관한다. 메모리는 CPU 내부에 있는 메모리 컨트롤러의 채널을 통해 명령 및 데이터를 주고받으며 이를 위해 보통 CPU 옆에 위치한다. 또한 메모리에 저장되는 정보는 오로지 전기적인 작업으로만 처리되기에 전원이 꺼지면 모두 휘발된다. 이런 결점에도 메모리를 사용하는 이유는 엑세스 속도가 매우 빠르기 때문이다. (여기서 엑세스란 데이터를 쓰거나 읽는 동작을 말한다.) CPU 내부에도 작은 메모리를 가지고 있는데, 보통 1차(L1)/2차(L2) 캐시라고 불리며 CPU 내부에 존재한다. 그렇기에 메모리(RAM)보다는 엑세스 속도가 더 빠르지만 용량이 작아 보통 자주 사용되는 명령이나 데이터를 보관한다. 일반적으로 메모리 용량이 커질수록 액세스 속도가 느려지기에 캐시 메모리는 작게 여러 단계를 두어 명령 및 데이터를 저장한다.</p><p>또한 메모리는 처리지연(latency)을 최소화하기 위해 메모리를 복수개의 모듈(뱅크,bank)로 나누고 각 모듈에 연속적인 주소를 부여하여 동시에 접근이 가능하게 하는 방법인 '메모리 인터리빙'이라는 기능이 있다. 이는 대부분의 데이터가 연속해서 액세스 된다는 규칙을 기반으로 만들어진 것이다. 이 기능을 활용하기 위해서는 모든 채널의 동일 뱅크에 메모리를 배치해야 하며, 채널 영역도 많이 사용된다.</p><h2 id="io-장치">I/O 장치</h2><p>I/O는 Input/Output의 줄임말로 데이터의 입출력을 나타내며 이를 담당하는 장치들은 크게 디스크, 네트워크 인터페이스, I/O 제어 등이 있다.</p><h3 id="디스크">디스크</h3><p>디스크는 주로 오래 보관해야 하는 데이터를 저장하는 장치이며, 종류는 크게 하드 디스크(HDD)와 반도체 디스크(SSD)로 나뉜다. 하드 디스크(HDD)는 자기 원반이 여러 개 들어있으며, 이것이 고속으로 회전해서 읽기/쓰기를 처리한다. 이 회전구조 때문에 속도가 물리법칙에 좌우되며 메모리처럼 순식간에 액세스할 수 없다. 일반적으로 수십 밀리초 정도의 시간이 걸린다. 반면 반도체 디스크(SSD)는 메모리같이 반도체로 만들어졌지만 전기가 없어도 데이터가 사라지지 않는 방식으로 설계되어 있다. SSD의 등장으로 메모리와 디스크 간의 속도 차이가 거의 없어지고 있는 추세이다.</p><p>이런 디스크들을 많이 탑재하고 있는 하드웨어를 저장소(storage)라고 한다. 저장소에는 보통 데이터 I/O처리를 위한 CPU와 캐시 메모리 같이 포함되어 있으며, 실제 서버에서 데이터 읽기나 쓰기를 요청하면 CPU가 데이터를 캐시에 올려두고 관리한다. 저장소가 캐시에만 데이터를 기록하고 I/O처리를 완료했다고 서버에 알리는 방식을 라이트 백(Write Back)이라고 하며, 캐시와 디스크에 모두 기록하고 I/O처리를 완료했다고 서버에 알리는 방식을 라이트 스루(Write Through)라고 한다.</p><h3 id="네트워크-인터페이스">네트워크 인터페이스</h3><p>네트워크 인터페이스(NIC)는 서버와 외부 장비를 연결하기 위한 것으로 외부 접속용 인터페이스이다. 즉, 우리가 데스크탑에서 인터넷에 접속하기 위해 유선 랜(LAN, Local Area Network)을 연결할 때 사용하는 장치이다. 네트워크 인터페이스는 다른 서버나 저장소와 같은 외부 장비들과 네트워크 통신이 가능하게 함으로써 데이터를 주고 받을 수 있도록 한다.</p><h3 id="io-제어">I/O 제어</h3><p>I/O 제어는 I/O 장치들의 중요도에 따라 CPU의 처리속도를 제어하는 컨트롤러 장치들을 말한다. 즉, I/O처리 줄세우기를 시켜주는 장치인 것이다. 이런 컨트롤러들이 존재하는 이유는 CPU가 해야할 일들을 분산하여 연산에 더 집중하게 만들기 위함이다. 예를 들어 서버 내부의 디스크는 CPU와 직접 연결하고 USB같은 외부 저장장치들은 컨트롤러와 연결함으로써 I/O처리의 병목현상을 방지할 수 있다.</p><h2 id="버스bus">버스(Bus)</h2><p>버스(Bus)는 서버 내부에 있는 컴포넌트들을 서로 연결시키는 회선을 가리키며, 각 컴포넌트가 데이터를 주고받을 수 있도록 도와주는 역할을 담당한다. 그렇다면 버스의 성능을 어떻게 측정할까? 바로 데이터를 얼마나 주고받을 수 있는지를 나타내는 대역을 통해서 확인할 수 있다. 대역은 Throughput이라고도 부르며, '한번에 데이터를 보낼 수 있는 전송 폭 x 1초에 전송할 수 있는 횟수'로 계산한다.</p>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>infrastructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>하드웨어</tag>
      
      <tag>Hardware</tag>
      
      <tag>CPU</tag>
      
      <tag>Memory</tag>
      
      <tag>Disk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>인프라 아키텍처</title>
    <link href="/ko/Infra/infra-0/"/>
    <url>/ko/Infra/infra-0/</url>
    
    <content type="html"><![CDATA[<p>글을 시작하기에 앞서 해당 글은 야마자키 야스시, 미나와 케이코, 아제카츠 요헤이, 사토 타카히코의 저서인 『그림으로 공부하는 IT 인프라 구조』 를 바탕으로 요약 및 정리한 글임을 알려드립니다. <span id="more"></span></p><hr /><h2 id="인프라-아키텍처란">인프라 아키텍처란</h2><p>인프라(Infra)는 Infrastructure의 줄임말로, 어떤 시스템을 지탱하는 기반이나 토대라는 의미이다. 보통 인프라는 복잡한 구조를 가지지만 대부분 전문가에 의해 관리되고 있어 사용자들은 인프라 구조를 이해하지 않고도 해당 시스템을 간단하게 이용할 수 있다. 인프라 아키텍처는 이런 인프라의 구조를 정의한 '설계도'를 의미한다. 우리가 흔히 사용하는 검색 포털 사이트나 메세지 프로그램과 같은 서비스들도 설계도 기반으로 구축된 인프라 위에서 동작하고 있으며, 이렇게 사용되는 설계도인 인프라 아키텍처들은 모두 특정 패턴으로 귀결된다. 이번 글에서는 현재 주류로 사용되고 있는 인프라 아키텍처를 살펴볼 것이다.</p><h2 id="집약형-아키텍처">집약형 아키텍처</h2><p>집약형 아키텍처는 대형 컴퓨터 한 대가 모든 처리를 담당하는 구조라고 설명할 수 있다. 예를 들어 쇼핑몰 시스템을 집약형 아키텍처 기반의 인프라로 구축한다고 가정해보자. 그러면 하나의 대형 컴퓨터가 물건 검색이나 구매 진행 등 여러 고객들이 쇼핑몰에서 요청한 사항들을 모두 처리할 것이다. 집약형 아키텍처는 한 대의 컴퓨터만 사용하기에 구성이 간단하며 컴퓨터의 성능이 좋지만, 컴퓨터 자체의 가격대가 높기에 쉽게 확장하기 어렵다는 단점이 있다.</p><table><thead><tr class="header"><th>아키텍처</th><th>종류</th><th>장점</th><th>단점</th></tr></thead><tbody><tr class="odd"><td>집약형</td><td></td><td>- 구성이 간단하다. <br> - 리소스 관리나 이중화에 의해 안정성이 높고 고성능이다.</td><td>- 대형 컴퓨터의 도입 및 유지비용이 비싸다. <br> - 확장성에 한계가 있다.</td></tr></tbody></table><h2 id="분할형-아키텍처">분할형 아키텍처</h2><p>분할형 아키텍처는 여러 대의 컴퓨터를 조합해서 하나의 시스템을 운영하는 구조이며 흔히 분산 시스템이라고도 부른다. 해당 아키텍처에서는 대형 컴퓨터 한 대가 하던 역할을 소형 컴퓨터 여러 대를 연결하여 대체하는데, 대형 컴퓨터보다 소형 컴퓨터가 훨씬 저렴하기에 성능은 비슷하게 유지하면서 비용을 아낄 수 있는 구조이다. 또한 성능이 부족하다면 소형 컴퓨터를 추가하여 성능을 향상시킬 수 있어서 확장성이 좋다. 다만 컴퓨터의 수가 늘어날수록 운영 및 관리하기 위한 포인트가 늘어나며 특정 컴퓨터에 장애가 발생했을 시의 부작용을 최소화하기 위한 설계가 요구된다.</p><table><thead><tr class="header"><th>아키텍처</th><th>종류</th><th>장점</th><th>단점</th></tr></thead><tbody><tr class="odd"><td>분할형</td><td>수직, 수평, 지리</td><td>- 낮은 비용으로 시스템 구축이 가능하다. <br> - 컴퓨터 수를 늘릴 수 있어 확장성이 높다.</td><td>- 대수가 늘어날수록 관리가 어렵다. <br> - 장애대응에 대한 설계가 까다롭다.</td></tr></tbody></table><h3 id="수직-분할형-아키텍처">수직 분할형 아키텍처</h3><p>수직 분할형 아키텍처는 여러 컴퓨터들이 서로 다른 각자의 역할을 맡아서 시스템을 운영하는 구조이다. 수직 분할형 아키텍처에는 크게 클라이언트-서버형과 3계층형이 있다.</p><ul><li><p><strong>클라이언트-서버형</strong><br />클라이언트-서버형은 사용자들이 특정 앱이나 프로그램을 소형 컴퓨터에 설치하여 물리서버와 통신하는 구조이다. 흔히 스마트폰이나 데스크탑에서 어플, 게임 등을 다운로드 받아서 사용하는 구조는 해당 아키텍처를 사용하고 있는 것이다. 이 구조는 사용자(클라이언트) 소형 컴퓨터의 리소스를 사용할 수도 있으며 소수의 서버로도 다수의 사용자들을 처리할 수 있다. 다만 소수의 서버에서 처리하는 량이 급증하면 서버가 장애를 발생시킬 수 있다.</p></li><li><p><strong>3계층형</strong><br />3계층형은 서버 처리량의 분할을 위해 구성된 구조이다. 3계층형은 크게 프레젠테이션, 어플리케이션, 데이터 계층으로 구분되어 있으며 각 계층마다 사용자(클라이언트)의 요청을 파악하여 업무를 처리한다. 프레젠테이션 계층은 사용자에게 직접 입력을 받고 웹브라우저에 화면을 표시하고, 어플리케이션 계층은 사용자 요청에 따라 업무를 진행하며, 데이터 계층은 어플리케이션 요청에 따라 데이터를 제공한다. 따라서 각 계층들은 스스로 제공할 수 있는 정보들은 알아서 처리하고 추가로 필요한 정보들만 밑단의 서버들에게 요청한다. 예를 들어 이미지 파일만 읽으면 되는 요청은 프레젠테이션 계층에서 해결할 수 있기에 다른 계층으로 넘어가지 않는다.</p></li></ul><p>수직 분할형 아키텍처들의 장단점을 정리하면 아래와 같다.</p><table><thead><tr class="header"><th>아키텍처</th><th>종류</th><th>장점</th><th>단점</th></tr></thead><tbody><tr class="odd"><td>수직 분할형</td><td>클라이언트-서버형</td><td>- 소수의 서버로도 다수의 사용자들을 처리할 수 있다.</td><td>- 클라이언트 측 소프트웨어 정기 업데이트가 필요하다. <br> - 서버 확장성의 한계가 발생할 수 있다.</td></tr><tr class="even"><td>수직 분할형</td><td>3계층형</td><td>- 서버부하를 개선할 수 있다. <br> - 클라이언트 단말에 브라우저만 있으면 된다.</td><td>- 구조가 비교적 복잡하다.</td></tr></tbody></table><h3 id="수평-분할형-아키텍처">수평 분할형 아키텍처</h3><p>수평 분할형 아키텍처는 하나의 역할을 여러 대의 서버가 맡아서 운영하는 구조이다. 즉, 3계층형 아키텍처에서 나눠졌던 3개의 계층들에 서버를 각각 한 대가 아닌 여러 대로 구성하여 운영하는 것이다. 이 구조는 특정 역할을 처리하는 컴퓨터 수가 늘어나기에 전체적인 시스템 성능이 향상된다. 또한 한 대에 장애가 생겨도 서비스에는 큰 지장이 없기에 시스템 안정성도 증가한다.</p><ul><li><p><strong>단순 수평 분할형</strong><br />단순 수평 분할형은 특정 기준을 바탕으로 인프라를 분할하는 방식이다. 예를 들어 서울과 부산에 동일한 시스템을 구성한다고 가정해보자. 해당 아키텍처는 서울은 A 인프라를 사용하고, 부산은 B 인프라를 사용하게 한다. 따라서 A 인프라가 장애가 발생해도 부산 시스템에는 문제가 없어 독립성은 보장된다. 다만 데이터 계층도 독립적이기에 두 지사의 데이터를 일원화할 수 없으며 한 인프라에 과부화가 발생해도 이를 공유할 수는 없다.</p></li><li><p><strong>공유형</strong><br />공유형은 데이터 계층에서 데이터를 동기화하여 상호 접속이 가능하도록 설계된 구조이다. 특히 데이터 계층은 저장고의 역할도 하기 때문에 보안이 요구되며 이를 관리하기 위해서는 한 장소에 모아 관리하는 것이 더 효율적이다. 또한 이 구조는 데이터 일원화가 가능하다.</p></li></ul><p>수평 분할형 아키텍처들의 장단점을 정리하면 아래와 같다.</p><table><thead><tr class="header"><th>아키텍처</th><th>종류</th><th>장점</th><th>단점</th></tr></thead><tbody><tr class="odd"><td>수평 분할형</td><td>단순형</td><td>- 확장성이 향상된다. <br> - 시스템이 독립적으로 운영되어 서로 영향을 주지 않는다.</td><td>- 데이터 일원화가 불가하다. <br> - 처리량이 균등하게 분할되지 않는다.</td></tr><tr class="even"><td>수평 분할형</td><td>공유형</td><td>- 확장성이 향상된다. <br> - 서로 다른 시스템의 데이터를 참조할 수 있다.</td><td>- 독립성이 낮아진다. <br> - 공유한 계층의 확장성이 낮아진다.</td></tr></tbody></table><h3 id="지리-분할형-아키텍처">지리 분할형 아키텍처</h3><p>수직, 수평 분할형은 서버 성능을 높이기 위한 설계였다면 지리 분할형은 업무 연속성과 시스템 가용성을 높이기 위한 설계이다. 지리 분할형 아키텍처로는 크게 스탠바이형과 재해대책형이 있다.</p><ul><li><p><strong>스탠바이형</strong><br />스탠바이형은 최소 2대의 서버를 준비하여 한 대가 고장나면 다른 한 대가 작동하는 구조이다. 흔히 고가용성(HA), 액티브-스탠바이 구조라고도 한다. 이 방식은 장애발생 시 문제없이 서비스를 제공할 수 있지만, 액티브 서버가 정상작동 중에는 스탠바이 서버가 놀고 있기에 리소스 낭비가 발생한다.</p></li><li><p><strong>재해대책형</strong><br />재해대책형은 실제 사용중인 서비스 시스템을 똑같이 다른 지역에 구축하는 구조이다. 흔히 DRS(Disaster Recovery System)라고도 불린다. 이 방식은 실제 특정 지역에 재해가 발생하거나 기타 이유로 메인 시스템에 장애가 발생했을 시 DRS를 사용하여 서비스를 유지하는 구조이다. 이 구조를 사용하기 위해서는 메인 시스템과 DRS가 실시간 동기화가 이루어지도록 셋업해야 한다.</p></li></ul><p>지리 분할형 아키텍처들의 장단점을 정리하면 아래와 같다.</p><table><thead><tr class="header"><th>아키텍처</th><th>종류</th><th>장점</th><th>단점</th></tr></thead><tbody><tr class="odd"><td>지리 분할형</td><td>스탠바이형</td><td>- 물리서버 고장에 대처 가능하다. (failover)</td><td>- 리소스 낭비가 발생한다.</td></tr><tr class="even"><td>지리 분할형</td><td>재해대책형</td><td>- 재해에도 서비스 유지 가능하다.</td><td>- DRS를 운영하는 데 있어 많은 비용이 발생한다.</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>infrastructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>인프라</tag>
      
      <tag>인프라아키텍처</tag>
      
      <tag>Infra</tag>
      
      <tag>Infrastructure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>데이터베이스 아키텍처</title>
    <link href="/ko/Database/Database-0/"/>
    <url>/ko/Database/Database-0/</url>
    
    <content type="html"><![CDATA[<p>데이터베이스 아키텍처에 대해서 공부하고 정리합니다. <span id="more"></span></p><hr /><h2 id="시작하기-전에">시작하기 전에</h2><p>가끔씩 데이터베이스(DB)에 대해서 설명할 때 DBMS, DB서버, 저장소를 혼용하여 사용하곤 한다. 하지만 이에 대한 차이점을 명확히 짚고 넘어가지 않는다면 아키텍처를 이해하는 데 어려울 수 있다. 따라서 데이터베이스 아키텍처를 공부하기 전에 아래 단어들의 차이점들을 살펴보자.</p><table><thead><tr class="header"><th>단어</th><th>설명</th><th>예시</th></tr></thead><tbody><tr class="odd"><td>DBMS</td><td>데이터를 체계적인 형태로 가공하여 저장소에 저장하거나 가져오는 프로그램</td><td>mysql, oracle, postgresql 등</td></tr><tr class="even"><td>DB서버</td><td>DBMS가 설치되어 다른 앱들과의 데이터 송수신을 담당하는 서버</td><td>DBMS가 설치된 서버</td></tr><tr class="odd"><td>저장소</td><td>DB서버가 데이터를 저장하는 물리적 하드웨어</td><td>하드디스크, SSD 등</td></tr></tbody></table><p>위 정보를 기반으로 데이터베이스 아키텍처에 대해 알아보자.</p><h2 id="데이터베이스-아키텍처란">데이터베이스 아키텍처란</h2><p>아키텍처는 어떤 시스템을 구성한 설계도이다. 그렇기에 어떤 아키텍처를 채택했는가에 따라서 해당 시스템의 견고함과 안정성이 결정된다. 만약 달성하려는 목적에 적합하지 않은 아키텍처를 사용한다면 당연히 시스템은 여러 문제들에 부딪힐 것이다. 예로 건물을 건축하는 과정을 생각해보자. 만약 어떤 사람이 10층 규모의 빌딩을 건설하려고 하는데 3층 규모의 설계도를 사용한다면 당연히 그 건물은 안정성을 보장받을 수 없다. 또한 내부균열이나 자연재해 등에 의해 문제가 발생할 가능성이 높아지며 이를 해결하기가 훨씬 어려워진다. 그래서 보통 설계를 진행할 때는 건물이 완공되고 유지되면서 부딪힐 수 있는 외부변수들을 모두 고려하여 건물의 견고함과 안정성을 향상시키고자 한다. 시스템도 마찬가지다.</p><p>위 내용을 바탕으로 고민해보자. 데이터베이스 아키텍처란 무엇일까? 데이터베이스 서버들이 견고하고 안정적으로 운영될 수 있도록 구성된 설계도라고 설명할 수 있을 것이다.</p><h2 id="데이터베이스-아키텍처-종류">데이터베이스 아키텍처 종류</h2><p>어떤 서비스가 예상치 못한 중단 없이 안정적으로 지속되는 비율을 가용성이라고 하며, 가용성은 시스템의 안정성을 검증하는 하나의 요소이다. 가용성을 높이기 위한 전략으로는 크게 소수의 고품질을 지향하는 심장전략과 다수의 저품질을 지향하는 신장전략 2가지가 언급되며, 현재는 이 중에서 신장전략을 대부분 채택한다. 서비스 컴포넌트 하나에 문제가 생겨도 서비스가 중단되지 않도록 여러 개의 동일한 컴포넌트를 마련해두는 것이다.</p><h3 id="클러스터링">클러스터링</h3><p>클러스터링은 DB서버와 저장소를 수평적인 구조로 설계된 아키텍처이다. 여러 대의 컴퓨터가 데이터 트랜젝션을 처리하다보니 데이터 정합성 유지하는 것이 중요하기 때문에 동기 방식으로 노드들 간의 데이터를 동기화한다.</p><h4 id="shared-disk">Shared Disk</h4><p>Shared Disk란 이름 그대로 여러 대의 DB서버가 저장소(Disk)를 공유하는 구조이다. 여러 대의 DB서버가 사용되므로 단일 DB서버 구조에 비해 장애가능성이 현져히 낮아지지만, 단일 저장소로 운영하다보니 저장소에 장애가 발생한 경우 서비스가 중단될 수 있다. Shared Disk 구조는 아래와 같다.</p><figure><img src="/images/159.png" alt="SD" /><figcaption aria-hidden="true">SD</figcaption></figure><p>Shared Disk 구조는 운영 방식에 따라서 Active-Active, Active-Standby 2가지로 구분된다.</p><ul><li>Active-Active: DB서버 여러 대를 동시에 작동하는 운영방식<ul><li>장점: 여러 대 리소스를 사용하여 성능 향상, 시스템 다운 시간 미미</li><li>단점: 서버 대수가 늘어날수록 저장소 병목현상 발생가능성 증가</li></ul></li><li>Active-Standby: Active DB서버 한대만 운영하다가 장애 시 Standby DB서버를 사용하는 운영방식<ul><li>장점: 비용 절약하며 다중화 가능</li><li>단점: 전환 시에 시스템 다운 시간 발생</li></ul></li></ul><h4 id="shared-nothing">Shared Nothing</h4><p>Shared Nothing이란 DB서버뿐만 아니라 저장소도 분리한 구조이다. 각 DB서버는 로컬에 위치한 데이터만 관리하면 되므로 노드를 추가할수록 선형적으로 성능이 향상된다. 다만 각자 로컬 저장소만을 사용하기 때문에 메타 데이터를 관리하는 서버가 따로 필요하다. 또한 한 대의 노드에 장애 발생 시 데이터 일부를 사용할 수 없기에 이를 방지하기 위한 조치도 요구된다. Shared Nothing 구조는 아래와 같다.</p><figure><img src="/images/160.png" alt="SN" /><figcaption aria-hidden="true">SN</figcaption></figure><h3 id="레플리케이션">레플리케이션</h3><p>레플리케이션은 DB서버와 저장소를 그대로 복제해두는 아키텍처이다. 레플리케이션의 DB서버는 마스터(master)-슬레이브(slave)구조로 구성되며, 마스터는 실제 서비스의 데이터를 관리하고 슬레이브 서버는 마스터와 비동기 방식으로 동기화한다.</p>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DB</tag>
      
      <tag>database</tag>
      
      <tag>architecture</tag>
      
      <tag>sharednothing</tag>
      
      <tag>shareddisk</tag>
      
      <tag>아키텍처</tag>
      
      <tag>clustering</tag>
      
      <tag>replication</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Post 2021, Pre 2022</title>
    <link href="/ko/Reviews/2021/"/>
    <url>/ko/Reviews/2021/</url>
    
    <content type="html"><![CDATA[<p>해당 글은 개인적으로 성장하고 있는지를 판단하기 위해서 작성하며, 1년동안 했던 일들을 정리하고 앞으로 나아갈 방향에 대한 글입니다. <span id="more"></span></p><hr /><h2 id="post-2021">Post 2021</h2><p>2021년 2월 15일, 현재 다니고 있는 회사에 입사한 날이다. 어느새 나는 2년차 엔지니어가 되었다. 1년동안 나름 열심히 달려왔다고 생각했는데 오히려 마음은 작년에 비해 더 조급해졌다. 성장에 대한 뿌듯함보다는 미래에 대한 불안함이 커지는 만큼 1년간 나의 노력들을 정리해보고자 글을 작성한다.</p><p>2020년의 나는 원래 대학원을 준비했었다. 2020년 9월에 몇몇 대학원 지원서를 작성했었는데 아이러니하게도 지원서를 작성하면서 떨어질 것을 예감했다. 왜냐하면 대학원에 입학하여 무엇을 공부하고 싶은지조차도 스스로 설명이 안되었기 때문이다. 지금 생각해보면 그때의 나는 데이터 분석이 재밌어서 공부했던거지 어떤 목표나 성취를 바란 건 아니었다. 그러다보니 당연히 서류 탈락 + 면접 탈락의 고배를 마셨다.</p><p>대학원 결과가 발표될 무렵인 2020년 12월에 스터디에서 만난 분께 입사 제안을 받았다. 구직 중이라면 현재 다니고 있는 회사를 내부 추천해주신다고 하셨고 나는 취업을 하기로 결심했다. 이력서 제출 후 대략 2개월동안 두 번의 면접이 진행되었고, 마침내 2021년 2월에 첫 출근을 하게 되었다. 첫 이력서 제출에 바로 합격이라니 지금 생각해봐도 난 정말 운이 좋았다.</p><h3 id="업무에-관하여">업무에 관하여</h3><p>내가 입사한 팀은 고객사에 파견되어 빅데이터 플랫폼을 구축해주고 데이터 엔지니어링을 진행해주는 회사였다. 처음 입사했을 때의 나는 빅데이터 플랫폼이라고는 바닐라 하둡과 스파크를 조금 만져본 경험이 전부인 새내기였고, 당연히 배울 것은 너무너무너무너무너무너무 많았다. 알아야 했던 내용들을 정리해보자.</p><ul><li><strong>빅데이터 플랫폼을 구축하기 위한 노드들 Linux 환경 셋팅 공부</strong><ul><li>이를 위해 운영체제부터 공부하기 시작</li><li>공부가 대충 끝나고는 바로 앤서블을 도입해서 자동화 프로그램 개발 시작</li><li>노가다는 컴퓨터에게 맡기는 것을 추구</li></ul></li><li><strong>하둡과 에코시스템이 어떤 아키텍처를 가지고 있는지 공부</strong><ul><li>HDFS, YARN, Hive, Impala, Spark, Kudu, Ranger, Nifi 등</li><li>고객사가 픽하는 에코 시스템으로 프로젝트를 진행하니 일단 다 공부하기</li><li>아직도 공부할 에코 시스템이 많이 남았다는 사실</li></ul></li><li><strong>데이터 워크플로우 공부</strong><ul><li>보통 Hive, Impala로 쿼리엔진 사용</li><li>배치 프로그램 shell로 작성해서 스케쥴링</li><li>실시간으로 필요한건 Nifi로 워크플로우 작성</li></ul></li><li><strong>플랫폼 인증 단일화 위해 kerberos 공부</strong><ul><li>이를 위해 계정 관리 툴인 AD부터 공부하기 시작</li><li>kerberos 프로토콜 아키텍처 공부</li></ul></li><li><strong>플랫폼끼리의 통신 보안을 위해 TLS 공부</strong><ul><li>은행은 보통 폐쇄망이라서 self TLS로 구축한 뒤 인증서버에 추가한다.</li><li>RootCA 바탕으로 호스트 별 키 생성해서 배포하는 방식</li><li>서로의 truststore에 넣어주어야 함</li></ul></li></ul><p>이렇게 적어보니 플랫폼부터 데이터 엔지니어링까지 많은 것들을 배우고 공부했었구나 싶다. 전문가처럼 완벽하게는 아니지만 위 목록들을 다 경험해봤다는 자체가 이제 막 2년차가 된 내게는 좋은 경험이라는 생각이 든다.</p><h3 id="사이드-프로젝트">사이드 프로젝트</h3><p>2021년에 진행한 사이드 프로젝트는 아래와 같다.</p><ul><li><strong>KBO-data 패키지</strong><ul><li>KBO 데이터를 수집하는 패키지 생성</li><li>poetry 패키지 관리</li><li>수집한 데이터를 저장하기 위한 데이터 모델링</li><li>데이터 모델에 대한 문서 작성</li></ul></li><li><strong>KBO 실시간 수집 진행</strong><ul><li>github action 사용하여 매일 job 진행</li><li>수집된 데이터는 DB서버로 전송</li><li>DB서버는 대시보드와 연동</li></ul></li><li><strong>KBO dashboard 업데이트</strong><ul><li>KBO 데이터를 분석한 결과를 제공</li><li>Flask 기반</li><li>서버 EC2에서 lightsail로 변경</li></ul></li><li><strong>resume 페이지 생성</strong><ul><li>github page 기능을 사용하여 페이지 생성</li><li>bootstrap 템플릿에 커스터마이징함</li></ul></li></ul><h3 id="hadoop-외-공부한-기술들">Hadoop 외 공부한 기술들</h3><ul><li>SQL: 기초 내용 공부하여 SQLD 획득했고 실제 업무에서도 사용중이다.</li><li>Shell script: Hadoop기반 플랫폼에서 배치 프로그램 작성하는 법 등을 배웠다.</li><li>Ansible: 수동으로 반복되는 작업을 자동화하고 싶어서 배우기 시작했으며, 프로그램 개발에 사용했다.</li><li>Rust: 러스트 가이드 공부하고 코테 문제 풀어보면서 문법을 익혔다.</li><li>Poetry: 파이썬 패키지 생성 및 관리 방법을 공부하고 사용했다.</li><li>Kubernetes: 공부중. 프로젝트 전까지 공부하다가 파견나가면서 스탑되었다.</li></ul><h3 id="커뮤니티-활동">커뮤니티 활동</h3><p>현재 파이썬 커뮤니티와 러스트 커뮤니티에서 활동을 하고 있다. 2021년에는 파이콘 준비위원회로 활동하면서 후원사와 게더타운 등의 업무를 맡아서 진행했었다.</p><h2 id="pre-2022">Pre 2022</h2><p>이제 2022년이 되었다. 2년차는 어떻게 보내야 할까? 일단은 파견직이 아닌 곳으로 이직을 도전해 볼 생각이다. 프로젝트 파견 + 기술지원으로 여러 사이트를 맡아서 업무를 진행하다보니 정신없기도 하고 생각보다 스트레스도 많이 받은 것 같다. 또한 나는 오픈소스에 관심이 많은데 보통 고객사는 폐쇄망이라서 개발 환경에 대한 아쉬움도 있다. 마침 날 추천해준 동료분도 이직을 준비중이라고 해서 나도 조금씩 준비해보기로 하였다.</p><h3 id="어떤-업무를-원하는가">어떤 업무를 원하는가</h3><p>다양한 데이터 아키텍처를 배울 수 있는 환경을 원한다. 효율성을 위해 같이 고민할 수 있는 팀에 들어가고 싶다. 사수 데이터 엔지니어가 있었으면 좋겠다. 오픈소스를 사용할 수 있는 개발 환경에서 일하고 싶다.</p><h3 id="도전할-사이드-프로젝트">도전할 사이드 프로젝트</h3><ul><li><strong>2022년 파이콘 웹사이트 개발</strong><ul><li>일단 장고를 공부하고 있음</li><li>아직 어떻게 참여할지는 모르겠음</li></ul></li><li><strong>Rust로 이것저것 해보기</strong><ul><li>러스트를 사용해서 무언가를 개발해보고 싶음</li></ul></li><li><strong>오픈소스에 참여해보기</strong><ul><li>작은 부분이라도 오픈소스에 기여해보고 싶음</li></ul></li></ul><h3 id="공부할-기술들">공부할 기술들</h3><ul><li>Spark: 스파크로 실시간 데이터를 처리하는 워크플로우를 공부할 예정</li><li>SQLP: 올해는 쿼리 튜닝하는 방법들을 공부해서 SQLP 자격증을 도전할 예정</li><li>Kubernetes: 다시 공부 시작할 예정</li></ul><h3 id="커뮤니티-기여">커뮤니티 기여</h3><p>올해도 파이콘 준비위원회로 활동할 예정이다. 이번에는 파이콘 웹페이지 개발에도 참여를 하려고 한다. 이를 위해 장고도 다시 공부하며 코드 분석을 하고 있다. 우리나라에서도 러스트 컨퍼런스가 열렸으면 좋겠다.</p>]]></content>
    
    
    <categories>
      
      <category>etc.</category>
      
      <category>reviews</category>
      
    </categories>
    
    
    <tags>
      
      <tag>엔지니어</tag>
      
      <tag>개발자</tag>
      
      <tag>회고</tag>
      
      <tag>주니어</tag>
      
      <tag>소프트웨어</tag>
      
      <tag>2년차</tag>
      
      <tag>신입</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust print 매크로 병목현상</title>
    <link href="/ko/Rust/rust-8/"/>
    <url>/ko/Rust/rust-8/</url>
    
    <content type="html"><![CDATA[<p>러스트 print 매크로 사용하는 경우의 성능에 대해서 정리합니다. <span id="more"></span></p><h2 id="문제-발생-시점">문제 발생 시점</h2><p>러스트로 <a href="https://www.acmicpc.net/problem/1914">백준의 하노이 탑 문제</a>를 풀고 있었다. 이미 해당 문제는 파이썬으로 풀었기에 로직 변화 없이 러스트 코드로 컨버팅했다. 하지만 계속 채점률 40%에서 시간 초과 오류가 발생했다. 시간 초과가 발생하는 코드는 아래와 같다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">read_line</span>(&amp;<span class="hljs-keyword">mut</span> num).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span>:<span class="hljs-type">u32</span> = num.<span class="hljs-title function_ invoke__">trim</span>().<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;숫자가 아닙니다.&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">start</span>:<span class="hljs-type">u32</span> = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">dest</span>:<span class="hljs-type">u32</span> = <span class="hljs-number">3</span>;<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt; n &amp;&amp; n &lt;= <span class="hljs-number">20</span> &#123;<br>        <span class="hljs-title function_ invoke__">count_move</span>(n);<br>        <span class="hljs-title function_ invoke__">hanoi</span>(n, start, dest);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-title function_ invoke__">count_move</span>(n);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">count_move</span>(n: <span class="hljs-type">u32</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">count</span> = <span class="hljs-type">i128</span>::<span class="hljs-title function_ invoke__">pow</span>(<span class="hljs-number">2</span>,n);<br>    <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&#123;&#125;\n&quot;</span>,count-<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">hanoi</span>(n: <span class="hljs-type">u32</span>, start: <span class="hljs-type">u32</span>, dest: <span class="hljs-type">u32</span>) &#123;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125;\n&quot;</span>,start, dest);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_ invoke__">hanoi</span>(n-<span class="hljs-number">1</span>, start, <span class="hljs-number">6</span>-start-dest);<br>        <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125;\n&quot;</span>,start, dest);<br>        <span class="hljs-title function_ invoke__">hanoi</span>(n-<span class="hljs-number">1</span>, <span class="hljs-number">6</span>-start-dest, dest);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>위 코드의 로직이 궁금한 사람은 <a href="https://dev-bearabbit.github.io/2022/03/08/Algorithms/Algorithms-2/">이 글</a>에서 확인할 수 있다.</p><h2 id="원인-분석">원인 분석</h2><p>처음에는 로직에 문제가 있었나 했지만 파이썬 코드로는 채점 통과하는 것을 확인하니 이 부분은 문제가 아닐 것 같아 배제하고 다른 원인을 찾아보았다. 그러다가 아래와 같은 글을 발견하였다.</p><blockquote><p>아 출력 병목이었습니다.<br />rust 쓰시는 분들 조심하세요.<br />println!이나 print! 호출이 100000단위가 넘어가면 무조건 병목 생깁니다.<br />병목 해결 소스도 같이 올려요~<br />https://www.acmicpc.net/board/view/43948</p></blockquote><p>위 코드는 원판이 20개 이하라면 이동 과정을 모두 출력하는데, 원판 20개일 때 출력해야 하는 개수는 <span class="math inline">\(2^{20}-1\)</span>의 결과인 1048575개이다. 그래서 채점 중간에 시간초과로 결과가 나오는 것 같았다. 그렇다면 러스트는 왜 <code>println!</code>, <code>print!</code>를 일정 이상 사용하면 병목현상이 발생하는 것인가? 이에 대해 reddit에서 관련 내용들을 찾아보았다.</p><blockquote><p>I would guess the explanation is output buffering. By default, Python will buffer multiple lines before writing them to stdout, which Rust does not. Try running the Python script with a -u flag and see what happens.<br />https://www.reddit.com/r/rust/comments/qiyqlo/fizzbuzz_in_rust_is_slower_than_python/</p></blockquote><p>사실인지는 확실하지 않지만 이를 통해 파이썬에서는 작동이 되고 러스트에서는 안되는 이유를 유추해볼 수 있을 것 같다. 파이썬은 여러 줄을 버퍼링해서 출력하지만 러스트는 매크로가 작동될 때마다 출력한다는 것이다. 당연히 출력이 여러 번 발생하면 rust가 모니터로 출력할 데이터를 전송해야 하기에 더 많은 시간이 소요될 수밖에 없다. 따라서 위와 같은 로직을 구현할 때는 버퍼를 사용하여 출력해야 할 자료들을 메모리에 올려놨다가 한번에 출력하는게 훨씬 빠를 수 있다는 것이다.</p><h2 id="코드-분석">코드 분석</h2><p>아래의 코드는 채점을 통과한 코드이다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">read_line</span>(&amp;<span class="hljs-keyword">mut</span> num).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span>:<span class="hljs-type">u32</span> = num.<span class="hljs-title function_ invoke__">trim</span>().<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;숫자가 아닙니다.&quot;</span>);<br>    <span class="hljs-title function_ invoke__">count_move</span>(n);<br><br>    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">21</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">list</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>        <span class="hljs-title function_ invoke__">hanoi</span>(n, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, &amp;<span class="hljs-keyword">mut</span> list);<br>        <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, list);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">count_move</span>(n: <span class="hljs-type">u32</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">count</span> = <span class="hljs-type">i128</span>::<span class="hljs-title function_ invoke__">pow</span>(<span class="hljs-number">2</span>,n);<br>    <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&#123;&#125;\n&quot;</span>,count-<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">hanoi</span>(n: <span class="hljs-type">u32</span>, start: <span class="hljs-type">u32</span>, dest: <span class="hljs-type">u32</span>, list: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">String</span>) &#123;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;<br>        list.<span class="hljs-title function_ invoke__">push_str</span>(&amp;<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125;\n&quot;</span>,start, dest));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_ invoke__">hanoi</span>(n-<span class="hljs-number">1</span>, start, <span class="hljs-number">6</span>-start-dest, list);<br>        list.<span class="hljs-title function_ invoke__">push_str</span>(&amp;<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125;\n&quot;</span>,start, dest));<br>        <span class="hljs-title function_ invoke__">hanoi</span>(n-<span class="hljs-number">1</span>, <span class="hljs-number">6</span>-start-dest, dest, list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>에러가 발생한 코드와의 차이점은 재귀함수에 <code>println!</code>, <code>print!</code> 명령어를 없앴다는 것이다. 코드를 자세히 뜯어보면 <code>main()</code>에서 list라는 빈 문자열을 만들고 출력해야 할 문자열을 list에 저장하였다. 그리고 재귀가 끝나면 한번에 출력하였다.</p><h2 id="python과-성능-비교">Python과 성능 비교</h2><p>이제 러스트의 성능을 확인해보기 위해서 동일한 로직으로 작성한 파이썬 코드와 비교해보자. 먼저 위 코드를 백준에서 채점하면 아래와 같다.</p><figure><img src="/images/158.png" alt="rust" /><figcaption aria-hidden="true">rust</figcaption></figure><p>다음으로는 파이썬 코드를 채점해보자. 아래 코드는 비교를 위해 사용한 파이썬 코드이다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">hanoi_func</span>(<span class="hljs-params">n, _<span class="hljs-keyword">from</span>, _to</span>):<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>        path.append([_<span class="hljs-keyword">from</span>,_to])<br>    <span class="hljs-keyword">else</span>:<br>        hanoi_func(n-<span class="hljs-number">1</span>,_<span class="hljs-keyword">from</span>,<span class="hljs-number">6</span>-(_<span class="hljs-keyword">from</span>+_to))<br>        path.append([_<span class="hljs-keyword">from</span>,_to])<br>        hanoi_func(n-<span class="hljs-number">1</span>,<span class="hljs-number">6</span>-(_<span class="hljs-keyword">from</span>+_to),_to)<br>        <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hanoi_num_func</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>**n -<span class="hljs-number">1</span><br><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><br><span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">21</span>:<br>    <span class="hljs-built_in">print</span>(hanoi_num_func(n))<br>    path = []<br>    hanoi_func(n,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">for</span> a,b <span class="hljs-keyword">in</span> path:<br>        <span class="hljs-built_in">print</span>(a, end=<span class="hljs-string">&quot; &quot;</span>)<br>        <span class="hljs-built_in">print</span>(b)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(hanoi_num_func(n))<br></code></pre></td></tr></table></figure><p>백준에서 파이썬 코드로 채점한 결과는 아래와 같다.</p><figure><img src="/images/157.png" alt="python" /><figcaption aria-hidden="true">python</figcaption></figure><p>확실히 똑같은 로직이라도 러스트가 리소스를 덜 사용하는 것을 알 수 있다.</p><table><thead><tr class="header"><th>언어</th><th>메모리</th><th>소요시간</th></tr></thead><tbody><tr class="odd"><td>python</td><td>122052 KB</td><td>1812 ms</td></tr><tr class="even"><td>rust</td><td>20340 KB</td><td>120 ms</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>recursion</tag>
      
      <tag>recursive</tag>
      
      <tag>python</tag>
      
      <tag>rust</tag>
      
      <tag>비교</tag>
      
      <tag>hanoi</tag>
      
      <tag>시간초과</tag>
      
      <tag>println</tag>
      
      <tag>print</tag>
      
      <tag>퍼포먼스</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>하노이 탑 문제</title>
    <link href="/ko/Algorithms/Algorithms-2/"/>
    <url>/ko/Algorithms/Algorithms-2/</url>
    
    <content type="html"><![CDATA[<p>하노이 탑 문제를 재귀 알고리즘으로 해결합니다. <span id="more"></span></p><h2 id="하노이-탑-문제">하노이 탑 문제</h2><p>하노이 탑은 3개의 기둥에서 원판을 옮기는 과정을 찾는 문제이다. 아래의 글은 <a href="https://www.acmicpc.net/problem/1914">백준의 하노이 탑 문제</a>의 설명을 가져온 것이다.</p><blockquote><p>세 개의 장대가 있고 첫 번째 장대에는 반경이 서로 다른 n개의 원판이 쌓여 있다. 각 원판은 반경이 큰 순서대로 쌓여있다. 이제 수도승들이 다음 규칙에 따라 첫 번째 장대에서 세 번째 장대로 옮기려 한다.</p><ul><li>한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다.</li><li>쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다.</li><li>이 작업을 수행하는데 필요한 이동 횟수는 최소가 되는 이동 순서를 출력하는 프로그램을 작성하라.</li></ul></blockquote><p>이제 문제를 분석해보자.</p><h3 id="문제-분석">문제 분석</h3><p>하노이 탑 문제에서는 기둥이 3개로 제한된다. 처음에는 C 원판을 3기둥으로 옮겨야 하는데 이를 위해서는 위에 있던 나머지 원판들을 모두 2기둥에 옮겨야 한다. 결국 원판을 목적지까지 옮기면 아래처럼 정리된다.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">A ║─  ║   ║   ║       ║   ║   ║   ║       ║   ║   ║   ║       ║   ║   ║   ║       ║   ║   ║   ║    <br>B ║── ║   ║   ║   -&gt;  ║── ║   ║   ║   -&gt;  ║   ║   ║   ║   -&gt;  ║   ║─  ║   ║   -&gt;  ║   ║─  ║   ║ <br>C ║───║   ║   ║       ║───║   ║─  ║       ║───║── ║─  ║       ║───║── ║   ║       ║   ║── ║───║<br>    1   2   3 <br></code></pre></td></tr></table></figure><ul><li>C원판은 B원판이 보관 기둥인 2에 먼저 도착한 후에 도착 기둥인 3으로 이동할 수 있다.</li><li>B원판 위에 있는 A원판이 보관 기둥인 3에 도착한 후에 도착 기둥인 2로 이동할 수 있다.</li><li>A원판은 B원판이 도착하고자 하는 2를 제외한 보관 기둥인 3으로 이동해야 한다.</li><li>B원판은 도착 기둥인 2로 이동하며, B원판이 도착했으므로 A원판도 2로 이동한다.</li><li>B원판이 보관 기둥에 이동한 후에 C원판은 3으로 이동한다.</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">A ║   ║   ║   ║       ║   ║   ║   ║       ║   ║   ║   ║<br>B ║   ║─  ║   ║   -&gt;  ║   ║   ║   ║   -&gt;  ║   ║   ║── ║<br>C ║   ║── ║───║       ║─  ║── ║───║       ║─  ║   ║───║<br>    1   2   3 <br></code></pre></td></tr></table></figure><ul><li>C원판이 도착했으므로 B원판은 보관 기둥 2에서 도착기둥 3으로 이동한다.</li><li>B원판이 이동하기 위해서는 위에 있는 A원판이 보관 기둥인 1로 이동한다.</li><li>B원판이 도착한다.</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">A ║   ║   ║   ║       ║   ║   ║─  ║<br>B ║   ║   ║── ║  -&gt;   ║   ║   ║── ║<br>C ║─  ║   ║───║       ║   ║   ║───║<br>    1   2   3<br></code></pre></td></tr></table></figure><ul><li>B원판이 도착했으므로 A원판도 도착 기둥인 3으로 이동한다.</li><li>원판이 하나만 남았을 경우에는 보관이 필요 없이 바로 이동할 수 있다.</li></ul><p>이런 구조는 A원판을 제외한 원판마다 출발 -&gt; 경유, 경유 -&gt; 도착 형태의 동일 로직을 사용하고 있음을 보여준다. 또한 각 원판들이 모두 바로 위에 있는 원판의 이동 후에 움직일 수 있다는 규칙도 찾을 수 있다. 이를 로직으로 표현해보자.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">1. C(1 -&gt; 3) --- B(1 -&gt; 2) --- 이동(A(1 -&gt; 3))<br>2.          |             |   이동(B(1 -&gt; 2))<br>3.          |              --- 이동(A(3 -&gt; 2))<br>4.          |    이동(C(1 -&gt; 3))<br>5.           --- B(2 -&gt; 3) --- 이동(A(2 -&gt; 1))<br>6.                        |    이동(B(2 -&gt; 3))<br>7.                         --- 이동(A(1 -&gt; 3))<br></code></pre></td></tr></table></figure><p>결론적으로 하노이 문제에서 핵심은 크게 3가지로 나눠볼 수 있다.</p><ul><li>위에 있는 원판을 보관 기둥으로 옯기자</li><li>그 다음 도착 기둥으로 가자</li><li>워에 있던 원판을 다시 가져오자.</li></ul><p>이제 위 로직을 코드로 작성해보자.</p><h2 id="파이썬-코드">파이썬 코드</h2><p>아래 함수는 원판의 개수와 출발 기둥, 도착 기둥을 인자 값으로 넣어주면 원판들의 이동 과정을 출력한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">hanoi_func</span>(<span class="hljs-params">n, _<span class="hljs-keyword">from</span>, _to</span>):<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(_<span class="hljs-keyword">from</span>)+<span class="hljs-string">&quot; &quot;</span>+<span class="hljs-built_in">str</span>(_to))<br>    <span class="hljs-keyword">else</span>:<br>        hanoi_func(n-<span class="hljs-number">1</span>,_<span class="hljs-keyword">from</span>,<span class="hljs-number">6</span>-(_<span class="hljs-keyword">from</span>+_to))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(_<span class="hljs-keyword">from</span>)+<span class="hljs-string">&quot; &quot;</span>+<span class="hljs-built_in">str</span>(_to))<br>        hanoi_func(n-<span class="hljs-number">1</span>,<span class="hljs-number">6</span>-(_<span class="hljs-keyword">from</span>+_to),_to)<br></code></pre></td></tr></table></figure><p>원판이 1인 경우에는 위에 다른 원판이 없기 때문에 나만 옮겨지면 된다. 그래서 if문으로 예외를 두었다. 나머지의 경우 이전 원판(n-1)을 보관 기둥으로 옮겨주는 과정과 보관 기둥에서 도착 기둥으로 가는 과정을 재귀로 작성하였다. 보관 기둥을 구하는 식은 <code>6-출발기둥-도착기둥</code>인데 그 이유는 간단하다. 기둥이 3개로 한정되어 있고 1+2+3에서 각 기둥을 빼주면 남는 숫자가 보관 기둥이 되기 때문이다.</p><p>위 코드는 이동 순서들을 모두 보여주기 때문에 이해하기는 쉽지만, 원판의 개수가 많아질수록 성능이 떨어질 것이다. 만약 이동 순서가 필요없다면 이동 횟수만 수학식으로 구할 수는 없을까?</p><p>다행히도 있다. 위에서 찾았던 패턴을 바탕으로 일반항을 구할 수 있다. 어떤 원반의 도착할 때까지의 이동 횟수를 구하려면 다음의 과정이 필요하다.</p><ul><li><span class="math inline">\(a_{n-1}\)</span>: 위(n-1)에 있는 원반이 보관 기둥으로 이동하는 것</li><li><span class="math inline">\(+1\)</span>: 해당 원반이 도착 기둥으로 이동하는 것</li><li><span class="math inline">\(a_{n-1}\)</span>: 위(n-1)에 있는 원반이 도착 기둥으로 이동하는 것</li></ul><p>이를 정리하면 아래의 식이 도출된다.</p><p><span class="math display">\[a_n = 2a_{n-1}+1\]</span></p><p>위 수식을 정리해서 일반항을 구해보자.</p><p><span class="math display">\[a_n+1 = 2(a_{n-1}+1) = 2^{n-1}(a_1+1)\]</span> <span class="math display">\[a_1 = 1 이므로\]</span> <span class="math display">\[a_n+1 = 2^{n}\]</span> <span class="math display">\[a_n = 2^{n}-1\]</span></p><p>이를 파이썬 코드로 작성하면 아래와 같다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">hanoi_num_func</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>**n - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>재귀</tag>
      
      <tag>하노이탑</tag>
      
      <tag>recursion</tag>
      
      <tag>recursive</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flask 웹 서버 구축하기</title>
    <link href="/ko/Web/web-5/"/>
    <url>/ko/Web/web-5/</url>
    
    <content type="html"><![CDATA[<p>Flask로 웹 서버를 구축하는 과정에 대해서 정리합니다.</p><span id="more"></span><h3 id="static-ip-setting">Static IP setting</h3><p>관리의 편리함을 위해 서버가 재가동 되어도 동일한 IP를 유지하도록 설정하고자 한다. 현재 사용하고 있는 것은 AWS의 가상 서버이기에 콘솔에서 변경해보자.</p><figure><img src="/images/154.png" alt="server" /><figcaption aria-hidden="true">server</figcaption></figure><p>lightsail 콘솔에 들어가면 네트워킹이라는 섹션이 있다. 이를 클릭하면 위 사진과 같이 "고정 IP 생성"이라는 버튼을 찾을 수 있다.</p><figure><img src="/images/155.png" alt="server" /><figcaption aria-hidden="true">server</figcaption></figure><p>"고정 IP 생성"을 클릭하면 위 사진과 같이 고정 IP를 내가 보유하고 있는 인스턴스에 설정할 수 있다. 나의 경우 이미 붙여놓은 상태라서 연결에 사용할 인스턴스가 없다고 보여진다. 인스턴스 선택하고 해당 IP의 이름을 붙여준 뒤 생성 버튼을 누르면 설정은 끝난다.</p><h3 id="firewall-setting">Firewall setting</h3><p>그 다음으로는 웹 서버가 사용할 포트를 오픈해야 한다. AWS lightsail의 경우 기본적으로 Http와 Https 포트는 개방되어 있다. 사용하고자 하는 포트를 추가하려면 "규칙 추가"를 눌러 포트를 추가해준다.</p><figure><img src="/images/156.png" alt="server" /><figcaption aria-hidden="true">server</figcaption></figure><h3 id="python-setting">Python setting</h3><p>이 프로젝트에서 사용하는 프레임워크는 플라스크(Flask)이다. 파이썬 기반의 환경을 셋팅해보자.</p><p>먼저 파이썬 버전을 확인한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; python3 --version<br></code></pre></td></tr></table></figure><p>python3이 설치되어 있다면 다음으로 파이썬 패키지 매니저인 pip를 설치한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 패키지 업데이트</span><br>&gt; <span class="hljs-built_in">sudo</span> apt update<br><span class="hljs-comment"># pip 설치</span><br>&gt; <span class="hljs-built_in">sudo</span> apt-get install python3-pip<br></code></pre></td></tr></table></figure><h2 id="flask-웹-서버-구동하기">Flask 웹 서버 구동하기</h2><p>다음으로는 웹 서버를 구동해보자. 이를 위해 해당 서버에 소스 파일을 가져온다. 나의 경우 로컬에 있는 소스들을 tar로 묶은 다음 scp로 복사했다. 이제 웹 서버를 올리기 위해 필요한 패키지들을 설치한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 파이썬 컴파일러 업데이트</span><br>pip3 install --upgrade cython<br><span class="hljs-comment"># 필요한 라이브러리 설치</span><br>pip3 install -r requirement.txt<br></code></pre></td></tr></table></figure><p>소스 파일 <code>requirement.txt</code>에는 해당 웹 서버 구동에 필요한 라이브러리들이 정리되어 있다. 이를 위 코드처럼 한번에 설치할 수 있다. <code>requirement.txt</code>의 내용은 아래와 같다.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text"># requirement.txt list<br>flask<br>sqlalchemy<br>pandas<br>plotly<br>dash<br>dash_bootstrap_components==0.13<br>pymysql<br>pyarrow==0.16.0<br>dominate<br>visitor<br></code></pre></td></tr></table></figure><p>설치가 완료되었다면 아래의 명령어로 웹 서버를 실행한 후, 접속해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> python3 __init__.py run<br></code></pre></td></tr></table></figure><p>정상적으로 접속이 된다면 이제 백그라운드에서 웹 서버를 구동시키면 된다. 웹 서버를 구동시키는 방법은 아래와 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nohup</span> <span class="hljs-built_in">sudo</span> python3 -u __init__.py run &amp;<br></code></pre></td></tr></table></figure><p>nohup을 사용하여 구동하면 웹 서버에 로그가 nohup.out에 작성된다.</p>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>aws</tag>
      
      <tag>lightsail</tag>
      
      <tag>KBO</tag>
      
      <tag>analysis</tag>
      
      <tag>flask</tag>
      
      <tag>플라스크</tag>
      
      <tag>Web-server</tag>
      
      <tag>대시보드</tag>
      
      <tag>dashbooard</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 카테고리 404 에러</title>
    <link href="/ko/AboutHexo/about-hexo-4/"/>
    <url>/ko/AboutHexo/about-hexo-4/</url>
    
    <content type="html"><![CDATA[<p>Hexo에서 카테고리의 이름을 변경했을 때 404 에러가 발생하는 경우의 해결 방법을 정리합니다.</p><span id="more"></span><hr /><h2 id="에러-발생">에러 발생</h2><p>카테고리의 이름을 대소문자 변경을 하거나 띄어쓰기 변경을 하는 경우, 로컬 서버에서는 정상적으로 작동하지만 배포 후에는 404가 에러가 발생한다.</p><h2 id="에러-원인">에러 원인</h2><p>Git에서는 대소문자 등을 구분하지 않지만 자바스크립트 언어는 이를 구분한다. 따라서 이름을 변경 후 배포하면 Git에서는 카테고리 이름을 업데이트 하지 않는 반면 hexo에서는 변경된 Path로 웹이 작동한다.</p><h2 id="해결-방법">해결 방법</h2><p>먼저 블로그 레파지토리에서 <code>.deploy_git/.git/</code> 으로 이동한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> .deploy_git/.git/<br></code></pre></td></tr></table></figure><p>그 다음 <code>config</code> 파일을 오픈하여 아래의 내용을 수정한 후 저장한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#ignorecase=true</span><br>ignorecase=<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>그 후, <code>.deploy_git</code> 폴더를 비우고 Git에 push 한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">rm</span> -rf *<br>git commit -m <span class="hljs-string">&#x27;clear all files&#x27;</span><br>git push<br></code></pre></td></tr></table></figure><p>마지막으로 로컬 레파지토리에 있는 내용을 재배포 한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo generate<br>hexo deploy<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>etc.</category>
      
      <category>about hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>blog</tag>
      
      <tag>헥소</tag>
      
      <tag>깃허브</tag>
      
      <tag>블로그</tag>
      
      <tag>카테고리</tag>
      
      <tag>category</tag>
      
      <tag>404에러</tag>
      
      <tag>에러</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>robots.txt 확인</title>
    <link href="/ko/Web/web-4/"/>
    <url>/ko/Web/web-4/</url>
    
    <content type="html"><![CDATA[<p>웹사이트에서 데이터를 스크래핑할 때 robots.txt를 확인해야 하는 이유에 대해서 정리합니다.</p><span id="more"></span><h2 id="web-scraping">Web Scraping</h2><p>스크래핑(scraping)은 말 그대로 다양한 매체에 있는 데이터를 모으는 행위를 의미한다. 흔히 신문이나 잡지 등을 "스크랩한다"라는 표현을 사용하는데 웹 스크래핑 또한 동일한 범주이다. 즉, 웹 스크래핑이란 웹 기반 프로그램에서 데이터들을 가져와 모으는 방법들을 통칭한다.</p><p>스크래핑을 통해 다른 웹사이트에 제공된 데이터를 가져가서 사용하는 것은 어떨까? 대부분은 스크래핑 자체가 사용자들의 브라우저에 보여지는 데이터를 가져와 사용하는 것이기에 당연히 불법이 아니라고 생각한다. 우리가 신문을 스크랩하는 행위가 불법은 아니니 말이다. 맞다. 웹 스크랩핑 행위 자체는 문제가 되지 않는다. 하지만 그 행위가 초래하는 결과가 상업적인 피해를 주는 경우에는 당연히 법적인 문제가 될 수 있다.</p><h3 id="트래픽-문제">트래픽 문제</h3><p>스크래핑은 사실 서버 입장에서는 사용자와 동일하다. 그렇기에 스크래핑이 제한없이 이루어지면 서버 트래픽이 과도하게 증가되고 이는 서비스 운영 자체에 문제를 일으킬 수 있다. 그렇기에 사용자가 많은 사이트들은 스크래핑 봇들의 트래픽을 제한하고자 IP를 차단하거나 트래픽 수를 제한하는 방식으로 운영되고 있다.</p><h3 id="데이터-무단사용">데이터 무단사용</h3><blockquote><p><em>"데이터는 돈이다"</em></p></blockquote><p>데이터 분야에서 일하면서 마음속에 새겨진 말이다. 실제로 현 사회는 데이터를 기반으로 많은 의사결정이 진행되며, 또 이를 위해 더 좋은 더 많은 데이터를 얻기 위해 노력한다. 즉, 사용자에게 보여지는 데이터라고 해서 마음대로 가져가 사용하라는 의미는 아닌 경우가 태반이다.</p><p>그래서 위와 같은 문제들로 스크래핑 방식에도 어떤 규약이 필요했다. 그렇게 등장한 것이 <code>robots.txt</code>이다.</p><h2 id="robots.txt">robots.txt</h2><p><code>robots.txt</code>는 웹 사이트를 스크래핑할 수 있게 허용하거나 제한하는 내용을 담은 웹 페이지이다. 물론 <code>robots.txt</code>에 작성되었다고 해서 기술적으로 수집이 불가한 것은 아니지만 대부분의 웹 스크래핑 로봇들은 해당 페이지를 먼저 확인하고 허용된 페이지만을 수집한다. 따라서 스크래핑 작업을 진행할 때는 <code>robots.txt</code>를 먼저 확인하는 것이 좋다.</p><h3 id="확인-방법">확인 방법</h3><p>기본적으로 <code>robots.txt</code>는 웹페이지 도메인 뒤에 바로 붙어서 올라와야 한다. 따라서 개발자 입장에서는 웹 구축 당시에 최상위 디렉토리에 <code>robots.txt</code>를 작성하여 같이 올리면 된다.</p><p>예시: <code>https://www.koreabaseball.com/robots.txt</code></p><p>위 예시는 KBO 공식 사이트의 <code>robots.txt</code> 페이지이다. 해당 URL로 접속하면 아래와 같이 <code>robots.txt</code>의 내용을 확인할 수 있다.</p><figure><img src="/images/151.png" alt="robots" /><figcaption aria-hidden="true">robots</figcaption></figure><h3 id="작성-규칙">작성 규칙</h3><p><code>robots.txt</code>의 존재 여부에 따른 내용은 다음과 같다.</p><ul><li>페이지가 없는 경우: 스크래핑 허용</li><li>페이지가 공백인 경우: 스크래핑 허용</li></ul><p>페이지가 존재하지 않거나 페이지에 아무것도 쓰여있지 않다면 해당 도메인의 모든 하위 페이지들을 스크래핑해도 된다는 의미로 해석된다.</p><p>패이지가 있는 경우, 페이지 구조는 다음과 같다.</p><ul><li>User-agent: 검색 봇 이름 작성</li><li>Disallow: 허용되지 않은 페이지</li><li>Allow: 허용된 페이지</li></ul><p><code>robots.txt</code>에 대해 자세히 알고 싶다면 <a href="https://developers.google.com/search/docs/advanced/robots/create-robots-txt?hl=ko">해당 페이지</a>를 참고하면 된다.</p><p>마지막으로 위에서 봤던 KBO 사이트의 <code>robots.txt</code>를 한번 분석해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">User-agent: *<br>Disallow: /Common/<br>Disallow: /Help/<br>Disallow: /Member/<br>Disallow: /ws/<br></code></pre></td></tr></table></figure><p>먼저 모든 스크래핑 봇들을 대상으로 <code>/Common/</code>,<code>/Help/</code>,<code>/Member/</code>,<code>/ws/</code> 디렉토리의 스크래핑을 제한하고 있다. 즉, KBO 사이트를 스크래핑할 때 사용하는 URL에 위 디렉토리가 들어가 있으면 안된다는 의미이다.</p><h2 id="결론">결론</h2><p>이 글의 결론은 간단하다.</p><blockquote><p>스크래핑을 하기전에 무조건 해당 사이트에 <code>robots.txt</code>를 확인하고 그 내용을 준수하자</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data</tag>
      
      <tag>스크래핑</tag>
      
      <tag>scraping</tag>
      
      <tag>robots</tag>
      
      <tag>웹스크래핑</tag>
      
      <tag>webscraping</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Poetry로 패키지 관리</title>
    <link href="/ko/Package/pack-1/"/>
    <url>/ko/Package/pack-1/</url>
    
    <content type="html"><![CDATA[<p>Python에서 Poetry로 패키지를 관리하는 방법을 정리합니다.</p><span id="more"></span><h2 id="poetry">Poetry</h2><p>Poetry는 파이썬 패키지 및 의존성을 관리해주는 도구이다.</p><h2 id="poetry-설치">Poetry 설치</h2><p>Poetry 설치는 <a href="https://python-poetry.org/docs/#installation">공식 홈페이지</a>에 설명되어 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># osx / linux / bashonwindows install instructions</span><br>curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python<br><br><span class="hljs-comment"># windows powershell install instructions</span><br>(Invoke-WebRequest -Uri https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py -UseBasicParsing).Content | python<br></code></pre></td></tr></table></figure><h2 id="새-프로젝트-생성">새 프로젝트 생성</h2><p>이제 본격적으로 프로젝트를 진행해보자. 먼저 아래의 명령어로 패키지 디렉토리 구조를 생성한다. 여기서는 <code>tests</code>라는 이름의 패키지를 생성한다고 가정한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">poetry new tests<br></code></pre></td></tr></table></figure><p>그러면 아래와 같은 구조의 디렉토리가 생성된다.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">total 8<br>drwxr-xr-x@  6 ryu  staff   192  3  7 23:46 .<br>drwx------@ 46 ryu  staff  1472  3  7 23:46 ..<br>-rw-r--r--   1 ryu  staff     0  3  7 23:46 README.rst<br>-rw-r--r--   1 ryu  staff   295  3  7 23:46 pyproject.toml<br>drwxr-xr-x@  3 ryu  staff    96  3  7 23:46 test<br>drwxr-xr-x@  4 ryu  staff   128  3  7 23:46 tests<br></code></pre></td></tr></table></figure><p>그 다음 패키지 형상 관리를 위해서 Github을 사용하고자 한다. 그래서 해당 패키지의 레파지토리를 만들고 Git 주소를 연동해준다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 패키지 레파지토리로 이동 후 Git 초기화</span><br>git init<br><span class="hljs-comment"># 리모트 서버 추가</span><br>git remote add origin &#123;깃허브 URL&#125;<br><span class="hljs-comment"># 커밋 추가</span><br>git commit -m <span class="hljs-string">&quot;update&quot;</span><br><span class="hljs-comment"># 배포</span><br>git push origin main<br></code></pre></td></tr></table></figure><p>이렇게 하면 패키지 작성 및 관리를 위한 준비가 끝났다.</p><h2 id="pyproject.toml-작성">pyproject.toml 작성</h2><p>처음 생성된 <code>pyproject.toml</code> 파일에는 필수로 작성해야 하는 내용들이 포함되어 있으며, 그 양식은 아래와 같다.</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[tool.poetry]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;kbodata&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">description</span> = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-attr">authors</span> = [<span class="hljs-string">&quot;Hyeonji-Ryu &lt;dev.bearabbit@gmail.com&gt;&quot;</span>]<br><br><span class="hljs-section">[tool.poetry.dependencies]</span><br><span class="hljs-attr">python</span> = <span class="hljs-string">&quot;^3.7&quot;</span><br><br><span class="hljs-section">[tool.poetry.dev-dependencies]</span><br><span class="hljs-attr">pytest</span> = <span class="hljs-string">&quot;^5.2&quot;</span><br><br><span class="hljs-section">[build-system]</span><br><span class="hljs-attr">requires</span> = [<span class="hljs-string">&quot;poetry-core&gt;=1.0.0&quot;</span>]<br><span class="hljs-attr">build-backend</span> = <span class="hljs-string">&quot;poetry.core.masonry.api&quot;</span><br></code></pre></td></tr></table></figure><p>이제 기본으로 생성된 데이터에서 패키지 필요조건에 맞게 수정하면 된다. 수정해야 할 부분은 크게 2가지이다.</p><table><thead><tr class="header"><th>부분</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>tool.poetry</td><td>패키지에 대한 기본 정보를 작성헌다. 기존 setup.py에 작성하던 라이센스, 관리자 정보, 레포 정보 등을 압력하면 된다.</td></tr><tr class="even"><td>tool.poetry.dependencies</td><td>해당 패키지가 의존하고 있는 다른 라이브러리들을 정리한다. 기존 requirement.txt와 동일하다.</td></tr></tbody></table><p>그렇게 패키징에 필요한 내용들을 추가한 <code>pyproject.toml</code>은 아래와 같다.</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[tool.poetry]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;kbodata&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">description</span> = <span class="hljs-string">&quot;Scraping Korea Baseball Game information&quot;</span><br><span class="hljs-attr">authors</span> = [<span class="hljs-string">&quot;Hyeonji-Ryu &lt;dev.bearabbit@gmail.com&gt;&quot;</span>]<br><span class="hljs-attr">license</span> = <span class="hljs-string">&quot;MIT&quot;</span><br><span class="hljs-attr">readme</span> = <span class="hljs-string">&quot;README.md&quot;</span><br><span class="hljs-attr">repository</span> = <span class="hljs-string">&quot;https://github.com/Hyeonji-Ryu/kbo-data&quot;</span><br><span class="hljs-attr">documentation</span> = <span class="hljs-string">&quot;https://github.com/Hyeonji-Ryu/kbo-data/tree/main/docs&quot;</span><br><br><span class="hljs-comment"># Requirements</span><br><span class="hljs-section">[tool.poetry.dependencies]</span><br><span class="hljs-attr">python</span> = <span class="hljs-string">&quot;^3.7.1&quot;</span><br><span class="hljs-attr">selenium</span> = <span class="hljs-string">&quot;^3.141.0&quot;</span><br><span class="hljs-attr">pandas</span> = <span class="hljs-string">&quot;^1.2.2&quot;</span><br><span class="hljs-attr">bs4</span> = <span class="hljs-string">&quot;^0.0.1&quot;</span><br><span class="hljs-attr">lxml</span> = <span class="hljs-string">&quot;^4.6.2&quot;</span><br><span class="hljs-attr">requests</span> = <span class="hljs-string">&quot;^2.25.1&quot;</span><br><br><span class="hljs-section">[tool.poetry.dev-dependencies]</span><br><span class="hljs-attr">pytest</span> = <span class="hljs-string">&quot;^5.2&quot;</span><br><br><span class="hljs-section">[build-system]</span><br><span class="hljs-attr">requires</span> = [<span class="hljs-string">&quot;poetry-core&gt;=1.0.0&quot;</span>]<br><span class="hljs-attr">build-backend</span> = <span class="hljs-string">&quot;poetry.core.masonry.api&quot;</span><br></code></pre></td></tr></table></figure><h2 id="pypi에-업로드">PyPi에 업로드</h2><p>PyPi에 업로드하기 위해서는 해당 사이트의 아이디와 비밀번호가 필요하다. 따라서 회원가입이 되어 있지 않다면 <a href="https://pypi.org">pypi.org</a>에 가서 계정을 생성해야 한다.</p><p>그 다음 패키지로 올리는 프로젝트 디렉토리로 가서 아래의 코드를 입력한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">poetry publish --build<br></code></pre></td></tr></table></figure><p>그러면 PyPi 홈페이지의 아이디와 비밀번호를 입력하라고 한다. 이를 입력하고 나면 poetry는 내부의 소스코드를 확인하고 문제가 있는 부분에 대한 에러를 프린트 하거나 정상적으로 패키지를 업로드 해준다.</p><figure><img src="/images/153.png" alt="kbodata" /><figcaption aria-hidden="true">kbodata</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>package</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>package</tag>
      
      <tag>pypi</tag>
      
      <tag>패키지</tag>
      
      <tag>poetry</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KBO-data 패키지</title>
    <link href="/ko/Package/pack-0/"/>
    <url>/ko/Package/pack-0/</url>
    
    <content type="html"><![CDATA[<p>이 글은 한국프로야구(Korea Baseball Organization) 웹사이트에서 데이터를 스크래핑하는 패키지 만드는 과정을 정리합니다.</p><span id="more"></span><h2 id="시작하며">시작하며</h2><p>이 프로젝트의 목표는 크게 2가지아다.</p><ul><li>KBO 데이터를 가져오는 패키지 생성</li><li>파이썬 패키지를 생성하는 방법 공부</li></ul><p>해당 시리즈는 작업 중에 필요한 정보들을 정리할 예정이다.</p><h2 id="kbo-data">KBO-data</h2><p>KBO-data는 KBO 공식 사이트에서 경기 정보들을 스크래핑하는 패키지이다. 해당 패키지는 <a href="https://www.koreabaseball.com/Default.aspx">KBO 공식 사이트</a>에 있는 데이터들을 가져와 사용하기 편한 구조로 변형해준다. 패키지에 대한 자세한 설명은 <a href="https://github.com/Hyeonji-Ryu/kbo-data">깃허브</a>의 README에서 확인할 수 있다.</p><p>먼저 패키지를 사용하기 위해서는 설치를 해주어야 한다. 아래의 코드로 설치를 진행하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install kbodata<br></code></pre></td></tr></table></figure><p>설치 후 파이썬 환경에서 임포트 하면 바로 사용할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> kbodata<br></code></pre></td></tr></table></figure><p>패키지는 크게 3가지로 나누어진다.</p><h3 id="경기-스케쥴-가져오기">1. 경기 스케쥴 가져오기</h3><p>먼저 요청한 날짜에 맞춰서 스케쥴을 가져와야 한다. 스케쥴은 특정 날짜, 특정 월, 특정 년도를 선택하여 받을 수 있디. 스케쥴을 가져오는 함수는 아래와 같다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 2021년 4월 20일의 KBO 경기 스케쥴을 가져온다.</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>day = kbodata.get_daily_schedule(<span class="hljs-number">2021</span>,<span class="hljs-number">4</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&#x27;chromedriver_path&#x27;</span>)<br><br><span class="hljs-comment"># 2021년 4월 KBO 경기 스케쥴을 가져온다.</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>month = kbodata.get_monthly_schedule(<span class="hljs-number">2021</span>,<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;chromedriver_path&#x27;</span>)<br><br><span class="hljs-comment"># 2021년 KBO 경기 스케쥴을 가져온다.</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>year = kbodata.get_yearly_schedule(<span class="hljs-number">2021</span>,<span class="hljs-string">&#x27;chromedriver_path&#x27;</span>)<br></code></pre></td></tr></table></figure><p>이렇게 스케쥴을 받으면 Pandas의 DataFrame 형태로 결과가 반환된다. 결과는 아래와 같다.</p><figure><img src="/images/150.png" alt="KBO" /><figcaption aria-hidden="true">KBO</figcaption></figure><h3 id="경기-자료-가져오기">2. 경기 자료 가져오기</h3><p>경기 결과를 받는 함수는 스케쥴 데이터에 있는 날짜와 게임 ID를 바탕으로 경기 결과들을 가져오기 때문에 스케쥴 데이터가 필요하다. 따라서 원하는 기간의 스케쥴들을 먼저 가져와야 한다. 그다음 아래의 함수를 사용하여 경기 데이터를 가져온다. 경기 데이터는 크게 스코어보드, 경기 정보, 타자 정보, 투수 정보를 가져온다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 2021년 4월 20일의 KBO 경기 정보를 가져온다.</span><br>day_data = kbodata.get_game_data(day,<span class="hljs-string">&#x27;chromedriver_path&#x27;</span>)<br><br><span class="hljs-comment"># 2021년 4월 KBO 경기 정보를 가져온다.</span><br>month_data = kbodata.get_game_data(month,<span class="hljs-string">&#x27;chromedriver_path&#x27;</span>)<br><br><span class="hljs-comment"># 2021년 KBO 경기 정보를 가져온다.</span><br>year_data = kbodata.get_game_data(year,<span class="hljs-string">&#x27;chromedriver_path&#x27;</span>)<br></code></pre></td></tr></table></figure><p>경기 정보를 가져오면 아래 구조의 JSON 형태로 반환된다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123; <span class="hljs-built_in">id</span>: date_gameid,<br>contents: &#123;<br>  <span class="hljs-string">&#x27;scoreboard&#x27;</span>: []<br>  <span class="hljs-string">&#x27;ETC_info&#x27;</span>: &#123;&#125;<br>  <span class="hljs-string">&#x27;away_batter&#x27;</span>: []<br>  <span class="hljs-string">&#x27;home_batter&#x27;</span>: []<br>  <span class="hljs-string">&#x27;away_pitcher&#x27;</span>: []<br>  <span class="hljs-string">&#x27;home_pitcher&#x27;</span>: []<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="경기-데이터-타입-변형하기">3. 경기 데이터 타입 변형하기</h3><p>가져온 경기 자료는 복잡한 구조로 구성되어 있다. 따라서 좀 더 사용하기 편한 형태로 변환하는 함수를 구현했다. 변환하는 함수는 스코어보드, 타자, 투수 자료 총 3개로 정리하며, 변환하는 파일 포맷은 아래와 같다.</p><ul><li>DataFrame</li><li>Dict</li></ul><p>또한 각각 함수의 사용법은 다음과 같다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 팀 경기 정보만을 정리하여 DataFrame으로 변환한다.</span><br>scoreboard = kbodata.scoreboard_to_DataFrame(day_data)<br><span class="hljs-comment"># 타자 정보만을 정리하여 DataFrame으로 변환한다.</span><br>batter = kbodata.batter_to_DataFrame(day_data)<br><span class="hljs-comment"># 투수 정보만을 정리하여 DataFrame으로 변환한다.</span><br>pitcher = kbodata.pitcher_to_DataFrame(day_data)<br><br><span class="hljs-comment"># 팀 경기 정보만을 정리하여 Dict으로 변환한다.</span><br>scoreboard = kbodata.scoreboard_to_Dict(day_data)<br><span class="hljs-comment"># 타자 정보만을 정리하여 Dict으로 변환한다.</span><br>batter = kbodata.batter_to_Dict(day_data)<br><span class="hljs-comment"># 투수 정보만을 정리하여 Dict으로 변환한다.</span><br>pitcher = kbodata.pitcher_to_Dict(day_data)<br></code></pre></td></tr></table></figure><h2 id="패키지-작업">패키지 작업</h2><p>이 프로젝트에서는 KBO 데이터를 스크래핑하는 패키지를 만들어 파이썬 패키지 사이트인 <a href="https://pypi.org">PyPI</a>에 업로드할 예정이다. PyPI에 업로드된 패키지는 python 패키지 관리 시스템인 Pip로 바로 다운받을 수 있다. 좀 더 편리한 패키지 작업을 위해서 Poetry를 사용하여 진행할 예정이다. Poetry에 대한 자세한 내용은 <a href="https://python-poetry.org">이 사이트</a>에서 확인할 수 있다. 가능하다면 Poetry에 대한 글도 작성할 예정이다.</p>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>package</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>data</tag>
      
      <tag>KBO</tag>
      
      <tag>package</tag>
      
      <tag>pypi</tag>
      
      <tag>패키지</tag>
      
      <tag>한국프로야구</tag>
      
      <tag>야구데이터</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hive 아키텍쳐</title>
    <link href="/ko/Hadoop/hadoop-9/"/>
    <url>/ko/Hadoop/hadoop-9/</url>
    
    <content type="html"><![CDATA[<p>하둡 에코시스템 중 하나인 Hive의 아키텍처에 대해서 공부한 내용을 정리합니다. <span id="more"></span></p><p>지금까지 HDFS, YARN이라는 하둡의 코어 서비스들을 살펴보았다. 사실 두 서비스만 사용해도 하둡 플랫폼을 사용할 수는 있다. 하지만 <a href="https://dev-bearabbit.github.io/2021/11/21/Hadoop/hadoop-0/">이전 글</a>에서 말했듯이 사용자의 다양성과 편의를 위해서 많은 에코 시스템들이 등장하였으며, 그 중 대표적인 서비스 중 하나가 바로 하이브(Hive)이다.</p><h2 id="hive">Hive</h2><p>하이브(hive)는 Hadoop용 RDB 서비스이다. HDFS를 사용함에 있어 데이터베이스나 테이블 개념으로 디렉토리를 구성하고 관리하며, 이를 바탕으로 SQL과 유사한 HiveQL이라는 문법을 지원한다. 즉, 자바로 맵리듀스 프로그램을 작성하는 것이 아니라 간단한 sql 문법만으로도 Hadoop에 데이터를 저장하거나 가져올 수 있다. 이렇게만 보면 사용방법은 mysql과 같은 RDB와 매우 유사해보인다. 하지만 스키마를 정의하고 데이터를 입력하는 구조는 기존 RDB와는 다르다. 스키마를 먼저 작성하고 그 다음 데이터를 입력해야 하는 기존 RDB와 달리 하이브는 데이터를 HDFS에 파일단위로 저장한 후에 스키마를 정의하여 데이터를 가져올 수 있다. 하이브는 RDB에 요구되는 스키마 정보들을 metastore에 저장하며, metastore는 다른 DBMS를 사용한다.</p><h2 id="hive-roles">Hive Roles</h2><p>하이브를 구성하고 있는 컴포넌트는 아래 시진과 같다.</p><figure><img src="/images/146.png" alt="hive1" /><figcaption aria-hidden="true">hive1</figcaption></figure><p>하이브는 크게 metastore 관리, SQL 쿼리 실행의 업무로 나눠지며 이에 따라 컴포넌트들도 분리된다. HiveServer2(HS2)의 경우 하이브 서비스에 대한 모든 클라이언트들의 요청을 받으며, metastore 서버는 HS2에서 요청하는 메타정보들을 API로 제공한다.</p><h2 id="hive-architecture">Hive Architecture</h2><p>하이브 아키텍처는 매우 간단하다.</p><figure><img src="/images/147.png" alt="hive2" /><figcaption aria-hidden="true">hive2</figcaption></figure><p>하이브에 접근할 수 있는 방법은 Beeline, Hue, JDBC or ODBC 크게 3가지이다. 여기서 Beeline이란 노드 터미널에서 HS2에 바로 접속할 수 있는 방법이며 Beeline을 사용하면 터미널에서 직접 하이브로 쿼리를 날릴 수 있다. 다음 방법인 Hue는 apache의 오픈소스 서비스 중 하나로 하둡 에코 시스템들을 통합 사용할 수 있는 에디터이다. 마지막으로 JDBC or ODBC는 하둡을 DB로 사용하거나 데이터 IO가 있는 어플리케이션들과 연동할 때 보통 사용되는 방법이다.</p><p><strong>NOTE</strong> JDBC or ODBC 란?<br />특정 언어로 구현된 어플리케이션들이 데이터베이스에 접속할 때 두 언어를 변역해주는 인터페이스의 역할을 한다.</p><table><thead><tr class="header"><th>용어</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>JDBC(Java DataBase Connectivity)</td><td>JAVA 기반 앱들에서만 사용가능한 API</td></tr><tr class="even"><td>ODBC(Open DataBase Connectivity)</td><td>특정 언어와 상관없이 독립적으로 사용가능한 API</td></tr></tbody></table><h2 id="hive-process">Hive Process</h2><p>다음으로는 하이브가 작동되는 과정에 대해서 살펴보고자 한다.</p><figure><img src="/images/148.png" alt="hive3" /><figcaption aria-hidden="true">hive3</figcaption></figure><p>간단하게 생각해보면 하이브는 SQL 쿼리를 받아서 맵리듀스 코드로 변환한 뒤 실행 엔진을 통해 작업을 진행한다. 이 과정들을 진행하기 위해서는 위 사진과 같은 과정들이 새부적으로 진행된다. 이를 정리하면 아래와 같다.</p><ol type="1"><li>인터페이스 단에서 SQL 쿼리를 받은 후 드라이버에게 전달한다. (Hive Thrift)</li><li>드라이버는 컴파일러에게 SQL 쿼리 컴파일을 요청한다.</li><li>컴파일러는 Metastore 정보를 사용하여 쿼리에 필요한 데이터들을 가져오는 맵리듀스 프로그램을 작성한 후 드라이버에게 전달한다.</li><li>드라이버는 실행 엔진에게 해당 작업을 전달한다.</li><li>실행 엔진은 YARN에게 작업을 요청하여 작업을 진행한 후 그 결과를 가져온다.</li><li>드라이버는 해당 결과를 인터페이스 단으로 다시 송부한다.</li></ol><p>이런 아키텍처를 이해하고 있다면 차후 플랫폼을 사용하다가 발생하는 문제들에 대한 원인을 파악하는 데 도움이 된다. 예를 들어 Hue에서 쿼리를 날렸는데 문제가 발생했다면 HS2와의 세션에서 문제가 생긴 것인지, HS2 내부에서 진행되는 컴파일에서 문제가 생긴 것인지, YARN에서 작업이 돌다가 문제가 생긴 것인지 등을 파악할 수 있다.</p><h2 id="tez-engine">Tez engine</h2><p>초기 Hive는 기본 실행 엔진으로 맵리듀스를 사용하였지만 Hive 3.0부터는 테즈(Tez)를 기본 실행 엔진으로 사용한다. 실행 엔진에 대해서는 따로 글을 작성할 예정이라서 간단하게만 짚고 넘어가보자. 먼저 맵리듀스 엔진과 테즈 엔진의 차이는 다음 사진에 잘 나타나 있다.</p><figure><img src="/images/149.png" alt="hive4" /><figcaption aria-hidden="true">hive4</figcaption></figure><p>엔진에 대한 자세한 비교는 다음에 자세히 논의해보고자 한다.</p>]]></content>
    
    
    <categories>
      
      <category>BigData</category>
      
      <category>hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hive</tag>
      
      <tag>빅데이터</tag>
      
      <tag>hadoop</tag>
      
      <tag>ecosystem</tag>
      
      <tag>SQL</tag>
      
      <tag>Tez</tag>
      
      <tag>mapreduce</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>YARN 아키텍쳐</title>
    <link href="/ko/Hadoop/hadoop-8/"/>
    <url>/ko/Hadoop/hadoop-8/</url>
    
    <content type="html"><![CDATA[<p>하둡의 코어 서비스 중 하나인 YARN의 아키텍처에 대해서 공부한 내용을 정리합니다. <span id="more"></span></p><h2 id="core-hadoop">Core Hadoop</h2><p><a href="https://dev-bearabbit.github.io/2021/12/01/Hadoop/hadoop-1/">이전 글</a>에서 살펴봤듯이 YARN은 하둡의 두 기둥 중 하나이다.</p><figure><img src="/images/123.png" alt="corehadoop" /><figcaption aria-hidden="true">corehadoop</figcaption></figure><p>이번 글에서는 클러스터의 리소스를 관리 및 할당하는 YARN에 대해서 자세히 살펴볼 것이다.</p><h2 id="yarn">YARN</h2><p>YARN은 Yet Another Resource Negotiator의 줄임말로, 클러스터 내 서버들의 CPU와 메모리, 네트워크 등 시스템 리소스를 하나로 묶어 관리한다. YARN에서 자원을 할당하는 단위를 <code>컨테이너</code>라고 하며, YARN은 자원 할당 요청이 들어오면 자원을 제공하고 사용이 끝나면 회수한다.</p><p>그렇다면 컨테이너에서는 어떤 일이 진행될까? 아래의 사진을 살펴보자.</p><figure><img src="/images/141.png" alt="Yarn" /><figcaption aria-hidden="true">Yarn</figcaption></figure><p>위 사진은 Hadoop에서 기본적으로 사용하는 MapReduce 이며, YARN 컨테이너에서 작동할 수 있는 엔진 중 하나이다. 여기서 말하는 엔진이란 HDFS에 저장되어 있는 데이터들을 분산 컴퓨팅하여 결과를 도출하는 방법론이며, 결국 엔진 또한 하나의 실행 프로그램이다. 즉, YARN에서 프로그램을 돌릴 수 있는 환경을 제공받고 그 환경 내에서 MapReduce라는 프로그램을 작동하는 것이다. 현재는 MapReduce 엔진 외에도 Tez, Spark 도 사용되고 있다. 엔진에 대해서는 차후 다른 글에서 자세히 설명하고자 한다.</p><h2 id="yarn-roles">YARN Roles</h2><p>YARN은 크게 마스터-워커 구조로 이루어져 있다. 바로 Resource Manager와 Node Manager이다. 이름에서 유추할 수 있듯이 Resource Manager(RM)는 클러스터의 모든 리소스들을 관리하며, Node Manager(NM)는 각 노드에서 RM에게 지속적으로 노드 자원의 상태를 전달하고 실제 리소스들을 사용하여 컨테이너를 제공한다.</p><figure><img src="/images/142.png" alt="Yarn" /><figcaption aria-hidden="true">Yarn</figcaption></figure><p>위 사진에는 각 역할의 컴포넌트 설명이 자세하지는 않아서 덧붙여 이야기하고자 한다. 먼저 Resource Manager의 컴포넌트는 크게 Scheduler와 Application(App) Manager로 구성되어 있으며, 각각의 역할은 아래와 같다.</p><ul><li>Scheduler: Node Manager로부터 현재 리소스 사용률 등을 파악하여 자원 할당 요청이 들어오면 가능한 자원들의 리스트를 제공한다.</li><li>App Manager: 클라이언트로부터 작업 요청을 받아 Node Manager에 App master를 실행시키고 모든 App master의 상태를 관리한다.</li></ul><p>다음으로는 Node Manager의 컴포넌트에 대한 설명이다.</p><ul><li>App master: 특정 작업(Job)을 진행하는 관리자. 작업을 위한 Task들을 NM에 요청하여 실행 및 관리한다.</li><li>Task: 실제 작업이 진행되는 컨테이너. NM에 의해 생성되며 App master를 통해 관리된다.</li></ul><h2 id="yarn-process">YARN Process</h2><p>이제 YARN에서 작업(Job)을 수행할 때 어떤 프로세스로 작동되는지 자세히 살펴보자. 아래의 그림에는 어떤 클라이언트가 작업을 요청했을 시에 진행되는 과정들을 도식화 되어 있다.</p><figure><img src="/images/143.png" alt="Yarn" /><figcaption aria-hidden="true">Yarn</figcaption></figure><p>위 도식을 더 자세히 설명하면, App Manager는 NM에 App master 생성을 요청하는 것이고, App master를 직접 생성하는 건 NM이다. 또한 Scheduler는 App master의 요청에 따라 현재 사용가능한 NM 컨테이너들의 리스트를 제공하며, App master는 해당 리스트에 속한 NM에게 Task 컨테이너 생성을 요청한다.</p><h2 id="fault-tolerance">Fault tolerance</h2><p>YARN은 비교적 내결함성이 잘 보장되어 있다. 아래 그림의 Case들을 살펴보자.</p><figure><img src="/images/144.png" alt="Yarn" /><figcaption aria-hidden="true">Yarn</figcaption></figure><p>Case 1,2,3처럼 NM이 죽은 경우에는 대부분 운영 상에 문제가 발생하지는 않는다. 물론 NM이 다 죽는 최악의 경우에는 작업할 컨테이너 생성 자체가 안되기에 문제가 발생하지만 그런 경우는 거의 없다. 하지만 기본적인 YARN 구조에서 RM은 독단적으로 존재하며 작업 운영 상의 중요한 역할들을 맡고 있어서 RM 노드가 죽을 시 바로 내결함성은 보장되지 않는다.</p><h2 id="yarn-ha-process">YARN HA Process</h2><p>결국 마스터-워커 구조인 YARN 또한 HDFS처럼 마스터가 죽으면 바로 운영이 중단된다. 따라서 고가용성 보장을 위하여 RM을 Active-StandBy 구조로 이중화하여 액티브 RM에 문제가 있을 시 바로 스탠바이 RM이 작동할 수 있도록 한다. HA 구조로 설정한 YARN의 프로세스는 아래의 그림과 같다.</p><figure><img src="/images/145.png" alt="Yarn" /><figcaption aria-hidden="true">Yarn</figcaption></figure><p>HDFS와 동일한 구조이기에 보통 네임노드와 같은 서버에 셋팅하는 경우가 많으며, 효율적인 리소스 사용을 위해 위 그림과 달리 한 서버에 액티브 네임노드와 스탠바이 RM을 두는 크로스 셋팅을 하기도 한다. 또한 Active-StandBy구조의 경우 필수적으로 Jookeeper의 failover Controller가 셋팅되어 각각의 생존여부를 Jookeeper가 관리하도록 한다.</p>]]></content>
    
    
    <categories>
      
      <category>BigData</category>
      
      <category>hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>빅데이터</tag>
      
      <tag>hadoop</tag>
      
      <tag>ecosystem</tag>
      
      <tag>datastorage</tag>
      
      <tag>Yarn</tag>
      
      <tag>resource</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>파이썬스러운 코드</title>
    <link href="/ko/Python/python-1/"/>
    <url>/ko/Python/python-1/</url>
    
    <content type="html"><![CDATA[<p>글을 시작하기에 앞서 해당 글은 Mariano Anaya의 저서인 파이썬 클린 코드를 바탕으로 요약 및 정리한 글임을 알려드립니다. <span id="more"></span></p><hr /><h2 id="파이썬스럽다pythonic의-의미">파이썬스럽다(pythonic)의 의미</h2><p>모든 프로그래밍 언어는 각자의 고유한 관용구(idiom)를 가지고 있다. 여기서 관용구란 특정 작업을 수행하기 위한 특별한 방법이며, 패턴이라고도 불린다. 이런 관용구를 따른 코드를 관용적이라고 부르며, 파이썬에서는 파이썬스럽다고 한다. 이런 관용구를 따른 코드는 더 나은 성능을 낸다.</p><h2 id="인덱스와-슬라이스">인덱스와 슬라이스</h2><p>파이썬은 인덱스에 음수를 사용하여 끝에서부터 접근이 가능하다. 또한 슬라이스를 사용하여 특정 구간의 인덱스 요소롤 반환할 수 있다. 마지막 예제를처럼 슬라이스에서 세번째 값을 추가로 입력하여 간격을 설정할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt; num = (<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>)<br>&gt; num[-<span class="hljs-number">1</span>]<br><span class="hljs-number">7</span><br>&gt; num[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<br>(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br>&gt;num[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>:<span class="hljs-number">2</span>]<br>(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><h2 id="자체-시퀀스-생성">자체 시퀀스 생성</h2><p>슬라이스를 가져오는 또 다른 방법이 있다. 아래의 예시를 보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;interval = <span class="hljs-built_in">slice</span>(<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>)<br>&gt;num[interval]<br>(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>결과는 위에서 직접 슬라이스를 한 결과와 같다. 위 방법은 클래스 내부에 내장되어 있는 <code>__getitem__</code>이라는 메서드를 이용한 것이다. 파이썬의 클래스는 기본적으로 내장된 몇 가지의 매서드가 존재한다. 이런 기능들을 <strong>매직 메서드</strong>라고 한다.</p><p><strong>매직 메서드란</strong><br />매직 메서드란 사용자가 클래스안에 정의할 수 있는 스페셜 메서드로서 클래스를 int, str, list등의 파이썬의 빌트인 타입(built-in type)과 같은 작동을 하게 해준다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">items</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, *values</span>):<br>        <span class="hljs-variable language_">self</span>._values = <span class="hljs-built_in">list</span>(values)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>._values)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._values.__getitem__(item)<br></code></pre></td></tr></table></figure><p>위의 예시에서는 클래스 <code>items</code>에 3개의 매직 메서드를 정의했다. 하나씩 간단하게 기능을 살펴보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt; exam = items(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)<br>&gt; exam._values<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br>&gt;<span class="hljs-built_in">len</span>(exam)<br><span class="hljs-number">6</span><br>&gt;exam[interval]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><ul><li><code>__init__</code>: 클래스에 파라미터로 들어오는 값들을 객체로 저장한다. 위의 예시에서 클래스의 인스턴스인 <code>exam</code>은 <code>exam._values</code>에 리스트화된 <code>num</code>이 저장된다.</li><li><code>__len__</code>: <code>__init__</code>에 정의된 데이터의 개수를 반환한다. 위의 예시에서는 <code>exam._values</code>의 개수를 반환한다.</li><li><code>__getitem__</code>: key에 해당하는 대괄호 안의 값을 파라미터로 전달한다. 위의 예시에서는 <code>exam[interval]</code>을 입력하면 <code>interval</code>이 <code>__getitem__</code>의 파라미터로 전달되어 해당 함수의 반환값을 제공한다.</li></ul><p>이외에도 다양한 매직 메서드들이 많이 존재한다. 그렇다면 이런 기능을 왜 사용하는 것일까? 바로 데이터 타입을 맞춰주기 위함이다. 위와 같이 내장 함수나 사칙연산 함수 등을 데이터 타입에 맞게 함수로 지정해두면 편리하게 사용할 수 있다.</p><h2 id="컨텍스트-관리자">컨텍스트 관리자</h2><p>일반적으로 파일을 열면 파일 디스크럽터의 누수를 막기 위해 사용이 끝난 후 파일을 닫아야 한다. (파일 디스크럽터란 간단히 설명하면 데이터의 출입구이다.) 하지만 파일을 닫기 위해서는 할당된 모든 리소스를 해제하여야 하는데 코드가 복잡해지는 경우 모든 경로를 찾아서 해제하기는 어렵다. 이때 컨텍스트 관리자를 사용하면 이런 부분들을 자동으로 관리해준다. 아래 예시를 확인해보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> fd:<br>    process_file(fd)<br></code></pre></td></tr></table></figure><p>위 코드는 <code>with</code>로 컨텍스트 관리자로 진입한 후 <code>open()</code>으로 관리자 내부에서 파일을 오픈한 다음 <code>process_file()</code>함수에 들어있는 과정을 모두 실행한다. 여기서 예외가 발생해도 해당 함수에 들어있는 코드가 모두 진행되면 자동으로 해당 파일을 닫는다.</p><p>컨텍스트 관리자는 <code>__enter__</code>와 <code>__exit__</code>라는 두 개의 매직 메서드를 가지고 있다. 처음 <code>with</code>는 <code>__enter__</code>을 호출하여 해당 메서드에서 반환하는 객체를 <code>as</code> 다음에 오는 변수에 할당한다. 그후 코드가 끝나면 <code>__exit__</code>를 호출하여 해당 컨텍스트 관리자를 종료한다.</p><p>앞서 매직 메서드를 구현했던 예제와 같이 컨텍스트 관리자 또한 직접 구현할 수 있다. 바로 <code>contextlib</code>모듈을 사용하는 것이다. 아래의 예제를 확인해보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> contextlib<br><br><span class="hljs-meta">@contextlib.contextmanager</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">db_handler</span>():<br>    stop_database()<br>    <span class="hljs-keyword">yield</span><br>    start_database()<br><br><span class="hljs-keyword">with</span> db_handler():<br>    db_backup<br></code></pre></td></tr></table></figure><p>위와 같이 컨텍스트 관리자로 설정할 함수 위에 <code>@contextlib.contextmanager</code>를 추가하면 된다. 컨텍스트 관리자로 사용될 함수는 <strong>제너레이터</strong>라는 함수의 형태여야 한다.</p><p><strong>제너레이터란</strong><br />제너레이터는 이터레이터를 생성해주는 함수이다. 이터레이터는 클래스에 <strong>iter</strong>, <strong>next</strong> 또는 <strong>getitem</strong> 메서드를 구현해야 하지만 제너레이터는 함수 안에서 yield라는 키워드만 사용하면 된다. 그래서 제너레이터는 이터레이터보다 훨씬 간단하게 작성할 수 있다.</p><p><code>db_handler()</code>에서 <code>yield</code>는 <code>__enter__</code>와 <code>__exit__</code>를 나눠주는 역할을 한다.</p><h2 id="프로퍼티-속성과-객체-메서드의-다른-타입들">프로퍼티, 속성과 객체 메서드의 다른 타입들</h2><p>다른 언어들과 다르게 파이썬 객체의 모든 프로퍼티와 함수는 public이다. 즉 호출자가 객체의 속성을 호출하지 못하도록 할 방법이 없다는 것이다.</p><p>엄격한 강제사항은 없지만 몇 가지 규칙이 있다. 밑줄로 시작하는 속성은 해당 객체에 대해 private을 의미하여, 외부에서 호출되지 않기를 기대하는 것이다.</p><h3 id="파이썬에서의-밑줄">파이썬에서의 밑줄</h3><p>파이썬에서 밑줄을 사용하는 몇 가지 규칙이 있다. 아래의 예시를 먼저 살펴보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Connector</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, source</span>):<br>        <span class="hljs-variable language_">self</span>.source = source<br>        <span class="hljs-variable language_">self</span>._timeout = <span class="hljs-number">60</span><br><br>&gt; con = Connector(<span class="hljs-string">&#x27;mysql://localhost&#x27;</span>)<br>&gt; con.source<br><span class="hljs-string">&#x27;mysql://localhost&#x27;</span><br>&gt;con._timeout<br><span class="hljs-number">60</span><br>&gt;con.__dict__<br>&#123;<span class="hljs-string">&#x27;source&#x27;</span>: <span class="hljs-string">&#x27;mysql://localhost&#x27;</span>, <span class="hljs-string">&#x27;_timeout&#x27;</span>: <span class="hljs-number">60</span>&#125;<br></code></pre></td></tr></table></figure><p>위 속성에서 볼 수 있듯이 <code>source</code>는 public이고 <code>_timeout</code>은 private이다. 이 코드를 해석해보면 <code>_timeout</code>은 해당 클라스 자체에서만 사용되고 바깥에서는 호출되지 않아야 한다. 이렇게 내부에서 사용할 것들을 밑줄로 정리해두면 훨씬 안전하게 리팩토링 할 수 있다.</p><p>어떤 이들은 밑줄 2개를 이용하면 private 객체를 만들 수 있다고 한다. 하지만 그것은 사실이 아니다. 아래의 예시를 보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Connector</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, source</span>):<br>        <span class="hljs-variable language_">self</span>.source = source<br>        <span class="hljs-variable language_">self</span>.__timeout = <span class="hljs-number">60</span><br><br>&gt; con = Connector(<span class="hljs-string">&#x27;mysql://localhost&#x27;</span>)<br>&gt; con.source<br><span class="hljs-string">&#x27;mysql://localhost&#x27;</span><br>&gt;con.__timeout<br>AttributeError: <span class="hljs-string">&#x27;Connector&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;__timeout&#x27;</span><br></code></pre></td></tr></table></figure><p>위처럼 밑줄이 두 개인 경우는 메서드를 바로 인식하지 않는다. 하지만 이것은 파이썬이 다른 이름의 메서드를 만든 것이다. 이를 이름 맹글링이라고 한다. 이름 맹글링이란 파이썬이 본인의 규칙에 맞게 알아서 함수 또는 변수의 이름을 변형하는 것을 말한다. 밑줄 2개는 아래와 같은 이름의 메서드를 생성한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;con._Connector__timeout<br><span class="hljs-number">60</span><br></code></pre></td></tr></table></figure><h3 id="프로퍼티">프로퍼티</h3><p>객체에 저장되는 값이 일반적인 속성을 가져야 할 경우에 프로퍼티를 보편적으로 사용된다. 예를 들어서 사용자가 올바르지 않은 양식의 이메일을 입력하지 않도록 만드는 코드를 짠다고 가정해보자. 그럼 코드는 다음과 같다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>email_format= re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;[^@]+@[^@]+[^@]+&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_valid_email</span>(<span class="hljs-params">user_email: <span class="hljs-built_in">str</span></span>):<br>    <span class="hljs-keyword">return</span> re.<span class="hljs-keyword">match</span>(email_format,user_email) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, username</span>):<br>        <span class="hljs-variable language_">self</span>.username = username<br>        <span class="hljs-variable language_">self</span>._email = <span class="hljs-literal">None</span><br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">email</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._email<br><br><span class="hljs-meta">    @email.setter</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">email</span>(<span class="hljs-params">self, new_email</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_valid_email(new_email):<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;new_email&#125;</span>은 유효한 이메일이 아닙니다.&quot;</span>)<br>        <span class="hljs-variable language_">self</span>._email = new_email<br></code></pre></td></tr></table></figure><p>위 코드에서 <code>@property</code>는 클래스 User의 private 값인 <code>_email</code>을 반환한다. 두번째 메서드인 <code>@email.setter</code>는 프로퍼티에 값이 할당되면 해당 값이 올바른 이메일인지 검사한 후 클래스 User의 <code>_email</code> 속성을 업데이트 할지 결정한다.</p><p>프로퍼티는 명령-쿼리 분리 원칙을 따르기 위한 좋은 방법이다. 명령-쿼리 분리 원칙이란 객체의 메서드가 무언가의 상태를 변경하는 명령이거나 무언가의 값을 반환하는 쿼리이거나 둘 중 하나만 수행해야 한다는 것이다,</p><p>프로퍼티를 사용하면 <code>@property</code>는 무언가의 응답을 하기 위한 쿼리이고, <code>@&lt;property_name&gt;.setter</code>는 무언가를 하기 위한 커맨드(명령)이다.</p><h2 id="이터러블-객체">이터러블 객체</h2><p>파이썬에서는 기본적으로 반복 가능한 객체가 있다. for 루프를 사용하여 객체를 반복할 수도 있지만, 반복을 위한 자체 이터러블을 만들 수도 있다. 엄밀히 말하면 이터러블은 <code>__iter__</code> 매직 메서드를 구현한 객체, 이터레이터는 <code>__next__</code> 매직 메서드를 구현한 객체를 말한다.</p><p>파이썬의 반복은 이터러블 프로토콜이라는 자체 프로토콜을 사용해 동작한다. 객체를 반복할 수 있는지 확인하기 위해서 다음 2가지를 검사한다.</p><ul><li>객체가 <code>__next__</code>나 <code>__iter__</code> 중 하나를 포함하는가</li><li>객체가 시퀀스이고 <code>__len__</code>과 <code>__getitem__</code>를 모두 가져는가</li></ul><p>객체를 반복하려고 하면 파이썬은 해당 객체의 <code>iter()</code>를 호출한다. 이것은 해당 객체에 <code>__iter__</code> 메서드가 있는지 확인하는 것이다. <code>__iter__</code>가 있다면 해당 메서드를 실행한다. 예시를 보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> timedelta, date<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataRangeContainerIterable</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,start_date,end_date</span>):<br>        <span class="hljs-variable language_">self</span>.start_date = start_date<br>        <span class="hljs-variable language_">self</span>.end_date = end_date<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        current_day = <span class="hljs-variable language_">self</span>.start_date<br>        <span class="hljs-keyword">while</span> current_day &lt; <span class="hljs-variable language_">self</span>.end_date:<br>            <span class="hljs-keyword">yield</span> current_day<br>            current_day += timedelta(days=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>위 코드는 <code>__iter__</code>에서 제너레이터를 생성하고 제너레이터는 다시 그 안의 <code>__iter__</code>를 생성한다. 이런 형태의 객체를 '컨테이너 이터러블'이라고 한다. 예시를 통해 위 코드를 확인해보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;temp = DataRangeContainerIterable(date(<span class="hljs-number">2020</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>),date(<span class="hljs-number">2020</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>))<br>&gt;<span class="hljs-string">&quot;,&quot;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>,temp))<br><span class="hljs-string">&#x27;2020-01-01,2020-01-02,2020-01-03,2020-01-04&#x27;</span><br></code></pre></td></tr></table></figure><p>한번에 날짜들이 나오는 것을 볼 수 있다.</p><p>그렇다면 만약 객체에 <code>__iter__</code>가 없는 경우에는 어떻게 반복해야 할까? 객체는 <code>__iter__</code>가 없는 경우에 <code>__getitem__</code>을 찾으며, 이것도 없다면 <code>TypeError</code>를 일으킨다.</p><p>따라서 시퀀스는 기본적으로 <code>__len__</code>과 <code>__getitem__</code>를 수현하고 첫 번째 인덱스 0부터 시작하여 포함된 요소를 한 번에 하나씩 차례로 가져올 수 있어야 한다. 그렇지 않으면 반복이 작동하지 않는다.</p><p>이터러블 방식은 데이터를 하나씩 가져오기 때문에 메모리를 적게 사용하지만 시간복잡도는 O(n)이다. 이와 반대로 시퀀스의 경우 메모리가 많이 사용되지만 시간 복잡도는 O(1)로 상수에 가능하다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DateRangeSequence</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, start_date, end_date</span>):<br>        <span class="hljs-variable language_">self</span>.start_date = start_date<br>        <span class="hljs-variable language_">self</span>.end_date = end_date<br>        <span class="hljs-variable language_">self</span>._<span class="hljs-built_in">range</span> = <span class="hljs-variable language_">self</span>._create_range()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_create_range</span>(<span class="hljs-params">self</span>):<br>        days = []<br>        current_day = <span class="hljs-variable language_">self</span>.start_date<br>        <span class="hljs-keyword">while</span> current_day &lt; <span class="hljs-variable language_">self</span>.end_date:<br>            days.append(current_day)<br>            current_day += timedelta(days=<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> days<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, day_no</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._<span class="hljs-built_in">range</span>[day_no]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>._<span class="hljs-built_in">range</span>)<br></code></pre></td></tr></table></figure><p>위의 코드는 <code>_create_range()</code>을 사용하여 시퀀스를 차례대로 불러온다. 해당 코드가 어떻게 동작하는지 확인해보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt; temp = DateRangeSequence(date(<span class="hljs-number">2020</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>),date(<span class="hljs-number">2020</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>))<br>&gt; <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> temp:<br>    <span class="hljs-built_in">print</span>(i)<br><span class="hljs-number">2020</span>-01-01<br><span class="hljs-number">2020</span>-01-02<br><span class="hljs-number">2020</span>-01-03<br><span class="hljs-number">2020</span>-01-04<br>&gt; temp[-<span class="hljs-number">1</span>]<br>datetime.date(<span class="hljs-number">2020</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>보시다시피 음수 인덱스도 작동하는 것을 확인할 수 있다. 이는 DateRangeSequence 객체가 모든 작업을 래핑된 객체인 <code>days</code>에 위임했기 때문이다.</p><h2 id="컨테이너-객체">컨테이너 객체</h2><p>컨테이너는 <code>__contains__</code> 메서드를 구현한 객체로 <code>__contains__</code> 메서드는 일반적으로 불리언 값을 반환한다. 해당 메서드는 파이썬에서 <code>in</code>키워드가 발견될 때 호출된다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">element <span class="hljs-keyword">in</span> container <span class="hljs-comment"># container.__contains__(element)</span><br></code></pre></td></tr></table></figure><p>이 메서드를 잘 사용하면 코드의 가독성이 정말 높아진다. 아래의 예시는 2차원 게임 지도에서 특정 위치에 표시를 해야 하는 경우를 구현한 코드이다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 난해한 코드</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mark_coordinate</span>(<span class="hljs-params">grid, coord</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= coord.x &lt; grid.width <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= coord.y &lt; grid.height:<br>        grid[coord] = MARKED<br><br><span class="hljs-comment"># 정리된 코드</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Boundaries</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, width, height</span>):<br>        <span class="hljs-variable language_">self</span>.width = width<br>        <span class="hljs-variable language_">self</span>.height = height<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__contains__</span>(<span class="hljs-params">self, coord</span>):<br>        x,y = coord<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &lt;= x &lt; <span class="hljs-variable language_">self</span>.width <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= y &lt; <span class="hljs-variable language_">self</span>.height<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Grid</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, width, height</span>):<br>        <span class="hljs-variable language_">self</span>.width = width<br>        <span class="hljs-variable language_">self</span>.height = height<br>        <span class="hljs-variable language_">self</span>.limits = Boundaries(width, height)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__contains__</span>(<span class="hljs-params">self, coord</span>):<br>        <span class="hljs-keyword">return</span> coord <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.limits<br></code></pre></td></tr></table></figure><p>위의 난해한 코드는 복잡하고 이해하기도 직관적이지 않다. 아래의 코드처럼 클래스로 정리한다면 훨씬 가독성이 좋고 깔끔하다.</p><h2 id="객체의-동적인-속성">객체의 동적인 속성</h2><p><code>__getattr__</code> 매직 메서드를 사용하여 객체에서 속성을 얻는 방법을 제어할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicAttributes</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, attribute</span>):<br>        <span class="hljs-variable language_">self</span>.attribute = attribute<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, attr</span>):<br>        <span class="hljs-keyword">if</span> attr.startswith(<span class="hljs-string">&quot;fallback_&quot;</span>):<br>            name = attr.replace(<span class="hljs-string">&quot;fallback_&quot;</span>,<span class="hljs-string">&quot;&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;[fallback resolved] <span class="hljs-subst">&#123;name&#125;</span>&quot;</span><br>        <span class="hljs-keyword">raise</span> AttributeError(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.__class__.__name__&#125;</span>에는 <span class="hljs-subst">&#123;attr&#125;</span> 속성이 없음&quot;</span>)<br></code></pre></td></tr></table></figure><p>위의 예시를 이용하여 <code>__getattr__</code>의 작동원리를 확인해보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt; temp = DynamicAttributes(<span class="hljs-string">&#x27;value&#x27;</span>)<br>&gt; temp.fallback_test <span class="hljs-comment"># __getattr__ 적용</span><br><span class="hljs-string">&#x27;[fallback resolved] test&#x27;</span><br></code></pre></td></tr></table></figure><p>첫 번째 예시는 <code>fallback_test</code>라고 attribute 메서드로 보냄으로써 <code>f"[fallback resolved] &#123;name&#125;"</code> 해당 코드값이 반환된다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;temp.__dict__[<span class="hljs-string">&#x27;fallback_new&#x27;</span>] = <span class="hljs-string">&#x27;new_value&#x27;</span><br>&gt;temp.__dict__<br>&#123;<span class="hljs-string">&#x27;attribute&#x27;</span>: <span class="hljs-string">&#x27;value&#x27;</span>, <span class="hljs-string">&#x27;fallback_new&#x27;</span>: <span class="hljs-string">&#x27;new_value&#x27;</span>&#125;<br>&gt;<span class="hljs-built_in">getattr</span>(temp, <span class="hljs-string">&quot;fallback_new&quot;</span>)<br><span class="hljs-string">&#x27;new_value&#x27;</span><br></code></pre></td></tr></table></figure><p>두 번째 예시는 인스턴스 <code>temp</code>에 새로운 속성을 삽입한 후 <code>getattr()</code>을 통해 불러오면 속성값이 나오는 것을 확인할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;<span class="hljs-built_in">getattr</span>(temp, <span class="hljs-string">&quot;someting&quot;</span>)<br>AttributeError: DynamicAttributes에는 someting 속성이 없음<br>&gt; <span class="hljs-built_in">getattr</span>(temp, <span class="hljs-string">&quot;someting&quot;</span>,<span class="hljs-string">&quot;yaah&quot;</span>)<br><span class="hljs-string">&#x27;yaah&#x27;</span><br></code></pre></td></tr></table></figure><p>마지막 예시는 값을 검색할 수 없는 경우에는 <code>AttributeError</code>가 일어나는 것을 확인할 수 있다. 신기한 것은 뒤에 하나를 추가하면 마지막 값을 리턴하는 것이다. 이것은 기존에 파라미터 2개로 설정된 <code>getattr()</code>가 작동하는 것 같다.</p><h2 id="호출형-객체">호출형 객체</h2><p>함수처럼 작동하는 객체는 매우 편리하다. 매직 메서드인 <code>__call__</code>을 사용하면 일반 객체를 함수처럼 호출할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CallCount</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>._counts = defaultdict(<span class="hljs-built_in">int</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, argument</span>):<br>        <span class="hljs-variable language_">self</span>._counts[argument]+=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._counts[argument]<br></code></pre></td></tr></table></figure><p>위 코드는 해당 객체를 반복할수록 <code>__call__</code>를 호출하여 객체 값을 변경한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt; cc = CallCount()<br>&gt; cc(<span class="hljs-number">1</span>)<br><span class="hljs-number">1</span><br>&gt; cc(<span class="hljs-number">1</span>)<br><span class="hljs-number">2</span><br>&gt; cc(<span class="hljs-number">1</span>)<br><span class="hljs-number">3</span><br>&gt; cc(<span class="hljs-number">2</span>)<br><span class="hljs-number">1</span><br>&gt; cc.__dict__<br>&#123;<span class="hljs-string">&#x27;_counts&#x27;</span>: defaultdict(<span class="hljs-built_in">int</span>, &#123;<span class="hljs-number">1</span>: <span class="hljs-number">3</span>, <span class="hljs-number">2</span>: <span class="hljs-number">1</span>&#125;)&#125;<br></code></pre></td></tr></table></figure><p><code>__dict__</code>를 사용하여 객체들을 확인해보면 지금까지 변경된 부분이 저장되어 있는 것을 알 수 있다.</p><h2 id="파이썬에서-유의할-점">파이썬에서 유의할 점</h2><p>언어의 주요 기능을 이해하는 것 외에도 흔히 발생하는 잠재적인 문제를 피할 수 있는 관용적인 코드를 작성하는 것도 중요하다. 이번 섹션에서 논의되는 대부분은 완전히 해결할 수 있는 문제들이다. 따라서 지금부터 설명하는 방식대로 리팩토링하는 것이 좋다.</p><h3 id="변경가능한-파라미터-값">변경가능한 파라미터 값</h3><p>쉽게 말해 변경 가능한 객체를 함수의 기본 인자로 사용하면 안된다.</p>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>review</tag>
      
      <tag>Cleancode</tag>
      
      <tag>클린코드</tag>
      
      <tag>책리뷰</tag>
      
      <tag>code</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>소개, 코드 포매팅과 도구</title>
    <link href="/ko/Python/python-0/"/>
    <url>/ko/Python/python-0/</url>
    
    <content type="html"><![CDATA[<p>글을 시작하기에 앞서 해당 글은 Mariano Anaya의 저서인 파이썬 클린 코드를 바탕으로 요약 및 정리한 글임을 알려드립니다. <span id="more"></span></p><hr /><h2 id="클린-코드의-의미">클린 코드의 의미</h2><p>클린 코드에 대한 정확하고 엄격한 정의는 없다. 그렇다면 어떤 코드를 클린 코드라고 할 수 있을까? 이 질문을 살펴보기 전에 먼저 코드가 무엇인지 고민해보자.</p><p>흔히 코드라는 것은 개발자가 컴퓨터에게 원하는 내용을 전달하기 위한 언어로 생각되어 왔다. 이 정의를 바탕으로 클린 코드의 기준을 생각해본다면 컴퓨터가 이해함/이해하지 못함으로 구분할 수 있다. 하지만 저 기준은 코드가 올바른지 판단하는 기준으로 더 적절해 보인다. 좀 더 코드의 개념을 넓혀보자.</p><p>코드가 가지는 또 다른 의미는 무엇인가? 바로 다른 개발자와의 의사소통 도구라는 점이다. 즉, 코드는 다른 개발자들이 보고 이해할 수 있는 언어로서의 개념도 포함되어 있다. 해당 정의에서 클린 코드의 기준을 생각해본다면 클린 코드란 다른 개발자들이 보고 쉽게 이해할 수 있는 코드라고 말할 수 있다.</p><h2 id="클린-코드의-중요성">클린 코드의 중요성</h2><p>클린 코드가 중요한 이유는 매우 많다. 유지보수성 향상, 기술부채의 감소, 효과적인 작업 진행, 쉬운 프로젝트 관리 등등. 하지만 이 모든 장점을 하나의 단어로 설명할 수 있다. 바로 "효율성"이다. 클린 코드는 개발자가 일하는 대부분의 상황에서 효율성을 증대한다.</p><p>개인적으로 클린 코드는 단순히 코드의 로직만을 의미하는 것은 아닌 것 같다. 프로젝트에 필요한 파트들을 정하고 체계적으로 코드를 관리하는 능력 또한 클린 코드에 속하지 않을까? 만약 이런 생각 없이 프로젝트를 시작하면 아무리 코드를 간결하게 잘 짜도 파트가 늘어날 때마다 코드들이 뒤섞여 프로젝트가 혼란에 빠질 수도 있을 것 같다.</p><h2 id="클린-코드에서-코드-포매팅의-역할">클린 코드에서 코드 포매팅의 역할</h2><p>그런 의미에서 코드 포매팅은 비교적 세부적인 요소라고 생각된다. 하지만 코드를 이해해야 하는 개발자 입장에서 코드의 형식은 매우 중요하다. 컴퓨터는 공백이나 줄넘김 등을 인식하지 않는다. 즉, 코딩에서 그런 요소들은 대부분 코드를 읽는 다른 사람들을 위한 것이다. 각 언어마다 일반적으로 통용되는 코딩 가이드라인이 있다. 이를 지키기만 하면 클린 코드가 되는 것은 아니지만 그래도 중간은 갔다고 생각한다.</p><h2 id="프로젝트-코딩-스타일-준수">프로젝트 코딩 스타일 준수</h2><p>코딩 가이드라인은 품질 표준을 지키기 위해 프로젝트에서 따라야만 하는 최소한의 요구사항이다. 파이썬에서는 이를 'PEP-8(Python Enhancement Proposal)'이라고 한다. PEP-8은 파이썬 구문의 특수성을 고려하여 작성되었으며, 실제 파이썬 개발자가 만들어 이보다 좋은 표준을 찾기가 어렵다.</p><p>PEP-8의 특징은 다음과 같다.</p><ul><li><dl><dt>검색 효율성 (grep)</dt><dd>명령어 <code>grep</code>은 특정 파일에서 특정 문자열을 찾는 기능이다. 파이썬에서는 함수의 파라미터 할당 시에는 <code>=</code>을 공백없이 입력하고, 변수 할당 시에는 공백을 주어 입력하는 등의 규칙을 가지고 있다. 따라서 같은 문자열이라도 공백의 유무로도 원하는 값을 찾을 수 있다.</dd></dl></li><li><dl><dt>일관성</dt><dd>코드가 일정한 포맷을 가지면 훨씬 쉽게 읽을 수 있다. 코드 레이아웃, 문서화, 이름 작명 규칙 등이 모든 저장소에서 동일하게 적용된다면 훨씬 쉽게 익숙해질 수 있다.</dd></dl></li><li><dl><dt>코드 품질</dt><dd>코드를 구조화하여 살펴보면 한 눈에 코드를 이해하고 버그와 실수를 쉽게 찾을 수 있다. 코드 품질 도구를 사용하면 잠재적인 버그까지 살펴볼 수 있다.</dd></dl></li></ul><h2 id="docstring과-어노테이션">Docstring과 어노테이션</h2><p>Docstring과 어노테이션은 파이썬 코드를 문서화하는 방법이다. 파이썬은 함수나 메서드를 거치면 변수나 객체의 값이 무엇인지 알기가 어려운 경우가 많다. 이런 정보들을 문서로 명시하면 향후 다른 개발자가 쉽게 이해하는 데 도움이 된다. 주의해야 할 점은 주석(Comment)은 문서화가 아니라는 것이다.</p><h3 id="docstring">Docstring</h3><p>Docstring은 해당 코드의 설명을 글로 쓴 것이며, 모듈이나 클래스, 함수 등에 추가된다. 먼저 간단하게 Docstring의 예시를 살펴보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_function</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;임의의 계산 수행&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>위 코드에서 <code>"""</code>에 들어있는 글들이 Docstring이다. 이는 단순한 주석과는 다르다. 주석의 경우 스크립트 코드 소스에서만 확인할 수 있는 반면, Docstring은 동적 프로그래밍 환경에서도 찾아볼 수 있다. 위의 함수의 Docstring을 확인하는 방법은 아래와 같다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">my_function.__doc__<br></code></pre></td></tr></table></figure><p>그렇기에 주석보다는 Docstring을 사용하는 것이 개발자들에게도 훨씬 간편하다. 하지만 Docstring의 유일한 단점이 있다. 바로 코드가 변경되면 Docstring 또한 직접 수정해야 한다는 점이다. 변경되는 코드마다 문서를 알맞게 수정하는 것은 생각보다 귀찮은 일이다.</p><h3 id="어노테이션">어노테이션</h3><p>어노테이션의 기본적인 아이디어는 코드 사용자에게 함수 인자로 어떤 값이 와야하는지 힌트를 주자는 것이다. 어노테이션을 사용해 변수의 예상 타입을 지정할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, lat, long</span>):<br>        <span class="hljs-variable language_">self</span>.lat = lat<br>        <span class="hljs-variable language_">self</span>.long = long<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">locate</span>(<span class="hljs-params">latitude:<span class="hljs-built_in">float</span>, longitude:<span class="hljs-built_in">float</span></span>) -&gt; Point:<br>    <span class="hljs-string">&quot;&quot;&quot;앱에서 좌표에 해당하는 객체를 검섹&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>위의 예시는 함수 <code>locate()</code> 파라미터들의 데이터 타입을 미리 설정하였으며, 동시에 반환값의 타입 또한 지정하였다.</p><p>이렇게 설정해두면 해당 함수를 사용하는 다른 개발자들은 파라미터 데이터 형태의 힌트를 얻을 수 있다. 만약 동적 개발을 하고 있던 도중이었다면 아래와 같이 입력하면 설정한 어노테이션이 보인다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">locate.__annotations__<br> &#123;<span class="hljs-string">&#x27;latitude&#x27;</span>:<span class="hljs-built_in">float</span>, <span class="hljs-string">&#x27;longitude&#x27;</span>:<span class="hljs-built_in">float</span>, <span class="hljs-string">&#x27;return&#x27;</span>:__main__.Point&#125;<br></code></pre></td></tr></table></figure><p>어노테이션을 사용하면 타입 힌팅을 통해 적절하지 못한 타입이 들어간 경우를 찾아낼 수 있으며, 이후 테스트 시 디버깅에도 도움이 된다.</p><h2 id="기본-품질을-위한-도구-설정">기본 품질을 위한 도구 설정</h2><p>코드의 기본 품질은 무엇일까? 일단 코드는 컴퓨터 뿐만 아니라 다른 개발자도 이해해야 한다는 것을 명심하자. 그러면 기본 품질은 아래와 같이 정의할 수 있다.</p><ul><li>해당 코드를 다른 개발자들도 쉽게 이해하고 따라갈 수 있는가?</li><li>업무 도메인에 대해서 말하고 있는가?</li><li>팀에 새로 합류하는 사람도 효과적으로 작업할 수 있는가?</li></ul><p>이런 부분들을 매번 사람이 직접 체크하는 것은 매우 번거로운 일이다. 따라서 우리는 자동으로 코드의 품질을 관리해주는 도구들을 살펴볼 것이다.</p><h3 id="mypy">Mypy</h3><p>Mypy는 파이썬에서 가장 일반적으로 사용하는 정적 타입 검사 도구이다. Mypy를 설치하면 프로젝트의 모든 파일을 분석하여 타입 불일치를 검사해준다. 설치하는 코드는 아래와 같다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install mypy<br></code></pre></td></tr></table></figure><p>사용방법은 설치 후 <code>mypy&#123;파일 명&#125;</code>을 입력하면 검사 결과가 나오는 방식이다. 잘못 탐지한 경우 해당 문장 끝에 <code>#type: ignore</code>를 추가하여 Mypy가 무시하도록 할 수 있다.</p><h3 id="pylint">Pylint</h3><p>Pylint는 가장 엄격하게 코드를 검사하는 도구이다. VScode에 기본적으로 내장되어 있으며, 빨간색은 버그, 노란색은 필요없는 코드, 하늘색은 PEP-8에 맞지 않는 코드를 반환한다. 만약 직접 설치하여 사용하고 싶다면 아래의 코드를 입력하자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install pylint<br></code></pre></td></tr></table></figure><p>Pylintsms <code>.pylintrc</code> 파일에서 설정 값들을 변경할 수 있다.</p><h3 id="makefile">Makefile</h3><p>Makefile은 리눅스 환경에서 프로젝트를 컴파일하고 실행하기 위한 설정을 도와주는 파워풀한 도구이다. 빌드 외에도 포매팅 검사나 코딩 컨벤션 검사를 자동화하기 위해서도 사용된다. 예시를 살펴보자.</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">typehint:</span><br>mypy src/tests/<br><br><span class="hljs-section">test:</span><br>pytest tests/<br><br><span class="hljs-section">lint:</span><br>pylint src/tests/<br><br><span class="hljs-section">chechlist: lint typehint test</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: typehint test lint chechlist</span><br></code></pre></td></tr></table></figure><p>위의 설정은 pylint로 PHP-8을 검사하고, mypy로 타입을 확인한 후 최종적으로 test를 진행하라는 명령 모음이다. 이렇게 저장해두면 단 한 줄의 코드로 모든 검사를 한번에 진행할 수 있다. 한 줄의 코드는 아래와 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make checklist<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>review</tag>
      
      <tag>Cleancode</tag>
      
      <tag>클린코드</tag>
      
      <tag>책리뷰</tag>
      
      <tag>code</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Resume 세부 레이아웃 완성</title>
    <link href="/ko/Web/web-3/"/>
    <url>/ko/Web/web-3/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 엔지니어의 Resume를 생성하는 과정을 공유합니다. <span id="more"></span></p><p>섹션을 어떻게 나눌지는 <a href="https://dev-bearabbit.github.io/2021/11/12/Resume/resume-1/">이전 글</a>에서 다뤘다. 이제 각 섹션 별로 어떻게 내용을 작성할지 고민해보자.</p><h2 id="상단-바">상단 바</h2><p>상단 바에는 크게 페이지 타이틀, 섹션, 언어 선택을 포함시켰다. 타이틀의 경우 블로그 이름과 동일하게 사용하였으며, 섹션 버튼은 누르면 바로 해당 자료가 있는 곳으로 이동할 수 있게 설정하였다. 마지막으로 언어 선택은 Bootstrap의 선택 폼을 사용하여 추가하였다.</p><figure><img src="/images/139.png" alt="intro1" /><figcaption aria-hidden="true">intro1</figcaption></figure><p>위 사진은 완성된 상단 바의 모습니다. 해당 폼에 대한 자세한 내용은 <a href="https://getbootstrap.com/docs/5.1/forms/select/">문서</a>에서 찾아볼 수 있다. 스크롤을 클릭하면 아래의 사진처럼 선택할 수 있는 언어가 나열된다.</p><figure><img src="/images/138.png" alt="intro0" /><figcaption aria-hidden="true">intro0</figcaption></figure><p>이 중 언어를 하나 선택하면 해당 언어로 된 Resume 페이지로 이동한다.</p><h2 id="헤더">헤더</h2><p>헤더는 가장 윗 부분에 위치한 섹션이다. 여기에는 블로그와 동일한 백그라운드를 사용하였으며, 이름과 현재 하고 있는 일과 엔지니어로서의 가지고 있는 가치관을 짧게 한줄로 적어두었다.</p><figure><img src="/images/130.png" alt="resume1" /><figcaption aria-hidden="true">resume1</figcaption></figure><h2 id="개인정보-간단한-소개">개인정보 &amp; 간단한 소개</h2><p>개인 정보는 이름, 현재 직업, 거주 위치, 이메일을 간단하게 작성하였다. 너무 많은 개인 정보를 입력하는 것은 모든 사람들에게 공개된 웹페이지라는 특성상 조금 부담스러웠기 때문이다. 또한 현재 나를 대표하는 이모티콘으로 사용하고 있는 사진을 추가하였으며, 엔지니어로서 중요하게 생각하는 가치들을 적어두었다. 해당 부분의 결과는 다음과 같다.</p><figure><img src="/images/131.png" alt="resume2" /><figcaption aria-hidden="true">resume2</figcaption></figure><h2 id="기술스택">기술스택</h2><p>기술스택의 경우 고민이 많았다. 어느 정도로 사용해야 입력할 수 있을까? 또 입력해도 어느정도 잘하는지의 여부를 작성해야 할까? 할 수 있다의 기준이 무엇인가? 등등. 그 결과 비교적 원리를 이해하고 사용했던 툴(tool)들과 프로그램을 작성할 때 사용한 적이 있는 언어를 입력하기로 결정하였다. 또한 실력이란 것은 혼자 객관적으로 판단이 어렵다고 생각했기에 추가로 작성하지는 않았다. 그 결과는 아래의 사진과 같다. 아래 사진에서 사용한 아이콘들은 <a href="https://fontello.com">fontello</a>라는 사이트에서 css로 변환하여 사용하였다.</p><figure><img src="/images/132.png" alt="resume3" /><figcaption aria-hidden="true">resume3</figcaption></figure><h2 id="블로그-깃허브">블로그 &amp; 깃허브</h2><p>블로그와 깃허브는 간단하게 이동할 수 있는 링크만 추가하는 방식으로 구상했었다. 그리하여 간단하게 Bootstrap의 card를 사용하여 간단하게 링크를 추가하였다. 여기에서 사용한 이모티콘들은 Bootstrap에서 기본으로 제공하는 것들을 사용하였다.</p><figure><img src="/images/133.png" alt="resume4" /><figcaption aria-hidden="true">resume4</figcaption></figure><h2 id="경력">경력</h2><p>경력은 아직 주니어 엔지니어이기 때문에 크게 내용은 없다. 현재 맡고 있는 직무와 개괄적으로 어떤 일들을 하는지 요약하여 덧붙였다.</p><figure><img src="/images/134.png" alt="resume5" /><figcaption aria-hidden="true">resume5</figcaption></figure><h2 id="프로젝트">프로젝트</h2><p>프로젝트는 크게 <code>WORK</code>와 <code>SIDE</code>로 나누어 시간순대로 작성하였다. <code>WORK</code>는 직장에서 실제 참여했던 프로젝트를 포함하였으며, <code>SIDE</code>는 직장 외 개인적으로 진행했던 프로젝트들을 포함하였다. 프로젝트들은 Bootstrap의 <a href="https://getbootstrap.com/docs/5.1/components/accordion/">Accordion</a> 레아이웃을 사용하였다. 각 리스트를 클릭하지 않은 모습은 다음과 같다.</p><figure><img src="/images/135.png" alt="resume6" /><figcaption aria-hidden="true">resume6</figcaption></figure><p>위 사진과 같은 구조에서 프로젝트 이름을 클릭하면 아래의 사진처럼 프로젝트에 대한 상세한 정보들이 보여진다. 상세한 정보들은 테이블 구조로 정리하였다.</p><figure><img src="/images/136.png" alt="resume7" /><figcaption aria-hidden="true">resume7</figcaption></figure><h2 id="개인-활동">개인 활동</h2><p>일이 아닌 개인적인 활동들을 적어두었다. 현재 활동 중인 개발 커뮤니티나 스터디에서 발표했던 것들, 또는 개인적으로 공부했던 것들을 적어두었다.</p><figure><img src="/images/152.png" alt="resume7" /><figcaption aria-hidden="true">resume7</figcaption></figure><h2 id="학력">학력</h2><p>힉력은 간단하게 학교이름, 전공, 기간을 입력하였다. 이후 대학원이나 Coursera에서 대학 강의를 듣는다면 추가할 예정이다. 아래의 사진이 학력의 레이아웃이다.</p><figure><img src="/images/137.png" alt="resume8" /><figcaption aria-hidden="true">resume8</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>엔지니어</tag>
      
      <tag>개발자</tag>
      
      <tag>resume</tag>
      
      <tag>이력서</tag>
      
      <tag>커리어</tag>
      
      <tag>career</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDFS 아키텍쳐</title>
    <link href="/ko/Hadoop/hadoop-7/"/>
    <url>/ko/Hadoop/hadoop-7/</url>
    
    <content type="html"><![CDATA[<p>하둡의 코어 서비스 중 하나인 HDFS의 아키텍처에 대해서 공부한 내용을 정리합니다. <span id="more"></span></p><h2 id="core-hadoop">Core Hadoop</h2><p>하둡은 크게 클러스터의 데이터를 저장하는 HDFS와 리소스를 관리하는 YARN, 이 2가지의 형태로 이루어져 있다.</p><figure><img src="/images/123.png" alt="corehadoop" /><figcaption aria-hidden="true">corehadoop</figcaption></figure><p>이번 글에서는 이 중 클러스터의 스토리지를 관리하고 데이터를 분산 저장하는 HDFS에 대해서 살펴볼 것이다.</p><h2 id="hdfs">HDFS</h2><p>HDFS는 Hadoop Data File System의 줄임말로 클러스터에 속한 노드들의 스토리지를 관리하며 데이터들을 분산 저장한다. 즉, 여러 개의 노드에 들어있는 스토리지들을 하나의 저장소처럼 사용할 수 있는 것이다. HDFS에서는 <code>블록</code>이라는 개념으로 데이터를 분산저장한다. 아래의 그림을 참고하자.</p><figure><img src="/images/124.png" alt="hdfsblock" /><figcaption aria-hidden="true">hdfsblock</figcaption></figure><p>위 그림의 예시를 보면 블록의 개념을 알 수 있다. 만약 1GB의 파일을 HDFS에 저장한다면 이를 데이터 블록으로 나누어 여러 노드에 분산저장한다. 데이터 블록의 크기는 변경할 수 있으며, HDFS에서 다루는 파일 크기와 갯수에 따라서 튜닝할 수 있다. 작은 크기의 파일이 경우에는 데이터 블록 크기를 작게 변경하는 것이 스토리지의 낭비가 없을 것이며, 큰 파일은 적당한 블록 크기로 올려주는 것이 좋다. 너무 잘게 분산해두면 이후 서버에서 데이터를 끌어올 때 상대적으로 많은 블록들을 오픈해야 하기 때문이다.</p><h2 id="hdfs-roles">HDFS Roles</h2><p>HDFS는 크게 마스터-워커 구조로 이루어져 있다. 마스터의 역할을 하는 서버를 네임 노드라고 하며, 워커 역할을 하는 서버를 데이터 노드라고 한다. HDFS의 역할들의 자세한 설명은 아래의 그림을 참고하자. 세컨더리 네임 노드의 경우 아래의 프로세스에서 자세히 설명할 것이다.</p><figure><img src="/images/125.png" alt="hdfsrole" /><figcaption aria-hidden="true">hdfsrole</figcaption></figure><p>이제 어느정도 HDFS가 어떻게 작동하는지 머리속에 그려질 것이다. HDFS는 데이터가 들어오면 여러 개의 블록으로 나눈다. 그 다음 여러 데이터 노드에 저장하고, 그 위치를 네임 노드에게 전달한다. 그러면 네임 노드는 한 파일에 대한 블록 개수와 위치 등을 메타 정보로 저장한다.</p><h2 id="hdfs-process">HDFS Process</h2><p>위 정보들을 바탕으로 HDFS가 작동하는 프로세스를 확인해보자. 아래의 그림에는 세컨더리 네임 노드(2NN)의 역할 또한 자세하게 설명되어 있다.</p><figure><img src="/images/126.png" alt="hdfsprc" /><figcaption aria-hidden="true">hdfsprc</figcaption></figure><p>네임 노드는 데이터 노드에게 지속적으로 HeartBeat를 받으며 상태를 모니터링한다. 네임 노드는 블록 변경 정보들을 edits이라는 파일에 저장해두었다가 일정 시간이 되면 세컨더리 네임 노드(2NN)에게 보낸다. 2NN은 edits의 내용들을 fsimage에 업데이트 하여 새로운 메타 정보(fsimage)를 생성하고 이를 다시 네임 노드에 보낸다.</p><h2 id="hdfs-ha-process">HDFS HA Process</h2><p>HA는 High Availability의 약자로 고가용성이라고도 한다. 일반적인 HDFS 구조에서는 네임노드가 어떤 이유로 정상작동을 하지 않을 시 즉각적으로 운영 상에 문제가 생긴다. 이런 부분을 방지하고자 네임 노드를 Active-StandBy 구조로 설정하여 액티브 네임 노드에 문제가 있을 시 바로 스탠바이 네임 노드가 작동할 수 있도록 한다. HA 구조로 설정한 HDFS의 프로세스는 아래의 그림과 같다.</p><figure><img src="/images/127.png" alt="hdfsHA" /><figcaption aria-hidden="true">hdfsHA</figcaption></figure><p>일반 HDFS 구조에서는 2NN이 존재했지만, HA구조에서는 스탠바이 네임 노드가 이를 대신한다. 또한 스탠바이 네임 노드가 액티브 네임 노드와 동일하게 업데이트가 진행되어야 하기에 저널 노드를 추가한다. 저널 노드는 블록 변경 기록을 바로 받아서 스탠바이 노드에 넘기는 역할을 한다. 저널노드를 3개 배치한 이유는 저널 노드끼리도 변경 기록이 유효한 정보인지를 검증하기 때문이다. 또한 액티브 네임노드는 더이상 edits를 생성 및 저장하지 않기 때문에 네임 노드의 할 일도 줄어든다.</p><h2 id="fault-tolerance">Fault tolerance</h2><p>HA구조로 네임노드의 가용성을 높였으니 그 다음은 내결함성을 보장하는 것이다. 이를 위해서 HDFS의 데이터 노드들은 데이터 블록들을 복제하여 저장한다. 이는 특정 데이터 노드가 정상작동하지 않을 시 유실될 데이터 블록들을 방지하기 위한 방법 중 하나이다.</p><h3 id="basic-replication-factor">Basic Replication factor</h3><p>HDFS는 3벌 복제를 디폴트 값으로 가진다. 즉, 데이터 블록들은 총 3개로 복제되어 다른 데이터 노드에 저장된다. 이 방법은 데이터 노드 2대까지 정상작동하지 않아도 시스템 운영상에는 문제 없도록 하지만 데이터 노드 3대 이상 문제가 생긴다면 데이터 유실이 발생하게 된다. 또한 기본이 3벌 복제라는 말은 한 가지를 암시하고 있다. 바로 HDFS의 데이터 노드는 최소 3대가 필요하다는 것이다. 복제된 데이터 블록들이 각각 다른 노드에 저장되어야 하기 때문에 복제 수에 따라 최소 데이터 노드 수도 달라진다.</p><h3 id="erasure-coding">Erasure Coding</h3><p>이레이저 코딩은 3벌 복제의 단점을 해결하기 위해 나온 방법이며, 하둡에는 버전 3부터 도입되었다. 원리는 아래의 그림을 참고하자.</p><figure><img src="/images/128.png" alt="EC" /><figcaption aria-hidden="true">EC</figcaption></figure><p>위 그림처럼 이레이저 코딩은 인코딩, 디코딩 방식으로 손실된 데이터를 복구한다. 데이터 블럭을 n개의 청크(덩어리)로 나눈 후, 이를 인코딩하여 n의 절반인 parity block를 생성한다. 이후 원본 청크 n개 중에 parity block 개수보다 이하로 손실이 된다면 이는 디코딩을 통해 원본을 복구할 수 있다.</p><p>그렇다면 인코딩 방식은 무엇일까? 이레이저 코딩에서는 RAID에서 주로 사용하는 Reed-Solomon 알고리즘을 사용한다. Reed-Solomon 알고리즘 원리는 아래 그림과 같다.</p><figure><img src="/images/140.png" alt="Reed-Solomon" /><figcaption aria-hidden="true">Reed-Solomon</figcaption></figure><h3 id="두-가지-방법-비교">두 가지 방법 비교</h3><p>두 가지 방법은 확실한 장단점이 있다. 3벌 복제는 간단하고, 어떤 연산도 요구되지 않지만 잘 사용하지 않는 데이터도 디스크 공간을 원데이터의 3배나 차지하게 된다. 그와 반면 이레이저 코딩은 인코딩, 디코딩 작업에서 연산이 필요하지만 차지하는 디스크 용량이 확실하게 줄어든다.</p><figure><img src="/images/129.png" alt="compare" /><figcaption aria-hidden="true">compare</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>BigData</category>
      
      <category>hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>빅데이터</tag>
      
      <tag>hadoop</tag>
      
      <tag>ecosystem</tag>
      
      <tag>hdfs</tag>
      
      <tag>HDFS</tag>
      
      <tag>datastorage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>빅데이터 플랫폼</title>
    <link href="/ko/Hadoop/hadoop-6/"/>
    <url>/ko/Hadoop/hadoop-6/</url>
    
    <content type="html"><![CDATA[<p>빅데이터와 빅데이터 플랫폼에 대한 개인적인 생각들을 정리합니다. <span id="more"></span></p><h2 id="빅데이터">빅데이터</h2><p>요즘 4차 산업혁명이라는 말과 함께 여기저기에서 <code>빅데이터</code>라는 단어를 들을 수 있다. 또한 빅데이터에 대한 정의는 아직까지 사람마다, 업계마다 조금씩 다른 것 같다. 그런 의미에서 빅데이터에 관심있는 사람들은 한 번쯤 "빅데이터란 어느정도 크기의 데이터를 말하는걸까?" 하는 고민이 있었을 것이다. 개인적으로 생각했던 빅데이터의 기준은 "하나의 컴퓨터(서버)로 핸들링할 수 없는 크기의 데이터"이다. 이렇게 생각한 근거는 개인적인 경험에 있다.</p><p>옛날에 주식데이터 분석 프로젝트에서 예상치 못한 난관을 만났던 적이 있다. 주식데이터를 열심히 크롤링해서 많은 데이터 소스를 가지게 되었고 이를 바탕으로 데이터 분석을 진행하려고 하였으나, 하나의 컴퓨터에서 모아둔 모든 데이터를 매니징 할 수 없었다. 파일을 전부 열 수도 없었고, 그렇기에 분석도 진행할 수 없었다. 물론 아마도 실제 운영에 사용하는 서버였다면 가능했겠지만 우리는 현재 사용중인 노트북이 전부였기에 이런 부분은 예상하지 못한 문제였던 것이다. 그 때 "아, 이게 빅데이터구나" 라는 것을 느꼈다. 빅데이터는 절대적인 크기가 있는 것이 아니라 제공된 자원에서 일반적인 방식으로 관리할 수 없는 크기의 데이터라는 생각이 문뜩 스쳐갔다.</p><h2 id="빅데이터-플랫폼">빅데이터 플랫폼</h2><p>그렇다면 위 상황에서 우리의 선택은 무엇이겠는가? 바로 빅데이터를 처리할 수 있는 여러 도구들을 찾아봤으며, 그 중 현실적으로 가능한 방안이 바로 저렴한 라즈베리 파이로 하둡 클러스터를 구축하는 것이었다. (클러스터 구축 관련된 글은 <a href="https://dev-bearabbit.github.io/categories/toyproject/clustering/">이 링크</a>를 클릭하면 볼 수 있다) 이때 처음 서버 여러 대를 하나의 컴퓨터처럼 사용하는 빅데이터 플랫폼에 대해서 알게 되었다.</p><h3 id="하둡hadoop">하둡(Hadoop)</h3><p>하둡은 대표적인 빅데이터 플랫폼 중 하나로, 여러 대의 서버를 클러스터로 구축하여 데이터들을 분산처리를 할 수 있는 플랫폼이다. 하둡의 구성은 크게 파일 저장소인 HDFS와 리소스 매니징을 담당하는 YARN으로 구성되어 있으며, 하둡에 저장된 모든 데이터에 관련된 처리는 맵리듀스(MR, MapReduce)라는 엔진으로 이루어진다. 즉, 하둡을 사용하기 위해서는 맵리듀스 요청 프로그램을 직접 작성할 수 있어야 한다. 하둡은 자바(JAVA) 언어로 만들어졌기에 요청 프로그램도 자바로 작성한다. 그 후 "jar" 파일을 생성해서 MR엔진이 있는 YARN을 통해 실행시키면 된다.</p><p>그렇다면 자바 개발자만 하둡을 사용할 수 있는가? 과거에는 그랬다. 하지만 지금은 많은 에코 시스템이 생겼기 때문에 sql문으로도 하둡 클러스터에 저장된 데이터를 가져올 수 있다. sql엔진으로는 하이브(hive)와 임팔라(impala), 스파크(spark) 등이 있다. 이처럼 하둡을 기반으로 한 여러 에코 시스템들이 존재한다. 현재 빅데이터 엔지니어로 일하면서 하둡 및 에코 시스템들을 실제 업무에서 사용하고 있으며, 또 공부한 내용들을 블로그에 하나씩 저장해두려고 한다. 다음 글부터는 하둡의 코어 서비스인 HDFS와 YARN를 시작으로 삼아 각각의 에코 시스템들을 기본 아키텍쳐에 대해서 정리할 계획이다.</p>]]></content>
    
    
    <categories>
      
      <category>BigData</category>
      
      <category>hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>빅데이터</tag>
      
      <tag>hadoop</tag>
      
      <tag>ecosystem</tag>
      
      <tag>hdfs</tag>
      
      <tag>hive</tag>
      
      <tag>impala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust Cargo 사용하기</title>
    <link href="/ko/Rust/rust-7/"/>
    <url>/ko/Rust/rust-7/</url>
    
    <content type="html"><![CDATA[<p>러스트 카고 사용법에 대해 공부한 내용을 정리합니다. <span id="more"></span></p><h2 id="cargo">Cargo</h2><p>카고는 러스트의 빌드 시스템이자 패키지 관리자이다. 간단한 러스트 프로그램들은 <code>rustc</code>를 통해 컴파일할 수 있지만 대형 프로젝트들은 이를 관리하고 공유하기 위한 담당자가 필요하다. 카고는 아래의 일들을 맡아서 처리한다.</p><ul><li>코드의 빌드</li><li>필요한 라이브러리 다운로드</li><li>라이브러리 빌드</li></ul><p>카고의 버전은 아래의 코드를 통해서 확인할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ cargo --version<br>    cargo 1.54.0 (5ae8d74b3 2021-06-22)<br></code></pre></td></tr></table></figure><h2 id="how-to-use">How to use</h2><p>이제 카고를 사용하여 프로젝트를 하나 생성해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ cargo new test_carge<br>     Created binary (application) `test_carge` package<br></code></pre></td></tr></table></figure><p>위 코드를 입력한 디렉토리에 <code>test_carge</code>라는 새로운 디렉토리를 생성한다. <code>test_carge</code>에 들어가보면 <code>Cargo.toml</code>의 파일과 <code>src</code>의 디렉토리가 있을 것이다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> test_carge/<br>$ <span class="hljs-built_in">ls</span><br>Cargo.toml      src<br></code></pre></td></tr></table></figure><p><code>Cargo.toml</code>을 열어보면 아래와 같은 내용이 작성되어 있다.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml">[<span class="hljs-string">package</span>]<br><span class="hljs-string">name</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;test_carge&quot;</span><br><span class="hljs-string">version</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-string">edition</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;2018&quot;</span><br><br><span class="hljs-comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span><br><br>[<span class="hljs-string">dependencies</span>]<br></code></pre></td></tr></table></figure><p>내용을 보면 알겠지만 이 파일은 카고의 설정 파일이다. 첫 번째 줄의 <code>[package]</code>는 패키지 설정을 위한 정보가 들어가며, 이 줄 아래에 사용하는 패키지 정보들을 입력하면 된다. 그 다음 입력된 정보들은 카고가 프로그램을 컴파일 할 때 필요한 이름, 버전, 러스트 에디션 등의 값들을 입력하는 구간이다. 마지막으로 <code>[dependencies]</code>는 프로젝트에서 사용하는 <code>크레이트(crate, 러스트의 패키지)</code> 목록들을 입력한다.</p><p>카고로 관리되는 프로젝트의 소스코드는 모두 <code>src</code> 디렉토리에 저장 및 보관한다. 따라서 카고가 생성한 최상위 디렉토리는 프로젝트의 설정파일, 라이센스, 사용법 등 전반적인 메타정보가 저장된다. 위 예시처럼 <code>Cargo.toml</code>, <code>src</code>가 기본적으로 생성되고 필요에 따라 <code>readme.md</code> 등도 생성할 수 있다.</p><p>이제 <code>src</code>에 들어가보자. 그러면 <code>main.rs</code>라는 소스코드 파일이 보일 것이다. 카고는 기본적으로 <code>main.rs</code>라는 파일을 생성하고 아래의 코드를 자동 입력해준다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="cargo-build">cargo build</h3><p>이제 위 코드를 기반으로 "Hello, world!" 프로그램을 빌드해보자. 빌드는 하고자 하는 프로젝트 디렉토리 최상단에서 아래의 코드를 입력하면 된다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">$ cargo build<br>   Compiling test_carge v0.<span class="hljs-number">1.0</span> (/Users/ryu/Desktop/STUDY/rust/test_carge)<br>    Finished dev [unoptimized + debuginfo] <span class="hljs-title function_ invoke__">target</span>(s) <span class="hljs-keyword">in</span> <span class="hljs-number">2.23</span>s<br></code></pre></td></tr></table></figure><p>그러면 최상단 디렉토리에 <code>Cargo.lock</code>이라는 파일과 <code>target</code>이라는 디렉토리가 생성된다. <code>Cargo.lock</code>는 의존 패키지의 정확한 버전을 추적하기 위하여 생성된 파일이며, 현재는 패키지를 사용하지 않기 때문에 내부에 내용이 별로 없는 것을 확인할 수 있다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"># This file is automatically @generated by Cargo.<br># It is not intended <span class="hljs-keyword">for</span> <span class="hljs-title class_">manual</span> editing.<br>version = <span class="hljs-number">3</span><br><br>[[package]]<br>name = <span class="hljs-string">&quot;test_carge&quot;</span><br>version = <span class="hljs-string">&quot;0.1.0&quot;</span><br></code></pre></td></tr></table></figure><p>그럼 컴파일된 프로그램 파일은 어디에 있을까? 바로 <code>target</code> 안에 위치한다. 정확한 위치는 <code>target/debug/</code>이며, 빌드 시 카고 프로젝트의 이름으로 실행 파일을 생성한다. 우리가 예시로 생성한 카고 프로젝트 이름이 <code>test_carge</code>이기에 실행 파일 이름도 <code>test_carge</code> 일 것이다. 이 해당 파일을 직접 실행시켜도 잘 작동한다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">$ target/debug/test_carge<br>Hello, world!<br></code></pre></td></tr></table></figure><h3 id="cargo-run">cargo run</h3><p>하지만 빌드 + 작동까지 한번에 진행해주는 명령어가 있다. 바로 <code>cargo run</code> 이다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust">$ cargo run<br>    Finished dev [unoptimized + debuginfo] <span class="hljs-title function_ invoke__">target</span>(s) <span class="hljs-keyword">in</span> <span class="hljs-number">0.02</span>s<br>     Running `target/debug/test_carge`<br>Hello, world!<br></code></pre></td></tr></table></figure><p>컴파일이 진행되지 않은 이유는 카고가 기존 코드와 변동된 것이 없는 것을 확인하고 바로 바이너리 파일을 실행했기 때문이다.</p><h3 id="cargo-check">cargo check</h3><p>만약 중간중간에 코드를 제대로 작성하고 있는지 확인하기 위해서는 어떻게 해야 할까? 빌드를 계속 해보면 되는걸까? 지금은 예시로 아주 간단한 코드를 작성하여 컴파일이 빨랐지만 실제 프로젝트를 진행하다보면 빌드는 비교적 시간이 더 필요하다. 그렇다면 코딩 천재처럼 한번에 코드를 모두 개발해야 할까? 당연히 아니다. 카고에서는 코드가 컴파일되는지 여부만 확인해보는 기능이 있다. 바로 <code>cargo check</code> 이다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">$ cargo check<br>    Checking test_carge v0.<span class="hljs-number">1.0</span> (/Users/ryu/Desktop/STUDY/rust/test_carge)<br>    Finished dev [unoptimized + debuginfo] <span class="hljs-title function_ invoke__">target</span>(s) <span class="hljs-keyword">in</span> <span class="hljs-number">0.16</span>s<br></code></pre></td></tr></table></figure><p><code>cargo check</code>를 사용하면 실행파일을 생성하는 과정들을 생략하므로 비교적 빠르게 오류들이 있는지 확인할 수 있다.</p><h3 id="cargo-build---release">cargo build --release</h3><p>이제 프로젝트가 어느정도 완성이 되면 최적화된 컴파일을 실행해야할 순간이 된다. 그때는 <code>cargo build</code>에 옵션 <code>--release</code>를 추가로 붙여서 컴파일을 실행한다. 해당 실행파일은 <code>target/debug/</code>에 생기는 것이 아니라 <code>target/release/</code>에 생성되며, 시간도 일반 빌드보다 오래걸린다.</p>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>start</tag>
      
      <tag>cargo</tag>
      
      <tag>setup</tag>
      
      <tag>tutorial</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Resume 1차 레이아웃 완성</title>
    <link href="/ko/Web/web-2/"/>
    <url>/ko/Web/web-2/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 엔지니어의 Resume를 생성하는 과정을 공유합니다. <span id="more"></span></p><h2 id="레이아웃-설계">레이아웃 설계</h2><p>이전 글에서 결정한 요구조건은 다음과 같다.</p><ul><li>PDF로 내보내기 위해서는 한 페이지에 모든 내용을 볼 수 있어야 한다.</li><li>Header에 애니메이션이 가미된 배경을 사용하여 생동감을 살리고 Navbar에 section을 연동시키자.</li><li>반응형에서도 문제없도록 심플한 구조로 작성하자.</li><li>구체적인 설명을 최대한 압축해서 작성하자.</li><li>PDF에서도 해당 웹페이지로 들어올 수 있도록 링크를 걸어두자.</li></ul><p>이를 바탕으로 설계를 시작하였으며, 먼저 단락을 어떻게 나눌지 고민하였다.</p><h2 id="섹션-나누기">섹션 나누기</h2><p>어떤 내용이 들어가야 할까? 처음 떠오른 것들은 기본적인 개인정보, 간단한 소개글, 학력, 경력, 프로젝트, 블로그, 깃허브 등 이었다. 이를 몇 개의 섹션으로, 또 어떤 순서로 배열하는게 좋을까? 고민하다가 읽는 이가 자연스럽게 나에 대한 정보를 쌓아갈 수 있으면 좋을 것 같다는 생각이 들었다. 그 결과 순서는 다음과 같다.</p><ul><li>개인정보 &amp; 간단한 소개</li><li>기술스택</li><li>블로그 &amp; 깃허브</li><li>경력</li><li>프로젝트</li><li>학력</li></ul><p>이렇게 나열한 이유는 아직 엔지니어로 일을 시작한지 1년도 안되었기 때문이다. 경력보다는 기술 스택이나 개인적으로 운영하는 블로그 &amp; 깃허브가 나를 표현하는 데 있어 좋은 방식이라고 생각했다. 그러면 경력은 왜 프로젝트보다 앞으로 배치했을까? 바로 차후에 진행되는 프로젝트들도 경력과 연관되어 있을 가능성이 99%기 때문이다. 즉, 내가 어떤 직무를 맡았을 때 했던 프로젝트인지를 연계하고자 경력을 먼저 언급하고 이후에 프로젝트의 세부적인 내용들을 제시한 것이다. 학력의 경우 사실 비전공자에 컴퓨터와는 전혀 상관이 없으므로 메리트 있는 요소는 아니라고 생각하여 맨 마지막에 배치하였다.</p><p>이제 위 섹션들의 이름을 정할 차례이다. 섹션 제목의 경우 한글보다는 영어로 작성하는 것이 단어의 길이가 짧아서 인식되기 쉬울 것으로 예상하였다. 결정한 제목들은 다음과 같다.</p><table><thead><tr class="header"><th>섹션제목</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>About</td><td>개인정보 &amp; 간단한 소개</td></tr><tr class="even"><td>Skills</td><td>기술스택</td></tr><tr class="odd"><td>Archiving</td><td>블로그 &amp; 깃허브</td></tr><tr class="even"><td>Experience</td><td>경력</td></tr><tr class="odd"><td>Project</td><td>프로젝트</td></tr><tr class="even"><td>Education</td><td>학력</td></tr></tbody></table><p>이제 디자인적인 요소들을 확인해보자.</p><h2 id="테마-설정하기">테마 설정하기</h2><p>자 어려운 문제에 도착하였다. 먼저 크게 3가지 정도를 결정해보기로 하였다.</p><ul><li>테마 컬러</li><li>글씨체</li><li>Header 배경</li></ul><p>먼저 테마 컬러이다. 사실 색상의 경우 "블로그와 컬러감이 유지 될 것"이라는 제한조건이 있었다. 그리하여 블로그 색상을 그래도 가져왔다. 색상은 크게 3가지이고 검정색, 회베이지색, 흰색이다. 검정색의 경우 부트스트랩에서 제공하는 <code>dark</code> 색상을 사용하였다.</p><p>그다음 글씨체이다. 처음에는 예쁜 글씨체를 다운받아서 사용하려고 했으나 이력서 특성 상 너무 가벼워보이면 안될 것 같아 제공된 고딕체를 사용하였다.</p><p>Header 배경은 정말 고민이 많았다. 웹페이지라는 부분을 살리고 싶어 애니메이션이 가미되었으면 좋겠다고 생각했는데, 화려한 애니메이션들은 생각보다 정신이 없었다. 그래서 배경화면은 "개발자스러운 표현, 컬러는 3개 이하, 흰색 또는 검은색 글씨가 오버레이 되어도 잘 보일 것"으로 제한을 걸고 찾아보았다. 그 결과 영화 매트릭스에 등장하는 검은색 배경에 숫자가 내려오는 애니메이션이 선택되었다.</p><h2 id="언어-설정하기">언어 설정하기</h2><p>이전 페이지는 한글과 영어를 같이 써두었다가 나중에는 영어만 남겨두었다. 하지만 국내에서 이직을 할 때 사용하려면 한국어 버전도 필요하였다. 처음에는 번역처럼 한글 아래에 영어를 작성하려고 하였으나 가독성도 좋지 못했고, 글이 너무 많아져서 해당 방법은 포기하였다. 어떻게 할까 하다가 상단 바에 언어를 선택할 수 있는 폼을 추가하였다. 이렇게 하면 나중에 이력서를 PDF로 만들어서 제출할 때도 언어에 따라서 제출할 수도 있고, 글도 추가되지 않는다.</p><p>일단 완성된 이력서는 <a href="https://dev-bearabbit.github.io/Resume/">해당 링크</a>에서 확인할 수 있다. 완성된 페이지는 이미 각 섹션 별로 레이아웃이 잡혀있고 글도 채워져 있다. 다음 글에서는 섹션 별 레이아웃과 내용 정리 등에 대해서 이야기해보고자 한다.</p>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>엔지니어</tag>
      
      <tag>개발자</tag>
      
      <tag>resume</tag>
      
      <tag>이력서</tag>
      
      <tag>커리어</tag>
      
      <tag>career</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[ADsP] 회귀분석</title>
    <link href="/ko/Certificate/ADsP-3/"/>
    <url>/ko/Certificate/ADsP-3/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 데이터분석 준전문가(ADsP) 자격증 공부 내용을 정리합니다. <span id="more"></span></p><h2 id="회귀분석">회귀분석</h2><ul><li>하나 이상의 독립변수들이 종속변수에 얼마나 영향을 미치는지 추정하는 통계기법.</li><li>기본적으로 연속형 변수일 때 사용하며, 범주형 변수일 경우 파생변수로 변환하여 사용.</li><li>종속변수가 범주형일 경우 로지스틱 회귀분석방법을 사용.</li><li>회귀계수: 독립변수가 종속변수에 미치는 영향의 정도. 회귀함수의 기울기를 의미.</li><li>회귀결정계수: 0-1 사이의 수로 인과관계의 정도를 나타내는 수.</li></ul><h3 id="회귀분석-기본가정">회귀분석 기본가정</h3><p>회귀분석의 결과가 유의미하기 위해서는 아래의 조건들이 요구된다.</p><ul><li>선형성: 독립변수와 종속변수는 선형적이어야 한다.(다항회귀분석은 예외)</li><li>독립성: 독립변수들 간에 상관성 없어야 한다.</li><li>등분산성: 분산이 같으며, 잔차들이 고르게 분포되어 있어야 한다. 등분산성을 만족하지 못하면 회귀선은 어떤 추세를 띠지 못하고 덩어리 모양을 하게 된다.</li><li>정규성: 잔차항이 정규분포 형태를 보여야 한다.</li></ul><h3 id="회귀분석-분산분석표">회귀분석 분산분석표</h3><table><thead><tr class="header"><th>용어</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>SST(총제곱합)</td><td>회귀식과 실제값의 차이를 제곱한 값,모형이 설명해야 하는 전체 부분(SSR+SSE)</td></tr><tr class="even"><td>SSR(회귀제곱합)</td><td>회귀식과 평균값의 차이,모형이 설명하는 부분</td></tr><tr class="odd"><td>SSE(오차제곱합)</td><td>편차의 제곱합, 모형이 설명하지 못하는 부분</td></tr></tbody></table><ul><li>회귀분석 결과를 분산분석을 통해 검증하고, 이로부터 도출된 결정계수 <span class="math inline">\(R^2\)</span>로 모형의 설명력을 판단한다. <span class="math display">\[R^2= \frac{Q-Q^e}{Q}= \frac{SSR}{SST}=\frac{1-SSE}{SSE+SSR}\]</span></li><li>다중회귀분석에서는 <code>수정된 결정계수</code>를 사용한다. <span class="math display">\[\text{adjusted } R^2= 1- \frac{(n-1)(1-R^2)}{n-p-1}\]</span></li></ul><h3 id="회귀분석-유의성-검증">회귀분석 유의성 검증</h3><p>1-1) 회귀모형 검증: F-검정</p><ul><li>모형의 통계적 유의성은 F-검정을 통해 확인.</li><li>분산의 차이를 나타내는 F-통계량 값이 크다는 것은 회귀계수가 크다는 의미이고, 이는 변수간의 유의미한 인과관계가 있음을 나타냄.</li><li>F값이 크면 F값이 0에 가까울 확률 값인 P값은 상대적으로 작아짐. 인과관계가 있을 확률이 높아짐.</li></ul><p>1-2) 회귀계수 검증: t-검정</p><ul><li>t-통계량은 회귀계수를 표준오차로 나눈 값이기에 t값이 크다는 것은 표준오차가 상대적으로 작다는 의미이다.</li><li>t-통계량이 커지면 회귀계수도 크다는 의미이므로 인과관계가 존재한다고 판단할 수 있다.</li></ul><table style="width:6%;"><tbody><tr class="odd"><td><strong>NOTE. P값 정리표</strong></td></tr><tr class="even"><td>|내용|p&lt;0.05|p&gt;0.05| |---|-----|------| |F값|크다(분산차이 크다)| 작다(분산차이 작다)| |회귀추세선|가파르다|완만하다| |기각역|기각역 안에 있다.(대립가설채택)| 기각역 밖에 있다.(귀무가설채택)| |독립변수|독립변수는 종속변수에 영향 O|독립변수는 종속변수에 영향 X| |우연 확률|우연히 발생 X | 우연히 발생 O| |인과관계|유의미한 관계 O|유의미한 관계 X|</td></tr></tbody></table><h3 id="회귀분석-종류">회귀분석 종류</h3><ul><li>단순회귀: 1개의 독립변수와 반응변수가 직선(선형) 관계 <span class="math display">\[Y=\beta_0+\beta_1X+\epsilon\]</span></li><li>다중회귀: k개의 독립변수와 반응변수가 선형 관계 <span class="math display">\[Y=\beta_0+\beta_1X_1+\cdots+\beta_kX_k+\epsilon\]</span></li><li>다항회귀: k개의 독립변수와 반응변수가 2차함수 이상의 관계 <span class="math display">\[Y=\beta_0+\beta_1X^1+\cdots+\beta_kX^k+\epsilon\]</span></li><li>비선형회귀: 회귀식이 미지의 모수들과 선형관게가 아닌 경우(지수함수, 로그함수, 삼각함수 등) <span class="math display">\[Y=\alpha e^{\beta_1X}+\epsilon\]</span> <span class="math display">\[Y=\alpha \ln \beta_1X+\epsilon\]</span></li></ul><h2 id="단순선형회귀분석">단순선형회귀분석</h2><ul><li>독립변수와 종속변수가 1개씩일 때 둘 사이의 인과관계를 분석하는 방법</li><li>최소제곱법을 활용하여 실제 데이터와 오차가 가장 작아지는 직선의 방정식을 찾는다.</li></ul><h2 id="다중선형회귀분석">다중선형회귀분석</h2><ul><li>독립변수가 2개 이상이고 종속변수가 하나일 때 사용 가능한 분석방법</li><li>단순회귀분석이 확장된 형태로 회귀계수 및 통계적 유의성은 동일하다.</li><li>독립변수가 여러 개이므로 회귀계수도 여러 개이다.</li></ul><h3 id="다중공선성-개념">다중공선성 개념</h3><ul><li>회귀분석에서 독립변수 간에 강한 상관관계가 나타나는 문제</li><li>다중공선성은 회귀분석의 기본가정인 독립성에 위배된다.</li></ul><h3 id="다중공선성-진단">다중공선성 진단</h3><ul><li>결정계수(<span class="math inline">\(R^2\)</span>)값이 커서 설명력은 높지만 P값도 커서 개별 인자가 유의하지 않은 경우에 의심 -&gt; 독립변수 간의 상관계수를 구해본다. -&gt; 분산팽창요인(VIF)를 구해 이 값이 10을 넘는다면 다중공선성이 있다고 판단할 수 있다. <span class="math display">\[VIF=\frac{1}{1-R^2}\]</span></li></ul><h3 id="다중공선성-해결방법">다중공선성 해결방법</h3><ul><li>문제가 발생하는 변수를 제거한다.</li><li>주성분분석(PCA)를 통해 변수 차원을 축소한다.</li><li>선형판별분석(LDA)로 차원을 축소한다.</li><li>특잇값분해(SVD)로 차원을 축소한다.</li></ul><h2 id="최적-회귀방정식">최적 회귀방정식</h2><ul><li>종속변수에 유의미한 영향을 미칠 것으로 생각되는 독립변수를 찾는 방법</li><li>보통 모델의 성능을 향상시키기 위해 사용한다.</li></ul><h3 id="부분집합법">부분집합법</h3><p>가능한 모든 모델을 고려하여 가장 좋은 모델을 선정하는 방법</p><h3 id="변수선택법">변수선택법</h3><p>일정한 단계를 거치면서 변수를 추가하거나 제거하는 방식으로 최적의 방정식을 도출하는 방법</p><ul><li>전진선택법</li><li>후진제거법</li><li>단계별 방법</li></ul>]]></content>
    
    
    <categories>
      
      <category>etc.</category>
      
      <category>certificate</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ADsP</tag>
      
      <tag>데이터자격시험</tag>
      
      <tag>데이터분석</tag>
      
      <tag>자격증</tag>
      
      <tag>R</tag>
      
      <tag>python</tag>
      
      <tag>통계</tag>
      
      <tag>통계분석</tag>
      
      <tag>회귀분석</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[ADsP] 기초 통계</title>
    <link href="/ko/Certificate/ADsP-2/"/>
    <url>/ko/Certificate/ADsP-2/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 데이터분석 준전문가(ADsP) 자격증 공부 내용을 정리합니다. <span id="more"></span></p><h2 id="t-검정">t-검정</h2><h3 id="단일-표본-t-검정">(단)일 표본 t-검정</h3><ul><li>가설검정의 일종으로 하나의 모집단의 평균값을 특정 값과 비교할 때 사용하는 통계적 분석 방법이다.</li></ul><table><thead><tr class="header"><th>종류</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>일 표본 단측 t-검정</td><td>모수값이 크다/작다와 같이 한쪽으로의 방향성을 갖는 경우 사용</td></tr><tr class="even"><td>일 표본 양측 t-검정</td><td>모수값이 크다/작다와 같이 한쪽으로의 방향성을 갖지 않는 경우 사용</td></tr></tbody></table><h3 id="독립이-표본-t-검정">독립(이) 표본 t-검정</h3><ul><li>가설검정의 일종으로 서로 독립적인 두 개의 집단에 대하여 모수의 값이 같은 값을 가지는지 검정하는 방법이다.</li><li>두 모집단의 분산이 같음을 의미하는 등분산성을 만족하는 경우에 검정을 진행하기에 F 검정을 먼저 수행한 후 진행한다.</li></ul><table><thead><tr class="header"><th>종류</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>이 표본 단측 t-검정</td><td>두 집단 사이의 대소가 있는 경우 사용</td></tr><tr class="even"><td>이 표본 양측 t-검정</td><td>두 집단 사이의 대소 없는 경우 사용</td></tr></tbody></table><h3 id="대응-표본-t-검정">대응 표본 t-검정</h3><ul><li>동일한 대상에 대해 두 가지 관측치가 있는 경우 이를 비교하여 차이가 있는지 검정할 때 사용</li><li>주로 실험 전과 후를 비교하기 위해 사용한다.</li></ul><h2 id="분산분석anova">분산분석(ANOVA)</h2><ul><li>분산분석은 세 개 이상의 모집단이 있을 경우 여러 집단 사이의 평균을 비교하는 검정 방법이다.</li><li>분산분석의 귀무가설은 항상 <strong>"집단 간 평균의 차이는 같다"</strong>이다.</li><li>분산분석의 단점으로는 귀무가설이 기각될 경우 각 집단들의 차이를 정확하게 알려주지 않는다는 것이다.</li><li>분산분석에는 <code>집단 간 분산/집단 내 분산</code>인 <strong>F-value</strong>가 사용된다.</li><li>분산분석은 <strong>독립변수: 범주형 데이터, 종속변수: 연속형 데이터</strong> 만을 취급한다.</li></ul><table><thead><tr class="header"><th>종류</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>일원분산분석</td><td>독립변수와 종속변수가 모두 한 개인 경우 사용</td></tr><tr class="even"><td>이원분산분석</td><td>독립변수가 두 개 이상일 때 사용</td></tr><tr class="odd"><td>다변량분산분석</td><td>종속변수가 두 개 이상일 때 사용</td></tr></tbody></table><h2 id="교차분석">교차분석</h2><ul><li>범주형 자료(명목, 서열)간의 관계를 알아보고자 할 때 사용되는 분석 방법.</li><li>카이제곱(<span class="math inline">\(x^2\)</span>)검정 통계량을 이용.</li><li>적합도 검정, 독립성 검정, 동질성 검정에 사용.</li><li><strong>교차분석표</strong>를 통해 분석.</li></ul><h3 id="적합도-검정">적합도 검정</h3><ul><li>실험결과 얻어진 관측값이 예상값과 일치하는지 여부를 검정하는 방법</li><li>모집단 분포에 대한 가정(기대도수)이 옳게 되었는지 관측값(관측도수)과 비교하여 검정한다.</li></ul><h3 id="독립성-검정">독립성 검정</h3><ul><li>모집단이 두 개의 변수에 의해 범주화됐을 때 그 두 변수들 사이의 관계가 독립적인지 여부를 검정하는 방법</li><li>변수들 사이의 관계가 독립적이라면 유의한 관계가 없다고 판단한다.</li><li>해당 검정은 관계여부만을 보여줄 뿐 관계 강도를 보여주지 않는다.(관계 강도는 상관분석)</li></ul><h3 id="동질성-검정">동질성 검정</h3><ul><li>관측값들이 정해진 범주 내에서 비슷하게 나타나고 있는지 검정하는 방법</li><li>모집단에서 보이는 속성을 추출한 표본집단에서도 동일하게 보이고 있는지를 확인한다.</li></ul><h2 id="상관분석">상관분석</h2><ul><li>두 변수 간의 선형적 관계가 존재하는지 알아보는 분석 방법</li><li>상관계수(-1과 1사이의 값)를 사용하여 상관관계를 표현한다.</li><li>상관관계가 있다고 해도 인과관계는 없을 수 있다.</li><li>산점도 행렬을 사용하여 여러 변수를 조합한 산점도와 상관계술를 한 화면에서 확인할 수 있다.</li></ul><h3 id="피어슨-상관분석선형적-상관관계">피어슨 상관분석(선형적 상관관계)</h3><ul><li>피어슨 상관계수는 모수적 방법의 하나로 두 변수가 모두 정규분포를 따른다는 가정이 필요하다.</li><li>모수검정: 표본이 정규성을 갖는다는 모수적 특성을 이용하는 통계 방법(표본의 정규성 전제되어야 함)</li></ul><h3 id="스피어만-상관분석비선형적-상관관계">스피어만 상관분석(비선형적 상관관계)</h3><ul><li>측정된 두 변수들이 서열척도일 때 사용하는 상관계수이다.</li><li>비모수검정: 표본이 정규분포를 따른다고 가정할 수 없는 경우에 사용하는 통계방법</li></ul>]]></content>
    
    
    <categories>
      
      <category>etc.</category>
      
      <category>certificate</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ADsP</tag>
      
      <tag>데이터자격시험</tag>
      
      <tag>데이터분석</tag>
      
      <tag>자격증</tag>
      
      <tag>R</tag>
      
      <tag>python</tag>
      
      <tag>통계</tag>
      
      <tag>통계분석</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[ADsP] 통계의 이해</title>
    <link href="/ko/Certificate/ADsP-1/"/>
    <url>/ko/Certificate/ADsP-1/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 데이터분석 준전문가(ADsP) 자격증 공부 내용을 정리합니다. <span id="more"></span></p><h2 id="통계-개요">통계 개요</h2><p>통계란 불확실한 상황에서 효과적인 의사결정을 할 수 있도록 수치자료를 수집, 정리, 표현, 분석하는 이론과 연구를 하는 학문이다. 통계분석이란 특정 집단을 대상으로 자료를 수집하여 대상 집단에 대한 정보를 구하고, 적절한 통계분석 방법을 이용하여 의사결정을 하는 과정을 말한다.</p><h3 id="표본조사">표본조사</h3><p>자료를 수집함에 있어 모집단으로부터 표본집단을 선출하는 조사 방식. 표본집단은 모집단을 대표할 수 있어야 한다는 표본의 대표성을 가져야 한다.</p><ul><li>오차범위: 가설에서 오차로 설정될 수 있는 범위</li><li>신뢰수준: 100번을 선발했을 때 가설이 맞을 확률</li></ul><h3 id="표본추출방법">표본추출방법</h3><table><thead><tr class="header"><th>방법</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>단순 랜덤 추출법</td><td>모집단에서 필요한 개수의 데이터를 무작위로 추출</td></tr><tr class="even"><td>계통 추출법</td><td>모집단에 번호를 붙이고 일정한 간격으로 추출</td></tr><tr class="odd"><td>군집(집락) 추출법</td><td>각 군집은 동질적, 군집 내 데이터는 이질적으로 묶은 뒤, 랜덤 추출법으로 군집을 선택</td></tr><tr class="even"><td>층화 추출법</td><td>각 군집은 이질적, 군집 내 데이터는 동질적으로 묶은 뒤, 각 군집에서 원하는 개수만큼 추출</td></tr></tbody></table><ul><li>비례 층화 추출법: 모집단 데이터 분포에 맞도록 추출할 개수를 선택</li><li>불비례 층화 추출법: 모집단 데이터 분포와 상관없이 추출할 개수를 선택</li></ul><h3 id="측정과-척도">측정과 척도</h3><ul><li>측정: 실험단위로부터 적합하게 관측된 데이터를 그대로 자료화하는 것</li><li>척도: 관측 대상의 속성을 측정하여 이를 숫자로 나타내도록 일정한 규칙을 통해 바꾸는 도구</li></ul><p>1-1) 질적 척도</p><table><thead><tr class="header"><th>구분</th><th>특징</th><th>예시</th></tr></thead><tbody><tr class="odd"><td>명목척도</td><td>측정대상이 어느 <strong>집단</strong>에 속하는지 나타내는 자료</td><td>성별, 지역 등</td></tr><tr class="even"><td>순서(서열)척도</td><td>측정 대상이 <strong>명목척도</strong>이면서 <strong>서열</strong>을 같는 자료</td><td>선호도, 신용도, 학년 등</td></tr></tbody></table><p>1-2) 양적 척도</p><table><thead><tr class="header"><th>구분</th><th>특징</th><th>예시</th></tr></thead><tbody><tr class="odd"><td>구간(등간)척도</td><td>측정대상 속성이 두 <strong>구간</strong> 사이에 의미가 있는 자료</td><td>온도, 지수 등</td></tr><tr class="even"><td>비율척도</td><td>측정대상 속성이 <strong>구간척도</strong>이면서 <strong>절대적 기준</strong> 0이 존재하는 자료</td><td>신장, 무게, 점수, 가격 등</td></tr></tbody></table><h3 id="기술통계와-추리통계">기술통계와 추리통계</h3><ul><li>기술통계: 표본 자체의 속성이나 특징을 파악하기 위한 통계기법. 모집단의 특성을 유추하는 데 사용.</li><li>추리통계: 수집한 데이터를 바탕으로 추론 및 예측하는 통계기법. 모집단의 특성 파악, 가설 검증, 확률적 가능성 파악 등에 사용.</li></ul><table style="width:6%;"><tbody><tr class="odd"><td><strong>NOTE. 통계기초상식</strong> 통계를 이해하기 위해서는 기본적으로 3가지 개념을 알고 있어야 한다.</td></tr><tr class="even"><td>- 편차(difference): 데이터의 평균으로부터 떨어져 있는 정도 - 분산(variance): 데이터 편차를 나타내는 분포. 편차 제곱 합의 평균. 보통 산점도(scatter)로 표현. - 표준편차(standard deviation): 분산의 단위 오류를 해결. 분산에 루트를 씌워 값 도출.</td></tr></tbody></table><h2 id="확률과-확률분포">확률과 확률분포</h2><h3 id="개념-정리">개념 정리</h3><ul><li><p>확률: 모든 사건들의 집합 표본에서 부분집합인 특정 사건 A가 발생할 수 있는 비율을 나타내는 값. 총 확률의 합은 항상 1이다. <span class="math display">\[P(A)\]</span></p></li><li><p>조건부 확률: 특정 사건 A가 발생했다는 전제 하에 특정 사건 B가 발생할 확률을 나타내는 값. 0과 1사이의 값을 갖는다. <span class="math display">\[P(B|A) = \frac{P(B\cap A)}{P(A)}\]</span></p></li><li><p>독립사건: 서로에게 영향을 주지 않는 두 개의 사건. <span class="math display">\[P(B\cap A) = P(B)P(A)\]</span> <span class="math display">\[P(B|A) = P(B)\]</span></p></li><li><p>배반사건: 두 사건의 교집합이 없는 경우. 즉, 동시에 일어날 수 없는 사건. <span class="math display">\[B\cap A = \phi\]</span></p></li><li><p>확률변수: 무작위 실험 시 특정 확률로 발생하는 각각의 결과를 값으로 표현하는 변수.</p></li><li><p>확률분포: 확률변수의 모든 값과 그에 대응하고 있는 확률의 분포.</p></li></ul><table><thead><tr class="header"><th>변수</th><th>분포</th><th>함수</th></tr></thead><tbody><tr class="odd"><td>이산확률변수</td><td>이산확률분포</td><td>확률질량함수</td></tr><tr class="even"><td>연속확률변수</td><td>연속확률분포</td><td>확률밀도함수</td></tr></tbody></table><h3 id="이산확률">이산확률</h3><ul><li><p>이산확률변수: 셀 수 있는 변수. 서로 배반인 사건들의 합집합의 확률은 1이다. <span class="math display">\[0\le p(X) \le 1\]</span> <span class="math display">\[\sum p(X) = 1\]</span></p></li><li><p>이산확률분포: 이산확률변수의 모든 값과 그에 대응하고 있는 확률의 분포.</p><ul><li>베르누이 분포<span class="math inline">\(B(1,p)\)</span>: 확률이 2가지이며 확률변수가 0,1 또는 1,-1인 분포 <span class="math display">\[p(x)=p^x(1-p)^{(1-x)}\]</span></li><li>이항 분포<span class="math inline">\(B(n,p)\)</span>: <span class="math inline">\(n\)</span>번의 베르누이 시행에서 <span class="math inline">\(x\)</span>번 성공할 확률의 분포 <span class="math display">\[p(x)=\dbinom{n}{x}p^x(1-p)^{(N-x)}\]</span></li><li>기하 분포<span class="math inline">\(Geo(p)\)</span>: 성공확률이 <span class="math inline">\(p\)</span>인 베르누이 실행에서 처음으로 성공이 나올 때까지 <span class="math inline">\(x\)</span>번 실패할 확률의 분포 <span class="math display">\[p(x)=p(1-p)^x\]</span></li><li>다항 분포<span class="math inline">\(M(n,p_1,p_2,...)\)</span>: <span class="math inline">\(n\)</span>의 시행에서 각 시행이 3개 이상의 결과를 가질 수 있는 분포 <span class="math display">\[p(x_1,x_2...)=\frac{n!}{x_1!+x_2!,...}p_1^{x_1}p_2^{x_2}...\]</span></li><li>포아송 분포<span class="math inline">\(Pois(\lambda)\)</span>: 단위 시간 또는 단위 공간 내에서 발생할 수 있는 사건의 발생 횟수에 대한 확률 분포 <span class="math display">\[p(x)=\frac{e^{-\lambda} \cdot \lambda^x}{x!}\]</span></li></ul></li><li><p>이산확률변수 기댓값 <span class="math display">\[E(X)=\sum xf(x)\]</span></p></li><li><p>이산확률변수 분산 <span class="math display">\[Var(X)=E[(X-E(X))^2]=E(X^2)-E(X)^2\]</span></p></li><li><p>이산확률변수 표준편차 <span class="math display">\[sd(X)=\sqrt{Var(X)}\]</span></p></li></ul><h2 id="연속확률">연속확률</h2><ul><li><p>연속확률변수: 해당하는 실수 값이 어떤 특정 구간에 해당하여 그 수를 셀 수 없는 변수. 확률밀도함수의 아래 면적이 확률을 의미한다. <span class="math display">\[ p(a \le x \le b) = \int_{a}^{b} xf(x)dx\]</span></p></li><li><p>연속확률분포: 연속확률변수의 모든 값과 그에 대응하고 있는 확률의 분포.</p></li></ul><table><thead><tr class="header"><th>종류</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>균일 분포</td><td>연속확률변수 X가 취할 수 있는 모든 값에 대하여 같은 확률을 가진 분포</td></tr><tr class="even"><td>정규 분포</td><td>평균이 <span class="math inline">\(\mu\)</span>이고 표준편차가 <span class="math inline">\(\alpha\)</span>인 분포 (<span class="math inline">\(X \sim N(\mu, \alpha^2)\)</span>)</td></tr><tr class="odd"><td>t-분포</td><td>자유도가 <span class="math inline">\(n\)</span>인 분포. 자유도가 커질수록 표준정규분포애 가까워진다.</td></tr><tr class="even"><td>카이제곱 분포</td><td><span class="math inline">\(n\)</span>의 독립적인 표준졍규분포의 제곱의 합으로 얻을 수 있는 분포로 모집단의 구성을 파악하기 위한 동질성검정에 사용된다.</td></tr><tr class="odd"><td>F 분포</td><td>정규분포를 이루는 모집단에서 독립적으로 추출한 표본들의 분산비율을 나타내며, 등분산검정, 분산분석에 활용된다.</td></tr></tbody></table><ul><li><p>연속확률변수 기댓값 <span class="math display">\[E(X)=\int xf(x)dx\]</span></p></li><li><p>연속확률변수 분산 <span class="math display">\[Var(X)=\int (x-E(X))^2xf(x)dx=\int x^2f(x)dx - \int xf(x)dx^2\]</span></p></li><li><p>연속확률변수 표준편차 <span class="math display">\[sd(X)=\sqrt{Var(X)}\]</span></p></li></ul><h3 id="통계-개념-정리">통계 개념 정리</h3><ul><li>기댓값(<span class="math inline">\(E(X)\)</span>): 특정 사건이 시행되었을 때 확률변수가 취할 수 있는 값의 평균. 확률변수와 그 사건이 발생할 확률의 곱들의 합으로 구할 수 있다.</li><li>분산(<span class="math inline">\(Var(X)\)</span>): 데이터들이 중심에서 얼마나 떨어져이는지 알아보기 위한 측도. 값이 크면 확률 값이 기댓값에서 멀리 떨어져 있다고 해석한다.</li><li>첨도(<span class="math inline">\(k\)</span>): 확률분포의 뾰족한 정도를 나타내는 측도로서 값이 3에 가까울수록 정규분포 모양을 갖는다.</li><li>왜도(<span class="math inline">\(\gamma\)</span>): 호가률분포의 비대칭 정도를 나타내는 측도로서 왜도 값이 0인 경우 정규분포와 유사한 모습을 가지며 평균, 중앙값, 최빈값이 모두 같다.</li><li>공분산(<span class="math inline">\(Cov(X,Y\)</span>): 두 확률변수 X,Y의 상관 정도를 나타내는 값. 상관 정도는 공분산이 0이면 서로 독립적이며 공분산이 0보다 작으면 반비례, 크면 비례한다.</li><li>상관계수(Correlation): 공분산을 보다 명확히 파악하기 위해 사용하는 값. 공분산을 -1과 1 사이의 값으로 나타내기 위해 표준편차의 곱으로 나눈 값이다.</li></ul><h2 id="추정과-가설검정">추정과 가설검정</h2><h3 id="추정">추정</h3><ul><li>모수 추정: 모집단의 확률분포 및 특성을 모수라고 하는데, 이를 도출하는 것은 어렵기에 표본조사를 통해 모수를 추정한다.</li><li>점 추정: 모수 중 특히 모평균을 하나의 특정한 값으로 추정하는 것. 보통 불편추정량을 사용한다. 불편(unbiased)추정량은 모수 추정값과 실제 모수값 차이의 기댓값이 0으로 어느 한쪽에도 편향되지 않아 이상적인 값을 의미한다.</li><li>구간추정: 모수가 특정한 구간 안에 존재할 것이라고 예상하는 것. 구간추정은 모수가 특정 구간에 포함될 확률인 신뢰도를 필요로 한다.</li></ul><h3 id="가설검정">가설검정</h3><ul><li>통계적 가설검정: 통계적 가설을 세우고 표본에서 얻은 정보를 이용해 가설이 옳은지를 판정하는 과정</li><li>통계적 가설: 모집단의 특정에 대한 주장 또는 가설</li></ul><table><thead><tr class="header"><th>종류</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>귀무가설(<span class="math inline">\(H_0\)</span>)</td><td>증명하고자 하는 가설이 의미가 없다고 주장하는 가설. 귀무가설을 기각시킴으로 주장을 입증할 수 있다.</td></tr><tr class="even"><td>대립가설(<span class="math inline">\(H_1\)</span>)</td><td>귀무가설의 반대 가설로 귀무가설이 틀렸다고 판단될 경우 채택된다.</td></tr></tbody></table><ul><li>제 1종 오류: 귀무가설이 사실임에도 불구하고 틀렸다고 결정하는 오류</li><li>제 2종 오류: 귀무가설이 틀렸음에도 불구하고 사실이라고 결정하는 오류</li></ul><table><thead><tr class="header"><th>실제 결과</th><th><span class="math inline">\(H_0\)</span> 채택(<span class="math inline">\(H_1\)</span>기각)</th><th><span class="math inline">\(H_0\)</span> 기각(<span class="math inline">\(H_1\)</span> 채택)</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(H_0\)</span> 사실</td><td>올바른 결정</td><td>제1종 오류</td></tr><tr class="even"><td><span class="math inline">\(H_0\)</span> 거짓</td><td>제2종 오류</td><td>올바른 결정</td></tr></tbody></table><ul><li><p>검정통계량: 귀무가설의 채택 여부를 판단하기 위해 표본조사를 실시하였을 때 특정 수식에 의하여 표본들로부터 얻을 수 있는 값. 즉, 귀무가설의 옳고 그름을 판단할 수 있는 값이다.</p></li><li><p>기각역: 귀무가설을 기각하게 될 검정통계량의 영역. 검정통계량이 기각역 내에 있으면 귀무가설을 기각한다.</p></li><li><p>유의수준(<span class="math inline">\(\alpha\)</span>): 귀무가설이 참임에도 이를 잘못 기각하는 오류(제1종 오류)를 범할 확률의 최대 허용 한계. 1%(0.01), 5%(0.05)를 보통 사용.</p></li><li><p>유의확률(p-value): 귀무가설을 지지하는 정도를 나타낸 확률. 유의확률 &lt; 유의수준이면 귀무가설을 기각할 수 있다.</p></li><li><p>가설검정 절차</p></li></ul><table><thead><tr class="header"><th>단계</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>1. 가설 설정</td><td>귀무가설, 대립가설</td></tr><tr class="even"><td>2. 검정의 유의수준 결정</td><td>0.01, 0.05, 0.1 등</td></tr><tr class="odd"><td>3. 검정방법 결정</td><td>-</td></tr><tr class="even"><td>4. 검정통계량 산출</td><td>p-value 산출</td></tr><tr class="odd"><td>5. 기각역 판단</td><td>유의확률 &lt; 유의수준 인가 확인</td></tr><tr class="even"><td>6. 결론</td><td>귀무가설 수용 혹은 대립가설 채택</td></tr></tbody></table><ul><li>모수검정: 표본이 정규성을 갖는다는 모수적 특성을 이용하는 통계 방법(표본의 정규성 전제되어야 함)</li><li>비모수검정: 표본이 정규분포를 따른다고 가정할 수 없는 경우에 사용하는 통계방법</li></ul><table><thead><tr class="header"><th>모수검정</th><th>비모수검정</th></tr></thead><tbody><tr class="odd"><td>등간척도,비율척도</td><td>명목척도, 서열척도</td></tr><tr class="even"><td>평균</td><td>중앙값</td></tr><tr class="odd"><td>피어슨상관계수</td><td>스피어만 순위상관계수</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>etc.</category>
      
      <category>certificate</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ADsP</tag>
      
      <tag>데이터자격시험</tag>
      
      <tag>데이터분석</tag>
      
      <tag>자격증</tag>
      
      <tag>R</tag>
      
      <tag>python</tag>
      
      <tag>통계</tag>
      
      <tag>통계분석</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 제네릭 타입</title>
    <link href="/ko/Rust/rust-6/"/>
    <url>/ko/Rust/rust-6/</url>
    
    <content type="html"><![CDATA[<p>러스트 제네릭 타입에 대해 공부한 내용을 정리합니다. <span id="more"></span></p><h2 id="제네릭-타입이란">제네릭 타입이란</h2><p>보편적으로 함수 코드를 작성할 때는 매개변수와 결과값에 대한 데이터 타입을 지정한다. 그렇기에 해당 함수는 지정한 데이터 타입을 이외의 다른 타입이 매개변수로 들어온다면 타입에러를 발생시킨다. 따라서 만약 정수와 문자 모두를 매개변수로 받는 프로그램을 만들고 싶다면 아래와 같은 코드가 필요하다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">find_max_i32</span>(list: &amp;[<span class="hljs-type">i32</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">max</span> = list[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-keyword">for</span> &amp;item <span class="hljs-keyword">in</span> list.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>        <span class="hljs-keyword">if</span> item &gt; max  &#123;<br>            max = item;<br>        &#125;<br>    &#125;<br>    max<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">find_max_char</span>(list: &amp;[<span class="hljs-type">char</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">char</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">max</span> = list[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-keyword">for</span> &amp;item <span class="hljs-keyword">in</span> list.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>        <span class="hljs-keyword">if</span> item &gt; max  &#123;<br>            max = item;<br>        &#125;<br>    &#125;<br>    max<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">i32_list</span> = [<span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">15</span>, <span class="hljs-number">30</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">i32_result</span> = <span class="hljs-title function_ invoke__">find_max_i32</span>(&amp;i32_list);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;max num: &#123;&#125;&quot;</span>, i32_result);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">char_list</span> = [<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;j&#x27;</span>,<span class="hljs-string">&#x27;k&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">char_result</span> = <span class="hljs-title function_ invoke__">find_max_char</span>(&amp;char_list);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;max char: &#123;&#125;&quot;</span>, char_result);<br>    &#125;<br></code></pre></td></tr></table></figure><p>위에서 정의된 함수 <code>find_max_i32()</code> <code>find_max_char()</code>은 매개변수와 결과값은 데이터 타입만 다를 뿐 동일한 로직을 가지고 있다. 만약 위 예시처럼 두 가지가 아닌 모든 데이터 타입을 받는 함수를 작성하고 싶다면 어떻게 해야할까? 예시처럼 모든 데이터 타입에 맞추어 코드를 짜는 것은 복잡하다.</p><p>위와 같은 상황에서 사용할 수 있는 방법이 바로 <code>제네릭 타입</code>이다. 제네릭 타입이란 말 그대로 데이터 타입을 정의해야 하는 부분을 대신하는 추상적인 데이터 타입이다. 이번 글에서는 데이터 타입을 정의해야 하는 상황에 따라 어떻게 제네릭 타입을 사용하는지 알아볼 것이다.</p><h2 id="함수-정의">함수 정의</h2><p>위 예시를 그대로 사용해보자. 위 예시에서는 i32 타입과 char 타입의 데이터를 모두 받아서 처리하는 프로그램을 작성하기 위한 방법 중 하나였다. 이는 각각의 데이터 타입에 맞춰 코드를 작성해야 하기에 코드가 길고 중복된다는 문제점이 있었다. 이를 제네릭 타입을 사용하여 수정해보자.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">find_max</span>(list: &amp;[T]) <span class="hljs-punctuation">-&gt;</span> T &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">max</span> = list[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-keyword">for</span> &amp;item <span class="hljs-keyword">in</span> list.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>        <span class="hljs-keyword">if</span> item &gt; max  &#123;<br>            max = item;<br>        &#125;<br>    &#125;<br>    max<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">i32_list</span> = [<span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">15</span>, <span class="hljs-number">30</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">i32_result</span> = <span class="hljs-title function_ invoke__">find_max</span>(&amp;i32_list);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;max num: &#123;&#125;&quot;</span>, i32_result);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">char_list</span> = [<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;j&#x27;</span>,<span class="hljs-string">&#x27;k&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">char_result</span> = <span class="hljs-title function_ invoke__">find_max</span>(&amp;char_list);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;max char: &#123;&#125;&quot;</span>, char_result);<br>    &#125;<br></code></pre></td></tr></table></figure><p>이전의 예시 코드의 위 코드의 차이점은 무엇인가? 일단 max값을 찾는 코드가 하나로 줄었다. 또한 그 함수이름 옆에 <code>&lt;T&gt;</code>가 추가되었고, 매개변수의 데이터 타입을 지정해야 하는 위치에 <code>T</code>로 변경되었다. 이 변경 사항들이 함수 정의에서 제네릭 타입을 사용하는 문법이다. 이 문법은 함수 <code>find_max()</code>가 어떤 타입 <code>T</code>를 일반화한 함수이며, 타입 <code>T</code>로 구성된 리스트를 매개변수로 받아 타입 <code>T</code>를 결과값으로 반환한다는 의미를 나타낸다. 이제 위 예시코드를 컴파일해보자. 그러면 아래의 에러가 발생한다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust">error[E0369]: binary operation `&gt;` cannot be applied to <span class="hljs-keyword">type</span> `T`<br> -<span class="hljs-punctuation">-&gt;</span> test.rs:<span class="hljs-number">5</span>:<span class="hljs-number">17</span><br>  |<br><span class="hljs-number">5</span> |         <span class="hljs-keyword">if</span> item &gt; max  &#123;<br>  |            ---- ^ --- T<br>  |            |<br>  |            T<br>  |<br>help: consider restricting <span class="hljs-keyword">type</span> <span class="hljs-title class_">parameter</span> `T`<br>  |<br><span class="hljs-number">1</span> | <span class="hljs-keyword">fn</span> <span class="hljs-title function_">find_max</span>&lt;T: std::cmp::<span class="hljs-built_in">PartialOrd</span>&gt;(list: &amp;[T]) <span class="hljs-punctuation">-&gt;</span> T &#123;<br></code></pre></td></tr></table></figure><p>위 에러는 러스트 트레이트와 관련이 있기 때문에 트레이트 관련 글에서 자세히 다뤄볼 것이다.</p><h2 id="구조체-정의">구조체 정의</h2><p>다음으로는 구조체를 정의할 때 제네릭 타입을 사용하는 방법이다. 일반적으로 구조체는 정의 당시에 해당 변수의 데이터 타입을 지정한다. 아래의 예시를 살펴보자.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    x: <span class="hljs-type">i32</span>,<br>    y: <span class="hljs-type">i32</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>위처럼 정의된 <code>Point</code> 구조채에는 무조건 <code>i32</code> 타입만 필드 값으로 사용될 수 있다. 하지만 <code>float</code>도 필드값으로 사용하고 싶다면 어떻게 해야 할까? 답은 예상했다시피 제네릭 타입을 사용하면 된다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&lt;T&gt; &#123;<br>    x: T,<br>    y: T,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">int</span> = Point &#123;x: <span class="hljs-number">4</span>, y: <span class="hljs-number">7</span>&#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">float</span> = Point &#123;x: <span class="hljs-number">4.1</span>, y: <span class="hljs-number">7.1</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>위 코드는 문제없이 작동된다. 하지만 구조체 정의에서 두 필드값을 동일한 <code>T</code> 타입으로 정의했기 때문에 필드의 데이터 타입은 동일해야 한다. 즉, 둘다 <code>i32</code>아거나 <code>float</code>이어야 한다. 만약 두 필드의 데이터 타입을 다르게 정의하고 싶다면 다중 제네릭 타입을 사용하면 된다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&lt;T,U&gt; &#123;<br>    x: T,<br>    y: U,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">int</span> = Point &#123;x: <span class="hljs-number">4</span>, y: <span class="hljs-number">7.1</span>&#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">float</span> = Point &#123;x: <span class="hljs-number">4.1</span>, y: <span class="hljs-number">7</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="열거자-정의">열거자 정의</h2><p>열거자를 정의할 때도 제네릭 타입을 사용할 수 있다. 표준 라이브러리인 <code>Option&lt;T&gt;</code>를 통해서 알아보자.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span>&lt;T&gt; &#123;<br>    <span class="hljs-title function_ invoke__">some</span>(T),<br>    <span class="hljs-literal">None</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>위 코드에서 알 수 있듯이 <code>Option&lt;T&gt;</code>는 타입 <code>T</code>를 일반화한 열거자이며, <code>some</code>은 <code>T</code>값을 저장하고, <code>None</code>은 아무것도 저장하지 않는다.</p><p>구조체와 마찬가지로 열거자 또한 다중 제네릭 타입을 사용할 수 있다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">verification</span>&lt;T,E&gt; &#123;<br>    <span class="hljs-title function_ invoke__">success</span>(T),<br>    <span class="hljs-title function_ invoke__">fail</span>(E),<br>&#125;<br></code></pre></td></tr></table></figure><p>위에서 정의한 <code>verification&lt;T,E&gt;</code>는 성공했을 때와 실패했을 때의 값들을 모두 나타낼 수 있다.</p>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vec</tag>
      
      <tag>Option</tag>
      
      <tag>generic</tag>
      
      <tag>제네릭타입</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Resume 페이지 만들기</title>
    <link href="/ko/Web/web-1/"/>
    <url>/ko/Web/web-1/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 엔지니어의 Resume를 생성하는 과정을 공유합니다. <span id="more"></span></p><h2 id="시작">시작</h2><p>엔지니어로 커리어를 시작한지 3개월이 되었을 즈음, 시간이 남아 간단한 Resume 웹페이지를 만들었다. 막 수습 기간이 지나고 본격적으로 업무를 시작할 때라서 지금까지 해왔던 것들 또 앞으로 해나갈 것들을 한 페이지에 담아두고 싶었다. 또 이렇게 정리를 하다보면 스스로에 대한 메타인지도 향상되고 커리어 방향을 정하는 데 있어 도움이 될 것이라는 생각도 들었다. 그래서 부트스트랩에 있는 무료 템플릿 하나를 선택하여 커스터마이징 하였다. 사용된 템플릿 소스코드가 필요한 사람들은 해당 <a href="https://github.com/startbootstrap/startbootstrap-resume">깃허브</a>로 들어가서 가져오면 된다. (오픈소스이다)</p><figure><img src="/images/121.png" alt="resume" /><figcaption aria-hidden="true">resume</figcaption></figure><p>처음에는 테마도 깔끔하고 소스 코드도 비교적 커스터마이징하기 좋아서 선택했고 만족했었다. 하지만 최근 resume 업데이트를 위해 이것저것 시도해보면서 Navbar가 옆쪽에 위치한 것이 불편하게 느껴졌고, 추가해야 할 내용도 생각보다 많았다. 그래서 결국 2021년이 가기 전에 resume를 완전히 바꿔보려고 한다.</p><h2 id="레이아웃">레이아웃</h2><p>배포방식은 이전과 동일하게 깃허브의 Pages 기능을 사용할 예정이며, 기본적인 HTML 레이아웃은 부트스트랩 예시를 가져올 것이다. 사용한 예시 소스코드는 <a href="https://github.com/startbootstrap/startbootstrap-scrolling-nav">홈페이지</a>에 들어가면 받을 수 있다. 이번에 사용하는 코드의 경우 이전과 다르게 정말 레이아웃 코드만 들어있기 때문에 자유도가 높은 만큼 신경써야 할 것들이 많다. 예로 든다면 이전 페이지는 인스턴스 식품이라서 간단한 조리로도 먹을 수 있었지만 지금은 재료를 산 경우라서 직접 요리를 해 먹어야 하는 정도라고 볼 수 있을 것 같다.</p><h2 id="설계">설계</h2><p>이번에는 Navbar를 상단에 두고 정보들을 아래 방향으로 나열하는 방식을 선택하였다. 또 이번 페이지에는 아래의 조건들을 모두 만족할 수 있는 구조로 설계를 시도하였다.</p><ul><li>PDF 파일로 내보내도 괜찮은 디자인이어야 한다.</li><li>웹페이지로 봤을 때 너무 정적이지 않았으면 좋겠다.</li><li>모바일이나 다른 기기에서도 볼 수 있는 반응형 웹이어야 한다.</li><li>이후 내용들을 추가해도 레이아웃 상 문제가 없어야 한다.</li><li>simple is the best.</li></ul><p>위 내용들을 바탕으로 고민한 결과 결정된 사항은 다음과 같다.</p><ul><li>PDF로 내보내기 위해서는 한 페이지에 모든 내용을 볼 수 있어야 한다.</li><li>Header에 애니메이션을 배경으로 해서 생동감을 살리고 Navbar에 section을 연동시키자.</li><li>반응형에서도 문제없도록 심플한 구조로 작성하자.</li><li>구체적인 설명을 최대한 압축해서 작성하자.</li><li>PDF에서도 해당 웹페이지로 들어올 수 있도록 링크를 걸어두자.</li></ul><p>이제 해당 내용들을 바탕으로 하나씩 개발을 시작해보자.</p>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>엔지니어</tag>
      
      <tag>개발자</tag>
      
      <tag>resume</tag>
      
      <tag>이력서</tag>
      
      <tag>커리어</tag>
      
      <tag>career</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[ADsP] 데이터 분석 기획과 방법론</title>
    <link href="/ko/Certificate/ADsP-0/"/>
    <url>/ko/Certificate/ADsP-0/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 데이터분석 준전문가(ADsP) 자격증 공부 내용을 정리합니다. <span id="more"></span></p><h2 id="분석-기획">분석 기획</h2><ul><li>분석 기획: 분석을 수행하기 전 수행할 과제 정의 및 원하는 결과 도출을 위한 방안을 계획하는 것</li></ul><p>목표 시점에 따라 분석 기회의 방식은 크게 2가지로 나뉜다.</p><ul><li>과제 단위: 빠른 해결이 주 목적, 문제 해결에 초점을 맞춘다.</li><li>마스터플랜 단위: 지속적으로 해결 가능, 문제 파악 및 해결의 정확도에 초첨을 맞춘다.</li></ul><h3 id="분석-주제">분석 주제</h3><table><thead><tr class="header"><th style="text-align: center;">분석 대상</th><th style="text-align: center;">분석 방법</th><th style="text-align: center;">결론</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">O</td><td style="text-align: center;">O</td><td style="text-align: center;">최적화<br>(Optimization)</td></tr><tr class="even"><td style="text-align: center;">O</td><td style="text-align: center;">X</td><td style="text-align: center;">솔루션<br>(Solution)</td></tr><tr class="odd"><td style="text-align: center;">X</td><td style="text-align: center;">O</td><td style="text-align: center;">통찰<br>(Insight)</td></tr><tr class="even"><td style="text-align: center;">X</td><td style="text-align: center;">X</td><td style="text-align: center;">발견<br>(Discovery)</td></tr></tbody></table><h3 id="분석-기획-시-고려사항">분석 기획 시 고려사항</h3><ol type="1"><li>가용 데이터 고려</li><li>적절한 활용 방안과 유스케이스 검색</li><li>장애 요소에 대한 사전 계획 수립</li></ol><h3 id="분석-과제-발굴">분석 과제 발굴</h3><ul><li>하향식 접근법</li></ul><table><thead><tr class="header"><th>단계</th><th>태스크</th></tr></thead><tbody><tr class="odd"><td>문제 탐색 단계</td><td>- 비즈니스 모델 탐색 기법<br> - 분석기회 발굴 및 범위 확장<br> - 외부 참조 모델 기반 문제 탐색<br> - 분석 유스케이스</td></tr><tr class="even"><td>문제 정의 단계</td><td>식별된 비스니스 문제를 데이터 문제로 변환하여 과제를 정의</td></tr><tr class="odd"><td>해결방안 탐색 단계</td><td>과제 정의 후 어떻게 해결할 것인지 그 방안을 탐색(분석기법, 시스템 등)</td></tr><tr class="even"><td>타당성 검토 단계</td><td>경제적 타당성, 기술적 타당성 등을 검토</td></tr></tbody></table><ul><li>상향식 접근법</li></ul><table><thead><tr class="header"><th>단계</th><th>태스크</th></tr></thead><tbody><tr class="odd"><td>지도/비지도 학습</td><td>- 지도 학습<br> - 비지도 학습</td></tr><tr class="even"><td>프로토 타입</td><td>시행착오 해결법</td></tr></tbody></table><h3 id="분석-프로젝트-관리-방안">분석 프로젝트 관리 방안</h3><p>분석가의 목표는 단순히 분석의 정확도를 높이는 것뿐만 아니라 원하는 결과를 사용자가 원활하게 활용할 수 있도록 하는 것이다. 따라서 분석가는 데이터 영역과 비즈니스 영역의 중간에서 조율을 수행하는 조정자의 역할을 수행해야 하며, 분석 과제의 속성에 따라 관리 방안을 수립해야 한다. 분석 과제의 5가지 주요 속성은 다음과 같다.</p><ol type="1"><li>데이터의 양: 데이터 양에 따라 분석환경을 결정</li><li>데이터 복잡도: 데이터 형식에 따라 적용 모델을 결정</li><li>분석의 속도: 실시간인지 아닌지에 따라 분석 모델을 결정</li><li>분석 복잡도: 정확도가 높으면서도 해석이 편리한 최적의 모델 탐색</li><li>정확도 &amp; 정밀도: 모델과 실제 값 간의 차이를 나타내는 정확도와 반복적인 모델 결과값의 편차 수준인 정밀도를 확인</li></ol><h2 id="분석-방법론">분석 방법론</h2><ul><li>방법론 필요성: 데이터 분석을 효과적으로 기업 내에 정착하기 위함</li><li>방법론 생성 과정: 개인의 암묵지 -&gt; 조직의 형식지(형식화) -&gt; 회사의 방법론(체계화)</li><li>방법론 구성요소: 절차, 방법, 도구와 기법, 템플릿과 산출물</li></ul><h3 id="방법론-모델">방법론 모델</h3><table><thead><tr class="header"><th style="text-align: center;">모델 이름</th><th style="text-align: center;">설명</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">폭포수 모델</td><td style="text-align: center;">단계를 거쳐 순차적으로 진행하는 방법</td></tr><tr class="even"><td style="text-align: center;">프로토타입 모델</td><td style="text-align: center;">일부분 우선 개발 후 사용자의 요구 분석을 통해 개선 작업을 진행하는 방법</td></tr><tr class="odd"><td style="text-align: center;">나선형 모델</td><td style="text-align: center;">위험요소 사전 제거를 위해 반복하며 점증적으로 개발하는 방법</td></tr><tr class="even"><td style="text-align: center;">계층적 프로세스 모델</td><td style="text-align: center;">일반적인 분석 방법론. 단계 &gt; 태스크 &gt; 스텝 구조</td></tr></tbody></table><h3 id="전통적인-분석-방법론">전통적인 분석 방법론</h3><ul><li>KDD 분석 방법론<br />KDD(Knowledge Discovery in Database)는 데이터로부터 통계적 패턴이나 지식을 찾기 위해 체계적으로 정리한 데이터 마이닝 프로세스이다.</li></ul><table><thead><tr class="header"><th>단계</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>1. 데이터셋 선택</td><td>분석에 필요한 데이터 선택(타킷데이터 설정)</td></tr><tr class="even"><td>2. 데이터 전처리</td><td>잡음, 이상치 등을 파악하여 제거하거나 의미있는 데이터로 재가공</td></tr><tr class="odd"><td>3. 데이터 변환</td><td>변수를 생성 및 선택하고 데이터 차원을 축소, 학습/검증용 데이터 분리</td></tr><tr class="even"><td>4. 데이터 마이닝</td><td>분석 목적에 맞는 데이터 마이닝 기법 선택 및 적절한 알고리즘 적용</td></tr><tr class="odd"><td>5. 해석 및 평가</td><td>분석 목적과 일치성을 확인하고 평가</td></tr></tbody></table><ul><li>CRISP-DM 분석 방법론<br />CRISP-DM(Cross Industry Standard Process for Ddata Mining)은 KDD와 비슷하나 좀 더 세분화된 방식이다.</li></ul><table><thead><tr class="header"><th>단계</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>1. 업무이해</td><td>업무목적파악, 데이터 마이닝 목표 설정, 프로젝트 계획 수립</td></tr><tr class="even"><td>2. 데이터 이해</td><td>초기 데이터 수집, 데이터 탐색, 데이터 품질 확인</td></tr><tr class="odd"><td>3. 데이터 준비</td><td>분석용 데이터 선택, 데이터 정제, 데이터 통합, 데이터 포매팅</td></tr><tr class="even"><td>4. 모델링</td><td>모델링 기법 선택, 모델 테스트 계획, 모델 작성, 모델 평가</td></tr><tr class="odd"><td>5. 평가</td><td>분석 결과 평가, 모델링 과정 평가, 모델 적용성 평가</td></tr><tr class="even"><td>6. 전개</td><td>전개 계획 수립, 모니터인 유지보수 계획 수립, 프로젝트 리뷰</td></tr></tbody></table><h2 id="빅데이터-분석-방법론">빅데이터 분석 방법론</h2><p>빅데이터 분석 방법론은 완벽한 계층적 프로세스 모델로서 5단계로 구성되어 있다.</p><table><thead><tr class="header"><th>단계</th><th>태스크</th></tr></thead><tbody><tr class="odd"><td>1단계: 분석기획</td><td>- 비즈니스 이해 및 범위 설정<br> - 프로젝트 정의 및 계획 수립<br> - 프로젝트 위험계획 수립</td></tr><tr class="even"><td>2단계: 데이터 준비</td><td>- 필요 데이터 정의<br> - 데이터 스토어 설계 <br> - 데이터 수집 및 정합성 검정</td></tr><tr class="odd"><td>3단계: 데이터 분석</td><td>- 분석용 데이터 준비<br> - 텍스트 분석<br> - 탐색적 분석<br> - 모델링 <br> - 모델 평가 및 검증<br> - 모델 적용 및 운영방안 수립</td></tr><tr class="even"><td>4단계: 시스템 구현</td><td>- 설계 및 구현<br> - 시스템 테스트 및 운영</td></tr><tr class="odd"><td>5단계: 평가 및 전개</td><td>- 모델 발전계획 수립<br> - 프로젝트 평가 및 보고</td></tr></tbody></table><h2 id="분석-마스터플랜">분석 마스터플랜</h2><p>분석 마스터플랜은 특정 분석 프로젝트를 위한 전체 설계도와 같으며, 프로젝트를 시작할 때 우선순위 및 기업 상황을 고려하여 분석 구현 로드맵을 수립한다.</p>]]></content>
    
    
    <categories>
      
      <category>etc.</category>
      
      <category>certificate</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ADsP</tag>
      
      <tag>데이터자격시험</tag>
      
      <tag>데이터분석</tag>
      
      <tag>자격증</tag>
      
      <tag>R</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 메서드 문법</title>
    <link href="/ko/Rust/rust-5/"/>
    <url>/ko/Rust/rust-5/</url>
    
    <content type="html"><![CDATA[<p>러스트 메서드 문법에 대해 공부한 내용을 정리합니다. <span id="more"></span></p><h2 id="메서드">메서드</h2><p>메서드는 간단하게 말하면 특정 구조체에서 사용할 수 있는 함수라고 볼 수 있다. 메서드는 함수와 동일하게 <code>fn</code>으로 정의하고, 매개변수와 결과값도 지정한다. 다만 메서드는 일반 함수를 정의할 때와 달리 <code>impl</code> 블록 안에 함수들을 정의해야 한다는 점과 첫 번쨰 매개변수로 <code>&amp;self</code>를 넣어야 한다는 점이 있다. 메서드 예시 코드를 보면서 좀 더 알아보자.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    width: <span class="hljs-type">i32</span>,<br>    height: <span class="hljs-type">i32</span><br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>        <span class="hljs-keyword">self</span>.width * <span class="hljs-keyword">self</span>.height<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rec1</span> = Rectangle &#123;width:<span class="hljs-number">30</span>, height:<span class="hljs-number">50</span>&#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;사각형의 면적은 &#123;&#125;입니다.&quot;</span>, rec1.<span class="hljs-title function_ invoke__">area</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>위 코드는 사각형의 면적을 구하는 프로그램을 작성한 것이다. 메서드를 정의하기 위해서는 <code>impl</code> 뒤에 구조체 이름을 붙이면 된다. 위 구조는 <code>impl</code> 컨텍스트 내부에 정의되는 모든 함수들을 <code>Rectangle</code>의 메서드로 사용하겠다는 의미를 가진다. 정의한 메서드를 사용하는 방식은 해당 구조체 인스턴스 다음에 마침표, 메서드의 이름, 괄호 순서로 작성하면 된다. <code>area()</code>라는 메서드의 매개변수는 <code>Rectangle</code>이 아닌 <code>self</code>를 사용한다. 이 또한 이미 <code>area()</code>가 <code>Rectangle</code>의 컨텍스트 내부에 정의됨으로서 해당 구조체의 메서드라는 것을 러스트가 알고 있기애 굳이 다시 데이터 타입을 알려줄 필요가 없다는 것을 의미한다. 위 코드는 <code>area()</code>가 <code>Rectangle</code> 필드 값을 참조만 하면 되기에 <code>&amp;self</code>을 사용하였다. 상황에 따라서 <code>self</code> 또한 가변변수로 대여하거나 소유권을 가져오는 등의 설정도 가능하다.</p><h2 id="많은-매개변수를-가진-메서드">많은 매개변수를 가진 메서드</h2><p>이제 메서드에 대해 기본적인 구조는 배웠다. 이를 바탕으로 아래의 문제를 풀어보자.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// Q: 아래의 코드에서 compare()을 작성하여 프로그램을 완성해보자.</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    width: <span class="hljs-type">i32</span>,<br>    height: <span class="hljs-type">i32</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rec1</span> = Rectangle &#123;width: <span class="hljs-number">40</span>, height:<span class="hljs-number">30</span>&#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rec2</span> = Rectangle &#123;width: <span class="hljs-number">50</span>, height:<span class="hljs-number">30</span>&#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rec3</span> = Rectangle &#123;width: <span class="hljs-number">20</span>, height:<span class="hljs-number">30</span>&#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;rec1은 rec2를 가릴 수 있나요? &#123;&#125;&quot;</span>, rec1.<span class="hljs-title function_ invoke__">compare</span>(&amp;rec2));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;rec1는 rec3를 가릴 수 있나요? &#123;&#125;&quot;</span>, rec1.<span class="hljs-title function_ invoke__">compare</span>(&amp;rec3));<br>&#125;<br></code></pre></td></tr></table></figure><p>위 문제를 해결하기 위해서는 <code>rec1.compare(&amp;rec2)</code>에 해당하는 함수가 필요하다. <code>compare()</code>은 예측했겠지만 <code>Rectangle</code>의 메서드이다. 제대로 작동하는 메서드 코드를 작성했다면 결과는 아래과 같다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">rec1은 rec2를 가릴 수 있나요? <span class="hljs-literal">false</span><br>rec1는 rec3를 가릴 수 있나요? <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>위 문제는 <code>rec1</code>이 나머지 사각형을 가릴 수 있는지 여부를 판단하는 것이었다. 즉, 가로, 세로 모든 면적이 다른 사각형보다 길거나 같아야지만 가릴 수 있다. 따라서 rec1은 rec2보다 width가 짧기에 가릴 수 없으며 정답은 <code>false</code> 이며, rec3와 비교했을 때 rec1 모든 변의 길이가 같거나 더 길기에 정답은 <code>true</code>이다. 위 문제를 해결하는 코드는 다양하겠지만 아래의 코드는 위 설명을 그대로 구현하였다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    width: <span class="hljs-type">i32</span>,<br>    height: <span class="hljs-type">i32</span><br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">compare</span>(&amp;<span class="hljs-keyword">self</span>, x: &amp;Rectangle) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">self</span>.width &gt;= x.width &amp;&amp; <span class="hljs-keyword">self</span>.height &gt;= x.height<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rec1</span> = Rectangle &#123;width: <span class="hljs-number">40</span>, height:<span class="hljs-number">30</span>&#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rec2</span> = Rectangle &#123;width: <span class="hljs-number">50</span>, height:<span class="hljs-number">30</span>&#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rec3</span> = Rectangle &#123;width: <span class="hljs-number">20</span>, height:<span class="hljs-number">30</span>&#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;rec1은 rec2를 가릴 수 있나요? &#123;&#125;&quot;</span>, rec1.<span class="hljs-title function_ invoke__">compare</span>(&amp;rec2));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;rec1는 rec3를 가릴 수 있나요? &#123;&#125;&quot;</span>, rec1.<span class="hljs-title function_ invoke__">compare</span>(&amp;rec3));<br>&#125;<br></code></pre></td></tr></table></figure><p>이제 코드의 관점으로 되돌아오자. 위 코드는 메서드로 <code>compare()</code>을 구현하였으며, 매개변수를 2개 사용하여 두 개의 사각형 정보를 입력하였다. 첫번째 매개변수의 경우 해당 메서드를 사용할 인스턴스의 값이기에 <code>&amp;self</code>로 작성하였으며, 두번째의 경우는 어떤 데이터가 들어오는지 타입을 명확히 지정해주었다. 위 예시로 알 수 있듯이 매서드를 불러오는 인스턴스만 <code>&amp;self</code> 그 뒤에 추가적으로 필요한 매개변수는 함수와 동일하게 작성하면 된다.</p><h2 id="연관-함수">연관 함수</h2><p>연관 함수란 해당 구조체 인스턴스를 매개변수로 사용하지는 않지만 프로그램 상 연관되어있는 함수들을 칭한다. 따라서 연관 함수는 메서드에 속하지 않는다. 다만 연관성을 나타내기 위해 <code>impl</code> 블록에 묶어서 정의할 수 있다. 연관 함수를 사용하는 방법은 <code>impl이름::함수이름()</code> 구조이며, 보통 해당 구조체 인스턴스를 리턴하는 생성자를 구현해야 할 때 자주 사용된다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    width: <span class="hljs-type">i32</span>,<br>    height: <span class="hljs-type">i32</span><br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>        <span class="hljs-keyword">self</span>.width * <span class="hljs-keyword">self</span>.height<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">squre</span>(x: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> Rectangle &#123;<br>        Rectangle &#123; width: x, height:x&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;변이 3인 정사각형의 면적: &#123;&#125;&quot;</span>, Rectangle::<span class="hljs-title function_ invoke__">squre</span>(<span class="hljs-number">3</span>).<span class="hljs-title function_ invoke__">area</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>위 코드는 <code>squre()</code>이라는 연관함수를 통해 <code>Rectangle</code>의 인스턴스를 생성하고 이에 대한 면적을 구하는 코드이다. 이와 같이 연관 함수는 메서드는 아니지만 <code>impl</code> 블록 내에서 정의되는 메서드와 연관이 있는 경우 메서드와 같이 블록 내부에 정의한다.</p><h2 id="여러-개의-impl-블록">여러 개의 impl 블록</h2><p>특정 구조체에 하나의 <code>impl</code> 블록만을 정의할 수 있는 것은 아니다. 상황에 따라서 블록을 구분하는게 코드가 더 명확할 때가 있기에 충분히 여러 개로 나누어 사용할 수 있다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    width: <span class="hljs-type">i32</span>,<br>    height: <span class="hljs-type">i32</span><br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>        <span class="hljs-keyword">self</span>.width * <span class="hljs-keyword">self</span>.height<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">compare</span>(&amp;<span class="hljs-keyword">self</span>, x: &amp;Rectangle) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">self</span>.width &gt;= x.width &amp;&amp; <span class="hljs-keyword">self</span>.height &gt;= x.height<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">squre</span>(x: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> Rectangle &#123;<br>        Rectangle &#123; width: x, height:x&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">sq3</span> = Rectangle::<span class="hljs-title function_ invoke__">squre</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">sq5</span> = Rectangle::<span class="hljs-title function_ invoke__">squre</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;변이 3인 정사각형의 면적: &#123;&#125;&quot;</span>, sq3.<span class="hljs-title function_ invoke__">area</span>());<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;sq3는 sq5보다 면적이 큰가요?: &#123;&#125;&quot;</span>, sq3.<span class="hljs-title function_ invoke__">compare</span>(&amp;sq5));<br>&#125;<br></code></pre></td></tr></table></figure><p>위 코드는 연관 함수와 메서드를 <code>impl</code> 블록으로 나누어 작성하였다. 물론 예시처럼 간단한 코드들은 하나의 <code>impl</code> 블록에 써도 상관없지만 가능하다는 것을 보기 위해 나눈 것일 뿐 어떤 규칙은 없다.</p>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>struct</tag>
      
      <tag>method</tag>
      
      <tag>context</tag>
      
      <tag>impl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[SQLD] 합격 후기</title>
    <link href="/ko/Certificate/sqld-1/"/>
    <url>/ko/Certificate/sqld-1/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 SQL 개발자(SQLD) 자격증 공부 내용을 정리합니다. <span id="more"></span></p><h2 id="sqld-합격">SQLD 합격</h2><p>이번에는 잊지 않고 DAsP에 이어 SQLD를 신청했다. 시험 날짜는 9월 5일이었고, 나는 여의도에 위치한 중학교에서 시험을 봤다. 사실 프로젝트 기간 중이라서 공부도 거의 못했기에 기대 없이 응시했다. 보고 나서 나오는 길에도 "다음에 다시 응시하면 되지" 라는 마음으로 친구를 만나 더 현대에 가서 맛있는 걸 사먹었던 기억이 남아았다. 그 이후 파이콘 준비와 프로젝트 시작이 겹치면서 정말 밤, 낮으로 일했고 정신차리니 어느새 SQLD 결과 발표 날이었다. 결과는 아래와 같다.</p><figure><img src="/images/120.png" alt="SQLD" /><figcaption aria-hidden="true">SQLD</figcaption></figure><p>그렇다. 완전 턱걸이로 합격에 골인하였다. 아마 추측하건대 이론 부분에서 많이 감점되고, 실제 쿼리를 묻는 질문들을 맞은 것 같다. 실제 업무에서 사용하던 경험들의 도움을 정말 많이 받았다. 재밌는 건 SQLD 시험에 오라클 RDBMS 를 기준으로 나온 문제들이 많아서 나름 고전했다. 실제 업무에서는 HiveQL이나 MySQL, MariaDB만 주로 사용하기 때문이다. 언젠가 오라클도 공부해야겠다고 일단 다짐해본다.</p><h2 id="sqld-시험-정보">SQLD 시험 정보</h2><p>SQLD(SQL Developer)시험은 크게 2개의 과목으로 구성되어 있다.</p><ol type="1"><li>데이터 모델링의 이해 (10문제)</li><li>SQL 기본 및 활용 (40문제) - 단답형 포함</li></ol><p>총 점수는 100점 만점이며, 한 문제 당 2점이다. 또한 합격 조건은 전체점수 60점 이상 획득하고, 각 과목당 40% 이상 맞추는 것이다. 따라서 내 성적은 각각 몇 문제를 맞췄는지 계산해보면 다음과 같다.</p><ol type="1"><li>데이터 모델링의 이해 (6문제/10문제/60%)</li><li>SQL 기본 및 활용 (25문제/40문제/62.5%)</li></ol><p>이렇게 직접 비율로 환산해보니 얼마나 턱걸이로 통과했는지 실감이 난다. 공개하기 살짝 창피하지만 이 또한 내 발자취라고 생각하여 블로그에 글을 남긴다. 참고로 SQLD에는 서술형(단답형) 문제가 있다. 꼭 잊지말고 컴퓨터용 사인펜과 검은색 볼펜을 챙겨가기를 바란다. 준비하시는 모든 분들은 나처럼 서술형 존재를 시험장에서 눈치채지 않았으면 하는 바람에 남겨본다.</p><h2 id="sqld-후기">SQLD 후기</h2><p>이번에 봤던 SQLD는 시험 유형도 제대로 인지하지 못하고 갈 정도로 준비를 많이 못했었다. 물론 기준 점수가 비교적 낮고, 문제가 어렵지 않아서 운좋게 붙었지만 개인적으로 SQL을 다시 한 번 공부해야겠다고 느꼈다. 시간이 된다면 꼭 블로그에도 공부한 내용을 정리해야겠다.</p>]]></content>
    
    
    <categories>
      
      <category>etc.</category>
      
      <category>certificate</category>
      
    </categories>
    
    
    <tags>
      
      <tag>자격증</tag>
      
      <tag>SQLD</tag>
      
      <tag>sqld</tag>
      
      <tag>sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>구조체로 실습하기</title>
    <link href="/ko/Rust/rust-4/"/>
    <url>/ko/Rust/rust-4/</url>
    
    <content type="html"><![CDATA[<p>러스트 구조체(struct)를 바탕으로 사각형 면적 구하는 프로그램을 작성한 내용을 정리합니다. <span id="more"></span></p><hr /><p><a href="https://dev-bearabbit.github.io/2021/10/09/Rust/rust-3/#more">이전 글</a>에서 러스트 구조체에 대해서 간단하게 알아보았다. 이번 글에서는 구조체를 사용하여 간단한 프로그램을 작성해보려고 한다.</p><h2 id="사각형-면적-구하기-step-1-변수">사각형 면적 구하기 step 1: 변수</h2><p>지금까지 공부했던 내용을 바탕으로 사각형의 면적을 구하는 간단한 프로그램을 작성해보자. 프로젝트를 생성할 디렉토리에서 아래의 코드를 입력하자.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">cargo new rectangles<br></code></pre></td></tr></table></figure><p>그러면 해당 디렉토리에 <code>rectangles</code>라는 폴더가 생성되고, 내부에 <code>src/main.rs</code>와 <code>Cargo.toml</code>이 생성될 것이다. 우리가 만들 코드들은 <code>src/main.rs</code>에 입력하면 된다.</p><p>사각형의 면적을 구하는 식은 대부분의 사람들이 알고 있다. 바로 '(밑변) x (높이)'이다. 구조체나 튜플 등 없이 가장 간단하게 코드를 작성한다면 아래와 같다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">width</span> = <span class="hljs-number">30</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">height</span> = <span class="hljs-number">40</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;사각형의 면적은 &#123;&#125; 입니다.&quot;</span>, <span class="hljs-title function_ invoke__">area</span>(width, height));<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(width:<span class="hljs-type">i32</span>, height:<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>&#123;<br>    width * height<br>&#125;<br></code></pre></td></tr></table></figure><p>위 코드는 밑변과 높이를 모두 받아서 곱한다. 하지만 위 코드를 바탕으로 여러 개의 사각형 넓이를 도출하는 프로그램을 생성해보자.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">width1</span> = <span class="hljs-number">30</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">height1</span> = <span class="hljs-number">40</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">width2</span> = <span class="hljs-number">50</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">height2</span> = <span class="hljs-number">50</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;사각형의 면적은 &#123;&#125; 입니다.&quot;</span>, <span class="hljs-title function_ invoke__">area</span>(width1, height1));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;사각형의 면적은 &#123;&#125; 입니다.&quot;</span>, <span class="hljs-title function_ invoke__">area</span>(width2, height2));<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(width:<span class="hljs-type">i32</span>, height:<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>&#123;<br>    width * height<br>&#125;<br></code></pre></td></tr></table></figure><p>밑변인 <code>width</code>와 높이인 <code>height</code>가 여러 개 사용되다보니 정신이 없다. 만약 100개의 면적을 구하는 프로그램을 작성해야 한다면 위 코드를 사용하는 프로그래머는 머리가 아플 것이다. 우리는 다행히 이런 상황에서 적절하게 사용할 수 있는 데이터 타입을 배웠다. 바로 튜플이다.</p><h2 id="사각형-면적-구하기-step-2-튜플">사각형 면적 구하기 step 2: 튜플</h2><p>튜플을 이용하여 밑변인 <code>width</code>와 높이인 <code>height</code>을 묶을 수 있다면 이전 코드보다는 훨씬 편리하고 코드 길이도 줄어들 것이다. 아래 코드를 통해 살펴보자.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rec1</span> = (<span class="hljs-number">30</span>,<span class="hljs-number">40</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rec2</span> = (<span class="hljs-number">50</span>,<span class="hljs-number">50</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;사각형의 면적은 &#123;&#125; 입니다.&quot;</span>, <span class="hljs-title function_ invoke__">area</span>(rec1));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;사각형의 면적은 &#123;&#125; 입니다.&quot;</span>, <span class="hljs-title function_ invoke__">area</span>(rec2));<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(rec:(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>)) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>&#123;<br>    rec.<span class="hljs-number">0</span> * rec.<span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>위 코드에서는 사각형의 개수 별로 변수가 생성되며, 이전 코드보다 훨씬 알아보기도 쉽다. 다만 튜플 인덱스 중에서 어떤 것이 밑변이고, 높이인지 여부는 코드에 나타나 있지 않다. 따라서 해당 코드를 작성하여 전달하는 프로그래머는 주석으로 인덱스들의 의미를 추가해야 한다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 튜플의 0은 밑변, 1은 높이</span><br></code></pre></td></tr></table></figure><p>하지만 이런 주석도 개발 단계에서만 사용될 뿐 실제 프로그램에 사용할 소스 코드에서는 보안 상 전부 지우는게 좋다. 따라서 튜플보다는 좀 더 새로운 데이터 타입이 필요하다. 사용할 데이터 타입의 필수 요건은 아래와 같다.</p><ol type="1"><li>밑변과 높이가 특정 사각형에 속한다는 점이 확실하게 보여야 한다.</li><li>특정 사각형의 밑변과 높이의 값이 정확히 무엇인지 파악할 수 있어야 한다.</li></ol><p>위 조건들을 모두 만족할 수 있는 데이터 타입을 구조체로 직접 만들 수 있다면, 보다 가독성 있는 소스 코드를 작성할 수 있을 것이다.</p><h2 id="사각형-면적-구하기-step-3-구조체">사각형 면적 구하기 step 3: 구조체</h2><p>드디어 구조체를 사용할 기회가 왔다. 위 조건을 모두 포함하는 데이터 타입을 만들어보자.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    width: <span class="hljs-type">i32</span>,<br>    height: <span class="hljs-type">i32</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rec1</span> = Rectangle &#123;width: <span class="hljs-number">30</span>, height: <span class="hljs-number">40</span>&#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rec2</span> = Rectangle &#123;width: <span class="hljs-number">50</span>, height: <span class="hljs-number">50</span>&#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;사각형의 면적은 &#123;&#125; 입니다.&quot;</span>, <span class="hljs-title function_ invoke__">area</span>(&amp;rec1));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;사각형의 면적은 &#123;&#125; 입니다.&quot;</span>, <span class="hljs-title function_ invoke__">area</span>(&amp;rec2));<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(rec: &amp;Rectangle) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>&#123;<br>    rec.width * rec.height<br>&#125;<br></code></pre></td></tr></table></figure><p>위 코드는 <code>Rectangle</code>이라는 구조체를 생성 및 사용하여 변수를 정의하고, <code>area()</code>에서는 밑변인 <code>width</code>와 높이인 <code>height</code>를 필드로 선택하여 구현하였다. 위와 같이 작성된 프로그램은 이후 다른 프로그래머가 소스 코드를 이해함에 있어 훨씬 명확한 의미를 전달해 줄 것이다.</p>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>structure</tag>
      
      <tag>struct</tag>
      
      <tag>field</tag>
      
      <tag>instance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 구조체란</title>
    <link href="/ko/Rust/rust-3/"/>
    <url>/ko/Rust/rust-3/</url>
    
    <content type="html"><![CDATA[<p>러스트 구조체(struct)에 대해 공부한 내용을 정리합니다. <span id="more"></span></p><hr /><p>모든 프로그래밍 언어에는 기본적으로 제공되는 데이터 타입이 있다. 배열이나 튜플 또한 그 중 하나이다. 하지만 그것만으로는 모든 데이터들을 효과적으로 핸들링하기 힘들다. 그럴 때 구조체는 좋은 해결 방법이다. 구조체는 프로그래머가 묶어서 저장하고 싶은 데이터들을 직접 정의하고 변수 하나로 간편하게 관리할 수 있다.</p><h2 id="구조체">구조체</h2><p>러스트에서 구조체란 프로그래머가 직접 정의한 데이터 타입을 말한다. 구조체를 정의하는 방법은 <code>struct</code> 뒤에 구조체 이름, 중괄호{} 를 입력한다. 그 다음 중괄호 안에 저장할 데이터들의 이름과 타입을 작성하면 끝이다. 아래의 예시 코드를 살펴보자.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span> &#123;<br>    username: <span class="hljs-type">String</span>,<br>    email: <span class="hljs-type">String</span>,<br>    login_count: <span class="hljs-type">u64</span>,<br>    active: <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><p>위 구조체는 어떤 서비스의 사용자 정보를 저장하는 데이터 타입이다. 이름, 이메일, 로그인 한 횟수, 활동 중인지 등을 한번에 저장 및 처리할 수 있다. 이처럼 구조체 내부에 저장되는 데이터들을 필드(field)라고 한다. 위 구조체에서 필드는 <code>username</code>, <code>email</code>, <code>login_count</code>, <code>active</code> 이다.</p><p>다음으로는 해당 구조체를 사용하여 <code>USER1</code>라는 유저의 정보를 입력해보자.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span> &#123;<br>    username: <span class="hljs-type">String</span>,<br>    email: <span class="hljs-type">String</span>,<br>    login_count: <span class="hljs-type">u64</span>,<br>    active: <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">user1</span> =User &#123;<br>        username: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;USER1&quot;</span>),<br>        email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;user1@gmail.com&quot;</span>),<br>        active: <span class="hljs-literal">true</span>,<br>        login_count: <span class="hljs-number">1</span>,<br>    &#125;;<br>    <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, user1.username);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, user1.email);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, user1.active);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, user1.login_count);<br>&#125;<br></code></pre></td></tr></table></figure><p>위 코드는 <code>user1</code>을 이전에 정의했던 구조체 <code>User</code>을 사용하여 데이터를 저장한 후, 저장된 값들을 순서대로 보여준다. 이처럼 특정 구조체를 바탕으로 데이터가 저장된 변수들을 <code>인스턴스(instance)</code>라고 부른다. 인스턴스를 생성하기 위해서는 구조체 필드 각각의 저장할 값들을 <code>키:쌍</code> 형태로 입력하면 된다. 만약 인스턴스에 저장된 특정 필드의 값만 지정하고 싶다면 <code>인스턴스이름.필드이름</code> 형태로 변수를 불러올 수 있다.</p><p>그렇다면 인스턴스에 저장된 데이터 값들을 수정할 수 있을까? 이 또한 인스턴스를 생성할 때 <code>mut</code>를 추가해주면 가능하다. 아래의 코드를 실행해보자.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span> &#123;<br>    username: <span class="hljs-type">String</span>,<br>    email: <span class="hljs-type">String</span>,<br>    login_count: <span class="hljs-type">u64</span>,<br>    active: <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">user1</span> =User &#123;<br>        username: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;USER1&quot;</span>),<br>        email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;user1@gmail.com&quot;</span>),<br>        active: <span class="hljs-literal">true</span>,<br>        login_count: <span class="hljs-number">1</span>,<br>    &#125;;<br><br>    user1.username = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;DEVAnythinG&quot;</span>);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, user1.username);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, user1.email);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, user1.active);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, user1.login_count);<br>&#125;<br></code></pre></td></tr></table></figure><p>위 코드는 <code>user1.username</code>의 값이 "DEVAnythinG" 으로 수정되어 프린트 된다. 만약 <code>user1</code>을 정의할 때 <code>mut</code>을 추가하지 않는다면 변경된 값을 할당할 수 없다는 에러가 발생한다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust">error[E0594]: cannot assign to `user1.username`, <span class="hljs-keyword">as</span> `user1` is not declared <span class="hljs-keyword">as</span> mutable<br>  -<span class="hljs-punctuation">-&gt;</span> test.rs:<span class="hljs-number">16</span>:<span class="hljs-number">5</span><br>   |<br><span class="hljs-number">9</span>  |     <span class="hljs-keyword">let</span> <span class="hljs-variable">user1</span> =User &#123;<br>   |         ----- help: consider changing this to be mutable: `<span class="hljs-keyword">mut</span> user1`<br>...<br><span class="hljs-number">16</span> |     user1.username = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;DEVAnythinG&quot;</span>);<br>   |     ^^^^^^^^^^^^^^ cannot assign<br><br>error: aborting due to previous error<br><br>For more information about this error, <span class="hljs-keyword">try</span> `rustc --explain E0594`.<br></code></pre></td></tr></table></figure><p>인스턴스 정의에 <code>mut</code>을 추가하는 방법은 인스턴스 내의 모든 필드 값들을 가변으로 저장된다. 그렇다면 특정 필드 값만 가변으로 변경할 수 있을까? 그것은 불가능하다. 결론은 다음과 같다. "구조체의 인스턴스는 모든 필드값이 가변이거나 불변이다"</p><h2 id="필드-초기화-단축-문법">필드 초기화 단축 문법</h2><p>필드 초기화 단축 문법이란 함수의 매개 변수와 구조체의 필드 이름이 같을 경우 사용할 수 있는 방법이다. 아래 코드를 살펴보자.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span> &#123;<br>    username: <span class="hljs-type">String</span>,<br>    email: <span class="hljs-type">String</span>,<br>    login_count: <span class="hljs-type">u64</span>,<br>    active: <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">build_user</span>(username: <span class="hljs-type">String</span>, email: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> User &#123;<br>    User &#123;<br>    username,<br>    email,<br>    active: <span class="hljs-literal">true</span>,<br>    login_count: <span class="hljs-number">1</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">user1</span> = <span class="hljs-title function_ invoke__">build_user</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;user&quot;</span>),<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;user@gmail.com&quot;</span>));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, user1.username);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, user1.email);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, user1.active);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, user1.login_count);<br>&#125;<br></code></pre></td></tr></table></figure><p>위 코드에서 <code>build_user()</code>는 매개변수로 받는 <code>username</code>, <code>email</code>을 구조체의 필드 이름과 동일하게 작성하여 <code>키:쌍</code> 형태로 입력하지 않았다. 하지만 위 코드를 컴파일 후 실행해보면 결과는 아래와 같이 정상적으로 프린트 된다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-string">&quot;user&quot;</span><br><span class="hljs-string">&quot;user@gmail.com&quot;</span><br><span class="hljs-literal">true</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="필드-갱신-단축-문법">필드 갱신 단축 문법</h2><p>이미 존재하는 인스턴스의 값을 참조하여 새로운 인스턴스를 만드려면 어떻게 할 수 있을까?</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span> &#123;<br>    username: <span class="hljs-type">String</span>,<br>    email: <span class="hljs-type">String</span>,<br>    login_count: <span class="hljs-type">u64</span>,<br>    active: <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">user1</span> = User &#123;<br>        username: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;user1&quot;</span>),<br>        email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;user1@gmail.com&quot;</span>),<br>        login_count: <span class="hljs-number">1</span>,<br>        active: <span class="hljs-literal">true</span><br>    &#125;;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">user2</span> = User &#123;<br>        username: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;user2&quot;</span>),<br>        email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;user2@gmail.com&quot;</span>),<br>        login_count: user1.login_count,<br>        active: user1.active<br>    &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, user2.username);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, user2.email);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, user2.active);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, user2.login_count);<br>&#125;<br></code></pre></td></tr></table></figure><p>위 코드는 <code>user2</code>의 <code>login_count</code>, <code>active</code> 필드 값을 <code>user1</code>으로부터 복사한다. 하지만 만약 어떤 인스턴스로부터 복사할 필드 갯수가 100개라고 생각해보자.그러면 위 예시처럼 작성하면 코드가 매우 길어질 것이다. 이럴 때 바로 필드 갱신 단축 문법(<code>..</code>)을 사용하면 된다. 아래 코드는 이전 코드와 동일한 작동을 하지만 단축 문법을 사용하여 더 짧은 코드로 구현할 수 있다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span> &#123;<br>    username: <span class="hljs-type">String</span>,<br>    email: <span class="hljs-type">String</span>,<br>    login_count: <span class="hljs-type">u64</span>,<br>    active: <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">user1</span> = User &#123;<br>        username: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;user1&quot;</span>),<br>        email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;user1@gmail.com&quot;</span>),<br>        login_count: <span class="hljs-number">1</span>,<br>        active: <span class="hljs-literal">true</span><br>    &#125;;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">user2</span> = User &#123;<br>        username: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;user2&quot;</span>),<br>        email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;user2@gmail.com&quot;</span>),<br>        ..user1<br>    &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, user2.username);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, user2.email);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, user2.active);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, user2.login_count);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="튜플-구조체">튜플 구조체</h2><p>튜플과 유사하게 생긴 구조체를 정의할 수도 있다. 아래 코드를 살펴보자.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">RGB</span> (<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LOC</span> (<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">black</span> = <span class="hljs-title function_ invoke__">RGB</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">origin</span> = <span class="hljs-title function_ invoke__">LOC</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,black.<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,origin.<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>위 코드는 <code>RGB</code>, <code>LOC</code> 두 개의 구조체를 사용한다. 정의된 <code>black</code>, <code>origin</code>은 똑같은 (0,0,0)의 값을 가지고 있지만 정의된 구조체가 다르기에 두 개가 동일한 데이터는 아니다. 따라서 <code>RGB</code> 인스턴스를 매개 변수로 받는 함수에 <code>LOC</code> 인스턴스를 사용할 수는 없다. 그 점을 제외하고는 튜플과 동일한 원리로 작동한다.</p><h2 id="유사-유닛-구조체">유사 유닛 구조체</h2><p>유사 유닛 구조체는 필드가 하나도 없이 생성된 구조체이다. 사실 지금은 해당 구조체가 왜 필요한지 의문일 수 있지만 이후 트레이트를 공부할 때 더 자세히 다룰 것이다.</p><h2 id="구조체-데이터의-소유권">구조체 데이터의 소유권</h2><p>이번 글 모든 예시에서 우리는 <code>String</code> 타입을 사용하였다. 구조체에서도 물론 <code>&amp;str</code>과 같은 참조를 사용할 수 있지만 이를 위해서는 러스트 기능인 <code>lifetime</code>을 사용해야 한다. <code>lifetime</code>는 특정 범위 내에서 참조된 데이터의 유효성을 보장해준다. 이에 대한 부분도 뒤에서 더 자세히 다룰 것이다.</p>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>structure</tag>
      
      <tag>struct</tag>
      
      <tag>field</tag>
      
      <tag>instance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Inventory 작성하기</title>
    <link href="/ko/Ansible/ansible-2/"/>
    <url>/ko/Ansible/ansible-2/</url>
    
    <content type="html"><![CDATA[<p>Ansible Inventory 의미 및 작성 과정을 설명합니다. <span id="more"></span></p><hr /><h2 id="ansible-inventory">Ansible inventory</h2><p>인벤토리는 관리 노드들에 대한 정보를 기술한 파일이다. 보통은 노드 목록과 그룹핑을 정의하기 때문에 호스트파일(hostfile)이라고도 부른다. 또한 인벤토리는 그룹에 따라 변수들을 생성할 수 있다. 형태는 다음과 같다.</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs INI"><span class="hljs-section">[all]</span><br>target1 <span class="hljs-attr">ansible_host</span>=<span class="hljs-variable">$IP</span><br>target2 <span class="hljs-attr">ansible_host</span>=<span class="hljs-variable">$IP</span><br>target3 <span class="hljs-attr">ansible_host</span>=<span class="hljs-variable">$IP</span><br><br><span class="hljs-section">[all:vars]</span><br><span class="hljs-attr">ansible_python_interpreter</span>=/usr/bin/python<br><span class="hljs-attr">ansible_ssh_pass</span>=<span class="hljs-variable">$passwd</span><br></code></pre></td></tr></table></figure><p><code>[그룹이름]</code>부분에 들어가는 단어가 앤서블에서 사용할 그룹이름이며 <code>[그룹이름:vars]</code> 아래로 입력한 부분은 해당 그룹에 대한 변수를 설정한 것이다. 보통 그룹에 속하는 노드들의 공통 속성은 <code>[그룹이름:vars]</code>에 하나로 입력한다. 위 예시를 보면 target1-3까지는 각각 IP가 다르므로 [all]에 작성하였고, ssh 비밀번호는 동일하므로 [all:vars]에 작성하였다.</p><p>또한 만약 사용되는 호스트 이름이 비슷한 패턴으로 구성되어 있다면 [start:end]규칙을 사용하여 그룹 변수를 작성할 수 있다.</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs INI"><span class="hljs-section">[EXAMPLE]</span><br>target<span class="hljs-section">[1:3]</span><br></code></pre></td></tr></table></figure><p>위의 예시처럼 숫자 패턴을 지정할 수도 있고, 또 아래 예시처럼 문자 패턴도 가능하다.</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs INI">targetA <span class="hljs-attr">ansible_host</span>=<span class="hljs-variable">$IP</span><br>targetB <span class="hljs-attr">ansible_host</span>=<span class="hljs-variable">$IP</span><br>targetC <span class="hljs-attr">ansible_host</span>=<span class="hljs-variable">$IP</span><br><br><span class="hljs-section">[EXAMPLE]</span><br>target<span class="hljs-section">[A:C]</span><br></code></pre></td></tr></table></figure><p>인벤토리 파일은 확장자 없이도 사용할 수 있으며, 보통 txt, ini 확장자로 저장하여 사용한다. 물론 yaml 파일 형식으로도 작성할 수는 있지만 yaml 형식이 익숙하지 않다면 txt, ini로 쓰는 것을 추천한다. 위 예시를 yaml 파일 방식으로 작성하면 다음과 같다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-attr">all:</span><br>    <span class="hljs-attr">hosts:</span><br>        <span class="hljs-attr">target1:</span><br>            <span class="hljs-attr">ansible_host:</span> <span class="hljs-string">$IP</span><br>        <span class="hljs-attr">target2:</span><br>            <span class="hljs-attr">ansible_host:</span> <span class="hljs-string">$IP</span><br>        <span class="hljs-attr">target3:</span><br>            <span class="hljs-attr">ansible_host:</span> <span class="hljs-string">$IP</span><br>    <span class="hljs-attr">vars:</span><br>        <span class="hljs-attr">ansible_python_interpreter:</span> <span class="hljs-string">/usr/bin/python</span><br>        <span class="hljs-attr">ansible_ssh_pass:</span> <span class="hljs-string">$passwd</span><br></code></pre></td></tr></table></figure><p>yaml 파일 형식은 playbook 파트에서 더 자세히 알아보자. 이처럼 인벤토리에 작성된 노드들은 네트워크 상에서 통신만 가능하다면 컨트롤러 서버에서 관리할 수 있다. 보통 앤서블을 설치하면 <code>/etc/ansible</code> 디렉토리 내부에 자동으로 <code>hosts</code> 파일이 생성된다. 해당 파일에 노드 정보를 입력하면 옵션 <code>-i</code>없이 앤서블 명령어를 사용할 수 있다. 만약 여러 개의 인벤토리를 구성하고 싶다면 호스트 디렉토리를 따로 생성하여 관리할 수도 있다.</p><h2 id="inventory-parameters">Inventory Parameters</h2><p>아래는 앤서블 인벤토리를 작성할 때 사용되는 요건들을 정리한 목록이다.</p><ul><li><p>호스트 연결 타입 ansible_connection: 기본값은 ssh, 호스트와 연결할 방법 [local, smart, ssh, paramiko]</p></li><li><p>SSH 연결 관련 ansible_host: 연결할 호스트의 IP ansible_port: SSH 포트 번호, 기본값인 22일 경우에는 작성할 필요 없음 ansible_user: 접속에 사용할 유저 이름, 사용하는 유저가 root인 경우 작성할 필요 없음 ansible_ssh_pass: SSH 연결시 사용할 비밀번호 ansible_ssh_private_key_file: 연결시에 사용할 SSH 비밀키 파일, 비밀번호로 연결하는 경우 필요 없음</p></li><li><p>권한 관련 ansible_become: sudo와 동일. 권한을 확대 [yes / no] ansible_become_method: 권한 확대 방법 [su] ansible_become_user: 입력된 유저로 권한을 확대 ansible_become_password: 권환 확대할 유저의 비밀번호 ansible_become_exe: 선택한 권한 확대 방법을 어떻게 실행할지 설정 ["sudo su -"] ansible_become_flags: 권한 확대 방법 실행 시 추가적으로 옵션을 설정</p></li></ul><h2 id="with-docker-container">with Docker container</h2><ul><li>호스트 연결 타입 ansible_host: 연결할 Docker 컨테이너의 이름 ansible_user: 컨테이너 내에서 작동할 유저 이름, 컨테이너 안에 유저가 있어야 함 ansible_become: true, become_user로 설정하면 컨테이너 내에서 작동하는데 사용 ansible_docker_extra_args: Docker에 접속할 때 추가할 args들을 입력</li></ul>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
      <category>ansible</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sshpass</tag>
      
      <tag>docker</tag>
      
      <tag>script</tag>
      
      <tag>앤서블</tag>
      
      <tag>ansible</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>슬라이스 타입이란</title>
    <link href="/ko/Rust/rust-2/"/>
    <url>/ko/Rust/rust-2/</url>
    
    <content type="html"><![CDATA[<p>러스트 슬라이스 타입에 대해 공부한 내용을 정리합니다. <span id="more"></span></p><hr /><p><a href="https://dev-bearabbit.github.io/2021/09/04/Rust/rust-1/#more">이전 글</a>에서는 러스트만의 고유한 참조 방식에 대해서 살펴보았다. 러스트의 참조 방식은 데이터 경합을 유발할 수 있는 경우를 제외한 제한된 허용 하에서 사용할 수 있었다. 이번 글에서는 이런 러스트의 특성을 잘 나타내는 슬라이스 타입에 대해 정리할 것이다.</p><h2 id="첫-번째-문자를-도출하기">첫 번째 문자를 도출하기</h2><p>어떤 문장에서 첫 번째 문자를 도출하고 싶다. 이런 경우 러스트에서 어떻게 코드를 만들 수 있을까? 아래의 코드를 살펴보자.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">sen</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello world!&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = <span class="hljs-title function_ invoke__">first_word</span>(&amp;sen);<br>    sen.<span class="hljs-title function_ invoke__">clear</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,num);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">first_word</span>(s: &amp;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span>&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bytes</span> = s.<span class="hljs-title function_ invoke__">as_bytes</span>();<br>    <span class="hljs-keyword">for</span> (i, &amp;item) <span class="hljs-keyword">in</span> bytes.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>()&#123;<br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">b&#x27; &#x27;</span>&#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    s.<span class="hljs-title function_ invoke__">len</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>위 코드는 "Hello world!"에서 첫 번째 단어의 글자 수를 반환해주는 함수이다. <code>first_word()</code>를 자세히 살펴보자.</p><p>먼저 <code>first_word()</code>는 문자열을 받아 이를 byte로 변환한다. 이렇게 변환하면 변수 <code>bytes</code>는 [72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33] 배열로 저장된다. 이를 <code>for</code>문으로 통해 인덱스와 함께 하나씩 살펴보면서 공백(32)과 동일한 수가 있다면 인덱스인 <code>i</code>를 반환한다.</p><p>위 함수는 그럴 듯 해보인다. 하지만 문자열 변수 <code>sen</code>가 변경되거나 사라져도 <code>num</code>값은 계속 유지된다. 위 코드에서 <code>sen.clear()</code>를 통해 변수 <code>sen</code>을 제거하였음에도 <code>num</code>은 사라지지 않는다. 이런 변수들의 독립성은 추후 컴파일단에서 잡히지 않는 버그가 될 수 있다. 나중에 변수 <code>sen</code>이 변경된 상태에서 <code>num</code>값을 사용하여 첫 번째 단어를 추출해도 프로그램 상 어떤 오류도 발생하지 않기 때문이다.</p><p>따라서 변수 <code>sen</code>이 변경되거나 사라지면 에러가 도출되는 함수를 만들고 싶다. 그럴 때 러스트의 슬라이스 타입을 사용할 수 있다.</p><h2 id="슬라이스-타입이란">슬라이스 타입이란</h2><p>슬라이스(Slice) 타입은 소유권을 갖지 않으며, 문자열의 일부를 참조하는 방식이다. 위 예시에서 사용된 문자열 변수 <code>sen</code>을 통해 예시를 살펴보자.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">sen</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello world!&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">first</span> = &amp;sen[..<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">second</span> = &amp;sen[<span class="hljs-number">5</span>..];<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, first);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, second);<br>&#125;<br></code></pre></td></tr></table></figure><p>위 코드는 변수 <code>sen</code>의 값인 "Hello world!"에서 변수 <code>first</code>가 인덱스 0부터 5까지의 문자열을 참조로 가져오며, 변수 <code>second</code>는 인덱스 5에서부터 끝까지의 문자열을 참조로 가져온다. 한번 더 강조하지만 슬라이스 타입은 <strong>참조</strong>이기 때문에 변수 <code>sen</code>의 값이 변경된다면 <code>first</code>, <code>second</code>를 도출하는 데 문제가 발생한다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">sen</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello world!&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">first</span> = &amp;sen[..<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">second</span> = &amp;sen[<span class="hljs-number">5</span>..];<br>    sen.<span class="hljs-title function_ invoke__">clear</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, first);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, second);<br>&#125;<br>error[E0502]: cannot borrow `sen` <span class="hljs-keyword">as</span> mutable because it is also borrowed <span class="hljs-keyword">as</span> immutable<br> -<span class="hljs-punctuation">-&gt;</span> test.rs:<span class="hljs-number">5</span>:<span class="hljs-number">5</span><br>  |<br><span class="hljs-number">3</span> |     <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">first</span> = &amp;sen[..<span class="hljs-number">5</span>];<br>  |                      --- immutable borrow occurs here<br><span class="hljs-number">4</span> |     <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">second</span> = &amp;sen[<span class="hljs-number">5</span>..];<br><span class="hljs-number">5</span> |     sen.<span class="hljs-title function_ invoke__">clear</span>();<br>  |     ^^^^^^^^^^^ mutable borrow occurs here<br><span class="hljs-number">6</span> |     <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, first);<br>  |                    ----- immutable borrow later used here<br><br>error: aborting due to previous error; <span class="hljs-number">2</span> warnings emitted<br><br>For more information about this error, <span class="hljs-keyword">try</span> `rustc --explain E0502`.<br></code></pre></td></tr></table></figure><p>위 코드는 전의 코드와 다르게 에러를 반환한다. 차이는 <code>sen.clear();</code> 이것 딱 하나이다. 에러를 자세히 살펴보면 슬라이스 타입에 이미 &amp;로 참조가 되었기 때문에 변수 <code>sen</code>을 변경할 수 없다고 설명한다. 이처럼 슬라이스 타입을 사용한다면 앞서 봤던 오류를 해결할 수 있다.</p><h2 id="슬라이스를-사용하여-첫-번째-문자를-도출하기">슬라이스를 사용하여 첫 번째 문자를 도출하기</h2><p>이제 배운 슬라이스 타입을 사용하여 첫 번째 문자를 도출해보자. 코드는 아래와 같다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">sen</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello world!&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = <span class="hljs-title function_ invoke__">first_word</span>(&amp;sen);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,num);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">first_word</span>(s: &amp;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span>&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bytes</span> = s.<span class="hljs-title function_ invoke__">as_bytes</span>();<br>    <span class="hljs-keyword">for</span> (i, &amp;item) <span class="hljs-keyword">in</span> bytes.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>()&#123;<br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">b&#x27; &#x27;</span>&#123;<br>            <span class="hljs-keyword">return</span> &amp;s[..i];<br>        &#125;<br>    &#125;<br>    &amp;s[..]<br>&#125;<br></code></pre></td></tr></table></figure><p>위 코드는 전반적인 논리는 앞에서 설명한 바와 동일하다. 다만 발견한 첫 번째 문자의 마지막 인덱스를 사용하여 슬라이스 타입으로 첫 번째 단어를 도출한다. 이렇게 코드를 변경하면 변수 <code>sen</code>가 변경되었을 시에도 이전 문장의 첫 번째 단어를 가져올 수 있다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">sen</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello world!&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = <span class="hljs-title function_ invoke__">first_word</span>(&amp;sen);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">sen</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;changed&quot;</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,num);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,sen);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">first_word</span>(s: &amp;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span>&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bytes</span> = s.<span class="hljs-title function_ invoke__">as_bytes</span>();<br>    <span class="hljs-keyword">for</span> (i, &amp;item) <span class="hljs-keyword">in</span> bytes.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>()&#123;<br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">b&#x27; &#x27;</span>&#123;<br>            <span class="hljs-keyword">return</span> &amp;s[..i];<br>        &#125;<br>    &#125;<br>    &amp;s[..]<br>&#125;<br></code></pre></td></tr></table></figure><p>위 코드의 결과는 다음과 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Hello<br>changed<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>ownership</tag>
      
      <tag>memory</tag>
      
      <tag>slice</tag>
      
      <tag>borrowing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[SQLD] 데이터 모델링의 이해</title>
    <link href="/ko/Certificate/sqld-0/"/>
    <url>/ko/Certificate/sqld-0/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 SQL 개발자(SQLD) 자격증 공부 내용을 정리합니다. <span id="more"></span></p><h2 id="데이터-모델링">데이터 모델링</h2><p>데이터 모델링이란 복잡한 현실 세계를 데이터베이스로 표현하기 위해서 추상화, 단순화, 명화학하는 과정을 의미한다.</p><h3 id="데이터-모델링-특징">데이터 모델링 특징</h3><ul><li>추상화: 현실세계를 간략하게 표현</li><li>단순화: 누구나 이해할 수 있게 표현</li><li>명확화: 애매한 의미 제거</li></ul><h3 id="데이터-모델링-단계">데이터 모델링 단계</h3><ul><li>개념적 모델링: 전사관점, 업무측면에서 모델링, 추상화 진행</li><li>논리적 모델링: 식별자 정의, 관계, 속성 표현, 재사용성을 위한 정규화 진행</li><li>물리적 모델링: DBMS에 실제 데이터 생성</li></ul><h3 id="데이터-모델링-관점">데이터 모델링 관점</h3><ul><li>데이터: 사용되는 데이터 구조분석, 정적분석</li><li>프로세스: 수행하는 작업 시나리오 분석, 동적 분석</li><li>데이터+프로세스: CRUD(Create, Read, Update, Delete) 분석</li></ul><h3 id="erdentity-relationship-diagram">ERD(Entity Relationship Diagram)</h3><p>엔터티 간의 관계 표기법</p><p><strong>엔터티란?</strong> 업무에서 관리해야 하는 데이터 집합. 보통 고객의 비즈니스 프로세스에서 추출</p><h3 id="erd-작성-절차">ERD 작성 절차</h3><ol type="1"><li>엔터티 도출</li><li>엔터티 배치</li><li>엔터티 간의 관계 설정</li><li>엔터티 간의 관계명 서술</li><li>엔터티 간의 관계 참여도 표현</li><li>엔터티 간의 관계 필수 여부를 표현</li></ol><h2 id="층-스키마">3층 스키마</h2><p>데이터 독립성을 위해 사용자, 설계자, 개발자가 바라보는 관점에 따라 데이터베이스를 기술하는 방법.</p><ul><li>사용자: 외부스키마(업무살 관련 데이터 접근. 응용 프로그램 -&gt; 데이터)</li><li>설계자: 개념스키마(전체 DB 내 구조 설계. 통합 DB 구조 설계)</li><li>개발자: 내부스키마(DB 물리적 저장구조. 레코드, 칼럼, 인덱스 정리)</li></ul><h3 id="데이터-독립성">데이터 독립성</h3><ul><li>논리적 독립성: 개념스키마 변경이 외부 스키마에 영향을 주지 않는 것</li><li>물리적 독립성: 내부스키마 변경이 개념 스키마에 영향을 주지 않는 것</li></ul><h3 id="데이터-독립의-장점">데이터 독립의 장점</h3><ol type="1"><li>복잡도 축소</li><li>중복제거 가능</li><li>사용자 요구사항 변경에 따른 대응 가능</li><li>관리 및 유지보수 비용 축소</li></ol><h2 id="엔터티">엔터티</h2><p>고객의 비즈니스 프로세스에서 관리되어야 하는 정보를 추출</p><h3 id="엔터티-특징">엔터티 특징</h3><table><thead><tr class="header"><th>특징</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>식별자</td><td>고유값 칼럼 필요</td></tr><tr class="even"><td>인스턴스 집합</td><td>인스턴스는 2개 이상</td></tr><tr class="odd"><td>속성</td><td>반드시 속성 보유</td></tr><tr class="even"><td>관계</td><td>다른 엔터티와 최소 1개 이상의 관계 필요</td></tr><tr class="odd"><td>업무</td><td>관리되어야 하는 집합</td></tr></tbody></table><h3 id="엔터티-종류">엔터티 종류</h3><ul><li>유형/무형</li></ul><table><thead><tr class="header"><th>종류</th><th>설명</th><th>예시</th></tr></thead><tbody><tr class="odd"><td>유형 엔터티</td><td>물리적 형태 존재. 업무에서 사용되는 엔터티</td><td>고객, 사원</td></tr><tr class="even"><td>개념 엔터티</td><td>물리적 형태 미존재</td><td>거래소 종목, 코스닥 종목</td></tr><tr class="odd"><td>사건 엔터니</td><td>비즈니스 상에서 생성</td><td>주문, 취소, 수수료 청구</td></tr></tbody></table><ul><li>발생시점</li></ul><table><thead><tr class="header"><th>종류</th><th>설명</th><th>예시</th></tr></thead><tbody><tr class="odd"><td>기본 엔터티</td><td>키 엔터티. 독립적으로 생성됨</td><td>고객, 사원</td></tr><tr class="even"><td>중심 엔터티</td><td>기본과 행위 중간에 위치</td><td>주문, 로그인</td></tr><tr class="odd"><td>행위 엔터티</td><td>2개 이상의 엔터티로부터 발생</td><td>주문이력, 로그인이력</td></tr></tbody></table><h2 id="속성attribute">속성(Attribute)</h2><p>엔터티의 요건 중 하나.</p><h3 id="속성의-특징">속성의 특징</h3><ul><li>하나의 값만 보유</li><li>업무에서 관리되는 정보</li><li>기본키가 변경되면 속성의 값도 변경(주식별자에게 함수적으로 종속)</li></ul><h3 id="속성의-종류">속성의 종류</h3><ul><li>분해여부</li></ul><table><thead><tr class="header"><th>종류</th><th>설명</th><th>예시</th></tr></thead><tbody><tr class="odd"><td>단일속성</td><td>하나의 의미로 구성된 것(1값:1의미)</td><td>회원ID,이름</td></tr><tr class="even"><td>복합속성</td><td>여러개의 의미를 보유(1값:N의미)</td><td>주소(시군동)</td></tr><tr class="odd"><td>다중값속성</td><td>여러개의 값, 의미를 보유(N값:N의미)</td><td>상품리스트</td></tr></tbody></table><ul><li>특성</li></ul><table><thead><tr class="header"><th>종류</th><th>설명</th><th>예시</th></tr></thead><tbody><tr class="odd"><td>기본속성</td><td>비즈니스 프로세스에서 도출되는 본래의 속성</td><td>회원ID</td></tr><tr class="even"><td>설계속성</td><td>데이터 모델링 관점에서 발생하는 속성</td><td>상품코드</td></tr><tr class="odd"><td>파생속성</td><td>다른 속성에 의해 생성되는 속성</td><td>합계, 평균</td></tr></tbody></table><h3 id="도메인">도메인</h3><p>속성이 가질 수 있는 값의 범위. 예로 성별이라는 속성이 가질 수 있는 도메인은 남성/여성이다.</p><h2 id="관계relationship">관계(Relationship)</h2><p>엔터티 간의 관련성을 의미</p><ul><li>분류</li></ul><table><thead><tr class="header"><th>종류</th><th>설명</th><th>예시</th></tr></thead><tbody><tr class="odd"><td>존재관계</td><td>엔터티 간 상태를 표현</td><td>회원가입 -&gt; 관리점 할당 -&gt; 관리점에서 고객관리</td></tr><tr class="even"><td>행위관계</td><td>엔터티 간 행위에 대한 관련성 표현</td><td>계좌개설 -&gt; 주문 발주</td></tr></tbody></table><h3 id="관계-차수cardinality">관계 차수(Cardinality)</h3><p>두 엔터티 간에 관계에 참여하는 수를 의미.</p><h3 id="관계-차수-종류">관계 차수 종류</h3><table><thead><tr class="header"><th>종류</th><th>설명</th><th>예시</th></tr></thead><tbody><tr class="odd"><td>1대1 관계</td><td>완전 1대1 관계와 선택적 1대1 관계로 나눠진다.</td><td>고객:고객등급</td></tr><tr class="even"><td>1대N 관계</td><td>엔터티 1행에 여러개의 값이 있는 관계</td><td>고객:계좌</td></tr><tr class="odd"><td>M대N 관계</td><td>2개의 엔터티가 서로 여러개의 값을 가진 관계</td><td>학생:수업</td></tr></tbody></table><ul><li><p>M대N 관계의 조인은 카테시안 곱이 발생하기에 1대1 관계, 1대N 관계로 변경해야 한다. 예로 학생은 여러 개의 수업을 들을 수 있고, 수업 또한 여러 명의 학생이 신청할 수 있다. 이런 관계에서는 학생, 수업 2개의 엔터티를 생성하는 것보다 학생, 수강, 수업이라는 3개의 엔터티를 생성하는 것이 좋다.</p></li><li><p>필수적 관계는 O로 표현되고, 선택적 관계는 |로 표현된다.</p></li></ul><h2 id="식별-관계와-비식별-관계">식별 관계와 비식별 관계</h2><table><thead><tr class="header"><th>종류</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>식별 관계</td><td>- 독립적으로 존재할 수 있는 강한 개체 (다른 엔터티에 의존X) <br>- 다른 엔터티와 관계를 가질 때 기본키를 공유 <br>- 식별 관계로 표현 <br>- 강한 개체의 값이 변경되면 식별관계에 있는 엔터티의 값도 변경된다.</td></tr><tr class="even"><td>비식별 관계</td><td>강한 개체의 기본키를 일반 칼럼으로 관계를 받는 가지는 것</td></tr></tbody></table><h2 id="엔터티-식별자">엔터티 식별자</h2><p>엔터티를 대표할 수 있는 유일성을 만족하는 속성.</p><h3 id="주식별자기본키">주식별자(기본키)</h3><ul><li><p>요건: 최소성, 대표성, 유일성, 불변성</p></li><li><p>키의 종류</p></li></ul><table><thead><tr class="header"><th>종류</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>기본키</td><td>후보키 중 엔터티를 대표하는 키</td></tr><tr class="even"><td>후보키</td><td>유일성과 최소성을 만족하는 키</td></tr><tr class="odd"><td>슈퍼키</td><td>유일성은 만족하지만 최소성을 만족하지 않는 키</td></tr><tr class="even"><td>대체키</td><td>여러 개의 후보키 중에서 기본키를 제외한 남은 키</td></tr><tr class="odd"><td>외래키</td><td>키본키 필드를 가리키는 것으로 참조무결성을 확인하기 위해 사용</td></tr></tbody></table><h3 id="식별자의-종류">식별자의 종류</h3><ul><li>대표성 여부</li></ul><table><thead><tr class="header"><th>종류</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>주식별자</td><td>엔터티를 대표하는 식별자, 참조관계로 연결</td></tr><tr class="even"><td>보조 식별자</td><td>유일성과 최소성은 만족하지만 대표성을 만족하지 못하는 식별자</td></tr></tbody></table><ul><li>생성 여부</li></ul><table><thead><tr class="header"><th>종류</th><th>설명</th><th>예시</th></tr></thead><tbody><tr class="odd"><td>내부 식별자</td><td>엔터티 내부에서 스스로 생성하는 식별자</td><td>부서코드, 주문번호 등</td></tr><tr class="even"><td>외부 식별자</td><td>다른 엔터티와의 관계로 인해 생성되는 식별자</td><td>계좌엔터티의 회원 ID</td></tr></tbody></table><ul><li>속성의 수</li></ul><table><thead><tr class="header"><th>종류</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>단일 식별자</td><td>하나의 속성으로 구성</td></tr><tr class="even"><td>복합 식별자</td><td>두 개 이상의 속성으로 구성</td></tr></tbody></table><ul><li>대체 여부</li></ul><table><thead><tr class="header"><th>종류</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>본질 식별자</td><td>비즈니스 프로세스에서 만들어지는 식별자</td></tr><tr class="even"><td>인조 식별자</td><td>인위적으로 만들어지는 식별자</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>etc.</category>
      
      <category>certificate</category>
      
    </categories>
    
    
    <tags>
      
      <tag>데이터자격시험</tag>
      
      <tag>자격증</tag>
      
      <tag>SQLD</tag>
      
      <tag>query</tag>
      
      <tag>데이터모델링</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>소유권 참조와 대여</title>
    <link href="/ko/Rust/rust-1/"/>
    <url>/ko/Rust/rust-1/</url>
    
    <content type="html"><![CDATA[<p>러스트 소유권 참조와 대여 방식에 대해 공부한 내용을 정리합니다. <span id="more"></span></p><hr /><p><a href="https://dev-bearabbit.github.io/2021/08/30/Rust/rust-0/#more">이전 글</a>에서는 러스트 소유권 원리에 대해 살펴보았다. 힙 메모리에 사용된 변수의 경우, 복제(clone)라는 방식을 통해서만 특정 변수를 복사할 수 있었다. 하지만 이 방식은 경우에 따라 효율적이지 못하다. 만약 특정 변수값을 전달하기만 하면 되는 경우에는 특히 더 비효율적이다. 그렇기에 러스트는 참조와 대여라는 방법을 제공한다. 즉, 도서관에서 책 빌려주듯이 러스트도 특정 변수를 범위 내의 다른 함수에 빌려줄 수 있는 것이다. 물론 해당 변수의 소유권은 그대로 가진 채 말이다.</p><h2 id="변수-참조">변수 참조</h2><p>참조(Reference)는 변수의 포인터, 길이, 용량 등의 값을 저장하고 있는 그 값들을 가져오는 방식이다. 아래의 코드를 보자.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = <span class="hljs-title function_ invoke__">check_length</span>(&amp;s);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#x27;&#123;&#125;&#x27;의 길이는 &#123;&#125;입니다.&quot;</span>,s, len)<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">check_length</span>(s: &amp;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    s.<span class="hljs-title function_ invoke__">len</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>위 코드에서는 <code>check_length()</code>가 <code>s</code>를 참조하여 길이 값을 리턴한다. 이는 <code>main()</code>에서 정의된 변수 <code>s</code>의 소유권을 가져오지 않으며 해당 변수의 정보를 사용할 수 있다는 것을 의미한다. 변수를 참조할 때는 변수이름 앞에 <code>&amp;(Ampersand)</code>을 붙임으로써 참조변수라는 것을 나타낸다. 즉 참조는 'read only' 정도의 권한을 제공받는 것이라고 볼 수 있다. 읽을 수 있기에 위 코드처럼 길이는 리턴하는 것도 가능하며, 또한 아래 코드처럼 해당 변수를 그대로 프린트 할 수도 있다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-title function_ invoke__">print_test</span>(&amp;s);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_test</span>(s: &amp;<span class="hljs-type">String</span>)&#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,s);<br>&#125;<br></code></pre></td></tr></table></figure><p>위 코드는 'hello'라는 결과값을 도출한다. 그렇다면 'read only' 권한 상태에서 불가능한 것은 무엇인가? 바로 '수정(edit)'이다. 만약 참조받은 변수를 일부 수정하여 사용하고 싶다면 복제밖에 방법이 없는걸까?</p><h2 id="가변-참조">가변 참조</h2><p>물론 몇가지 값만 추가한다면 참조받은 변수를 변경할 수 있다. 우선 아래의 코드를 살펴보자.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-title function_ invoke__">add_word</span>(&amp;<span class="hljs-keyword">mut</span> s);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_word</span>(s: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">String</span>)&#123;<br>    s.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot; world!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>위 코드의 결과는 어떻게 나올까? 과연 프린트되는 단어는 'hello'일까, 아니면 'hello world!' 일까? 정답은 'hello world!' 이다. 그 이유는 변수를 생성할 때 가변 참조가 가능하도록 생성했기 때문이다. <code>가변 참조</code>란 소유권 없이 참조만으로도 변수의 값을 변경할 수 있는 방법이다. 가변 참조 방법을 이용하면 참조받은 변수를 수정하여 리턴할 수 있다. 하지만 러스트는 데이터 경합(Data race)을 방지하기 위하여 가변 참조에 몇 가지 제한을 둔다.</p><h3 id="데이터-경합이란">데이터 경합이란</h3><p>데이터 경합(Data race)은 병렬 프로그래밍을 할 때 범하기 쉬운 오류로, 멀티 스레드가 동일한 데이터를 이용하는 도중에 다른 스레드가 업데이트 하는 경우를 말한다. 즉, 멀티 스레드로 코드를 작동시키는 과정에서 각각의 스레드가 메모리에 올라간 동일한 변수를 가져다가 사용하고, 이를 변경하는 것이다. 예시로 이해해보자.</p><ul><li>변수 'num'을 10으로 저장한다.</li><li>'add()'는 변수에 1을 더해서 리턴한다. 'add(num)'을 멀티 스레드로 실행시킨다.</li><li>그러면 두 스레드 모두 'num' 값인 10을 받아서 11로 리턴한다.</li><li>즉, 병렬로 처리되는 12를 기대했지만 사실상 두 스레드 모두 11을 리턴한다.</li></ul><p>데이터 경합은 왜 발생하는 것일까? 데이터 경합이 발생하는 조건은 다음과 같다.</p><ul><li>두 개 이상의 포인터가 동시에 같은 데이터에 접근</li><li>그 중 최소 하나 이상의 포인터가 데이터를 쓰기로 사용</li><li>데이터 동시 접근에 대한 동기화 메커니즘이 없음</li></ul><p>러스트는 해당 문제를 컴파일러단에서 미리 찾아 개발자에게 알려준다.</p><h3 id="가변-참조-조건-1-가변-변수로-생성">가변 참조 조건 1: 가변 변수로 생성</h3><p>위 코드를 보면 변수 <code>s</code>는 정의될 때 <code>mut</code>이라는 단어가 앞에 붙음으로서 가변 참조가 가능한 변수로 생성되었다. 따라서 <code>add_word()</code>가 참조만으로도 'world!'를 추가할 수 있던 것이다. 만약 변경하려는 변수 <code>s</code>를 가변 변수로 생성하지 않는다면 어떻게 될까?</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-title function_ invoke__">add_word</span>(&amp;<span class="hljs-keyword">mut</span> s);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_word</span>(s: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">String</span>)&#123;<br>    s.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot; world!&quot;</span>);<br>&#125;<br><br>error[E0596]: cannot borrow `s` <span class="hljs-keyword">as</span> mutable, <span class="hljs-keyword">as</span> it is not declared <span class="hljs-keyword">as</span> mutable<br> -<span class="hljs-punctuation">-&gt;</span> test.rs:<span class="hljs-number">3</span>:<span class="hljs-number">14</span><br>  |<br><span class="hljs-number">2</span> |     <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>  |         - help: consider changing this to be mutable: `<span class="hljs-keyword">mut</span> s`<br><span class="hljs-number">3</span> |     <span class="hljs-title function_ invoke__">add_word</span>(&amp;<span class="hljs-keyword">mut</span> s);<br>  |              ^^^^^^ cannot borrow <span class="hljs-keyword">as</span> mutable<br><br>error: aborting due to previous error<br><br>For more information about this error, <span class="hljs-keyword">try</span> `rustc --explain E0596`.<br></code></pre></td></tr></table></figure><p>컴파일러가 가변 참조가 불가능하다고 에러를 리턴한다.</p><h3 id="가변-참조-조건-2-소유권-범위에-가변-참조는-1개만-존재">가변 참조 조건 2: 소유권 범위에 가변 참조는 1개만 존재</h3><p>가변 참조는 실제 데이터의 값을 변경할 수 있다. 그렇기에 2개 이상의 갸변 변수가 발생하면 당연히 데이터 경합의 문제가 발생한다. 이를 방지하기 위해 러스트는 컴파일러단에서 가변 변수 갯수를 제한한다. 만약 가변 변수 2개를 생성하면 어떻게 될까? 아래의 코드에서 확인해보자.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = &amp;<span class="hljs-keyword">mut</span> s;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = &amp;<span class="hljs-keyword">mut</span> s;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&#123;&#125;&quot;</span>,s1,s2);<br>&#125;<br>error[E0499]: cannot borrow `s` <span class="hljs-keyword">as</span> mutable more than once at a time<br> -<span class="hljs-punctuation">-&gt;</span> test.rs:<span class="hljs-number">4</span>:<span class="hljs-number">14</span><br>  |<br><span class="hljs-number">3</span> |     <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = &amp;<span class="hljs-keyword">mut</span> s;<br>  |              ------ first mutable borrow occurs here<br><span class="hljs-number">4</span> |     <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = &amp;<span class="hljs-keyword">mut</span> s;<br>  |              ^^^^^^ second mutable borrow occurs here<br><span class="hljs-number">5</span> |     <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&#123;&#125;&quot;</span>,s1,s2);<br>  |                     -- first borrow later used here<br><br>error: aborting due to previous error<br></code></pre></td></tr></table></figure><p>위 코드는 가변 변수 <code>s1</code>, <code>s2</code>를 생성한다. 러스트는 컴파일 단에서 에러를 리턴한다. 그렇다면 만약 가변 변수의 소유 범위가 다르다면 어떻게 될까?</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = &amp;<span class="hljs-keyword">mut</span> s;<br>    <span class="hljs-title function_ invoke__">add_word</span>(s1);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,s1)<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = &amp;<span class="hljs-keyword">mut</span> s;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,s2)<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_word</span>(s: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">String</span>)&#123;<br>    s.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot; world!&quot;</span>);<br>&#125;<br>hello world!<br>hello world!<br></code></pre></td></tr></table></figure><p>위 코드는 에러 없이 컴파일이 되며, 결과값으로 "hello world!"가 2번 프린트 된다. 그 이유는 변수 <code>s1</code>은 소유 범위인 <code>&#123;&#125;</code>를 벗어나면서 메모리 할당이 해제되고 실제 데이터에 어떤 포인터도 없는 상태에서 변수 <code>s2</code>가 다시 가변 변수로 생성되기 때문이다.</p><h3 id="가변-참조-조건-3-불변-참조와-가변-참조는-동시-사용-불가">가변 참조 조건 3: 불변 참조와 가변 참조는 동시 사용 불가</h3><p>만약 불변 참조와 가변 참조를 동시에 진행하면 어떻게 될까? 아래의 코드를 작동시켜 확인해보자.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = &amp;s;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = &amp;<span class="hljs-keyword">mut</span> s;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&#123;&#125;&quot;</span>,s1,s2);<br>&#125;<br>error[E0502]: cannot borrow `s` <span class="hljs-keyword">as</span> mutable because it is also borrowed <span class="hljs-keyword">as</span> immutable<br> -<span class="hljs-punctuation">-&gt;</span> test.rs:<span class="hljs-number">4</span>:<span class="hljs-number">14</span><br>  |<br><span class="hljs-number">3</span> |     <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = &amp;s;<br>  |              -- immutable borrow occurs here<br><span class="hljs-number">4</span> |     <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = &amp;<span class="hljs-keyword">mut</span> s;<br>  |              ^^^^^^ mutable borrow occurs here<br><span class="hljs-number">5</span> |     <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&#123;&#125;&quot;</span>,s1,s2);<br>  |                     -- immutable borrow later used here<br><br>error: aborting due to previous error<br></code></pre></td></tr></table></figure><p>결과는 당연히 되지 않는다. 왜 불변 참조와 가변 참조는 동시에 진행되지 않을까? 바로 윗 글에서 답안을 찾을 수 있다. 바로 데이터 경합의 문제가 발생하기 때문이다. 불변 참조와 가변 참조가 동시에 한 데이터를 바라보고 있기에 2개 이상의 포인터가 존재하는 상황에서 하나의 포인터(가변 참조)는 쓰기 권한도 가지고 있다. 따라서 이 또한 러스트가 컴파일 단에서 에러를 일으킨다.</p><h2 id="죽은-참조">죽은 참조</h2><p>죽은 참조(dangling pointer)란 이미 메모리에서 해제된 데이터를 참조하는 포인터를 말한다. 아래 코드를 통해 좀 더 자세히 알아보자.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">dangling</span> = <span class="hljs-title function_ invoke__">dangle</span>();<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dangle</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span>  = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &amp;s<br>&#125;<br><br>error[E0106]: missing lifetime specifier<br> -<span class="hljs-punctuation">-&gt;</span> test.rs:<span class="hljs-number">4</span>:<span class="hljs-number">16</span><br>  |<br><span class="hljs-number">4</span> | <span class="hljs-keyword">fn</span> <span class="hljs-title function_">dangle</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">String</span> &#123;<br>  |                ^ expected named lifetime parameter<br>  |<br>  = help: this function<span class="hljs-symbol">&#x27;s</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">contains</span> a borrowed value, but there is no value <span class="hljs-keyword">for</span> <span class="hljs-title class_">it</span> to be borrowed from<br>help: consider using the `<span class="hljs-symbol">&#x27;static</span>` lifetime<br></code></pre></td></tr></table></figure><p>위 코드는 에러를 일으킨다. 그 이유는 <code>dangle()</code> 에서 생성된 변수 <code>s</code>는 함수가 종료되는 순간 소유 범위를 벗어났기에 메모리에서 해제되기 때문이다. 즉, 변수 <code>s</code> 데이터는 이미 존재하지 않지만 변수 <code>s</code>를 참조하는 포인터가 생성된다. 즉 죽은 참조가 발생하는 것이다. 러스트는 컴파일 단에서 이를 확인하고 에러로 반환해준다. 만약 위 코드를 죽은 참조없이 사용하려면 어떻게 해야 할까?</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">dangling</span> = <span class="hljs-title function_ invoke__">dangle</span>();<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dangle</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span>  = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    s<br>&#125;<br></code></pre></td></tr></table></figure><p>위 코드는 문제를 일으키지 않는다. <code>dangle()</code> 에서 생성된 변수 <code>s</code>가 변수 <code>dangling</code>로 이동하면서 메모리 할당이 해제되지 않기 때문이다.</p><h2 id="참조-사용-시-주의할-점">참조 사용 시 주의할 점</h2><p>이번 글에서는 러스트에서 참조를 사용하는 방법들에 대해 알아보았다. 위 내용들을 바탕으로 참조를 사용할 때 주의해야 할 점들을 정리해보자.</p><ul><li>불변 참조는 여러 개가 가능하지만 가변 참조는 하나만 가능하다.</li><li>불변 참조와 가변 참조는 동시에 사용될 수 없다.</li><li>가변 참조는 소유 범위 내에서 1개만 사용할 수 있다.</li><li>참조는 항상 유효해야 한다.</li></ul>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>ownership</tag>
      
      <tag>memory</tag>
      
      <tag>slice</tag>
      
      <tag>borrowing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>움직이는 배경 설정하기</title>
    <link href="/ko/AboutHexo/about-hexo-3/"/>
    <url>/ko/AboutHexo/about-hexo-3/</url>
    
    <content type="html"><![CDATA[<p>NexT 테마에서 움직이는 배경을 설정합니다.</p><p>아직 블로그를 만들지 않았다면 <a href="https://dev-bearabbit.github.io/2020/02/27/AboutHexo/about_hexo-0/">이전 글</a>을 참고해주시기 바랍니다.</p><span id="more"></span><hr /><p>오랜만에 다시 블로그 테마에 관련된 글을 가지고 왔다. 요즘 블로그 테마가 약간 지겨워져서 미세한 변화라도 주고 싶었고, 그 결과 움직이는 배경을 추가하였다.</p><p>이 글은 기존에 Hexo 블로그에 NexT 테마가 이미 적용된 상황을 가정하고 설명한다. 만약 블로그를 처음 만든다면 해당 카테고리 내에 첫 글부터 읽으며 따라오면 된다.</p><p>움직이는 배경을 추가해보자.</p><ul><li>먼저 움직이는 배경을 다운로드 한다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$hexo_directory</span><br>git <span class="hljs-built_in">clone</span> https://github.com/theme-next/theme-next-canvas-nest themes/next/source/lib/canvas-nest/<br></code></pre></td></tr></table></figure><ul><li>그 다음 themes/next/_config.yml 을 오픈하여 아래의 내용을 찾은 후, <code>enable</code>의 false를 true로 수정한다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">canvas_nest:<br>  <span class="hljs-built_in">enable</span>: <span class="hljs-literal">true</span><br>  onmobile: <span class="hljs-literal">true</span> <span class="hljs-comment"># Display on mobile or not</span><br>  color: <span class="hljs-string">&quot;0,0,255&quot;</span> <span class="hljs-comment"># RGB values, use `,` to separate</span><br>  opacity: 0.5 <span class="hljs-comment"># The opacity of line: 0~1</span><br>  zIndex: -1 <span class="hljs-comment"># z-index property of the background</span><br>  count: 99 <span class="hljs-comment"># The number of lines</span><br></code></pre></td></tr></table></figure><ul><li>마지막으로 수정된 컨피그 값을 저장하기 위해 아래의 명령어를 입력한다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 해당 리소스 생성</span><br>hexo generate<br><br><span class="hljs-comment"># 배포하기</span><br>hexo deploy<br></code></pre></td></tr></table></figure><p>그 후 시간이 조금 지나면 움직이는 배경이 적용된다. 만약 시간이 지나도 변경이 되지 않는다면 해당 브라우저의 캐시를 지우고 다시 접속하면 된다.</p>]]></content>
    
    
    <categories>
      
      <category>etc.</category>
      
      <category>about hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Github</tag>
      
      <tag>blog</tag>
      
      <tag>헥소</tag>
      
      <tag>깃허브</tag>
      
      <tag>블로그</tag>
      
      <tag>NexT</tag>
      
      <tag>next</tag>
      
      <tag>테마</tag>
      
      <tag>themes</tag>
      
      <tag>카테고리</tag>
      
      <tag>태그</tag>
      
      <tag>category</tag>
      
      <tag>tag</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 소유권이란</title>
    <link href="/ko/Rust/rust-0/"/>
    <url>/ko/Rust/rust-0/</url>
    
    <content type="html"><![CDATA[<p>러스트 소유권 원리에 대해 공부한 내용을 정리합니다. <span id="more"></span></p><hr /><p>모든 프로그램은 실행중인 동안 컴퓨터 메모리를 사용 및 관리한다. 예를 들어 C++의 경우는 해당 프로그램을 작성할 때 메모리 할당 및 해제를 프로그래머가 직접 작성해야 하며, Java의 경우 가비지 콜렉터를 통해 사용되지 않는 메모리를 주기적으로 찾아 메모리를 자동 해제한다. 그렇다면 러스트는 어떻게 메모리를 관리하는가?</p><h2 id="소유권">소유권</h2><p>러스트는 앞서 말한 두 방식 모두 사용하지 않는다. 러스트는 컴파일 하는 시점에 컴파일러가 여러 규칙으로 작성된 소유권 시스템에 의해 메모리를 관리한다. 즉, 메모리 할당에 문제가 있는 코드는 컴파일되는 과정에서 찾아낼 수 있다.</p><p><strong>NOTE</strong> 러스트의 소유권을 더 자세히 이해하기 위해서는 스택(stack) 메모리와 힙(heap) 메모리에 대해서 알아야 한다. 스택 메모리는 컴파일 할 때부터 크기가 고정된 데이터를 저장하며, LIFO(Last in, First out)방식으로 데이터가 사용된다. 반면 힙 메모리의 경우는 컴파일 할 때에는 크기를 알 수 없다가 프로그램 실행 시 들어오는 데이터를 저장 및 관리한다. 힙 메모리는 언제 어떤 크기의 데이터가 들어올 지 알 수 없기에 스택 메모리처럼 간단히 데이터를 쌓을 수 없다. 그래서 운영체제의 도움을 받아 데이터가 들어올 당시 사용가능한 메모리의 정보를 받고, 이에 저장한다. 힙 메모리의 저장방식을 자세히 보자. 프로그램이 실행 중에 데이터를 저장해야하는 상황이 왔다. 그러면 프로그램은 해당 데이터의 크기를 가지고 운영체제에 힙 메모리 할당을 요청한다. 요청을 받은 운영체제는 사용가능한 메모리 중 해당 데이터 크기에 맞는 크기를 찾은 후 해당 메모리 공간을 사용중으로 변경하고 그 주소를 프로그램에 넘긴다. 여기서 그 주소가 포인터(pointer)이다. 결국 모든 언어에서 관리하고 싶은 부분은 정확하게 힙 메모리이다. 힙 메모리를 어떻게 할당하고 해제하는지에 따라서 프로그램의 성능이 좋아질 수 있기 때문이다.</p><h2 id="소유권-규칙">소유권 규칙</h2><p>소유권에 적용되는 규칙은 다음과 같다.</p><ul><li>러스트가 다루는 값은 소유자(owner)라는 변수를 가진다.</li><li>특정 시점에서 값의 소유자는 단 한 명이다.</li><li>소유자가 소유 범위를 벗어나면 그 값은 제거된다.</li></ul><p>위 규칙에서 중요한 키워드는 <code>소유자</code>, <code>소유 범위</code> 이다. 이에 대하여 더 자세히 알아보자.</p><h2 id="소유자">소유자</h2><p>소유자는 메모리에 입력된 값을 가진 변수를 의미한다. 프로그램이 실행되면서 우리는 다양한 값들을 하나의 변수에 할당하여 사용하곤 한다. 그렇다면 물리적인 메모리에 저장된 값을 가진 변수는 어떻게 설정되는가? 이런 문제들은 해당 변수를 다른 변수로 이동(move)하거나 복사(copy)할 때 직면하게 된다.</p><h3 id="변수-이동move">변수 이동(move)</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// case 1</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = x;<br><span class="hljs-comment">// case 2</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1<br></code></pre></td></tr></table></figure><p>위 코드는 모두 첫 번째 변수에 특정 값을 할당한 후, 이를 두 번째 변수에 대입하는 코드이다. 하지만 메모리에서의 case 1과 case 2의 작동방식은 동일하지 않다. 먼저 case 1의 경우에는 변수 x,y에 대한 값이 각각 스택 메모리에 저장된다. 즉, 변수 x를 호출했을 때 불러오는 데이터의 위치와 변수 y를 호출했을 때 불러오는 데이터의 위치가 다른 것이다. 하지만 case 2의 경우, 컴파일 시 크기와 내용을 알 수 없는 변수로 저장되었기에 힙 메모리를 사용하게 된다. 힙 메모리의 경우, 변수에는 포인터 정보가 들어가 있기에 이 값을 가져오는 경우 포인터 정보가 복사된다. 즉, 실제 힙 메모리에 들어있는 데이터가 복사되는 것이 아니라 기존 데이터를 가리키는 포인터가 2개 생긴다는 의미이다. 하지만 이런 방식은 이후 러스트가 메모리 할당을 해제할 때 문제가 발생한다. 여러 개의 변수들이 하나의 데이터 위치를 가리키고 있기에 하나의 값을 해제하는 코드가 여러번 실행되고 이에 따라 이미 없는 값을 해제하려고 한다는 이중 해제 에러가 발생한다. 이는 안전성 버그 중 하나이다. 따라서 힙 메모리를 사용하는 변수의 경우 러스트는 하나의 값에는 하나의 포인터만 허용한다. 즉, 위 코드는 <code>s1</code>에서 <code>s2</code>로 값이 이동하는 것이고, 포인터 정보 또한 <code>s2</code>로 이동한다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust">error[E0382]: borrow of moved value: `x`<br> -<span class="hljs-punctuation">-&gt;</span> test.rs:<span class="hljs-number">4</span>:<span class="hljs-number">19</span><br>  |<br><span class="hljs-number">2</span> |     <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> =  <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>  |         - <span class="hljs-keyword">move</span> occurs because `x` has <span class="hljs-keyword">type</span> `<span class="hljs-type">String</span>`, which does not implement the `<span class="hljs-built_in">Copy</span>` <span class="hljs-keyword">trait</span><br><span class="hljs-number">3</span> |     <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = x;<br>  |             - value moved here<br><span class="hljs-number">4</span> |     <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,x);<br>  |                   ^ value borrowed here after <span class="hljs-keyword">move</span><br></code></pre></td></tr></table></figure><h3 id="변수-복사copy">변수 복사(copy)</h3><p>위에서의 설명으로 어느정도 이해가 되었을 것이다. 러스트에서는 스택 메모리에 저장되는 고정 변수들만 복사가 가능하다. 이렇게 복사가 가능하다는 것을 러스트식 표현으로 copy 트레이트(trait)를 제공한다고 한다. 트레이트란 러스트 컴파일러에게 특정 데이터 타입 별로 어떤 기능을 실행할 수 있고, 또 공유할 수 있는지 알려주는 방법이다. 즉 copy 트레이트, 복사도 특정 데이터에서만 가능하다는 의미이다. 러스트에서 복사가 가능한 데이터 타입들은 다음과 같다.</p><ul><li>모든 정수형 타입</li><li>Boolean 타입</li><li>문자 타입(char)</li><li>부동 소수점 타입</li><li>위 타입으로 구성된 튜플</li></ul><h3 id="변수-복제clone">변수 복제(clone)</h3><p>그렇다면 러스트에서는 힙 메모리에 사용된 변수는 복사가 불가능할까? 당연히 그렇지는 않다. 변수 복제(clone)이라는 메서드를 사용하면 된다. 변수 복제(clone)는 다음과 같이 사용할 수 있다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// case 2</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1.<span class="hljs-title function_ invoke__">clone</span>();<br></code></pre></td></tr></table></figure><p>해당 방식은 변수 크기에 따라서 매우 오래 걸리는 작업이 될 수 있으니 주의해서 사용하자.</p><h2 id="소유-범위">소유 범위</h2><p>규칙에서 등장하는 소유 범위란 무엇일까? 내가 이해한 바로는 소유 범위란 특정 값이 할당된 변수가 계속 그 값을 유지하고 있는 범주이다. 예시를 들어보자. 우리는 빨간색의 열매를 <code>사과</code>라고 부르며, 대한민국 안에서는 모두 <code>사과</code>라는 글자가 무엇을 의미하는지 알고 있다. 하지만 머나먼 핀란드에 가서 <code>사과</code>를 외쳐본다면 우리가 원하는 결과를 얻을 수 없을 것이다. 러스트의 소유 범위도 이와 동일한 논리라고 생각한다. 어떤 함수에서 선언한 변수는 그 함수 내에서만 선언했던 의미를 가지며, 소유 범위를 벗어난 순간 의미를 잃는다. 러스트는 함수를 기반으로 범위가 설정된다. 아래의 코드를 통해 범위가 어떻게 이동하는지 확인해보자.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;it&#x27;s test&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">t1</span> = <span class="hljs-title function_ invoke__">test_heap</span>(s1);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">t2</span> = <span class="hljs-title function_ invoke__">test_stack</span>(s2);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_heap</span>(temp:<span class="hljs-type">String</span>)&#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, temp);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_stack</span>(temp:<span class="hljs-type">i32</span>)&#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, temp);<br>&#125;<br></code></pre></td></tr></table></figure><p>먼저 <code>s1</code>의 값은 힙 메모리에, <code>s2</code>는 스택 메모리에 할당된다. 그 다음 <code>s1</code>은 <code>test_heap()</code> 범위로 이동하면서 자연스럽게 값이 해제된다. 즉, 힙 메모리에 저장된 변수는 다른 함수로 이동하면서 drop 되는 것이다. 그 후 이동된 <code>s1</code> 값도 <code>test_heap()</code>가 종료되면서 <code>t1</code>으로 할당된다. 반면 <code>s2</code>의 경우는 스택 메모리에 저장되기에 <code>test_stack()</code>으로 이동해도 그대로 값이 남아있는다. 따라서 현재까지 할당된 변수들은 <code>s2</code>, <code>t1</code>, <code>t2</code>이다. 그리고 <code>main()</code>가 종료되면서 모든 변수들이 할당 해제된다.</p>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>ownership</tag>
      
      <tag>memory</tag>
      
      <tag>slice</tag>
      
      <tag>borrowing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AWS Lightsail로 DB 서버 생성하기</title>
    <link href="/ko/AWS/AWS-5/"/>
    <url>/ko/AWS/AWS-5/</url>
    
    <content type="html"><![CDATA[<p>이 글은 AWS Lightsail 인스턴스를 생성하여 DB서버를 구축하는 방법을 정리합니다.</p><span id="more"></span><h2 id="db-서버-생성">DB 서버 생성</h2><p>DB 서버는 AWS의 lightsail을 사용하기로 결정했다. 그 이유로는 매달 결정되어 있는 가격대와 편리함 등이 꼽혔다. 여러 명이 같이 돈을 지불해야 하는 탓에 금액이 정해져있지 않으면 매달 귀찮은 일이 발생할 것 같았다.</p><h3 id="aws-lightsail-인스턴스-생성">AWS lightsail 인스턴스 생성</h3><p>AWS의 계정이 있다면, 간단하다. 서비스에서 lightsail을 찾아서 들어간 후 <code>인스턴스 생성</code>을 클릭하면 된다. 그러면 아래와 같은 화면은 만날 수 있다.</p><figure><img src="/images/115.png" alt="lightsail" /><figcaption aria-hidden="true">lightsail</figcaption></figure><p>여기서 사용하려는 OS를 선택하면 된다. 이 서버는 Ubuntu18.04 LTS를 선택하였다. 현재 회사에서는 redhat이나 centos를 주로 사용하기 때문에 사이드 프로젝트 할 때만이라도 ubuntu를 사용해보고 싶었다. 결론은 매우 개인적인 이유로 OS를 선택했다.</p><figure><img src="/images/116.png" alt="lightsail2" /><figcaption aria-hidden="true">lightsail2</figcaption></figure><p>그 다음 아래로 내리면 위 사진과 같은 화면을 볼 수 있다. 여기서 사양과 가격을 잘 분석한 뒤 선택하면 된다. 해당 프로젝트에서는 $10를 선택했다. 마지막으로 서버 이름을 변경해준 뒤 인스턴스 생성을 누르면 완료된다.</p><h3 id="터미널-접속">터미널 접속</h3><p>막 생성된 Lightsail 서버에 터미널로 접속하고 싶다면 2가지의 방법이 있다.</p><ul><li>AWS 홈페이지에서 접속하기</li></ul><p>먼저 AWS에서 접속하는 방법은 다음과 같다. 생성된 인스턴스를 누르면 해당 서버에 대한 정보들과 연결 카테고리가 있다. 연결 카테고리를 클릭한 후 아래를 보면 다음과 같은 화면이 보일 것이다.</p><figure><img src="/images/117.png" alt="lightsail3" /><figcaption aria-hidden="true">lightsail3</figcaption></figure><p>여기서 <code>ssh를 사용하여 연결</code>을 클릭하면 해당 서버의 터미널이 브라우저로 열린다.</p><ul><li>SSH 프라이빗 키 다운 받아 터미널로 접속하기</li></ul><p>다른 방법은 내 컴퓨터 터미널에서 해당 서버로 접속하는 방법이다. 이는 먼저 Lightsail 계정의 ssh 프라이빗 키를 저장해야 한다.</p><figure><img src="/images/118.png" alt="lightsail4" /><figcaption aria-hidden="true">lightsail4</figcaption></figure><p>연결 페이지 아래에 보면 위와 같은 안내와 함께 <code>계정 페이지</code> 링크가 있을 것이다. 클릭해보자.</p><figure><img src="/images/119.png" alt="lightsail5" /><figcaption aria-hidden="true">lightsail5</figcaption></figure><p>그러면 이렇게 내 계정의 SSH 프라이빗 키를 다운로드 받을 수 있다. 이를 로컬 컴퓨터에 저장한다. 이후 개인 컴퓨터의 터미널에서 해당 키가 있는 디렉토리로 이동한 후 프라이빗 키의 권한을 변경해준다.</p><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chmod</span> 400 <span class="hljs-variable">$keyname</span>.pem<br></code></pre></td></tr></table></figure></p><p>그 다음 아래의 코드로 접속하면 된다. Lightsail은 서버 생성도 너무 간단하다.</p><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -i keyname.pem <span class="hljs-variable">$username</span>@<span class="hljs-variable">$publicIP</span><br></code></pre></td></tr></table></figure></p><h3 id="ssh-패스워드로-접속하기">SSH 패스워드로 접속하기</h3><p>여러 명이 해당 서버를 관리해야 한다면 SSH 프라이빗 키 구조는 너무 불편해진다. 따라서 계정 비밀번호로도 SSH 접속을 가능하게 설정할 것이다. 먼저 기존에 생성된 user 계정에 비밀번호를 만들어주자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> passwd <span class="hljs-variable">$username</span><br></code></pre></td></tr></table></figure><p>위 명령어를 입력하면 해당 계정의 비밀번호를 설정할 수 있다. 이러면 접근에 사용할 계정 준비는 완료된 것이다. 이후 SSH 접근 가능 방법을 추가해주자. <code>/etc/ssh/</code>에 들어가서 <code>sshd_config</code> 파일을 수정해주면 된다.</p><p>해당 파일을 vi으로 수정해주자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> vi /etc/ssh/sshd_config<br><br><span class="hljs-comment"># 앞에 주석이 있다면 제거하거나 no로 되어있다면 yes로 변경하기</span><br>PasswordAuthentication <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><p>그 다음 아래의 명령어로 sshd를 다시 시작해주면 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl restart sshd<br></code></pre></td></tr></table></figure><h2 id="mariadb-설치하기">mariaDB 설치하기</h2><p>이제 생성된 서버에 mariaDB를 설치해주자. 이 서버에는 OS에 기본적으로 내장되어 있는 mariaDB 10.1.48 버전을 설치할 예정이다. 아래의 코드를 순차적으로 입력하여 설치해주자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># apt 사용가능한 패키지 모두 가져오기</span><br>apt-get update<br><br><span class="hljs-comment"># mariadb 패키지 있는지 확인하기</span><br>apt list | grep maria<br><br><span class="hljs-comment"># mariadb 설치</span><br><span class="hljs-built_in">sudo</span> apt install mariadb-server<br><br><span class="hljs-comment"># mariadb 프로세스 올라왔는지 확인</span><br><span class="hljs-built_in">sudo</span> systemctl status mariadb<br><br><span class="hljs-comment"># 안올라왔다면 시작해주기</span><br><span class="hljs-built_in">sudo</span> systemctl start mariadb<br></code></pre></td></tr></table></figure><p>설치가 끝나면 DB 보안을 설정해주어야 한다. 아래의 코드를 입력하여 보안설정을 진행하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> mysql_secure_installation<br></code></pre></td></tr></table></figure><p>보안설정 순서는 다음과 같다.</p><ul><li>최근 비밀번호 입력 (초기설정은 enter)</li><li>새로운 비밀번호 입력 (root 권한)</li><li>익명의 사용자 계정 삭제? -&gt; yes</li><li>root 엑세스 금지? -&gt; no</li><li>테스트 데이터베이스 삭제? -&gt; yes</li><li>권한 테이블 재설정? -&gt; yes</li></ul><p>그 후 아래의 코드를 입력하면 mariaDB에 접속할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> mysql -u root -p<span class="hljs-variable">$rootpasswd</span><br></code></pre></td></tr></table></figure><p>이러면 DB 서버가 완성된다.</p>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
      <category>aws</category>
      
    </categories>
    
    
    <tags>
      
      <tag>aws</tag>
      
      <tag>mariadb</tag>
      
      <tag>lightsail</tag>
      
      <tag>ssh</tag>
      
      <tag>DB</tag>
      
      <tag>KBO</tag>
      
      <tag>analysis</tag>
      
      <tag>dashborad</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ansible 설치하기</title>
    <link href="/ko/Ansible/ansible-1/"/>
    <url>/ko/Ansible/ansible-1/</url>
    
    <content type="html"><![CDATA[<p>Ansible 설치방법에 대해서 간단히 설명합니다. <span id="more"></span></p><hr /><h2 id="ansible-사용-방법">Ansible 사용 방법</h2><p>앤서블은 파이썬으로 구현되었기 때문에 사용하기 위해서는 해당 환경에 파이썬이 셋팅되어 있어야 한다. 현재 회사에서는 테스트 서버의 OS로 centos7를 사용하기 때문에 이를 기준으로 앤서블 사용법을 설명할 예정이다. 또한 앤서블은 저번 글에서 설명한 것처럼 에이전트리스 방식으로 작동하기 때문에 관리자 노드(controller)에만 설치하면 된다.</p><p><strong>TEST ENV</strong> 테스트 환경은 다음과 같다.</p><ul><li>Server: 4대</li><li>CPU: 4 core</li><li>mem: 8GB</li><li>disk: 50GB</li><li>OS: Centos 7</li><li>imbedded: python2.7.5</li><li>hostname: controller, target1, target2, target3</li></ul><h2 id="ansible-설치">Ansible 설치</h2><p>먼저 앤서블을 설치해보자. CentOS의 경우 ansible이 OS 기본 패키지에 속한 경우도 있지만, 아닌 경우도 있다. 일단 아래의 코드를 입력해서 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y ansible<br></code></pre></td></tr></table></figure><p>앤서블이 잘 설치된다면 OS 기본 패키지에 있다는 것이기에 바로 다음 글로 넘어가면 된다. 하지만 만약 아래와 같은 답변이 온다면 따로 rpm 파일들을 넣어준 후 설치해야 한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">Loaded plugins: product-id, search-disabled-repos, subscription-manager<br>This system is not registered with an entitlement server. You can use subscription-manager to register.<br>cm                                                       | 2.9 kB     00:00     <br>centos                                                   | 2.8 kB     00:00     <br>No package ansible available.<br>Error: Nothing to <span class="hljs-keyword">do</span><br></code></pre></td></tr></table></figure><h2 id="ansible-repository">Ansible repository</h2><p>앤서블은 EPEL(Extra Packages for Enterprise Linux)에 포함되어 있기에 이를 가져와서 사용해도 되지만 개인적으로 이 방법을 좋아하지 않는데, 그 이유로는 다음과 같다.</p><ul><li><p>쓰고 싶은 패키지는 일부인데 EPEL은 너무 많은 패키지를 가지고 있다. 실제 테스트에서 사용하는 centos ISO 이미지에는 패키지가 대략 4000개 정도 들어있는데, EPEL은 기본적으로 10000개 정도의 패키지를 가져온다. 물론 네트워크가 오픈망이고 외부 레파지토리를 가져오는거라면 EPEL을 사용해도 괜찮겠지만, 폐쇄망인 경우에는 10000개가 넘는 패키지를 직접 가지고 다녀야 한다.</p></li><li><p>의도치 않은 패키지 업데이트가 진행된다. yum은 기본적으로 EPEL에 현재 사용하는 패키지의 최신 버전이 들어있다면 자동으로 업데이트를 진행한다. 물론 yum에서 레파지토리를 무력화하여 업데이트를 하지 못하게 할 수도 있지만, 이를 잊어버린 경우 커널 단의 시스템들이 업데이트가 진행되면서 버전 문제로 고생할 수 있다. 실제 이 문제로 인해 패키지들의 버전이 맞지 않아 고생한 적이 있다.</p></li></ul><p>또한 현재 일하고 있는 분야에서는 대부분 클러스터가 폐쇄망으로 구성되기에 개인적으로는 필요한 패키지 rpm들을 다운받은 후 tar로 묶어서 가지고 다니는 것을 더 선호한다.</p><p>그래서 결론적으로 나는 앤서블 설치에 필요한 rpm 파일들을 따로 다운로드 받아 tar로 묶어두었다. 만약 해당 파일이 필요하다면 <a href="https://github.com/Hyeonji-Ryu/Ansible/tree/main/Centos">깃허브</a>에서 다운받을 수 있다. (해당 앤서블 버전은 2.9.2 이다)</p><p>centos에서 레파지토리를 잡는 방법은 다음과 같다.</p><ol type="1"><li>ansible rpm 파일들 다운로드</li><li>repo 파일 생성하기</li><li>yum repolist로 확인하기</li></ol><p>위 과정을 코드로 나타내면 아래와 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># repo 폴더 생성</span><br><span class="hljs-built_in">mkdir</span> -p /var/www/html/ans<br><br><span class="hljs-comment"># ansible.tar 파일을 전송 후 압축 해제</span><br>tar xvf /var/www/html/ans/ansible.tar<br><br><span class="hljs-comment"># repo 작성하기</span><br><span class="hljs-built_in">cat</span> &lt;&lt; <span class="hljs-string">EOT &gt;&gt; /etc/yum.repos.d/ans.repo</span><br><span class="hljs-string">[ans]</span><br><span class="hljs-string">name=ans</span><br><span class="hljs-string">baseurl=file://var/www/html/ans</span><br><span class="hljs-string">gpgcheck=0</span><br><span class="hljs-string">enabled=1</span><br><span class="hljs-string">EOT</span><br><br><span class="hljs-comment"># repo 확인</span><br>yum clean all<br>yum repolist<br><br><span class="hljs-comment"># ansible 설치</span><br>yum install ansible<br></code></pre></td></tr></table></figure><h2 id="ansible-설치-완료-확인">Ansible 설치 완료 확인</h2><p>문제 없이 설치되었다면 아래와 같이 입력해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ansible --version<br></code></pre></td></tr></table></figure><p>그럼 아래와 같이 설치된 앤서블 버전과 정보가 나올 것이다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">ansible 2.9.2<br>  config file = /etc/ansible/ansible.cfg<br>  configured module search path = [u<span class="hljs-string">&#x27;/root/.ansible/plugins/modules&#x27;</span>, u<span class="hljs-string">&#x27;/usr/share/ansible/plugins/modules&#x27;</span>]<br>  ansible python module location = /usr/lib/python2.7/site-packages/ansible<br>  executable location = /usr/bin/ansible<br>  python version = 2.7.5 (default, Oct 30 2018, 23:45:53) [GCC 4.8.5 20150623 (Red Hat 4.8.5-36)]<br></code></pre></td></tr></table></figure><p>엔서블 설치가 완료되었다. 다음 글에서는 앤서블로 관리할 노드들을 셋팅하는 방법에 대해서 살펴보자</p>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
      <category>ansible</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sshpass</tag>
      
      <tag>docker</tag>
      
      <tag>script</tag>
      
      <tag>앤서블</tag>
      
      <tag>ansible</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ansible 시작하기</title>
    <link href="/ko/Ansible/ansible-0/"/>
    <url>/ko/Ansible/ansible-0/</url>
    
    <content type="html"><![CDATA[<p>Ansible에 대해서 간략하게 소개합니다. <span id="more"></span></p><h2 id="ansible을-공부하게-된-계기">Ansible을 공부하게 된 계기</h2><p>앤서블(ansible)은 데이터 분산처리 플랫폼 구축을 위해 클러스터를 구성하면서 알게 되었다. 처음 클러스터를 구성할 때는 직접 쉘 스크립트로 함수를 작성하여 사용하였다. 그 때 사용했던 함수는 다음과 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> clustercmd &#123;<br>  <span class="hljs-keyword">for</span> pi <span class="hljs-keyword">in</span> $(otherpis); <span class="hljs-keyword">do</span> ssh <span class="hljs-variable">$pi</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>; <span class="hljs-keyword">done</span><br>  <span class="hljs-variable">$@</span><br>&#125;<br></code></pre></td></tr></table></figure><p>위 함수는 <code>clustercmd</code> 뒤에 입력하는 명령어를 다른 노드들에도 똑같이 적용해주는 함수이다. 만약 클러스터 하나만 만들면 되는 상황이라면 이렇게 필요한 함수들을 하나씩 만들어 사용하는 것도 나쁘지 않다. 하지만 테스트를 위한 클러스터 구축이라면?</p><p>만약 테스트를 10번 한다고 하면 똑같은 반복 업무를 10번 해야 한다. 그 와중에 환경변수 설정하다가 오타 났는데 모르고 넘어가는 경우도 태반이고, 결국 제대로 클러스터 구축이 안되면 처음부터 끝까지 구축 프로세스를 훑어야 한다. 음..너무 귀찮고 또 귀찮다.</p><p>그래서 처음 <code>ansible</code>을 시작했을 때는 테스트용 클러스터를 좀 더 빠르고 편하게 만들기 위해서였다. 또한 실제로 그렇게 사용하고 있다. <code>ansible</code>은 시스템 엔지니어나 Devops 엔지니어들이 많이 사용하는 도구이고, 사용해본 결과 엄청 편하다.</p><p>그렇다면 도대체 앤서블은 무엇인가?</p><h2 id="ansible-이란">Ansible 이란</h2><p>앤서블(Ansible)은 파이썬으로 구현된 오픈소스이며, 그동안 직접 쉘 스크립트로 일일이 수행했던 인프라 작업들을 코드로 해결할 수 있도록 해주는 도구이다. 예를 들어 각 서버에 소프트웨어를 배포하거나 환경설정 및 컨피그레이션을 수정하는 것 같은 일들도 자동화할 수 있다.</p><h2 id="ansible-특징">Ansible 특징</h2><p>앤서블의 특징으로는 크게 2가지가 있다.</p><ol type="1"><li><p>에이전트리스(Agentless) 엔서블은 관리하는 서버들에 에이전트를 설치하지 않고도 프로그램을 배포하거나 환경 변수, 컨피그레이션 등을 변경할 수 있다. 이런 방식이 가능한 이유는 각 서버들과 SSH 통신을 하여 유저가 요구한 작업들을 진행하기 때문이다.</p></li><li><p>멱등성 멱등성은 어떤 연산이나 코드를 여러 번 반복해도 동일한 결과를 도출하는 성질을 의미한다. 엔서블은 특정 코드들을 여러 번 실행시켜도 똑같은 결과를 제공한다.</p></li></ol><h2 id="ansible-구성요소">Ansible 구성요소</h2><p>앤서블의 구성요소 목록은 다음과 같다.</p><ul><li>관리자 노드 (Control node)</li><li>관리 노드 (Managed node)</li><li>인벤토리 (Inventory)</li><li>컬렉션 (Collection)</li><li>모듈 (Module)</li><li>과제 (Task)</li><li>플레이북 (Playbook)</li></ul><p>간단하게 각각의 역할에 대해서 살펴보자.</p><h3 id="controller관리자-노드">controller(관리자 노드)</h3><p>관리자 노드는 앤서블 명령어를 실제 입력하는 노드이다. 해당 서버에서는 아래에서 살펴볼 플레이북을 실행할 수 있다. 해당 서버에는 파이썬과 앤서블이 설치되어 있어야 한다. 관리자 노드로 사용하기 위해 체크해야 하는 중요한 부분은 바로 인터넷 접속 여부와 OS이다. 윈도우 서버로 관리자 노드가 될 수는 없으며, 인터넷 접속도 가능해야 한다.</p><h3 id="target관리-노드">target(관리 노드)</h3><p>관리 노드는 실제 앤서블이 관리하는 서버들을 통칭한다. 앤서블은 에이전트리스로 실행되기 때문에 관리 노드들에 무언가를 따로 설치할 필요는 없다. 보통 관리노드는 인벤토리에 저장하여 사용한다.</p><h3 id="inventory">inventory</h3><p>인벤토리는 관리 노드들에 대한 정보를 기술한 파일이다. 보통은 노드 목록과 그룹핑을 정의하기 때문에 호스트파일(hostfile)이라고도 부른다. 또한 인벤토리는 그룹에 따라 변수들을 생성할 수 있다. 인벤토리의 예시는 아래와 같다.</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[all]</span><br>target1 <span class="hljs-attr">ansible_host</span>=<span class="hljs-variable">$IP</span><br>target2 <span class="hljs-attr">ansible_host</span>=<span class="hljs-variable">$IP</span><br>target3 <span class="hljs-attr">ansible_host</span>=<span class="hljs-variable">$IP</span><br><br><span class="hljs-section">[all:vars]</span><br><span class="hljs-attr">ansible_python_interpreter</span>=/usr/bin/python<br><span class="hljs-attr">ansible_ssh_pass</span>=<span class="hljs-variable">$passwd</span><br></code></pre></td></tr></table></figure><h3 id="playbook">playbook</h3><p>플레이북은 관리 노드들에게 적용할 작업들을 모아놓은 yml 파일이다. 플레이북에는 크게 name, hosts, tasks 요소가 필수적으로 들어간다. hosts를 통해서 각 작업들의 대상을 특정할 수 있기 때문에 하나의 파일에 대상이 다른 작업도 입력할 수 있다. 또한 인벤토리 파일에 작성한 변수들을 가져다가 그대로 사용할 수도 있다. 변수를 입력하는 문법은 python의 jinja2와 동일하다. 플레이북의 예시는 아래와 같다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># playbook example</span><br><span class="hljs-bullet">-</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;repo setting&quot;</span><br>  <span class="hljs-attr">hosts:</span> <span class="hljs-string">all</span><br>  <span class="hljs-attr">tasks:</span><br>    <span class="hljs-bullet">-</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;stop and disable firewalld&quot;</span><br>      <span class="hljs-attr">service:</span> <br>        <span class="hljs-attr">name:</span> <span class="hljs-string">firewalld</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">False</span><br>        <span class="hljs-attr">state:</span> <span class="hljs-string">stopped</span><br>    <span class="hljs-bullet">-</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;stop and disable tuned&quot;</span><br>      <span class="hljs-attr">service:</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">tuned</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">False</span><br>        <span class="hljs-attr">state:</span> <span class="hljs-string">stopped</span><br></code></pre></td></tr></table></figure><h3 id="task">task</h3><p>테스크는 플레이북의 tasks에 들어가는 요소들을 의미한다. 위의 예시에서는 <code>"stop and disable firewalld"</code>, <code>"stop and disable tuned"</code>가 테스크라고 볼 수 있다. 앤서블에서 플레이북으로 명령을 시작하면 해당 플레이북 안에 있는 테스크가 순차적으로 진행되며, 이후 작업 결과에서 몇 개의 테스크가 성공하고 싷패했는지 알려준다.</p><h3 id="module">module</h3><p>마지막으로 살펴볼 모듈은 앤서블 테스크를 작성할 때 사용되는 템플릿이다. 위 예시를 바탕으로 살펴보자.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-bullet">-</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;stop and disable tuned&quot;</span><br>  <span class="hljs-attr">service:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">tuned</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">False</span><br>    <span class="hljs-attr">state:</span> <span class="hljs-string">stopped</span><br></code></pre></td></tr></table></figure><p>해당 테스크는 명령어 <code>systemctl stop tuned &amp;&amp; systemctl disable tuned</code>을 엔서블 테스크로 작성한 것이다. 여기서 <code>service</code>라는 딕셔너리에 관리할 프로세스의 이름, 변경하려는 상태 등을 입력하면 위 명령어처럼 작동하는 것이다. 저 <code>service</code>가 모듈이다. 즉, 앤서블에서 CLI로 입력하는 명령어에 대한 사용 툴이라고 볼 수 있다. 현재 앤서블에서 제공하는 모듈들의 종류는 매우 많으며, <a href="https://docs.ansible.com/ansible/2.9/modules/list_of_all_modules.html">앤서블 문서</a>에서 모듈 리스트를 확인할 수 있다.</p><p>앤서블에 대한 개괄적인 설명은 끝났다. 다음 글부터는 앤서블을 설치 및 사용법에 대해서 자세히 살펴보자.</p>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
      <category>ansible</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sshpass</tag>
      
      <tag>docker</tag>
      
      <tag>script</tag>
      
      <tag>앤서블</tag>
      
      <tag>ansible</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux core concepts</title>
    <link href="/ko/Linux/Linux-3/"/>
    <url>/ko/Linux/Linux-3/</url>
    
    <content type="html"><![CDATA[<p>리눅스 기본 개념들에 대해서 정리합니다.</p><span id="more"></span><h2 id="linux-boot-순서">Linux Boot 순서</h2><p>리눅스가 처음 부팅되는 순서는 다음과 같다.</p><ol type="1"><li>BIOS 설정</li><li>BOOT loader(GRUB2) 실행</li><li>커널 초기화</li><li>INIT process 실행(systemd)</li></ol><p>위 과정들을 순서대로 살펴보자.</p><h3 id="bios-설정">BIOS 설정</h3><p>바이오스(BIOS)는 Basic Input Output System의 약자로 컴퓨터가 가장 먼저 실행하는 프로그램이다. 바이오스는 부팅되면서 컴퓨터에 연결되어 있는 각종 부품(CPU, mem, disk 등)이 제대로 연결되어 있는지 확인하고 작동에 문제가 없는지 간단하게 검사한다. 바이오스는 펌웨어이기에 하드웨어 메인보드의 EPROM이나 플래시메모리 칩에 저장되어 있으며, OS가 처음 셋팅되기 전에 실행된다.</p><p><strong>NOTE</strong> 펌웨어(firmware)란?<br />펌웨어는 특정 하드웨어에 설치된 소프트웨어로, 하드웨어가 각자의 기능대로 작동하기 위해 필요한 최소한의 프로그램이다. 펌웨어는 보통 컴퓨터가 생산될 때 공장에서 읽기 전용 메모리인 ROM(Read Only Memory)에 셋팅하며, 따라서 일반 사용자들이 이를 변경하기는 어렵다. 또한 펌웨어는 램에서 실행되는 일반 프로그램들과 달리 전원이 꺼져도 셋팅이 사라지지 않는다.</p><p>바이오스가 검사를 마치고 이상이 없다면 다음 단계인 부트 로더를 실행한다.</p><h3 id="boot-loadergrub2-실행">BOOT loader(GRUB2) 실행</h3><p>부트 로더는 OS가 시작되기 이전에 미리 실행되어 커널이 올바르게 작동하기 위한 작업을 진행한다. 부트 로더는 보통 첫번째 하드디스크 맨 앞부분의 부트 섹터(boot sector)에 셋팅되어 있으며, 바이오스가 하드디스크 검사 후 해당 위치에서 프로그램을 읽어 메모리에 올린다.</p><p><strong>NOTE</strong> 부트 섹터(boot sector)란?<br />부트 섹터는 부팅 프로그램을 담을 수 있는 하드 디스크, 플로피 디스크 등 기억 장치의 첫 섹터를 말한다 (1섹터 512 바이트). 부트 섹터의 종류로는 MBR과 VBR이 있다.</p><p>그렇게 실행된 부트 로더는 압축된 리눅스 커널 이미지를 다시 메모리로 복사하여 압축을 해제하고 로드시키며, 커널이 제대로 작동하는지 체크한다. 사실 더 자세히 살펴본다면 부트 로더도 1차와 2차로 나눠진다. 1차는 방금 설명한 MBR과 VBR이고, 이들은 2차 부트 로더를 실행시킨다. 그리고 2차 부트 로더가 커널을 로드하는 방식이다. 2차 부트 로더는 각 OS마다 다른데 리눅스에서는 GRUB2를 많이 사용한다. 2차 부트 로더는 파일 형식으로 <code>/boot</code> 아래에 위치한다.</p><h3 id="커널-초기화">커널 초기화</h3><p>커널 초기화는 2차 부트 로더가 로드한 압축된 커널 이미지를 해제하는 과정이다. 커널은 압축된 이미지를 해제한 후 하드웨어를 초기화하고 메모리 관리 시스템 등을 시작한다. 즉, OS가 작동할 수 있도록 기본적인 환경을 갖추는 것이다. 이를 정상적으로 완료하면 INIT 프로세스를 진행한다.</p><h3 id="init-processsystemd-실행">INIT process(systemd) 실행</h3><p>INIT 프로세스는 사용자가 사용할 수 있는 OS 기타 환경들을 셋팅한다. 이전에는 initd를 사용했지만, systemd가 병렬로 부팅하여 더 빠르다는 등 여러 이유로 centos7 이후로는 systemd를 사용한다. 하지만 initd이나 systemd이나 추상적으로 부팅해서 하는 역할은 같으니 하는 일에 집중하자. systemd는 컴퓨터가 부팅되면서 가장 먼저 실행되는 프로세스이며, 이후 올라오는 모든 프로세스들을 설정 및 관리한다. 특징으로는 가장 먼저 올라오는 프로세스이기에 PID(Process ID)가 1이며, 관리 명령어는 <code>systemctl</code>이다. (기존에 사용했던 init 프로세스는 관리 명령어가 <code>service</code>이다.)</p><p>위 과정이 모두 진행되면 익숙한 리눅스 로그인 화면을 만날 수 있다.</p><h2 id="linux-runleveltarget">Linux Runlevel(target)</h2><p>Runlevel은 리눅스 시스템 관리를 보다 편하게 하기 위해 등장한 개념이다. 리눅스의 현 상태를 간단한 명령어 <code>runlevel</code>로 확인할 수 있다. Runlevel 단계는 다음과 같다.</p><table><thead><tr class="header"><th>번호</th><th>단계</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>0</td><td>halt<br>(DO NOT set initdefault to this)</td><td>시스템 종료</td></tr><tr class="even"><td>1</td><td>Single user mode<br>rescue</td><td>시스템 복원모드로 관리자 권한으로 접근 가능</td></tr><tr class="odd"><td>2</td><td>Multiuser mode<br>(The same as 3, if you do ot have networking)</td><td>네트워크 안되는 다중 사용자 모드(NFS 지원X)</td></tr><tr class="even"><td>3</td><td>Full muliuser mode<br>(multi-user.target)</td><td>네트워크 사용가능한 다중 사용자 모드</td></tr><tr class="odd"><td>4</td><td>unused</td><td>기본값 없음, 사용자 임의 설정 가능한 번호</td></tr><tr class="even"><td>5</td><td>X11<br>(graphical.target)</td><td>3번에 GUI 기능까지 탑재된 모드</td></tr><tr class="odd"><td>6</td><td>reboot<br>(DO NOT set initdefault to this)</td><td>시스템 재가동 모드</td></tr></tbody></table><p>중간에 runlevel을 변경하려면 간단하게 <code>init $number</code>로 입력하면 되고, 재부팅 없이 변경하려면 <code>telinit $number</code>를 사용하면 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># runlevel 확인</span><br>runlevel<br>&gt; N 3<br><br><span class="hljs-comment"># runlevel 변경</span><br>init 5<br><br><span class="hljs-comment"># 재부팅없이 runlevel 변경</span><br>telinit 5<br></code></pre></td></tr></table></figure><p>여기서 한 가지 짚고 넘어가야 하는 것이 있다. runlevel는 기존의 initd에서 사용하던 방식이며, systemd에서는 해당 타겟값들을 아래의 명령어로 확인 및 변경한다. systemd에서 사용하는 명령어는 다음과 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 현재 모드 확인</span><br>systemctl get-default<br>&gt; multi-user.target<br><br><span class="hljs-comment"># 모드 변경</span><br>systemctl set-default graphical.target<br></code></pre></td></tr></table></figure><p>만약 재부팅없이 모드를 변경하고 싶다면 <code>isolate</code>를 넣어주면 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 재부팅 없이 변경</span><br>systemctl isolate graphical.target<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>boot</tag>
      
      <tag>centos</tag>
      
      <tag>ubuntu</tag>
      
      <tag>repository</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[DAsP] 합격 후기</title>
    <link href="/ko/Certificate/DAsP-3/"/>
    <url>/ko/Certificate/DAsP-3/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 데이터아키텍처 준전문가(DAsP) 자격증 공부 내용을 정리합니다. <span id="more"></span></p><hr /><h2 id="dasp-합격">DAsP 합격</h2><p>사실 처음부터 DAsP를 보려고 했던 것은 아니다. 정확히는 이런 시험이 있는지도 몰랐고, 원래 목표는 ADsP와 SQLD 자격증을 획득하는 것이었다. 실제로 두 시험을 지원하려고 홈페이지를 방문했지만, 그 2개는 이미 신청 마감이었다. 그래서 당시 데이터자격시험 중 유일하게 DAsP만 신청이 가능했기에 일단 도전을 하기로 마음을 먹고 지원했다.</p><figure><img src="/images/114.jpg" alt="DAsP" /><figcaption aria-hidden="true">DAsP</figcaption></figure><p>합격한 성적표는 위와 같다. 100점 만점에 74점이니 잘한 점수는 아니지만, 아슬아슬한 점수도 아니라는 점에서 괜시리 뿌듯하다. 점수를 보면 알겠지만, 앞 장은(만) 참 열심히 봤다. 데이터 아키텍처는 조금 정리하면서 공부를 했는데 나머지 과목들은 시간이 없어 책 1회독만 하고 시험을 봤다. 그 결과가 저렇게 시험 점수에서 보인다.</p><h2 id="dasp-시험-정보">DAsP 시험 정보</h2><p>DAsP(데이터 아키텍처 준전문가)시험은 크게 4개의 과목으로 구성되어 있다.</p><ol type="1"><li>전사아키텍처 이해 (10문제)</li><li>데이터 요건 분석 (10문제)</li><li>데이터 표준화 (10문제)</li><li>데이터 모델링 (20문제)</li></ol><p>총 점수는 100점 만점이며, 한 문제 당 2점이다. 또한 합격 조건은 전체점수 60점 이상 획득하고, 각 과목당 40% 이상 맞추는 것이다. 따라서 내 성적은 각각 몇 문제를 맞췄는지 계산해보면 다음과 같다.</p><ol type="1"><li>전사아키텍처 이해 (10문제/10문제/100%)</li><li>데이터 요건 분석 (7문제/10문제/70%)</li><li>데이터 표준화 (7문제/10문제/70%)</li><li>데이터 모델링 (13문제/20문제/65%)</li></ol><p>확실히 마지막 장은 급하게 훑어보고 가서 가장 많이 틀렸다. 그래도 합격선을 충분히 넘어서 다행이다.</p><h2 id="dasp-후기">DAsP 후기</h2><p>DAsP 시험은 마냥 외우는 방식이 적합하지 않은 시험이라고 느꼈다. 그 이유는 시험 문제가 특정 절대 답안을 요구하는 것이 아니라, 상황에 따른 적합성을 물어보기 때문이다. 그래서 단순히 전문용어를 외우거나 순서를 외우는 공부방식은 효과적이지 않을 것 같다는 생각이 들었고, 현업에 있거나 실제 프로젝트 경험이 있는 사람들은 공부 벼락치기 하고 봐도 충분히 합격할 수도 있을 것 같다.</p>]]></content>
    
    
    <categories>
      
      <category>etc.</category>
      
      <category>certificate</category>
      
    </categories>
    
    
    <tags>
      
      <tag>자격증</tag>
      
      <tag>DAsP</tag>
      
      <tag>데이터아키텍처</tag>
      
      <tag>전사아키텍처</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>정렬 알고리즘 (1)</title>
    <link href="/ko/Algorithms/Algorithms-1/"/>
    <url>/ko/Algorithms/Algorithms-1/</url>
    
    <content type="html"><![CDATA[<p>다양한 정렬 알고리즘을 공부하고 Rust로 구현합니다. <span id="more"></span></p><h2 id="정렬-알고리즘">정렬 알고리즘</h2><p>정렬 알고리즘(sorting algorithm)은 무작위로 형성된 숫자 리스트나 원소들을 순서에 맞게 나열해주는 알고리즘이다. 정렬 알고리즘의 종류는 선택정렬, 삽입정렬, 버블정렬, 합병정렬, 퀵정렬 등 다양하며, 종류에 따라 시간복잡도나 공간복잡도도 달라진다.</p><p>이번 글에서는 정렬 알고리즘 중에서 기본적인 선택정렬과 삽입정렬, 버블 정렬에 대해서 살펴볼 것이다.</p><h2 id="선택-정렬">선택 정렬</h2><p>선택 정렬은 조건에 속하는 값을 선택하여 배열하는 정렬 알고리즘이다. 오름차순으로 정렬하는 방법을 최소선택정렬이라고 하며, 내림차순으로 정렬하는 방법을 최대선택정렬이라고 한다.</p><p>로직은 다음과 같다.</p><ol type="1"><li>정렬되지 않은 리스트에서 최솟(댓)값을 찾아 인덱스를 저장한다.</li><li>리스트에서 더 작은 최솟(댓)값이 있다면 해당 인덱스로 변경한다.</li><li>마지막 인덱스에 도착하면 가장 작은 최솟(댓)값과 값을 변경한다.</li></ol><p>위 로직에 따르면 맨 앞에서부터 최솟(댓)값이 정렬되기 때문에 반복할수록 비교해야 할 원소의 개수는 (총 개수 - 정렬된 개수)로 줄어든다. 또한 선택 정렬은 현재 상태와 상관없이 하나의 값 당 리스트 모든 원소를 살펴봐야 하기 때문에 시간복잡도는 <span class="math inline">\(O(n^2)\)</span>이며, 리스트 내에서 정렬이 진행되기 때문에 공간복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p><p>선택 정렬 예시를 러스트(Rust)로 구현하면 다음과 같다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">lis</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">10</span>] = [<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>];<br>    <span class="hljs-title function_ invoke__">selection_sort</span>(lis);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">selection_sort</span>(<span class="hljs-keyword">mut</span> lis: [<span class="hljs-type">i32</span>; <span class="hljs-number">10</span>]) &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..lis.<span class="hljs-title function_ invoke__">len</span>()-<span class="hljs-number">1</span>&#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">j</span> <span class="hljs-keyword">in</span> i..lis.<span class="hljs-title function_ invoke__">len</span>()&#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">min</span> = lis[i];<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">idx</span> = i;<br>            <span class="hljs-keyword">if</span> min &gt; lis[j]&#123;<br>                idx = j;<br>                min = lis[j];<br>            &#125;<br>            lis[idx] = lis[i];<br>            lis[i] = min;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,lis)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="버블-정렬">버블 정렬</h2><p>버블 정렬은 연속된 두개의 값만 비교하여 기준에 따라 위치를 바꾸는 방식이다. 만약 오름차순을 조건으로 버블 정렬을 한다면 연속되는 두개의 값 중 큰 수를 뒷자리로 보내게 되며, 결국 한바퀴 돌았을 때 가장 큰 수가 맨 뒷자리에 위치하게 된다.</p><p>로직은 다음과 같다.</p><ol type="1"><li>연속되는 두 수를 비교하여 큰 값을 뒤로 위치시킨다.</li><li>이를 반복하여 맨 뒷자리에 가장 큰 값이 위치된다.</li></ol><p>위 로직에 따르면 맨 뒤에서부터 최댓값이 정렬되기 때문에 반복할수록 비교해야 할 원소의 개수는 (총 개수 - 정렬된 개수)로 줄어든다. 또한 버블 정렬은 하나의 값 당 리스트 모든 원소를 살펴봐야 하기 때문에 시간복잡도는 <span class="math inline">\(O(n^2)\)</span>이며, 리스트 내에서 정렬이 진행되기 때문에 공간복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p><p>버블 정렬 예시를 러스트(Rust)로 구현하면 다음과 같다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">lis</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">10</span>] = [<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>];<br>    <span class="hljs-title function_ invoke__">bubble_sort</span>(lis);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">bubble_sort</span>(<span class="hljs-keyword">mut</span> lis: [<span class="hljs-type">i32</span>; <span class="hljs-number">10</span>]) &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..lis.<span class="hljs-title function_ invoke__">len</span>()&#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">j</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..lis.<span class="hljs-title function_ invoke__">len</span>()-<span class="hljs-number">1</span>&#123;<br>            <span class="hljs-keyword">if</span> lis[j] &gt; lis[j+<span class="hljs-number">1</span>]&#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">temp</span> = lis[j];<br>                lis[j] = lis[j+<span class="hljs-number">1</span>];<br>                lis[j+<span class="hljs-number">1</span>] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,lis)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="삽입-정렬">삽입 정렬</h2><p>삽입 정렬은 현 위치에 있는 숫자를 그 이전 숫자와 비교하여 위치를 찾아주는 방식이다. 앞에 있는 숫자와 비교하기 때문에 인덱스 2번부터 시작되며, 앞 숫자가 자신보다 더 작은 경우에 정렬은 끝난다.</p><p>로직은 다음과 같다.</p><ol type="1"><li>현 위치의 숫자는 바로 앞의 숫자와 크기를 비교하여 더 작은 경우 자리를 바꾼다.</li><li>계속 앞으로 가며 자리를 바꾸다가 앞 숫자가 크기가 작거나 같은 경우 이동을 멈춘다.</li><li>이를 2번째 인덱스부터 마지막 인덱스까지 진행한다.</li></ol><p>위 로직에 따르면 자신보다 작은 값이 앞에 있을 때까지만 이동하면 되기 때문에 숫자마다 비교해랴 하는 개수는 리스트 형식에 따라 다르다. 따라서 삽입 정렬에서 시간복잡도는 리스트가 정렬되어 있는 경우의 <span class="math inline">\(O(n)\)</span>부터 역으로 정렬되어 있는 경우의 <span class="math inline">\(O(n^2)\)</span>까지 모두 가능하며, 공간복잡도는 리스트 내에서 정렬이 진행되기 때문에 <span class="math inline">\(O(n)\)</span>이다.</p><p>삽입 정렬 예시를 러스트(Rust)로 구현하면 다음과 같다.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">lis</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">10</span>] = [<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>];<br>    <span class="hljs-title function_ invoke__">insertion_sort</span>(lis);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">insertion_sort</span>(<span class="hljs-keyword">mut</span> lis: [<span class="hljs-type">i32</span>; <span class="hljs-number">10</span>]) &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..lis.<span class="hljs-title function_ invoke__">len</span>()&#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">j</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>..i+<span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">rev</span>()&#123;<br>            <span class="hljs-keyword">if</span> lis[j] &lt; lis[j-<span class="hljs-number">1</span>]&#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">temp</span> = lis[j];<br>                lis[j] = lis[j-<span class="hljs-number">1</span>];<br>                lis[j-<span class="hljs-number">1</span>]=temp<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,lis)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithms</tag>
      
      <tag>알고리즘</tag>
      
      <tag>기초</tag>
      
      <tag>버블정렬</tag>
      
      <tag>삽입정렬</tag>
      
      <tag>선택정렬</tag>
      
      <tag>정렬알고리즘</tag>
      
      <tag>sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[DAsP] 데이터 모델링 이해</title>
    <link href="/ko/Certificate/DAsP-2/"/>
    <url>/ko/Certificate/DAsP-2/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 데이터아키텍처 준전문가(DAsP) 자격증 공부 내용을 정리합니다. <span id="more"></span></p><hr /><h2 id="데이터-모델링">데이터 모델링</h2><p>데이터를 중복없이 정확하게 유지 및 관리하기 위해서 시행하는 도구. 정보 시스템 개발은 크게 프로세스 모델링과 데이터 모델링으로 구분되는데 보통 데이터 모델링을 중심으로 설계한다. 따라서 데이터 모델링을 할 때는 <strong>중복, 비유연성, 비일관성</strong>을 주의해야 한다.</p><h2 id="데이터-모델링이-중요한-이유">데이터 모델링이 중요한 이유</h2><ul><li>파급효과: 데이터 모델은 차후에 변경하는 과정이 매우 힘들다.</li><li>간결한 표현: 시스템 구축 이해 관계자들에게 명확하게 요구사항을 전달할 수 있다.</li><li>데이터 품질: 모델에 따라 데이터 품질 수준이 달라진다.</li></ul><h2 id="데이터-모델링-기본-원칙">데이터 모델링 기본 원칙</h2><ul><li>커뮤니케이션 원칙: 사용자 및 이해관계자에게 시스템 지향성을 명확히 설명 가능</li><li>모델링 상세화 원칙: 조직이 사용하는 정보 구조의 최소 공통분모를 제시해야 함</li><li>논리적 표현 원칙: 데이터에 대한 논리적 측면을 최대한 표현</li></ul><h2 id="좋은-데이터-모델의-요소">좋은 데이터 모델의 요소</h2><ul><li>완전성: 업무에 필요한 모든 데이터가 존재</li><li>중복 배제: 동일한 정보는 한번만 있어야 함</li><li>비즈니스 룰: 업무 규칙을 적용</li><li>데이터 재사용: 여러 애플리케이션에 사용가능한 구조</li><li>안전성 및 확장성: 차후 변경되는 부분도 감당 가능한 구조</li><li>간결성: 테이블을 최대한 통합하여 모델의 간결함 유지</li><li>의사소통: 업무 규칙을 데이터 모델 요소를 기반으로 의사소통 가능</li><li>통합성: 전체가 한 몸처럼 연결 필요</li></ul><h2 id="데이터-모델링-기법">데이터 모델링 기법</h2><p>데이터에 따라 관리자, 사용자, 개발자가 서로 다르게 인식하고 있는 뷰들을 통합해야 단일화된 설계안 생성이 가능하다. 이를 위해 <strong>개체-관계 다이어그램(ERD)</strong>으로 도식화하는 방법인 <strong>개체-관계 모델 기법</strong>을 사용한다.</p><h3 id="개체-관계-모델-구성요소">개체-관계 모델 구성요소</h3><p>일반적으로 논리/물리 모델링으로 나누어지며, 논리 모델은 업무수행방식이 바뀌어도 설계를 거의 번경하지 않는다.</p><table><thead><tr class="header"><th>구성요소</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>엔터티</td><td>동질성을 가진 개체 집합이며 지속해서 관리를 해야하는 대상<br> 모델설계 초기에 도출</td></tr><tr class="even"><td>속성</td><td>엔터티에저장되는 집합의 특성을 설명하는 항목</td></tr><tr class="odd"><td>식별자</td><td>개체를 식별할 수 있는 속성, 논리적 관점에서 엔터티는 식별자를 가지고 물리적인 테이블은 키를 가진다.<br> - 본질식별자: 집합의 본질의 명확하게 설명하는 의미상 주어 <br> - 후보식별자: 인스턴스를 유일하게 식별할 수 있는 속성 <br> - 대체식별자: 원래 식별자응 대신할 수 있는 또다른 속성 <br> - 인조식별자: 기존 본질 식별자를 사용하기 어려울 때 임의로 만들어 사용 <br> - 실질 식별자: 인스턴스를 구별하기 위해 공식적으로 부여된 식별자</td></tr><tr class="even"><td>관계</td><td>엔터티 간의 연관성을 표현한 것 <br> 일대일, 일대다, 다대다 관계가 존재</td></tr><tr class="odd"><td>카디날리티</td><td>관계에서 한 개체가 각 엔터티들에 참여되는 수<br> 예로 한 학생이 6개의 수업을 들을 수 있다면 카티날리티는 (1,6)이다.</td></tr><tr class="even"><td>존재 종속</td><td>한 엔터티의 개체가 다른 엔터티의 개체에 영향을 받는 경우</td></tr><tr class="odd"><td>서브타입</td><td>전체집합인 슈퍼타입의 부분집합, 배타적/포괄적으로 구분</td></tr></tbody></table><h2 id="데이터-모델링-표기법">데이터 모델링 표기법</h2><h3 id="바커-표기법">바커 표기법</h3><figure><img src="/images/111.jpg" alt="barker" /><figcaption aria-hidden="true">barker</figcaption></figure><h3 id="ieinformation-engineering-표기법">IE(Information Engineering) 표기법</h3><figure><img src="/images/112.jpg" alt="IE" /><figcaption aria-hidden="true">IE</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>etc.</category>
      
      <category>certificate</category>
      
    </categories>
    
    
    <tags>
      
      <tag>자격증</tag>
      
      <tag>DAsP</tag>
      
      <tag>데이터아키텍처</tag>
      
      <tag>전사아키텍처</tag>
      
      <tag>데이터</tag>
      
      <tag>요건분석</tag>
      
      <tag>data</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[DAsP] 데이터 요건 분석</title>
    <link href="/ko/Certificate/DAsP-1/"/>
    <url>/ko/Certificate/DAsP-1/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 데이터아키텍처 준전문가(DAsP) 자격증 공부 내용을 정리합니다. <span id="more"></span></p><hr /><h2 id="정보-요구사항이란">정보 요구사항이란</h2><p>업무의 개선 사항이나 신규 개발 사항 등을 물어보고 정리한 자료이다. 일반적으로 사용자들이 해당 시스템에 어떤 기능들을 바라는지 묻고 정리한다.</p><h3 id="정보-요구사항-생명주기">정보 요구사항 생명주기</h3><ul><li><strong>정보 요구사항 수집</strong>: 사용자 인터뷰, 설문지, 워크숍, 현행 시스템 분석 등으로 요구사항 수집</li><li><strong>정보 요구사항 분석 및 정의</strong>: 수집된 요구사항을 프로세스별, 단계별로 종합하고 중요성과 긴급성을 기준으로 우선순위 설정</li><li><strong>정보 요구사항 상세화</strong>: 우선순위가 높은 것들을 중심으로 개별 사항을 세밀하게 분석</li><li><strong>정보 요구사항 검증</strong>: 비즈니스 관점, 조직 관점, 어플리케이션 관점과 상관분석을 통해 검증</li></ul><h3 id="정보-요구사항-유형">정보 요구사항 유형</h3><p>정보 요구사항 수집 시 아래의 조건들을 기준으로 한다.</p><h4 id="외부-인터페이스-요건">외부 인터페이스 요건</h4><table><thead><tr class="header"><th>구분</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>정의</td><td>모든 입출력에 관한 요건</td></tr><tr class="even"><td>관리기준</td><td>중복성: 동일한 인터페이스가 존재하는가 <br> 표준 준수도: 국내외 표준 존재 시 그에 적합한 형태로 제공되는가</td></tr><tr class="odd"><td>관리방법</td><td>항목 이름, 목적 설명, 입출력 위치, 데이터 포맷 등이 관리</td></tr></tbody></table><h4 id="기능-개선-요건">기능 개선 요건</h4><table><thead><tr class="header"><th>구분</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>정의</td><td>시스템에서 입력을 받은 후 출력을 만들어내는 과정 전체</td></tr><tr class="even"><td>관리기준</td><td>불가변성: 향후에 변경될 필요가 없는가 <br> 범용성: 많은 사용자가 편리하게 사용할 수 있는가</td></tr><tr class="odd"><td>관리방법</td><td>입력 유효 체크, 처리 순서, 비정상 상태의 반응, 변환 공식 등이 관리</td></tr></tbody></table><h4 id="성능-개선-요건">성능 개선 요건</h4><table><thead><tr class="header"><th>구분</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>정의</td><td>동시 사용자 수, 처리하는 정보 양과 종류, 트랜잭션 소요시한 등</td></tr><tr class="even"><td>관리기준</td><td>실현 가능성: 현행 기술 수준에서 구현 가능한가 <br> 측정 가능성: 측정 가능할 만큼 명확한가</td></tr><tr class="odd"><td>관리방법</td><td>각 서비스 특성에 따른 정적, 동적 기준을 만들고 모니터링 실시</td></tr></tbody></table><h4 id="보안-개선-요건">보안 개선 요건</h4><table><thead><tr class="header"><th>구분</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>정의</td><td>물리적 접근통제(통제구역)와 사용 통제(인증, 암호화, 방화벽) 등</td></tr><tr class="even"><td>관리기준</td><td>불가변성: 향후에 변경될 필요가 없는가 <br> 실현 가능성: 현행 기술 수준에서 구현 가능한가</td></tr><tr class="odd"><td>관리방법</td><td>보안 장비 등급 관리, 접근 방식 기준 생성, 이에 따른 모니터링 실시</td></tr></tbody></table><h3 id="정보-요구사항-관리">정보 요구사항 관리</h3><ul><li><strong>요구사항 발송</strong>: 요구사항 정의서 양식에 맞춰 작성 후 담당자에게 발송</li><li><strong>요구사항 수렴</strong>: 수집된 정의서를 양식 확인 후 처리할 담당자에 맞춰 전송</li><li><strong>요구사항 검토</strong>: 반영 여부 판단 후 미반영 시 사유와 함께 정의서 보낸 담당자에게 발송</li><li><strong>영향도 분석</strong>: 변경에 영향을 받는 설계서, 기존 앱, 데이터베이스 등을 확인</li><li><strong>공식화</strong>: 담당자들과 협의하여 규모, 시간, 긴급성에 따라 반영 유형 결정</li><li><strong>반영작업계획 수립</strong>: 영향도 분석 결과를 바탕으로 반영계획수립(설계서 변경, 테스트, 이관 등)</li></ul><h2 id="정보-요구사항-조사">정보 요구사항 조사</h2><ul><li>정보 요구사항 수집</li></ul><table><thead><tr class="header"><th>종류</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>관련 문서 수집</td><td>구현시스템의 대상과 범위를 명확하게 정의하기 위해 기존 자료 수집</td></tr><tr class="even"><td>사용자 면담</td><td>실무자와 질의응답, 면담자, 기록자, 관찰자로 구성하여 면담 진행</td></tr><tr class="odd"><td>워크숍</td><td>프로젝트 이해관계에 있는 부서들을 모아 한번에 면담을 진행</td></tr><tr class="even"><td>현행업무조사서</td><td>전체부서에 동일한 기준으로 조사</td></tr><tr class="odd"><td>형행 프로그램/데이터 관련 문서</td><td>현행 시스템을 파악하기 위한 작업</td></tr></tbody></table><ul><li>정보 요구사항 정리</li></ul><table><thead><tr class="header"><th>종류</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>사용자 면담 정리</td><td>자료샘플이나 관련문서를 체계적으로 정리 및 기록</td></tr><tr class="even"><td>업무 조사서 정리</td><td>수행중인 프로세스, 외부기관 문서, 사용중인 시스템 목록 등을 정리</td></tr><tr class="odd"><td>워크숍 정리</td><td>워크숍의 목적, 진행내용, 해결 상태, 기타 등의 내용을 정리</td></tr></tbody></table><ul><li>정보 요구사항 분석</li></ul><table><thead><tr class="header"><th>종류</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>화폐가치산출방법</td><td>기업차원 중요성과 시스템 차원 중요성 각각 점수를 부여한 후 백분율로 변환하여 중요도 도출</td></tr><tr class="even"><td>상대적중요도산정방법</td><td>업무에 기여하는 정도, 현행 정보시스템 상태, 관련성 기준으로 점수를 부여한 뒤 가중치 도출</td></tr></tbody></table><ul><li>정보 요구사항 통합</li></ul><table><thead><tr class="header"><th>종류</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>정보 요구사항 목록 검토</td><td>전사 관점에서 동일한 요구사항이 있는지 확인</td></tr><tr class="even"><td>정보 요구사항 목록 통합/분할</td><td>부서간 중복 요구사항이 있는지 확인</td></tr></tbody></table><h2 id="정보-요구사항-분석">정보 요구사항 분석</h2><h3 id="분석-대상-정의">분석 대상 정의</h3><ol type="1"><li>분석 대상 자료 수집: 현행 업무 흐름도, 현행 업무 설명서, 현행 업무 분장</li><li>분석 대상 업무 영역 선정: 분류 기준에 따른 현행 업무 목록 작성</li><li>분석 대상 현행 시스템 선정: 업무 영역별 선정 작업 실시</li><li>보완작업: 유용성(활용가능성), 완정성(누락여부), 정확성, 유효성(최신반영)을 기준으로 보완</li></ol><h3 id="정보-요구사항-상세화">정보 요구사항 상세화</h3><ul><li>프로세스 관점의 정보 요구사항 상세화</li></ul><table><thead><tr class="header"><th>작업</th><th>설명</th></tr></thead><tbody><tr class="odd"><td>프로세스 분해/상세화</td><td>- 업무별 기능별 하향식으로 프로세스 분해 및 도출 <br> - 프로세스 계층도(높은 응집도, 낮은 결합도)와 프로세스 정의서 작성</td></tr><tr class="even"><td>정보 항목 도출 및 표준화</td><td>- 분해한 프로세스를 CURD로 구분 <br> - 정보항목에 대한 표준화 정리 <br>- 정보항목 목록 정의</td></tr><tr class="odd"><td>정보 항목별 통합성, 분리성 여부 검토</td><td>- 나눠진 정보 항목 분류 <br> - 동음이의, 이음동의 존재 파악 <br>- 검토 후 최종 정보항목 목록 정의</td></tr></tbody></table><ul><li>객체지향 관점의 정보 요구사항 상세화 <img src="/images/113.jpg" alt="usecase" /></li></ul><h3 id="정보-요구사항-확인">정보 요구사항 확인</h3><ol type="1"><li><p>재검토 계획 수립 재검토 계획서를 생성하고, 완전성, 일관성, 정확성, 안정성 등의 평가할 기준점을 결정한다.</p></li><li><p>재검토 실시 재검토가 필요한 산출물을 참여자에게 배포하고 재검토 일정을 안내한다. 통합성 검증을 위해 담당자는 전부 참여해야 하며, 결과가 정리되면 요구사항별 보완 목록을 작성한다.</p></li><li><p>보완 결과 확인 반영되지 않은 사항들을 재검토허고 미반영 사유가 타당하지 않다면 보완 목록에 추가한다.</p></li></ol><h3 id="정보-요구사항-분석-방법">정보 요구사항 분석 방법</h3><h4 id="구조적-분석-방법">구조적 분석 방법</h4><p>개발될 시스템의 모형을 만들어 데이터보다는 기능(처리)적 관점에서 평가한다. 분석 순서는 다음과 같다.</p><ul><li>배경도 작성</li><li>상위 자료 흐름도 작성</li><li>하위 자료 흐름도 작성</li><li>자료 사전 작성</li><li>소단위 명세서 작성</li></ul><p>자료 흐름도 작성 원칙은 다음과 같다.</p><ul><li>자료 보존의 원칙: 출력 자료 흐름은 반드시 입력 자료 흐름으로 생성된 것이어야 한다.</li><li>최소 자료 입력의 원칙: 어떤 처리의 자료 흐름은 최소한의 흐름으로 입력되어야 한다.</li><li>독립성의 원칙: 각 자료흐름은 본인의 입력과 출력만 알면 된다.</li><li>지속성의 원칙: 처리는 항상 진행되어야 한다.</li><li>순차 처리의 원칙: 입력된 순서대로 출력되어야 한다.</li><li>영구성의 원칙: 자료저장소의 자료는 제거되지 않는다.</li><li>자료 변환의 원칙: 자료 본질의 변환(편짐, 계산), 자료 합성의 변환(여러 입력)</li></ul><h4 id="객체지향-분석-방법">객체지향 분석 방법</h4><p>데이터와 적용될 기능을 함께 추상화하는 방법</p><h2 id="정보-요구사항-검증">정보 요구사항 검증</h2><p>도출된 정보 요구사항을 다른 영역(프로새스, 기능 등)과 비교분석함으로써 요구사항의 도출이 정확히 이루어졌는지 검증할 수 있다.</p><h3 id="정보-요구어플리케이션-상관분석">정보 요구/어플리케이션 상관분석</h3><ul><li>정보 요구사항과 어플리케이션 프로세스 항목으로 매트릭스를 생성</li><li>프로세스 액션인 C(Create, 생성), D(Delete, 삭제) , U(Update, 수정), R(Read, 조회)을 대입</li><li>동시다발적인 복수의 액션 발생 시 C &gt; D &gt; U &gt; R 순서에 따라 하나만 기록</li><li>정보 요구사항과 어플리케이션 프로세스 항목 둘 중 하나만 누락되어도 검증 불가</li></ul><h3 id="정보-요구업무-기능-상관분석">정보 요구/업무 기능 상관분석</h3><ul><li>정보 요구사항과 BA에서 도출된 업무 기능을 항목으로 매트릭스를 생성</li><li>생성, 수정, 삭제는 C(Create, Change)로 표시하고, 검색만 하는 경우는 U(Use)로 표시</li></ul>]]></content>
    
    
    <categories>
      
      <category>etc.</category>
      
      <category>certificate</category>
      
    </categories>
    
    
    <tags>
      
      <tag>자격증</tag>
      
      <tag>DAsP</tag>
      
      <tag>데이터아키텍처</tag>
      
      <tag>전사아키텍처</tag>
      
      <tag>데이터</tag>
      
      <tag>요건분석</tag>
      
      <tag>data</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[DAsP] 전사 아키텍처 이해</title>
    <link href="/ko/Certificate/DAsP-0/"/>
    <url>/ko/Certificate/DAsP-0/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 데이터아키텍처 준전문가(DAsP) 자격증 공부 내용을 정리합니다. <span id="more"></span></p><hr /><h2 id="전사-아키텍처enterprise-architecture-ea">전사 아키텍처(Enterprise Architecture, EA)</h2><p>기업 전체의 정보화 시스템을 쉽게 파악하기 위해서 생성한 설계도. 기업의 목표와 요구를 효율적으로 지원하기 위해 IT 인프라 각 부분들이 어떻게 구성되고 작동되어야 하는지가 체계적으로 기술되어 있다. 전사 아키텍처가 구성되어 있어야 거대한 시스템들도 상황에 따른 변화를 도모할 수 있다.</p><h3 id="전사">전사</h3><p>프로젝트에서 수행하고자 하는 단위. 기업 및 기관뿐만 아니라 어떤 조직의 아이템이나 사업단위를 지칭할 수도 있다.</p><h3 id="아키텍처">아키텍처</h3><p>시스템의 큰 골격이나 뼈대. 크게 규칙(Rule), 계획(Plan), 모델(Model)로 구성된다.</p><ul><li>규칙: 아키텍처의 일관성을 위해 준수하여야 하는 원칙을 수립 및 적용</li><li>계획: 현재 상황과 목표 아키텍처를 정의한 후 목표 달성을 위한 이행 전략 및 계획을 수립</li><li>모델: 특정 시스템의 원리를 구조적으로 정의</li></ul><p>아키텍처는 비즈니스 모델을 바탕으로 한 비즈니스 아키텍처와 시스템 아키텍처로 나뉘며, 또 시스템 아키텍처는 데이터, 애플리케이션, 기술(하드웨어)로 구성된다.</p><h2 id="전사-아키텍처-프레임워크">전사 아키텍처 프레임워크</h2><p>전사 아키텍처 진행에서 발생하는 산출물들을 조직적으로 관리하기 위한 틀. 이해한 바로는 각 기업마다 요구되는 전사 아키텍처가 다르기에 프로젝트 시작 초반에 프레임워크를 구성함으로써 목표 및 진행과정을 명확하게 나타낼 수 있어서 사용하는 것 같다. 프레임워크는 기업마다 다르지만 보통 정책, 정보, 관리로 구성된다.</p><h3 id="전사-아키텍처-정책">전사 아키텍처 정책</h3><ul><li>아키텍처 메트릭스: EA의 정보를 체계적으로 분류한 틀. 기업이 요구하는 EA 수준과 활용 계층을 결정</li><li>EA 비전: 전사 아키텍처 수립을 통해 기업이 궁극적으로 달성하고자 하는 모습</li><li>EA 원칙: 효율적인 진행을 위해 프로젝트 시 조직 구성원이 공유해야 할 규범</li></ul><h3 id="전사-아키텍처-정보">전사 아키텍처 정보</h3><ul><li>현행 아키텍처: 아키텍처 도메인 별 현재의 아키텍처 상태</li><li>이행 계획: 목표 아키텍처로 변환하기 위한 이행 과정 및 계획</li><li>목표 아키텍처: 아키텍처 도메인 별 목표로 정의한 아키텍처 상태</li></ul><h3 id="전사-아키텍처-관리">전사 아키텍처 관리</h3><ul><li>관리 쳬계: 구축된 EA를 유지 및 개선하기 위한 제도적 기반 수립</li><li>관리 시스템: 효율적인 EA사용을 위한 시스템 구축. 모델링 도구, 레포지터리, 포털 등으로 구성</li><li>평가(성숙도 모형): EA관리 및 활용 수준을 주기적으로 평가 및 개선점 도출</li></ul><h2 id="아키텍처-도메인">아키텍처 도메인</h2><p>아키텍처 메트릭스가 어떻게 구성되는지에 따라 달라진다. 도메인은 크게 BA, AA, DA, TA로 구분되며, 각각의 아키텍처들은 아키텍처 매트릭스의 사용자관점(Perspective)에 따라 활용 내용과 업무가 달라진다.</p><h3 id="babusiness-architecture">BA(Business Architecture)</h3><p>기업의 최종 목표를 달성하기 위한 업무 구조를 정의한 아키텍처.<br />아래의 다른 아키텍처들의 방향을 정의하고 검증하는 기준이 된다.</p><h3 id="aaapplication-architecture">AA(Application Architecture)</h3><p>업무 수행에 필요한 어플리케이션을 식별하고 구조를 체계화 한 아키텍처.</p><h3 id="dadata-architecture">DA(Data Architecture)</h3><p>업무 수행에 있어 필요한 데이터 구조를 체계적으로 정의한 아키텍처.</p><h3 id="tatechnical-architecture">TA(Technical Architecture)</h3><p>다른 아키텍처에서 요구하는 인프라 체계를 정의한 아키텍처.</p><h2 id="전사-아키텍처-참조모델">전사 아키텍처 참조모델</h2><p>각각의 아키텍처들의 표준으로 제시된 모델. 전사 아키텍처를 빠르게 수립할 수 있도록 도와준다.</p><ul><li>업무 참조모델(Business Reference Model, BRM): 비즈니스 아키텍처의 표준</li><li>데이터 참조모델(Data Reference Model, DRM): 데이터 아키텍처의 표준</li><li>서비스 참조모델(Service Reference Model, SRM): 애플리케이션 아키텍처의 표준</li><li>기술 참조모델(Technical Reference Model, TRM): 기술 아키텍처의 표준</li><li>성과참조모델(Performance Reference Model, PRM): 성과 측정을 위한 항목과 방법 제시</li></ul><h2 id="전사-아키텍처-프로세스">전사 아키텍처 프로세스</h2><p>전사 아키텍처를 구축하고 관리하는 절차. 구성은 EA 비전 수립, EA 구축, EA 관리, EA 활용 단계로 구분한다.</p><figure><img src="/images/110.jpg" alt="process" /><figcaption aria-hidden="true">process</figcaption></figure><h3 id="ea-비전-수립">EA 비전 수립</h3><table><thead><tr class="header"><th>과정</th><th>내용</th></tr></thead><tbody><tr class="odd"><td>EA 환경 분석</td><td>기업 내외부 환경 분석 및 이해관계자로부터 수립 요건들을 도출</td></tr><tr class="even"><td>EA 구축 방향 정의</td><td>환경 분석 결과를 토대로 EA 구축 목적 및 범위를 정의</td></tr><tr class="odd"><td>EA 프레임워크 구성 정의</td><td>산출물 분류 및 유지관리를 위한 프레임워크 정립</td></tr></tbody></table><h3 id="ea-구축">EA 구축</h3><h4 id="ea-정보-구성-정의">EA 정보 구성 정의</h4><table><thead><tr class="header"><th>과정</th><th>내용</th></tr></thead><tbody><tr class="odd"><td>아키텍처 매트릭스 정의</td><td>요구된 산출물들을 사용자관점(Perspective)과 정보유형(View) 두 축을 바탕으로 매트릭스 구성</td></tr><tr class="even"><td>참조모델 정의</td><td>각 정보유형(View)의 참조모델을 정의</td></tr><tr class="odd"><td>아키텍처 원칙 수립</td><td>해당 아키텍처에 동일하게 적용되는 원칙 수립</td></tr></tbody></table><h4 id="ea-정보-구축">EA 정보 구축</h4><table><thead><tr class="header"><th>과정</th><th>내용</th></tr></thead><tbody><tr class="odd"><td>EA 자료 수집</td><td>현행 아키텍처를 정의하기 위해 기존의 자료들을 수집</td></tr><tr class="even"><td>현행 아키텍처 정의</td><td>현행 시스템의 기존 자료를 분석하여 현행 아키텍처를 정의</td></tr><tr class="odd"><td>목표 아키텍처 정의</td><td>현행 아키텍처의 문제점의 개선안을 바탕으로 목표 아키텍처를 정의</td></tr></tbody></table><h3 id="ea-관리">EA 관리</h3><table><thead><tr class="header"><th>과정</th><th>내용</th></tr></thead><tbody><tr class="odd"><td>EA 관리 체계</td><td>EA 정보를 활용하기 위한 인력 및 조직, 프로세스 정의</td></tr><tr class="even"><td>EA 관리 시스템</td><td>EA 정보를 관리하기 위한 도구 선정 및 시스템 구축 <br> - 정보를 생산하는 모델링 도구 영역 <br> - 정보를 저장 및 관리하는 레파지토리 영역 <br> - 정보를 활용하는 포털 <br> - EA 정보를 활용하는 영역</td></tr></tbody></table><h3 id="ea-활용">EA 활용</h3><table><thead><tr class="header"><th>과정</th><th>내용</th></tr></thead><tbody><tr class="odd"><td>EA 이행 계획</td><td>다른 IT 업무에도 해당 아키텍처를 적용하기 위한 중장기 계획 수립</td></tr><tr class="even"><td>EA 정보 활용</td><td>EA 정보를 활용하여 다른 IT 업무를 수행</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>etc.</category>
      
      <category>certificate</category>
      
    </categories>
    
    
    <tags>
      
      <tag>자격증</tag>
      
      <tag>DAsP</tag>
      
      <tag>데이터아키텍처</tag>
      
      <tag>전사아키텍처</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows 환경에서 Rust 컴파일 link 에러</title>
    <link href="/ko/ERROR/error-1/"/>
    <url>/ko/ERROR/error-1/</url>
    
    <content type="html"><![CDATA[<p>Windows 환경에서 msvc 없이 Rust를 실행하기 위한 추가 설정 방법을 정리합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">the msvc targets depend on the msvc linker but `link.exe` was not found<br></code></pre></td></tr></table></figure><span id="more"></span><hr /><h2 id="오류-설명">오류 설명</h2><p>개인 컴퓨터로는 mac을 쓰고 있어서 rust를 설치하는게 어렵지 않았다. 그냥 rustup 다운 받아서 실행하면 컴파일러까지 알아서 셋팅해주었고, 이후 소스 파일을 컴파일하는 것도 문제 없었다. 하지만 윈도우 환경은 조금 달랐다. 윈도우 버전 rustup을 설치한 후, 바로 소스 파일을 컴파일하면 위와 같은 컴파일 오류가 발생한다. 이는 윈도우 버전 rust가 디폴트로 가지고 있는 툴체인이 msvc이기 때문이다.</p><p>msvc(microsoft visual C++)는 마이크로소프트에서 제공하는 툴체인(통합개발도구)으로 보통 C, C++ 코드를 빌드하고 디버깅할 때 사용하는 도구이다. 당연히 회사 노트북에는 msvc가 설치되어 있지 않았고, 그렇기에 rust가 컴파일 도중 에러를 일으킨다.</p><h2 id="해결-방법">해결 방법</h2><p>처음에는 msvc를 설치하려고 했으나 다른 방법을 찾았다.</p><p>바로 gnu으로 셋팅하여 사용하는 것이다. gnu는 실제 윈도우 컴퓨터이지만 리눅스에서 개발하는 것과 같은 환경을 제공해준다. 러스트는 msvc, gnu를 모두 지원하기 때문에 툴체인 디폴트값만 변경해주면 되는 것이다. 변경 방법은 cmd에서 아래의 코드를 입력해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rustup default stable-x86_64-pc-windows-gnu<br></code></pre></td></tr></table></figure><p>그 다음 다시 소스 파일을 컴파일하면 문제 없이 진행된다.</p>]]></content>
    
    
    <categories>
      
      <category>etc.</category>
      
      <category>errors</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>rust</tag>
      
      <tag>compiler</tag>
      
      <tag>msvc</tag>
      
      <tag>gnu</tag>
      
      <tag>vscode</tag>
      
      <tag>error</tag>
      
      <tag>toolchain</tag>
      
      <tag>linkerror</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>날짜 데이터 일부만 추출하기</title>
    <link href="/ko/Sql/sql-5/"/>
    <url>/ko/Sql/sql-5/</url>
    
    <content type="html"><![CDATA[<p>DATETIME 형식의 날짜 데이터에서 일부만 추출하는 방법을 정리합니다. <span id="more"></span></p><hr /><h2 id="datetime">DATETIME</h2><p><code>DATETIME</code>은 SQL에서 지정한 날짜 형식이다. 해당 구조는 아래와 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">2013</span><span class="hljs-number">-12</span><span class="hljs-number">-22</span> <span class="hljs-number">11</span>:<span class="hljs-number">30</span>:<span class="hljs-number">00</span><br><span class="hljs-number">2017</span><span class="hljs-number">-09</span><span class="hljs-number">-27</span> <span class="hljs-number">19</span>:<span class="hljs-number">09</span>:<span class="hljs-number">00</span><br><span class="hljs-number">2018</span><span class="hljs-number">-02</span><span class="hljs-number">-02</span> <span class="hljs-number">14</span>:<span class="hljs-number">18</span>:<span class="hljs-number">00</span><br><span class="hljs-number">2018</span><span class="hljs-number">-02</span><span class="hljs-number">-02</span> <span class="hljs-number">14</span>:<span class="hljs-number">17</span>:<span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p>예시에서 확인할 수 있듯이 <code>연도-월-일 시간:분:초</code> 형식으로 셋팅되어 있다. 만약 여기서 시간만 필요하거나 월만 필요하다면 어떻게 쿼리를 해야할까? SQL에서는 원하는 날짜나 시간대를 부분 추출할 수 있는 여러 함수들을 제공한다.</p><h2 id="year-연도">YEAR: 연도</h2><p><code>YEAR</code>은 <code>DATETIME</code>형식에서 연도만 추출하여 출력한다. 문법은 다음과 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">YEAR</span>(DATETIME) <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span>;<br><span class="hljs-number">2013</span><br><span class="hljs-number">2017</span><br><span class="hljs-number">2018</span><br><span class="hljs-number">2018</span><br><span class="hljs-number">2018</span><br></code></pre></td></tr></table></figure><h2 id="month-월">MONTH: 월</h2><p><code>MONTH</code>은 <code>DATETIME</code>형식에서 월 단위만 추출하여 출력한다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MONTH</span>(DATETIME) <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span>;<br><span class="hljs-number">12</span><br><span class="hljs-number">9</span><br><span class="hljs-number">2</span><br><span class="hljs-number">2</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="day-일">DAY: 일</h2><p><code>DAY</code>은 <code>DATETIME</code>형식에서 일 단위만 추출하여 출력한다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DAY</span>(DATETIME) <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span>;<br><span class="hljs-number">22</span><br><span class="hljs-number">27</span><br><span class="hljs-number">2</span><br><span class="hljs-number">2</span><br><span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><h2 id="hour-시간">HOUR: 시간</h2><p><code>HOUR</code>은 <code>DATETIME</code>형식에서 시간 단위만 추출하여 출력한다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">HOUR</span>(DATETIME) <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span>;<br><span class="hljs-number">11</span><br><span class="hljs-number">19</span><br><span class="hljs-number">14</span><br><span class="hljs-number">14</span><br><span class="hljs-number">17</span><br></code></pre></td></tr></table></figure><h2 id="minute-분">MINUTE: 분</h2><p><code>MINUTE</code>은 <code>DATETIME</code>형식에서 분 단위만 추출하여 출력한다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MINUTE</span>(DATETIME) <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span>;<br><span class="hljs-number">30</span><br><span class="hljs-number">9</span><br><span class="hljs-number">18</span><br><span class="hljs-number">17</span><br><span class="hljs-number">51</span><br></code></pre></td></tr></table></figure><h2 id="second-초">SECOND: 초</h2><p><code>SECOND</code>은 <code>DATETIME</code>형식에서 초 단위만 추출하여 출력한다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">SECOND</span>(DATETIME) <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span>;<br><span class="hljs-number">0</span><br><span class="hljs-number">0</span><br><span class="hljs-number">0</span><br><span class="hljs-number">0</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>sql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql</tag>
      
      <tag>mariadb</tag>
      
      <tag>mysql</tag>
      
      <tag>DATETIME</tag>
      
      <tag>HOUR</tag>
      
      <tag>YEAR</tag>
      
      <tag>DATA</tag>
      
      <tag>DATE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux kernel</title>
    <link href="/ko/Linux/Linux-2/"/>
    <url>/ko/Linux/Linux-2/</url>
    
    <content type="html"><![CDATA[<p>리눅스 커널에 대해서 정리합니다.</p><span id="more"></span><h2 id="kernel이란">kernel이란</h2><p>커널(kernel)이란 운영체제에서 가장 중요한 프로그램 중 하나이며, 하드웨어라는 자원을 관리하는 관리자이다. 즉, 어떤 프로그램이 작동할 수 있도록 CPU, 메모리, 디스크와 같은 물리적 장치들을 배분하는 것이 커널이다. 리눅스 강의에서 들었던 좋은 예시를 가져왔다. 아래 그림을 보자</p><figure><img src="/images/107.png" alt="kernel" /><figcaption aria-hidden="true">kernel</figcaption></figure><p>위 그림은 커널의 역할을 도서관의 사서와 비교한 것이다. 컴퓨터에서 어떤 프로그램을 시작하려고 하면 특정한 양의 하드웨어 재료들이 필요하다. 이 재료들을 요구한만큼 찾아서 빌려주고 또 돌려받아서 관리하는 것이 커널이다. 마치 학생이 과제를 하기 위해 사서에게 과제에 필요한 책이나 영상, 신문들을 빌려가는 것과 같다. 또한 사서는 단순히 빌려주기만 하는 것이 아니라 자료들의 상태를 관리하고 빌려주기로 한 기간이 지나면 돌려받기도 한다. 이런 일들도 컴퓨터에서 커널이 동일하게 담당한다.</p><h2 id="kernel의-역할">kernel의 역할</h2><p>커널은 크게 4가지의 역할을 가진다.</p><ul><li>메모리 관리: 메모리 사용량과 잔여량 등을 체크하고, 건강에 문제 없는지 체크한다.</li><li>프로세스 관리: CPU의 건강을 체크하고, 각 프로세스의 진행상황들을 관리한다.</li><li>장치 드라이버: 하드웨어와 프로세스를 연결한다.</li><li>시스템 호출 및 보안: 프로그램이 요구하는 커널의 재료들을 사용할 수 있도록 한다. (print, read, open, write 등)</li></ul><h2 id="kernel-version">kernel version</h2><p>커널의 버전을 확인하고 싶다면 아래의 코드를 입력하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">uname</span> -a<br></code></pre></td></tr></table></figure><p>위 명령어를 입력하면 "Linux Kernel Version 4.15.0"와 같은 단어가 보일 것이다. 첫번째 숫자인 4가 커널 버전이다. 만약 커널의 소스코드를 보고 싶다면 <a href="https://www.kernel.org">해당 링크</a>에서 찾아볼 수 있다.</p><h2 id="kernel-space-user-space">kernel space &amp; user space</h2><p>컴퓨터 시스템은 크게 2가지로 구분된다. 바로 커널 스페이스와 유저 스페이스이다. 각각의 스페이스에 들어갈 수 있는 구성은 다음과 같다.</p><ul><li>kernel space: kernel code, kernel extention, device driver</li><li>user space: C, java, python로 만들어진 어플리케이션이나 프로그램</li></ul><p>위 예시에서 알 수 있듯이 커널 스페이스는 하드웨어와 직접적으로 접근 가능하며, 하드웨어 자원들을 관리 및 통제한다. 그렇기 때문에 만약 프로그램에서 커널 스페이스에 접근할 수 있다면 디스크에 있는 정보를 훔쳐가거나 할 수 있다. 따라서 보안 상의 문제를 방지하기 위해 일반적인 프로그램들은 커널 스페이스에 직접적으로 접근할 수 없다. 만약 하드웨어에 있는 데이터가 필요하다면 무조건 커널 스페이스에 요청해야 한다. 해당 과정을 세부적으로 살펴보면 다음과 같다.</p><figure><img src="/images/108.png" alt="data" /><figcaption aria-hidden="true">data</figcaption></figure><p>프로그램은 데이터를 가져오기 위해서 시스템 콜을 통해 커널 스페이스에 데이터를 요청하고 커널 스페이스 내부에 있는 디바이스 드라이버가 직접 하드웨어에 접근하여 데이터를 가져온다.</p><h2 id="하드웨어와의-관계">하드웨어와의 관계</h2><p>커널은 컴퓨터의 하드웨어와 직접적으로 소통한다. 그 말은 리눅스 터미널에서 하드웨어의 상태를 확인할 수 있다는 의미도 포함한다. 지금부터 해당 명령어들을 확인해보자.</p><h2 id="dmesg">dmesg</h2><p>명령어 <code>dmesg</code>는 커널의 로그를 출력한다. 커널의 로그는 컴퓨터를 처음 켠 순간부터 연결 장치들의 부팅까지 모든 정보를 포함하기 때문에, 해당 로그를 통해서 하드웨어 연결의 문제들을 진단할 수 있다. 하지만 터미널에 <code>dmesg</code>만 입력하면 모든 커널로그들이 출력되기에 오류를 찾기는 쉽지 않다. 따라서 여러 옵션들을 추가하여 필요한 특정 커널 로그들만 출력할 수 있다. 사용할 수 있는 옵션들은 다음과 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">Options:<br> -C, --clear                 clear the kernel ring buffer<br> -c, --read-clear            <span class="hljs-built_in">read</span> and clear all messages<br> -D, --console-off           <span class="hljs-built_in">disable</span> printing messages to console<br> -d, --show-delta            show <span class="hljs-keyword">time</span> delta between printed messages<br> -e, --reltime               show <span class="hljs-built_in">local</span> <span class="hljs-keyword">time</span> and <span class="hljs-keyword">time</span> delta <span class="hljs-keyword">in</span> readable format<br> -E, --console-on            <span class="hljs-built_in">enable</span> printing messages to console<br> -F, --file &lt;file&gt;           use the file instead of the kernel <span class="hljs-built_in">log</span> buffer<br> -f, --facility &lt;list&gt;       restrict output to defined facilities<br> -H, --human                 human readable output<br> -k, --kernel                display kernel messages<br> -L, --color                 colorize messages<br> -l, --level &lt;list&gt;          restrict output to defined levels<br> -n, --console-level &lt;level&gt; <span class="hljs-built_in">set</span> level of messages printed to console<br> -P, --nopager               <span class="hljs-keyword">do</span> not pipe output into a pager<br> -r, --raw                   <span class="hljs-built_in">print</span> the raw message buffer<br> -S, --syslog                force to use syslog(2) rather than /dev/kmsg<br> -s, --buffer-size &lt;size&gt;    buffer size to query the kernel ring buffer<br> -T, --ctime                 show human readable timestamp (could be <br>                               inaccurate <span class="hljs-keyword">if</span> you have used SUSPEND/RESUME)<br> -t, --notime                dont <span class="hljs-built_in">print</span> messages timestamp<br> -u, --userspace             display userspace messages<br> -w, --follow                <span class="hljs-built_in">wait</span> <span class="hljs-keyword">for</span> new messages<br> -x, --decode                decode facility and level to readable string<br><br> -h, --<span class="hljs-built_in">help</span>     display this <span class="hljs-built_in">help</span> and <span class="hljs-built_in">exit</span><br> -V, --version  output version information and <span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure><h2 id="dmesg---level">dmesg --level</h2><p>위의 수많은 옵션 중에서 오류를 나타내는 커널 로그만 확인하고 싶다면 무엇을 사용해야 할까? 정답은 <code>-l</code>, <code>--level</code>이다. (여기서 <code>-</code>는 문자가 하나일 때는 1개를 사용하고 문자가 여러개 이어질 때는 <code>--</code>를 사용한다) <code>--level</code>은 뒤에 추가 값을 받아서 해당 옵션에 속하는 커널 로그만 출력한다. 추가 옵션 값들은 다음과 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">Supported <span class="hljs-built_in">log</span> levels (priorities):<br>   emerg - system is unusable<br>   alert - action must be taken immediately<br>    crit - critical conditions<br>     err - error conditions<br>    warn - warning conditions<br>  notice - normal but significant condition<br>    info - informational<br>   debug - debug-level messages<br></code></pre></td></tr></table></figure><p>위에서 대략 파악했을 수 있지만 로그들은 몇 가지의 종류로 분류된다. 보통 오류를 파악하기 위해서는 <code>err</code>, <code>crit</code> 들을 출력하여 확인한다.</p><h2 id="lspci">lspci</h2><p><code>lspci</code>는 pci의 리스트를 출력한다. pci(Peripheral Component Interconnect)는 컴퓨터 내부에서 주변 장치들을 연결하는 연결선(local bus)라고 볼 수 있다. 따라서 해당 명령어를 입력하면 장비 리스트를 볼 수 있어서 각 하드웨어의 설정 정보를 확인할 수 있다.</p><p>아래의 예시는 vmware 가상 머신의 pci 리스트 일부이다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">00:00.0 Host bridge: Intel Corporation 440BX/ZX/DX - 82443BX/ZX/DX Host bridge (rev 01)<br>00:01.0 PCI bridge: Intel Corporation 440BX/ZX/DX - 82443BX/ZX/DX AGP bridge (rev 01)<br>00:07.0 ISA bridge: Intel Corporation 82371AB/EB/MB PIIX4 ISA (rev 08)<br>00:07.1 IDE interface: Intel Corporation 82371AB/EB/MB PIIX4 IDE (rev 01)<br>00:07.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 08)<br>00:07.7 System peripheral: VMware Virtual Machine Communication Interface (rev 10)<br>00:0f.0 VGA compatible controller: VMware SVGA II Adapter<br>00:11.0 PCI bridge: VMware PCI bridge (rev 02)<br></code></pre></td></tr></table></figure><h2 id="lsblk">lsblk</h2><p><code>lsblk</code>는 블럭들의 구조를 보여준다. 보통 스카시(SCSI)로 연결된 하드 디스크 장치를 <code>sd</code>라고 표현하고 갯수에 따라 뒤에 <code>a</code>,<code>b</code> 알파벳이 붙는다. 즉, 스카시(SCSI)로 연결된 하드 디스크 장치 2개가 연결되어 있다면 리스트에는 <code>sda</code>, <code>sdb</code> 이렇게 나타날 것이다. 또한 해당 하드 디스크를 파티셔닝하여 블럭 단위로 사용하기 때문에 각 블럭들은 하드 디스크 이름에 숫자가 붙어서 나타난다. 예시로 본다면 하드디스크 <code>sda</code>를 파티셔닝한 블럭들은 <code>sda1</code>, <code>sda2</code>의 이름으로 출력된다. 아래의 예시를 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT<br>sda               8:0    0  100G  0 disk <br>├─sda1            8:1    0    1G  0 part /boot<br>└─sda2            8:2    0   99G  0 part <br>  ├─centos-root 253:0    0 91.1G  0 lvm  /<br>  └─centos-swap 253:1    0  7.9G  0 lvm  [SWAP]<br></code></pre></td></tr></table></figure><p>위의 예시는 물리적인 하드디스크는 <code>sda</code> 1개이고, 이를 블럭 2개로 파티셔닝하였다. 블럭 <code>sda1</code>은 헤당 서버 부트 시스템만 들어가 있고, <code>sda2</code>에 나머지 스토리지 여분이 전부 할당되어 있다. 또 <code>sda2</code>는 내부에서 <code>root</code>와 <code>swap</code>으로 나눠졌다. <code>swap</code>은 리눅스에서 메모리가 부족한 경우, 메모리처럼 사용하기 위한 여분이다. <code>swap</code>에 대한 자세한 정보는 다음에 살펴볼 것이다. 위에서 <code>MAJ:MIN</code>을 확인할 수 있는데, <code>MAJ</code>는 디스크 넘버이고 <code>MIN</code>은 파티셔닝 넘버이다.</p><h3 id="lscpu">lscpu</h3><p><code>lscpu</code>는 해당 서버의 CPU 정보를 출력한다. 아래 예시에서 중요한 몇 가지만 살펴보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">Architecture:          x86_64<br>CPU op-mode(s):        32-bit, 64-bit<br>Byte Order:            Little Endian<br>CPU(s):                8<br>On-line CPU(s) list:   0-7<br>Thread(s) per core:    1<br>Core(s) per socket:    1<br>Socket(s):             8<br>NUMA node(s):          1<br>Vendor ID:             GenuineIntel<br>CPU family:            6<br>Model:                 44<br>Model name:            Intel(R) Xeon(R) CPU L5640 @ 2.27GHz<br>Stepping:              2<br>CPU MHz:               2261.000<br>BogoMIPS:              4522.00<br>Hypervisor vendor:     VMware<br>Virtualization <span class="hljs-built_in">type</span>:   full<br>L1d cache:             32K<br>L1i cache:             32K<br>L2 cache:              256K<br>L3 cache:              12288K<br>NUMA node0 CPU(s):     0-7<br></code></pre></td></tr></table></figure><p>먼저 <code>CPU op-mode</code>은 연산할 수 있는 비트 갯수를 나타내며 32-bit, 64-bit 두 가지 종류가 있다. 32-bit는 연산 비트 수가 <span class="math inline">\(2^{32}\)</span>인 것을 의미하고 대략 4GB까지 처리할 수 있으며, 64-bit는 연산 비트 수가 <span class="math inline">\(2^{64}\)</span>인 것을 의미하고 대략 18EB(엑사바이트)까지 처리할 수 있다. 64-bit 기반의 전자기기는 32-bit 기반으로 만들어진 어플리케이션도 작동시킬 수 있지만, 그 반대는 안된다. 다음으로 <code>Socket</code>, <code>Thread(s) per core</code>, <code>Core(s) per socket</code>이다. 이를 이해하기 위해서는 실제 CPU가 어떻게 생겼는지를 알아야 한다. 아래의 그림을 보자</p><figure><img src="/images/109.png" alt="CPU" /><figcaption aria-hidden="true">CPU</figcaption></figure><p>보통 CPU는 소켓 안에 코어가 들어가 있으며, 또 코어는 내부에 쓰레드로 나눠진다. CPU는 이 모든 것들을 통칭한다. 결론적으로 해당 서버의 CPU 갯수는 <code>Socket</code> x <code>Thread(s) per core</code> x <code>Core(s) per socket</code> 이다. 위의 예시에서 총 CPU 갯수를 확인하면 <code>8 x 1 x 1</code>임을 알 수 있다.</p><h2 id="lsmem">lsmem</h2><p><code>lsmem</code>은 메모리 사용량을 보여준다. 아래의 예시를 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">RANGE                                  SIZE  STATE REMOVABLE   BLOCK<br>0x0000000000000000-0x000000001fffffff  512M online        no     0-3<br>0x0000000020000000-0x000000002fffffff  256M online       <span class="hljs-built_in">yes</span>     4-5<br>0x0000000030000000-0x0000000037ffffff  128M online        no       6<br>0x0000000038000000-0x0000000047ffffff  256M online       <span class="hljs-built_in">yes</span>     7-8<br>0x0000000048000000-0x000000005fffffff  384M online        no    9-11<br>0x0000000060000000-0x000000006fffffff  256M online       <span class="hljs-built_in">yes</span>   12-13<br>0x0000000070000000-0x0000000097ffffff  640M online        no   14-18<br>0x0000000098000000-0x000000009fffffff  128M online       <span class="hljs-built_in">yes</span>      19<br></code></pre></td></tr></table></figure><p>해당 정보는 물리적인 메모리 장치의 블럭들을 사용하고 있는지의 여부를 보여준다. 위 예시는 리스트의 일부만을 가져온 것이며, 실제로는 훨씬 더 길다. 해당 결과는 사람이 보기에는 어렵다. 사람도 보기 좋은 형태로 메모리 남은 양을 확인해보자.</p><h2 id="lsmem---summary">lsmem --summary</h2><p>바로 옵션 <code>--summary</code>를 붙여주는 것이다. 해당 옵션을 붙여주면 출력되는 결과는 다음과 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">Memory block size:       128M<br>Total online memory:      16G<br>Total offline memory:      0B<br></code></pre></td></tr></table></figure><p>위 예시를 보면 메모리 블럭의 단위는 128 MiB(메비바이트)이며, 현재 16 GiB(기비바이트)의 양을 사용하고 있는 것이다. 즉, 128개의 메모리 블럭을 사용중이라고 볼 수 있다.</p><p><strong>NOTE</strong> <code>lsmem</code>과 <code>free</code>의 차이점은 무엇인가?<br /><code>lsmem</code>은 메모리 블럭을 단위로 책정하여 사용중인 총량을 확인할 수 있으며, <code>/sys/devices/system/memory</code>에 위치한 정보를 읽어온다. 이와 달리 <code>free</code>는 실제 시스템에서 사용할 수 있는 메모리의 량을 보여주며, <code>/proc/meminfo</code>에서 정보를 읽어온다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ free -h<br>            total        used        free      shared  buff/cache   available<br>Mem:          15G        4.3G        3.7G         29M        7.5G         10G<br>Swap:        7.9G          0B        7.9G<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
      <tag>systemd</tag>
      
      <tag>filesystem</tag>
      
      <tag>boot</tag>
      
      <tag>hardware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux shell</title>
    <link href="/ko/Linux/Linux-1/"/>
    <url>/ko/Linux/Linux-1/</url>
    
    <content type="html"><![CDATA[<p>리눅스에서 사용되는 shell의 종류와 bash에 대해 정리합니다.</p><span id="more"></span><h2 id="shell이란">shell이란</h2><p>셀(shell)이란 사람이 사용하는 명령어를 프로그램이 실행할 수 있도록 만들어주는 인터페이스이다. 좀 더 쉽게 설명하면 터미널에서 사용하는 명령어들은 전부 쉘 언어이다. 쉘에서는 프로그램에 직접 명령어를 전달할 수도 있고, 내부에서 함수도 짤 수 있으며, 또 초기 환경 셋팅도 가능하다.</p><h2 id="shell-종류">shell 종류</h2><p>요즘은 대부분 bash를 쓰지만, 쉘에는 생각보다 종류가 많다. 각 이름들은 다음과 같다.</p><ul><li>Bourne shell (sh) : 최초로 쓰인 쉘, 스크립트만 지원</li><li>C shell (csh or tcsh): C 언어 위주의 쉘</li><li>korn shell (ksh): sh을 확장한 쉘, sh의 명령어 + 히스토리, 작업제어, alias 등이 추가</li><li>Z shell (zsh): ksh보다 개선된 기능을 가진 쉘</li><li>Bourne again shell (bash): 가장 많이 쓰이는 쉘, sh 호환 가능</li></ul><h2 id="chsh">chsh</h2><p>만약 쉘을 변경하여 사용하고 싶다면 터미널에 <code>chsh</code>를 입력하면 된다. 뒤에 <code>-s</code> 옵션을 붙인 후 바꾸려는 쉘을 입력하면 바로 변경 가능하다. 쉘을 바꿀 때는 해당 서버의 비밀번호가 요구된다. 예시는 아래와 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ chsh -s /bin/sh<br>암호 : *******<br>Shell changed<br></code></pre></td></tr></table></figure><h2 id="alias-별명기존명령어">alias 별명=기존명령어</h2><p>해당 명령어는 별칭으로 사용하고자 하는 명령어를 설정하며, 쉘 중에서 bash, sh에서만 가능하다. 예시를 보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">alias</span> up=<span class="hljs-built_in">uptime</span><br></code></pre></td></tr></table></figure><p>위의 명령어를 터미널에 입력하면 <code>uptime</code>이라는 명령어는 <code>up</code>만 입력해도 사용 가능하다.</p><h2 id="prompt-설정">prompt 설정</h2><p>터미널에서 사용하는 리눅스 프롬프트도 원하는 형태로 변경할 수 있다. 터미널에 아래와 같이 입력해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ PS1=<span class="hljs-string">&#x27;[\d]\u@\h:\w&#x27;</span><br></code></pre></td></tr></table></figure><p>위 패턴은 정규표현식이며, 해석하면 다음과 같다. <code>[날짜]사용자@호스트:지금 사용중인 디렉토리</code> 만약 터미널을 다시 껐다가 켜도 해당 프롬프트를 유지하고 싶다면 환경변수로 셋팅하면 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ vi /etc/bashrc<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;PS1=[\d]\u@\h:\w&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="enviroment-variable">enviroment variable</h2><p>환경 변수는 해당 서버의 운영체제에서 명령어를 실행할 때 참조하는 변수이다. 지정된 변수들은 <code>$변수이름</code>으로 사용된다. 현재 서버에서 지정된 환경 변수는 아래의 명령어를 입력하여 볼 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">env</span><br>TERM_PROGRAM=터미널 프로그램 종류<br>USER=사용자 이름<br>PATH=저장된 실행파일 경로들<br>LANG=지원되는 언어<br>SHELL=사용되는 쉘 이름<br>HOME=사용자 홈 디렉토리<br>OSTYPE=운영체제 종류<br></code></pre></td></tr></table></figure><p>위의 예시는 환경 변수들 중에 몇 가지만 가져온 것이며, <code>env</code>를 입력하면 위와 같이 환경 변수들을 볼 수 있다. 만약 환경 변수를 새로 지정하려면 어떻게 해야 할까? 바로 <code>export</code>를 사용하여 선언한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">export</span> 변수이름=변수 값<br></code></pre></td></tr></table></figure><p>하지만 위 방법은 해당 서버가 재부팅되면 변수가 사라진다. 재부팅되어도 계속 변수를 유지하려면 어떻게 하면 될까? <code>bashrc</code>에서 변수를 해당 명령어를 추가한 후 적용하면 된다. 적용은 재부팅을 하거나 <code>source</code>라는 명령어를 사용한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ vi ~/.bashrc<br><span class="hljs-built_in">export</span> 변수이름=변수 값<br>$ <span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure><h2 id="path-variable">path variable</h2><p><code>path</code>는 해당 서버에 깔려 있는 프로그램이 어디 디렉토리에 존재하는지 경로를 설정하는 변수이다. 현재 추가되어 있는 경로를 보고 싶다면 아래의 명령어를 입력해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><br>:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin<br></code></pre></td></tr></table></figure><p>각 경로들은 콜론(:)으로 나눠져 있으며, 해당 경로에 존재하는 프로그램은 절대경로를 쓰지 않고도 바로 실행이 가능하다. 만약 프로그램의 path를 알고 싶다면 아래와 같이 입력해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">which</span> java<br>/usr/bin/java<br></code></pre></td></tr></table></figure><p>위의 결과는 명령어 <code>which</code>를 통해서 java 실행파일의 절대 경로를 보여준 예시이다. <code>which</code>는 경로가 있는 실행파일들의 위치를 보여준다.</p>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bash</tag>
      
      <tag>sh</tag>
      
      <tag>alias</tag>
      
      <tag>PS1</tag>
      
      <tag>ksh</tag>
      
      <tag>zsh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Basic Linux</title>
    <link href="/ko/Linux/Linux-0/"/>
    <url>/ko/Linux/Linux-0/</url>
    
    <content type="html"><![CDATA[<p>리눅스에 대해 간단하게 설명한 후, 리눅스의 기초적인 명령어를 정리합니다.</p><span id="more"></span><h2 id="linux란">Linux란</h2><p>리눅스는 운영체제(OS, Operating System) 중 하나로 보통 서버에서 많이 사용된다. 운영체제의 원조라고 할 수 있는 유닉스를 본따 구현되었으며, GNU에 속해있기에 모든 소스가 오픈되어 있다. (여기서 GNU란 소스를 모두 공개해야 하는 규약인데, 어떤 프로그램을 만들 때 GNU에 속한 소프트웨어를 사용한다면 해당 코드도 모두 공개헤야 한다.)</p><h2 id="linux-종류">Linux 종류</h2><p>오픈소스인 리눅스는 누구나 코드를 수정하고 배포할 수 있기에 수많은 버전들이 존재한다. 그 중에서 보편적으로 가장 많이 쓰이는 종류들만 살펴보자.</p><h3 id="centos">CentOS</h3><p>센토스(CentOS)는 레드햇 계열에 속하는 리눅스이다. 레드햇 계열이란 레드햇이라는 회사에서 배포한 리눅스들을 통칭하는 말인데, 센토스는 레드햇에서 제공한 오픈소스를 그대로 가져와 브랜드만 제거한 형태라고 볼 수 있다. 이런 센토스 계열은 명령어 yum을 사용하여 내부 패키지들을 관리한다.</p><h3 id="debian">Debian</h3><p>데비안(Debian)은 온라인 커뮤니티에서 레드햇보다 먼저 배포한 리눅스이다. 해당 리눅스를 기반으로 수정된 리눅스들을 모두 데비안 계열이라고 통칭한다. 초반에는 레드햇 계열에 비해 내장 유틸리티나 사후 관리 등이 부족하여 외면받았었지만 최근에는 지속적인 업데이트 등으로 레드햇 계열과 동일한 성능을 보여 인기를 얻고 있다. 이런 데비안 계열은 apt를 사용하여 내부 패키지들을 관리한다.</p><h3 id="ubuntu">Ubuntu</h3><p>우분투(Ubuntu)는 데비안 계열 중 하나로 데스크탑 환경을 지원한다. 위에서 설명한 리눅스들은 터미널만 제공되는 서버용이라면, 우분투는 테스크탑 UI를 지원하는 등 클라이언트용 운영체제라고도 볼 수 있다. 서버용 우분투도 있긴 하지만 대부분 개인용 데스크탑에서 많이 사용된다. 우분투 또한 데비안 계열이기에 apt로 패키지들을 관리한다.</p><h2 id="간단한-용어-정리">간단한 용어 정리</h2><ul><li>커널(kernel): 하드웨어를 직접적으로 통제하는 프로그램이며, 운영체제의 핵심이다.</li><li>쉘(shell): 사용자가 입력한 명령어를 기계어로 변환하여 커널에 전달하는 소프트웨어이다.</li><li>콘솔(console): 서버 장치에 물리적으로 연결되어 직접 명령어를 입출력할 수 있는 장치이다.</li><li>터미널(terminal): 서버에 로컬 또는 원격으로 접속할 수 있는 콘솔을 구현한 소프트웨어이다. (tty, teletype 이라고도 한다)</li><li>절대경로(absolute path): 어떤 디렉토리나 파일의 경로를 root부터 전부 나타낸 경로</li><li>상대경로(relative path): 현재 위치를 바탕으로 나머지만 나타낸 경로</li></ul><h2 id="linux-기초-명령어">Linux 기초 명령어</h2><p>리눅스에서 많이 사용되는 기초 명령어를 정리하였다.</p><h3 id="echo-코드">echo (코드)</h3><p>코드에 들어가는 것들을 프린트 한다. 예를 들어 코드에 $HOME을 넣는다면 홈 디렉토리 경로를 프린트 한다.</p><h3 id="uptime">uptime</h3><p>해당 운영체제의 작동시간이나 사용자 수 등을 보여준다. 여기서 사용자란 터미널 오픈 개수를 의미한다.</p><h3 id="tpye-명령어">tpye (명령어)</h3><p>어떤 명령어가 내장된 것인지 외부 디렉토리에 저장된 것인지 확인할 수 있다. 내장된 명령어는 echo, cd, pwd, set, mkdir 등이며, 외장된 명령어는 mv, date, uptime, cp 등이 있다.</p><h3 id="mkdir-디렉토리-이름">mkdir (디렉토리 이름)</h3><p>make directory. 디렉토리를 생성하는 명령어이다. 해당 명령어 뒤에 디렉토리 이름을 여러 개 넣어 한번에 여러 개의 디렉토리를 생성할 수 있다.</p><h3 id="mkdir--p-디렉토리-경로">mkdir -p (디렉토리 경로)</h3><p>mkdir에 옵션 -p가 붙으면 상하위 디렉토리를 한번에 생성할 수 있다. 예를 들어 home-user(생성필요)-data(생성필요)의 상황이라면 <code>mkdir -p /home/user/data</code>를 입력하여 user과 data를 한번에 생성할 수 있는 것이다.</p><h3 id="cd-디렉토리-경로">cd (디렉토리 경로)</h3><p>change directory. 디렉토리 변경하는 명령어이다.</p><h3 id="pwd">pwd</h3><p>print present working directory. 현재 위치한 디렉토리 경로를 프린트 한다.</p><h3 id="pushd-디렉토리-경로">pushd (디렉토리 경로)</h3><p>입력한 디렉토리를 스택 구조로 메모리에 저장한 후 해당 디렉토리로 이동한다. <code>dirs</code>를 입력하면 저장된 스택을 확인할 수 있다.</p><h3 id="popd">popd</h3><p>명령어 pushd로 저장했던 디텍토리 경로로 이동한다. 스택 구조이기에 최근에 저장했던 디렉토리로 이동한다. 웹페이지에서 뒤로가기와 같은 기능이라고 볼 수 있다.</p><h3 id="mv-현재-경로-이동할-경로">mv (현재 경로) (이동할 경로)</h3><p>파일이나 디렉토리를 이동할 때 사용한다. 참고로 이름을 변경할 때도 사용할 수 있다. 예를 들어 bird를 birds로 변경해야 한다면 <code>mv /home/user/bird /home/user/birds</code>를 입력하면 된다.</p><h3 id="cp-현재-경로-이동할-경로">cp (현재 경로) (이동할 경로)</h3><p>copy file. 현재 경로의 파일을 복사하여 이동할 경로에 붙여 넣는다.</p><h3 id="cp--r-현재-경로-이동할-경로">cp -r (현재 경로) (이동할 경로)</h3><p>copy directory. 옵션 <code>-r</code>이 붙어 디렉토리를 복사하여 붙여 넣는다.</p><h3 id="rm-파일-경로">rm (파일 경로)</h3><p>remove의 약자. 파일이나 빈 디렉토리를 삭제한다. 내용물이 든 디렉토리는 삭제가 안된다.</p><h3 id="rm--r-경로">rm -r (경로)</h3><p>옵션 <code>-r</code>이 추가되어 내용물이 든 디렉토리도 삭제할 수 있다.</p><h3 id="touch-파일-경로">touch (파일 경로)</h3><p>입력한 경로에 해당 파일을 생성해준다. 예를 들어 <code>/home/user</code> 디렉토리에 <code>id.txt</code>라는 파일을 만들어야 한다면 <code>touch /home/user/id.txt</code>로 입력하면 된다.</p><h3 id="cat-파일-경로">cat (파일 경로)</h3><p>파일의 내용을 프린트 한다. 해당 명령어는 오로지 파일의 내용물만 프린트하며, 디렉토리의 리스트는 반환하지 않는다.</p><h3 id="cat-파일-경로-1">cat &gt; (파일 경로)</h3><p><code>&gt;</code>가 추가되면 파일의 내용을 변경할 수 있다. 해당 명령어를 입력한 후, 변경할 내용을 입력하고 <code>ctrl+d</code>을 누르면 파일 내용이 변경된다. 참고로 파일 내용을 수정할 때 줄바꿈이 필요하다면 <code>shift+enter</code>를 입력하면 된다.</p><h3 id="ls">ls</h3><p>현재 위치한 디렉토리의 파일 리스트를 보여준다.</p><h3 id="ls--l">ls -l</h3><p>현재 디렉토리에 위치한 파일들의 정보(ownership과 같은)를 더 자세하게 보여준다.</p><h3 id="ls--a">ls -a</h3><p>all을 의미하는 옵션 <code>-a</code>를 붙여 현재 디렉토리의 히든파일까지 모두 보여준다.</p><h3 id="ls--lt">ls -lt</h3><p>현재 디렉토리에 위치한 파일들을 생성 시간별로 보여준다. (최근 생성파일이 상단에 나온다)</p><h3 id="ls--ltr">ls -ltr</h3><p>현재 디렉토리에 위치한 파일들을 생성 시간별로 보여준다. 다만 뒤에 붙은 옵션 <code>-r</code>이 reverse를 의미하여 최근 생성파일이 하단에 나온다.</p><h3 id="와-.."><code>.</code>와 <code>..</code></h3><p><code>.</code>은 현재 디렉토리를 나타내고 <code>..</code>은 상위 디렉토리를 나타낸다. 예를 들어 현재 <code>/home/user/</code>에 있고 <code>/home/user/data</code>를 입력하고 싶다면 <code>./data</code>로 입력할 수 있다. 또한 <code>/home/admin/data</code>을 입력해야 한다면 <code>../admin/data</code>로 쓰면 된다. 해당 기호는 디렉토리 이름이 달라 생기는 오류들을 방지할 수 있어 패키지나 모듈을 만들 때 많이 쓰인다.</p><h3 id="whatis-명령어">whatis (명령어)</h3><p>명령어에 대한 설명을 한문장으로 보여준다.</p><h3 id="man-명령어">man (명령어)</h3><p>명령어에 대한 설명을 자세하게 보여준다.</p><h3 id="apropos-키워드">apropos (키워드)</h3><p>키워드가 들어간 명령어를 찾아서 리스트업 해준다.</p>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>Linux</tag>
      
      <tag>리눅스</tag>
      
      <tag>커맨드라인</tag>
      
      <tag>명령어</tag>
      
      <tag>commandline</tag>
      
      <tag>cmd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KBO Dashboard</title>
    <link href="/ko/Web/web-0/"/>
    <url>/ko/Web/web-0/</url>
    
    <content type="html"><![CDATA[<p>이 글은 한국프로야구(Korea Baseball Organization) 대시보드를 구축할 때 사용했던 도구들을 정리합니다.</p><span id="more"></span><h2 id="시작하며">시작하며</h2><p>해당 시리즈는 데이터 스크래핑을 진행한 이후부터 설명한다. 아마도 데이터 스크래핑은 현재 패키지 작업을 하고 있기에 따로 시리즈를 만들어 글을 쓰게 될 것 같다. 또한 해당 시리즈는 웹 개발을 배워보고 싶다는 마음으로 간단하게 만든 사이드 프로젝트이다. 따라서 상업적인 목적으로 웹을 만드는 사람들은 재미로만 봐주면 될 것 같다. 완성된 대시보드는 <a href="http://kbo.lopes.co.kr">여기</a>로 접속하면 볼 수 있다.</p><p>KBO 대시보드를 만들 때 사용하는 것들을 다음과 같다.</p><ul><li>Flask</li><li>mariaDB</li><li>Dash</li><li>Bootstrap5</li><li>Plotly</li><li>AWS ec2 or lightsail</li></ul><p>위에 언급된 것들에 대해서 간단히 살펴보자.</p><h2 id="flask">Flask</h2><p>플라스크는 파이썬으로 구동되는 웹 프레임워크 중 하나이다. 상용으로 사용하는 웹 프레임워크인 장고(django)보다 가볍고 간단한 서버들도 생성할 수 있어서 데모 버전을 만드는 프로젝트에 적합하다.</p><h2 id="mariadb">mariaDB</h2><p>mySQL과 동일하게 작동하는 데이터베이스 관리 시스템이다. 무료로 사용 가능하다.</p><h2 id="dash">Dash</h2><p>대시보드를 만드는 데 특화된 파이썬 웹 프레임워크이다. html이나 css 코딩 없이 오로지 파이썬만으로 웹을 생성할 수 있다. 또한 plotly 시각화 툴을 바로 적용할 수 있다.</p><h2 id="bootstrap5">Bootstrap5</h2><p>부스스트랩은 웹페이지를 쉽게 생성할 수 있도록 도와주는 HTML, CSS, JS 프레임워크이다. 직접 디자인들을 설정하지 않고도 괜찮은 테마를 사용할 수 있으며, 스크린 사이즈(PC, 태블릿, 스마트폰)에 맞춰서 반응하는 UI를 제공한다. 플라스크와 마찬가지로 사이드 프로젝트로 간단한 웹을 만들 때 사용하기 좋다. 현재 플라스크에서 사용할 수 있는 버전은 Bootstrap3이지만 새로 나온 Bootstrap5를 써보고 싶어서 라이브러리 코드를 수정해서 사용하였다. Bootstrap5를 적용하는 방법은 이후에 설명할 것이다.</p><h2 id="plotly">Plotly</h2><p>Plotly는 파이썬으로 시각화를 할 수 있는 무료 오픈소스 그래프 라이브러리이다. 실시간으로 그래프를 확대 및 축소할 수도 있으며, 제공하는 그래프 종류도 다양하다. 그래프 종류가 궁금하다면 <a href="https://plotly.com/python/basic-charts/">해당 링크</a>를 통해서 확인할 수 있다.</p><h2 id="aws-ec2-or-lightsail">AWS ec2 or lightsail</h2><p>아마존 클라우드 서비스에서 제공하는 가상서버(ec2)를 웹 서버로 사용한다. 현재 프리 티어라서 무료로 사용하지만, 무료 기간이 끝나면 lightsail로 웹 서버를 구축할 예정이다. lightsail은 AWS에서 제공하는 가상서버이지만, ec2와 달리 월마다 가격이 정해져 있어서 비교적 저렴하다.</p>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AWS</tag>
      
      <tag>docker</tag>
      
      <tag>DB</tag>
      
      <tag>KBO</tag>
      
      <tag>analysis</tag>
      
      <tag>dashborad</tag>
      
      <tag>mariaDB</tag>
      
      <tag>flask</tag>
      
      <tag>EC2</tag>
      
      <tag>plotly</tag>
      
      <tag>dash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop과 spark 테스트하기</title>
    <link href="/ko/Hadoop/hadoop-5/"/>
    <url>/ko/Hadoop/hadoop-5/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 라즈베리파이 3개를 연결하고 하둡(Hadoop)과 스파크(spark)를 사용하여 빅데이터를 다루는 과정을 보여줍니다. <span id="more"></span></p><hr /><h2 id="hadoop-wordcount-test">Hadoop WordCount Test</h2><p>하둡에서 기본적으로 제공해주는 단어 개수 세는 맵리듀스 잡 예시가 있다. 이를 사용하여 우리가 구축한 하둡 분산시스템이 잘 작동하는지 확인해보자. 먼저 테스트에 사용할 데이터들을 가져오자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget -O alice.txt https://www.gutenberg.org/files/11/11-0.txt<br>wget -O holmes.txt https://www.gutenberg.org/files/1661/1661-0.txt<br>wget -O frankenstein.txt https://www.gutenberg.org/files/84/84-0.txt<br></code></pre></td></tr></table></figure><p>그다음 HDFS 내에 위에서 받아온 데이터들을 저장할 디렉토리를 생성해주자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hdfs dfs -<span class="hljs-built_in">mkdir</span> -p /user/pi<br>hdfs dfs -<span class="hljs-built_in">mkdir</span> books<br></code></pre></td></tr></table></figure><p>그리고 파일들을 해당 디렉토리에 넣으면 준비는 끝난다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hdfs dfs -put alice.txt holmes.txt frankenstein.txt books<br></code></pre></td></tr></table></figure><p>파일이 HDFS로 잘 들어갔는지 확인하고 싶다면 아래의 코드를 입력해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hdfs dfs -<span class="hljs-built_in">ls</span> books<br></code></pre></td></tr></table></figure><p>이제 하둡에서 제공하는 <code>jar</code>파일을 사용하여 <code>books</code>에 있는 파일들의 단어 개수를 세는 잡을 실행한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yarn jar /opt/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.2.1.jar wordcount <span class="hljs-string">&quot;books/*&quot;</span> output<br></code></pre></td></tr></table></figure><p>잡이 완료되면 <code>output</code> 폴더에 들어간 결과를 확인한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hdfs dfs -<span class="hljs-built_in">ls</span> output<br>hdfs dfs -<span class="hljs-built_in">cat</span> output/part-r-00000 | less<br></code></pre></td></tr></table></figure><h2 id="spark-piπ-value-test">Spark Pi(π) value Test</h2><p>스파크에서는 기본적으로 파이 값(3.14..)을 찾는 예제를 제공한다. 아래의 코드를 입력하여 예제를 실행해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">spark-submit --master yarn --deploy-mode cluster --class org.apache.spark.examples.SparkPi <span class="hljs-variable">$SPARK_HOME</span>/examples/jars/spark-examples_2.11-2.4.7.jar<br></code></pre></td></tr></table></figure><p>위 코드는 하둡의 yarn에서 리소스를 받아 실행하는 것이기 때문에 결과값 또한 하둡 웹 UI에서 찾아볼 수 있다. 따라서 <code>pi-master.local:8088</code>로 접속하여 실행된 잡(어플리케이션)의 로그를 클릭하면 결과값을 확인할 수 있다.</p>]]></content>
    
    
    <categories>
      
      <category>BigData</category>
      
      <category>hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>빅데이터</tag>
      
      <tag>bigdata</tag>
      
      <tag>raspberrypi</tag>
      
      <tag>cluster</tag>
      
      <tag>하둡</tag>
      
      <tag>스파크</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop 분산시스템 설정하기</title>
    <link href="/ko/Hadoop/hadoop-4/"/>
    <url>/ko/Hadoop/hadoop-4/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 라즈베리파이 3개를 연결하고 하둡(Hadoop)과 스파크(spark)를 사용하여 빅데이터를 다루는 과정을 보여줍니다. <span id="more"></span></p><hr /><h2 id="워커-노드-디렉토리-생성">워커 노드 디렉토리 생성</h2><p>이제 마스터를 제외한 다른 노드들에게도 하둡을 설치해야 한다. 마스터 노드에서 만들어둔 <code>clustercmd</code> 함수를 이용하여 한번에 작동시키자. 먼저 하둡을 설치할 디렉토리를 생성하고 권한을 위임한다,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">clustercmd <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">mkdir</span> -p /opt/hadoop_tmp/hdfs<br>clustercmd <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chown</span> pi:pi –R /opt/hadoop_tmp<br>clustercmd <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">mkdir</span> -p /opt/hadoop<br>clustercmd <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chown</span> pi:pi /opt/hadoop<br></code></pre></td></tr></table></figure><h2 id="hadoop-configration-수정">Hadoop Configration 수정</h2><p>분산시스템을 적용하기 위해서는 몇 가지 값들을 수정해주어야 한다. 먼저 파일이 존재하는 디렉토리로 이동하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /opt/hadoop/etc/hadoop<br></code></pre></td></tr></table></figure><p>우리가 수정할 파일은 다음과 같다.</p><ul><li>core-site.xml</li><li>hdfs-site.xml</li><li>mapred-site.xml</li><li>yarn-site.xml</li></ul><p>위의 파일들을 들어가서 하나씩 변경해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 접속</span><br>vim core-site.xml<br><br><span class="hljs-comment"># 입력</span><br>&lt;property&gt;<br>    &lt;name&gt;fs.default.name&lt;/name&gt;<br>    &lt;value&gt;hdfs://master:9000&lt;/value&gt;<br>&lt;/property&gt;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 접속</span><br>vim hdfs-site.xml<br><br><span class="hljs-comment"># 입력</span><br>&lt;property&gt;<br>    &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;<br>    &lt;value&gt;/opt/hadoop_tmp/hdfs/datanode&lt;/value&gt;<br>&lt;/property&gt;<br>&lt;property&gt;<br>    &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;<br>    &lt;value&gt;/opt/hadoop_tmp/hdfs/namenode&lt;/value&gt;<br>&lt;/property&gt;<br>&lt;property&gt;<br>    &lt;name&gt;dfs.replication&lt;/name&gt;<br>    &lt;value&gt;2&lt;/value&gt;<br>&lt;/property&gt;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 접속</span><br>vim mapred-site.xml<br><br><span class="hljs-comment"># 입력</span><br>&lt;property&gt;<br>        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;<br>        &lt;value&gt;yarn&lt;/value&gt;<br>&lt;/property&gt;<br>&lt;property&gt;<br>        &lt;name&gt;yarn.app.mapreduce.am.env&lt;/name&gt;<br>        &lt;value&gt;HADOOP_MAPRED_HOME=<span class="hljs-variable">$HADOOP_HOME</span>&lt;/value&gt;<br>&lt;/property&gt;<br>&lt;property&gt;<br>        &lt;name&gt;mapreduce.map.env&lt;/name&gt;<br>        &lt;value&gt;HADOOP_MAPRED_HOME=<span class="hljs-variable">$HADOOP_HOME</span>&lt;/value&gt;<br>&lt;/property&gt;<br>&lt;property&gt;<br>        &lt;name&gt;mapreduce.reduce.env&lt;/name&gt;<br>        &lt;value&gt;HADOOP_MAPRED_HOME=<span class="hljs-variable">$HADOOP_HOME</span>&lt;/value&gt;<br>&lt;/property&gt;<br>&lt;property&gt;<br>        &lt;name&gt;yarn.app.mapreduce.am.resource.memory-mb&lt;/name&gt;<br>        &lt;value&gt;512&lt;/value&gt;<br>&lt;/property&gt;<br>&lt;property&gt;<br>        &lt;name&gt;mapreduce.map.resource.memory-mb&lt;/name&gt;<br>        &lt;value&gt;256&lt;/value&gt;<br>&lt;/property&gt;<br>&lt;property&gt;<br>        &lt;name&gt;mapreduce.reduce.resource.memory-mb&lt;/name&gt;<br>        &lt;value&gt;256&lt;/value&gt;<br>&lt;/property&gt;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 접속</span><br>vim yarn-site.xml<br><br><span class="hljs-comment"># 입력</span><br>&lt;property&gt;<br>        &lt;name&gt;yarn.acl.enable&lt;/name&gt;<br>        &lt;value&gt;0&lt;/value&gt;<br>&lt;/property&gt;<br>&lt;property&gt;<br>        &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;<br>        &lt;value&gt;master&lt;/value&gt;<br>&lt;/property&gt;<br>&lt;property&gt;<br>        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;<br>        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;<br>&lt;/property&gt;<br>&lt;property&gt;<br>        &lt;name&gt;yarn.nodemanager.resource.memory-mb&lt;/name&gt;<br>        &lt;value&gt;3072&lt;/value&gt;<br>&lt;/property&gt;<br>&lt;property&gt;<br>        &lt;name&gt;yarn.scheduler.maximum-allocation-mb&lt;/name&gt;<br>        &lt;value&gt;3072&lt;/value&gt;<br>&lt;/property&gt;<br>&lt;property&gt;<br>        &lt;name&gt;yarn.scheduler.minimum-allocation-mb&lt;/name&gt;<br>        &lt;value&gt;256&lt;/value&gt;<br>&lt;/property&gt;<br>&lt;property&gt;<br>        &lt;name&gt;yarn.nodemanager.vmem-check-enabled&lt;/name&gt;<br>        &lt;value&gt;<span class="hljs-literal">false</span>&lt;/value&gt;<br>&lt;/property&gt;<br></code></pre></td></tr></table></figure><h2 id="워커-노드-configration-수정">워커 노드 Configration 수정</h2><p>마스터에서만 다운로드 했던 하둡 파일들을 워커에서 생성해둔 디렉토리로 보내준다. 이때 보내는 파일들은 위에서 수정한 configration이 적용된 상태이다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> pi <span class="hljs-keyword">in</span> $(otherpis); <span class="hljs-keyword">do</span> rsync –avxP <span class="hljs-variable">$HADOOP_HOME</span> <span class="hljs-variable">$pi</span>:/opt/; <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>복사가 끝나면 네임노드와 데이터노드를 초기화한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">clustercmd <span class="hljs-built_in">rm</span> –rf /opt/hadoop_tmp/hdfs/datanode/*<br>clustercmd <span class="hljs-built_in">rm</span> –rf /opt/hadoop_tmp/hdfs/namenode/*<br></code></pre></td></tr></table></figure><h2 id="마스터-정보-변경-및-클러스터-재부팅">마스터 정보 변경 및 클러스터 재부팅</h2><p>모두 완료되었다면 마스터 노드에서만 아래의 작업을 해준다.</p><ul><li>master 정보 생성</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 접속</span><br>vim /opt/hadoop/etc/hadoop/master<br><br><span class="hljs-comment"># 입력</span><br>pi-master<br></code></pre></td></tr></table></figure><ul><li>worker 정보 생성</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 접속</span><br>vim /opt/hadoop/etc/hadoop/worker<br><br><span class="hljs-comment"># 입력</span><br>pi-slave1<br>pi-slave2<br></code></pre></td></tr></table></figure><p>마스터에서 클러스터 정보 셋팅이 끝나면 마지막으로 워커 노드들에게도 하둡 환경설정 파일을 복사해준 후 적용시킨다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">clusterscp ~/.bashrc<br>clustercmd <span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure><p>적용이 안된 설정들이 있을 수 있으니 클러스터를 리부트하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">clusterreboot<br></code></pre></td></tr></table></figure><h2 id="hadoop-분산시스템-실행하기">Hadoop 분산시스템 실행하기</h2><p>클러스터 재부팅이 끝나면 하둡을 실행해보자. 아래의 코드를 마스터 노드에 입력하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hdfs namenode -format<br>start-dfs.sh &amp;&amp; start-yarn.sh<br></code></pre></td></tr></table></figure><p>위 명령어는 HDFS의 네임노드를 포맷하여 메타데이터들을 날려주고(만약 데이터노드와 맞지 않으면 에러가 발생한다), 하둡을 실행한 것이다. 각 노드마다 어떤 서비스들이 올라왔는지 알고 싶다면 아래의 코드를 입력하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jps<br></code></pre></td></tr></table></figure><p><code>jps</code>는 JVM Process Status tool로 자바 가상머신에 올라간 프로세스들의 목록을 보여준다. 또 분산시스템 정보를 한번에 보고 싶다면 아래의 코드를 입력해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">yarn node –list<br>hadoop dfsadmin -report<br></code></pre></td></tr></table></figure><p>다음 글에서는 하둡과 스파크에서 기본적으로 제공하는 테스트들을 실행해보자.</p>]]></content>
    
    
    <categories>
      
      <category>BigData</category>
      
      <category>hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>빅데이터</tag>
      
      <tag>bigdata</tag>
      
      <tag>raspberrypi</tag>
      
      <tag>cluster</tag>
      
      <tag>하둡</tag>
      
      <tag>스파크</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop &amp; Spark 설치하기</title>
    <link href="/ko/Hadoop/hadoop-3/"/>
    <url>/ko/Hadoop/hadoop-3/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 라즈베리파이 3개를 연결하고 하둡(Hadoop)과 스파크(spark)를 사용하여 빅데이터를 다루는 과정을 보여줍니다. <span id="more"></span></p><hr /><p>이번 글에서는 마스터 라즈베리 파이에서 하둡과 스파크를 다운받은 후 클러스터링을 진행할 것이다. 먼저 마스터로 지정한 라즈베리 파이에 접속한 후 아래의 순서대로 진행하자.</p><h2 id="hadoop-3.2.1-다운로드">Hadoop 3.2.1 다운로드</h2><p>먼저 아래의 코드를 입력하여 하둡을 다운받고 압축을 풀어준다. (마스터에서만 진행한다.)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 다운</span><br>wget https://downloads.apache.org/hadoop/common/hadoop-3.2.1/hadoop-3.2.1.tar.gz<br><br><span class="hljs-comment"># 압축 해제</span><br><span class="hljs-built_in">sudo</span> tar -xvf hadoop-3.2.1.tar.gz -C /opt/<br></code></pre></td></tr></table></figure><p>그 다음 압축 해제된 파일을 <code>/opt/hadoop</code>으로 옮긴 후, 해당 디렉토리의 권한을 변경한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> opt<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">mv</span> hadoop-3.2.1 hadoop<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chown</span> pi:pi -R /opt/hadoop<br></code></pre></td></tr></table></figure><p>각각의 실행파일들의 경로를 지정해야 한다. <code>~/.bashrc</code>에 들어가서 아래의 코드를 <strong>가장 윗부분</strong>에 붙여넣는다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> JAVA_HOME=$(<span class="hljs-built_in">readlink</span> –f /usr/bin/java | sed <span class="hljs-string">&quot;s:bin/java::&quot;</span>)<br><span class="hljs-built_in">export</span> HADOOP_HOME=/opt/hadoop<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HADOOP_HOME</span>/bin:<span class="hljs-variable">$HADOOP_HOME</span>/sbin<br><br><span class="hljs-built_in">export</span> HADOOP_INSTALL=<span class="hljs-variable">$HADOOP_HOME</span><br><span class="hljs-built_in">export</span> HADOOP_MAPRED_HOME=<span class="hljs-variable">$HADOOP_HOME</span><br><span class="hljs-built_in">export</span> HADOOP_COMMON_HOME=<span class="hljs-variable">$HADOOP_HOME</span><br><span class="hljs-built_in">export</span> HADOOP_HDFS_HOME=<span class="hljs-variable">$HADOOP_HOME</span><br><span class="hljs-built_in">export</span> HADOOP_INSTALL=<span class="hljs-variable">$HADOOP_HOME</span><br><span class="hljs-built_in">export</span> YARN_HOME=<span class="hljs-variable">$HADOOP_HOME</span><br><span class="hljs-built_in">export</span> HADOOP_COMMON_LIB_NATIVE_DIR=<span class="hljs-variable">$HADOOP_HOME</span>/lib/native<br><span class="hljs-built_in">export</span> HADOOP_CONF_DIR=<span class="hljs-variable">$HADOOP_HOME</span>/etc/hadoop<br><span class="hljs-built_in">export</span> HADOOP_OPTS=<span class="hljs-string">&quot;-Djava.library.path=<span class="hljs-variable">$HADOOP_HOME</span>/lib/native&quot;</span><br></code></pre></td></tr></table></figure><p>그 다음 해당 변경사항을 적용하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure><p>마지막으로 하둡 환경설정에도 자바 경로를 입력한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /opt/hadoop/etc/hadoop/hadoop-env.sh<br></code></pre></td></tr></table></figure><p>위 경로에 있는 스크립트 파일에서 아래의 코드를 추가해준다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> JAVA_HOME=$(<span class="hljs-built_in">readlink</span> –f /usr/bin/java | sed <span class="hljs-string">&quot;s:bin/java::&quot;</span>)<br></code></pre></td></tr></table></figure><p>다 끝난 후 아래의 명령어로 하둡이 잘 설치되었는지 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop version | grep Hadoop<br></code></pre></td></tr></table></figure><h2 id="spark-2.4.7-다운로드">Spark 2.4.7 다운로드</h2><p>Sparkd도 Hadoop과 동일하게 진행하면 된다. 먼저 스파크를 다운받고 압축을 푼다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 다운</span><br>wget https://downloads.apache.org/spark/spark-2.4.7/spark-2.4.7-bin-hadoop2.7.tgz<br><br><span class="hljs-comment"># 압축 해제</span><br><span class="hljs-built_in">sudo</span> tar -xvf spark-2.4.7-bin-hadoop2.7.tgz -C /opt/<br></code></pre></td></tr></table></figure><p>그 다음 압축 해제된 파일을 <code>/opt/spark</code>으로 옮긴 후, 해당 디렉토리의 권한을 변경한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> opt<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">mv</span> spark-2.4.7-bin-hadoop2.7 spark<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chown</span> pi:pi -R /opt/spark<br></code></pre></td></tr></table></figure><p>하둡과 동일하게 각각의 실행파일들의 경로를 지정해야 한다. <code>~/.bashrc</code>에 들어가서 아래의 코드를 붙여넣는다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> SPARK_HOME=/opt/spark<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$SPARK_HOME</span>/bin<br><span class="hljs-built_in">export</span> YARN_CONF_DIR=<span class="hljs-variable">$HADOOP_HOME</span>/etc/hadoop<br></code></pre></td></tr></table></figure><p>변경사항을 적용해준 뒤 스파크가 잘 작동하는지 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc<br>spark-shell --version<br></code></pre></td></tr></table></figure><p>이렇게 하둡과 스파크 설치는 끝났다. 다음 글에서는 분산처리 설정하는 방법에 대해서 살펴볼 것이다.</p>]]></content>
    
    
    <categories>
      
      <category>BigData</category>
      
      <category>hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>빅데이터</tag>
      
      <tag>bigdata</tag>
      
      <tag>raspberrypi</tag>
      
      <tag>cluster</tag>
      
      <tag>하둡</tag>
      
      <tag>스파크</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Raspberry Pi SSH 셋팅하기</title>
    <link href="/ko/Hadoop/hadoop-2/"/>
    <url>/ko/Hadoop/hadoop-2/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 라즈베리파이 3개를 연결하고 하둡(Hadoop)과 스파크(spark)를 사용하여 빅데이터를 다루는 과정을 보여줍니다. <span id="more"></span></p><hr /><p>이번 글에서는 마스터에서 슬레이브 컴퓨터에 바로 접속할 수 있도록 SSH를 설정할 것이다. 이 과정을 해두면 나중에 훨씬 편리하다. 또한 이 과정부터 클러스터링 과정이라고 볼 수 있다.</p><ul><li>Static IP Addresses 셋팅하기</li><li>hosts와 hostname 변경하기</li><li>SSH 활성화 및 연결하기</li><li>공개키/개인키 생성하여 복제하기</li><li>클러스터 관리 함수 만들기</li></ul><p>기술적인 부분에 들어가기 앞서 클러스터와 마스터/슬레이브 개념에 대해서 간단하게 살펴보자.</p><h2 id="클러스터란">클러스터란</h2><p>클러스터(컴퓨터 클러스터)는 컴퓨터 여러 대가 연결되어 하나의 컴퓨터처럼 작동되는 시스템이다. 좀 더 자세하게 설명한다면 각각의 OS를 가진 여러 대의 컴퓨터가 분산 컴퓨팅 프로그램에 의해서 하나의 컴퓨터가 여러 대의 컴퓨터를 통제하여 사용할 수 있는 것이다. 위 정의에서 여러 대의 컴퓨터를 통제하는 하나의 컴퓨터를 '마스터'라고 하며, 그외 통제 당하는 컴퓨터를 '슬레이브'라고 지칭한다. 해당 프로젝트에서는 라즈베리 파이 3개를 사용하므로 마스터 1개 슬레이브 2개로 구성된다.</p><h2 id="클러스터-셋팅하기">클러스터 셋팅하기</h2><p>본격적으로 클러스터를 셋팅해보자. 지금부터 진행하는 과정은 연결할 모든 라즈베리 파이에서 진행해야 한다. 먼저 라즈베리 파이에 접속한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh pi@raspberrypi.local<br></code></pre></td></tr></table></figure><h3 id="static-ip-addresses-셋팅하기">Static IP Addresses 셋팅하기</h3><p>그 다음으로는 네트워킹을 더 편하게 하기 위해 라우터에서 할당하는 IP를 지정하여 각각의 라즈베리 파이의 고정 IP 주소로 설정한다. 그 방법은 각각의 라즈베리 파이에서 <code>/etc/dhcpcd.conf</code>에 접속하여 <code>static_ip_address</code>를 수정하면 된다. 만약 에디터가 없다면 아래의 코드를 입력하여 <code>vim</code>을 설치하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt-get install vim<br></code></pre></td></tr></table></figure><p>그 다음 명령어 <code>cd</code>를 이용해 <code>etc</code> 디렉토리로 접속한 후, <code>dhcpcd.conf</code> 파일을 오픈한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> etc<br>vim dhcpcd.conf<br></code></pre></td></tr></table></figure><p>마지막으로 아래의 부분을 수정한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">interface eth0<br>static_ip_address = 192.168.0.0x/24<br></code></pre></td></tr></table></figure><p>고정 IP 주소는 현재 라즈베리 파이가 연결되어 있는 라우터에서 제공되는 것을 그대로 사용하면 된다. 라우터에서 제공하는 IP는 사용하는 기계마다 다르기 때문에 만약 해당 라즈베리 파이의 IP를 모른다면 아래의 명령어를 입력하여 확인한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ifconfig<br></code></pre></td></tr></table></figure><p>또한 vim을 사용하는 방법은 <code>I</code>를 누르면 INSERT 모드로 변경되고, 변경할 부분을 수정한 다음 <code>esc</code>키를 누른다. 그 다음 <code>:w</code>를 입력하면 변경사항이 저장되고 <code>:q</code>을 입력하여 파일에서 나오면 수정이 완료된 것이다.</p><h3 id="hosts와-hostname-변경하기">hosts와 hostname 변경하기</h3><p>다음으로 변경해야 할 것은 <code>etc</code>에 속해있는 <code>hosts</code>와 <code>hostname</code>이다. 여기서 각각의 라즈베리 파이의 이름을 설정할 수 있다. 이 프로젝트에서는 pi-master, pi-slave1, pi-slave2 을 각각의 이름으로 사용한다.</p><p><code>hostname</code>파일에는 해당 라즈베리 파이의 초기 셋팅된 이름이 들어있다. 따라서 해당 라즈베리 파이를 어떻게 사용할 것인지 정했다면 그에 맞게 이름을 변경한다. 예를 들어 마스터로 쓰는 라즈베리 파이의 경우 <code>hostname</code>파일의 내용을 "pi-master"로 변경해야 하고, 나머지 라즈베리 파이들도 각각 "pi-slave1", "pi-slave2"로 변경해주면 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /etc<br>vim hostname<br></code></pre></td></tr></table></figure><p>그 다음 <code>hosts</code>에 들어가서 각각의 고정 IP 주소와 변경한 이름들을 추가하여 저장한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim hosts<br></code></pre></td></tr></table></figure><p>위 코드를 입력하면 <code>hosts</code>파일이 열리고 해당 파일에 아래의 내용을 추가한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">192.168.0.0x pi-master<br>192.168.0.0x pi-slave1<br>192.168.0.0x pi-slave2<br></code></pre></td></tr></table></figure><h3 id="ssh-활성화-및-연결하기">SSH 활성화 및 연결하기</h3><p>그 다음은 ssh키를 활성화해야 한다. 각각의 라즈베리 파이에 아래의 코드를 입력하여 ssh를 활성화하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl <span class="hljs-built_in">enable</span> ssh<br><span class="hljs-built_in">sudo</span> systemctl start ssh<br></code></pre></td></tr></table></figure><p>이제 활성화된 컴퓨터에 서로의 이름만으로 접속하기 위해서는 <code>~/.ssh/config</code> 을 생성하여 각 정보를 저장해야 한다. 먼저 <code>.ssh</code> 디렉토리를 생성하고 <code>config</code> 파일을 만들자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/<br><span class="hljs-built_in">mkdir</span> .ssh<br><span class="hljs-built_in">cd</span> ~/.ssh<br><span class="hljs-built_in">touch</span> config<br></code></pre></td></tr></table></figure><p>위 코드로 디렉토리와 파일이 생성되었다면, 아래의 코드를 입력하여 정보를 입력하면 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">Host 변경한 이름<br>User pi<br>Hostname 해당 이름의 고정 IP<br></code></pre></td></tr></table></figure><p>여기서 중요한 것은 마스터인 경우 슬레이브들의 정보도 모두 입력해야 한다는 것이다. 슬레이브들은 본인의 정보만 저장하면 되지만, 마스터는 모두 가지고 있어야 한다. 예시는 아래와 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># pi-master의 config</span><br>Host pi-master<br>User pi<br>Hostname 해당 이름의 고정 IP<br><br>Host pi-slave1<br>User pi<br>Hostname 해당 이름의 고정 IP<br><br>Host pi-slave2<br>User pi<br>Hostname 해당 이름의 고정 IP<br></code></pre></td></tr></table></figure><p>이렇게 설정하면 ssh 활성화 및 연결이 완료된다.</p><h3 id="공개키개인키-생성하여-복제하기">공개키/개인키 생성하여 복제하기</h3><p>이름으로 편하게 들어갈 수 있지만 아직까지는 비밀번호를 입력해야 한다. 만약 슬레이브 100개를 관리한다면 비밀번호를 매번 입력하는 것은 매우 번거로울 것이다. 공개키와 개인키를 만들어 사용하면 ssh에서 비밀번호 없이 로그인할 수 있다. 따라서 우리는 공개키/개인키를 설정하여 이름만 입력하면 슬레이브에 바로 접속할 수 있도록 해줄 것이다. 과정은 다음과 같다.</p><ul><li>각 라즈베리 파이에서 아래의 코드를 입력하여 공개키와 개인키를 생성한다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen –t ed25519<br></code></pre></td></tr></table></figure><ul><li>슬레이브에서 아래의 코드를 입력하여 슬레이브의 공개키들을 마스터 컴퓨터의 <code>~/.ssh/authorized_keys</code>에 복사한다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> ~/.ssh/id_ed25519.pub | ssh pi@&lt;마스터 고정 IP&gt; <span class="hljs-string">&#x27;cat &gt;&gt; .ssh/authorized_keys&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>마찬가지로 마스터의 공개키도 <code>authorized_keys</code>에 복사한다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> .ssh/id_ed25519.pub &gt;&gt; .ssh/authorized_keys<br></code></pre></td></tr></table></figure><p>위 과정을 완료하면 마스터에서는 비밀번호 입력 없이 아래의 코드만을 사용하여 슬레이브에 접속할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh pi-slave1<br>ssh pi-slave2<br></code></pre></td></tr></table></figure><p>만약 모든 라즈베리 파이에서 이와 같이 접속하고 싶다면 만든 파일들을 슬레이브에 복사하면 된다. 아래의 코드를 마스터에서 입력하면 복사된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">scp ~/.ssh/authorized_keys &lt;슬레이브 이름&gt;:~/.ssh/authorized_keys<br>scp ~/.ssh/config &lt;슬레이브 이름&gt;:~/.ssh/config<br></code></pre></td></tr></table></figure><h3 id="클러스터-로그인-함수-만들기">클러스터 로그인 함수 만들기</h3><p>만약 연결하는 슬레이브가 100개라면 매번 이름을 입력하는 것도 번거로운 일이다. 따라서 모든 슬레이브에 접속하는 함수를 만들어 사용할 것이다. 이렇게 하면 슬레이브에 일괄적으로 접속해야 하는 일들을 한번에 처리할 수 있다. 따라서 아래의 함수들은 마스터에만 저장되어 있으면 된다.</p><p>함수를 사용하려면 아래의 코드들을 <code>~/.bashrc</code> 파일 끝에 추가하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> otherpis &#123;<br>  grep <span class="hljs-string">&quot;pi&quot;</span> /etc/hosts | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> | grep -v $(hostname)<br>&#125;<br></code></pre></td></tr></table></figure><p>위 함수는 마스터를 제외한 슬레이브의 이름들을 반환해준다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> clustercmd &#123;<br>  <span class="hljs-keyword">for</span> pi <span class="hljs-keyword">in</span> $(otherpis); <span class="hljs-keyword">do</span> ssh <span class="hljs-variable">$pi</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>; <span class="hljs-keyword">done</span><br>  <span class="hljs-variable">$@</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>clustercmd</code>는 각각 슬레이브에 바로 접속해준다. 이 함수 뒤에 코드를 입력하면 해당 코드가 슬레이브 모두에 적용된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> clusterreboot &#123;<br>  clustercmd <span class="hljs-built_in">sudo</span> shutdown -r now<br>&#125;<br><br><span class="hljs-keyword">function</span> clustershutdown &#123;<br>  clustercmd <span class="hljs-built_in">sudo</span> shutdown now<br>&#125;<br><br><span class="hljs-keyword">function</span> clusterscp &#123;<br>  <span class="hljs-keyword">for</span> pi <span class="hljs-keyword">in</span> $(otherpis); <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">cat</span> <span class="hljs-variable">$1</span> | ssh <span class="hljs-variable">$pi</span> <span class="hljs-string">&quot;sudo tee <span class="hljs-variable">$1</span>&quot;</span> &gt; /dev/null 2&gt;&amp;1<br>  <span class="hljs-keyword">done</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>clusterreboot</code>는 모든 슬레이브들을 일괄적으로 종료한 후 재부팅해주며, <code>clustershutdown</code>는 모든 슬레이브를 종료한다. 또한 <code>clusterscp</code>은 원하는 파일을 슬레이브에 복사한다.</p><p>마지막으로 아래의 코드를 입력하여 변경사항을 저장하고 슬레이브에도 해당 파일을 복사한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc &amp;&amp; clusterscp ~/.bashrc<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>BigData</category>
      
      <category>hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>빅데이터</tag>
      
      <tag>bigdata</tag>
      
      <tag>raspberrypi</tag>
      
      <tag>cluster</tag>
      
      <tag>하둡</tag>
      
      <tag>스파크</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mariaDB 그룹핑과 연산 명령어 모음</title>
    <link href="/ko/Sql/sql-4/"/>
    <url>/ko/Sql/sql-4/</url>
    
    <content type="html"><![CDATA[<p>mariaDB에서 그룹핑을 하는 명령어 GROUP BY과 수학 연산을 처리해주는 다양한 명령어들의 사용법을 정리합니다. <span id="more"></span></p><hr /><h2 id="부분-문자열-찾기">부분 문자열 찾기</h2><p>만약 특정 열에서 값 일부만 얻고 싶을 때에는 어떻게 해야할까? 바로 <code>LEFT()</code>와 <code>RIGHT()</code>를 사용하면 된다. 두 함수는 특정 열에서 값 일부만을 반환해준다.</p><p>먼저 <code>LEFT()</code>는 왼쪽을 기준으로 작동한다. 아래의 코드를 확인해보자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">LEFT</span>(<span class="hljs-string">&#x27;특정 열&#x27;</span>, <span class="hljs-string">&#x27;반환할 문자열 갯수&#x27;</span>) <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span>;<br></code></pre></td></tr></table></figure><p>위 코드는 왼쪽을 기준으로 특정 열의 값들을 입력한 문자열 갯수만큼을 반환해준다. <code>RIGHT()</code>도 원리는 동일하지만 기준점이 오른쪽이다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">RIGHT</span>(<span class="hljs-string">&#x27;특정 열&#x27;</span>, <span class="hljs-string">&#x27;반환할 문자열 갯수&#x27;</span>) <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="특정-패턴으로-문자열-찾기">특정 패턴으로 문자열 찾기</h2><p>만약 특정 열의 값이 콤마로 나눠져 있는 등의 측정 패턴으로 분리가 가능하다면 함수 <code>SUBSTRING_INDEX()</code>를 사용하면 된다. 해당 함수의 사용법은 아래와 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> SUBSTRING_INDEX(<span class="hljs-string">&#x27;특정 열&#x27;</span>,<span class="hljs-string">&#x27;기준점&#x27;</span>, <span class="hljs-string">&#x27;반환할 데이터 갯수&#x27;</span>) <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span>;<br></code></pre></td></tr></table></figure><p>위 코드는 특정 열의 값들을 기준점을 기준으로 나눈 후에 앞에서부터 입력한 갯수만큼을 반환한다.</p><h2 id="기존의-열의-값을-변경하기">기존의 열의 값을 변경하기</h2><p>기존에 있던 하나의 열을 2개로 분리한다고 가정해보자. 그러면 1. 새로운 열을 만들고 2. 기존의 열에 있던 값들 중 일부를 분리한 후에 3. 새로운 열에 넣으면 된다. 1,2 번 과정은 배웠기 때문에 3번을 살펴볼 것이다.</p><p>기존의 열값의 일부로 새로운 열을 채우는 방법은 다음과 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br><span class="hljs-keyword">SET</span> <span class="hljs-string">&#x27;새로운 열 이름&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">RIGHT</span>(<span class="hljs-string">&#x27;기존의 열 이름&#x27;</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>위 코드는 새로운 열을 기존 열의 일부로 채운다. 여기서 말하는 기존 열의 일부는 오른쪽에서 2개의 문자열이다. 이렇게 하면 특정 열이 원자적 데이터로 구성되지 않은 경우라도 테이블을 삭제하지 않고 원자적 데이터 형태로 수정할 수 있다.</p><h2 id="조건문-명령어-case">조건문 명령어 CASE</h2><p>만약 특정 열을 다른 열의 값에 따라서 따라서 다르게 변경하고 싶다면 어떻게 해야할까? 그럴 때는 명령어 <code>CASE</code>를 사용하면 된다.</p><p>명령어 <code>CASE</code>는 조건을 여러 개 설정하여 그에 따라 값을 변경할 수 있도록 해준다. 예를 들어 생각해보자.</p><p>만약 '성별' 카테고리에 'M'의 값이 들어있다면 '한글' 카테고리의 값을 '남성'으로 변경하고, 'F'가 들어있다면 '여성'으로 변경해야 한다고 가정하자.</p><p>그러면 명령어 <code>CASE</code>를 아래와 같이 사용할 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br>    <span class="hljs-keyword">SET</span> 한글 <span class="hljs-operator">=</span><br>        <span class="hljs-keyword">CASE</span><br>            <span class="hljs-keyword">WHEN</span> 성별 <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;M&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;남성&#x27;</span><br>            <span class="hljs-keyword">WHEN</span> 성별 <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;F&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;여성&#x27;</span><br>            <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;알 수 없음&#x27;</span><br>        <span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><p><code>ELSE</code>는 어떤 것에도 속하지 않는 경우에 뒤의 값을 넣어준다.</p><p>참고로 조건문 명령어인 <code>CASE</code>는 <code>INSERT</code>, <code>DELETE</code>에서도 사용할 수 있다.</p><h2 id="데이터-정렬하기">데이터 정렬하기</h2><p>만약 특정 열의 값 알파벳 순서를 기준으로 정렬하고 싶다고 생각해보자. 보통 열의 순서는 입력된 시간 순으로 되어 있다. 이럴 때 명령어 <code>ORDER BY</code>를 사용한다. 사용법은 다음과 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br>    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;기준 열 이름&#x27;</span>;<br></code></pre></td></tr></table></figure><p>위 코드에서 사용한 '기준 열'은 순서를 변경하는데 사용할 값들을 지정한 것이다. 따라서 해당 명령을 입력했을 시 다른 열들의 순서는 알파벳 순서가 아닐 수 있으며, 오로지 기준 열을 기준으로 정렬된다.</p><p>그렇다면 명령어 <code>ORDER BY</code>는 어떤 순서로 정렬할까?</p><p>실험 결과 명령어 <code>ORDER BY</code>의 순서는 기호 - 숫자 - 알파벳이고, 알파벳의 경우 대소문자 구분을 하지 않는다.</p><h2 id="여러-열로-정렬하기">여러 열로 정렬하기</h2><p>만약에 하나의 열이 아니라 여러 개의 열을 기준으로 정리하고 싶다면 어떻게 쿼리를 보내야할까? 예를 들어서 '카테고리 1'을 가장 큰 기준으로 정렬하고 이후 세부적으로는 '카테고리 2'의 알파벳 순으로 정렬하고 싶다고 가정해보자.</p><p>그러면 아래와 같이 쿼리를 보내면 된다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br>    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;카테고리 1&#x27;</span>, <span class="hljs-string">&#x27;카테고리 2&#x27;</span>;<br></code></pre></td></tr></table></figure><p>위 코드는 첫 번째로 오는 열인 '카테고리 1'를 기준으로 레코드 순서를 정렬한다. 그 다음 '카테고리 1'순으로 정렬했을 때 겹치는 데이터들을 두 번째로 오는 '카테고리 2'을 기준으로 정렬한다.</p><h2 id="역순으로-정렬하기">역순으로 정렬하기</h2><p>오름차순이 아니라 내림차순으로 정렬하고 싶을 때는 명령어 <code>DESC</code>를 <code>ORDER BY</code>에 오든 열 이름 뒤에 붙여주면 된다. 쿼리를 확인해보자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br>    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;카테고리 1&#x27;</span>, <span class="hljs-string">&#x27;카테고리 2&#x27;</span> <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><p>위의 쿼리는 '카테고리 1'는 알파벳 순서대로 정렬하고 같은 '카테고리 1'안의 데이터들은 '카테고리 2' 역순으로 정렬하라고 명령한다. 그 결과는 다음과 같다.</p><p>만약 정렬하는 모든 열들을 내림차순으로 하고싶다면 어떻게 해야할까? 아래의 쿼리를 참고하자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br>    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;카테고리 1&#x27;</span> <span class="hljs-keyword">DESC</span>, <span class="hljs-string">&#x27;카테고리 2&#x27;</span> <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><h2 id="덧셈-명령어-sum">덧셈 명령어 SUM</h2><p>먼저 더하는 방법이다. 코드는 다음과 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(<span class="hljs-string">&#x27;더하는 열 이름&#x27;</span>) <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span>;<br></code></pre></td></tr></table></figure><p>위 코드는 지정할 열의 모든 값을 더해서 반환한다. 만약 어떤 조건을 추가하고 싶다면 <code>WHERE</code>을 사용할 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(<span class="hljs-string">&#x27;더하는 열 이름&#x27;</span>) <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br>    <span class="hljs-keyword">WHERE</span> <span class="hljs-string">&#x27;조건에 사용할 카테고리&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;조건&#x27;</span>;<br></code></pre></td></tr></table></figure><p>만약 조건으로 사용할 카테고리의 모든 값들을 기준으로 결과값을 받고 싶을 때는 어떻게 해야할까? 위 코드를 해당 조건 갯수만큼 쿼리로 보낼 수도 있을 것이다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(<span class="hljs-string">&#x27;더하는 열 이름&#x27;</span>) <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br>    <span class="hljs-keyword">WHERE</span> <span class="hljs-string">&#x27;조건에 사용할 카테고리&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;조건 1&#x27;</span>;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(<span class="hljs-string">&#x27;더하는 열 이름&#x27;</span>) <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br>    <span class="hljs-keyword">WHERE</span> <span class="hljs-string">&#x27;조건에 사용할 카테고리&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;조건 2&#x27;</span>;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(<span class="hljs-string">&#x27;더하는 열 이름&#x27;</span>) <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br>    <span class="hljs-keyword">WHERE</span> <span class="hljs-string">&#x27;조건에 사용할 카테고리&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;조건 3&#x27;</span>;<br>.<br>.<br>.<br></code></pre></td></tr></table></figure><p>하지만 이 방법은 너무 비효율적이다. 이럴 때는 명령어 <code>GROUP BY</code>를 사용해주면 한번에 결과를 받을 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;조건에 사용할 카테고리&#x27;</span> ,<span class="hljs-built_in">SUM</span>(<span class="hljs-string">&#x27;더하는 열 이름&#x27;</span>) <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span><span class="hljs-string">&#x27;조건에 사용할 카테고리&#x27;</span>;<br></code></pre></td></tr></table></figure><p>만약 그룹 단위로 조건을 걸고 싶다면 <code>WHERE</code> 대신에 <code>HAVING</code>을 사용하면 된다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;조건에 사용할 카테고리&#x27;</span> ,<span class="hljs-built_in">SUM</span>(<span class="hljs-string">&#x27;더하는 열 이름&#x27;</span>) <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span><span class="hljs-string">&#x27;조건에 사용할 카테고리&#x27;</span> <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-string">&#x27;조건에 사용할 카테고리&#x27;</span>) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;조건&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="평균-명렁어-avg">평균 명렁어 AVG</h2><p>명령어 <code>AVG</code>는 평균을 구해준다. 즉, <code>SUM</code>과 사용방법은 동일하지만 더하는 것이 아니라 평균을 구해주는 것이다. 사용법은 다음과 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(<span class="hljs-string">&#x27;더하는 열 이름&#x27;</span>) <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br>    <span class="hljs-keyword">WHERE</span> <span class="hljs-string">&#x27;조건에 사용할 카테고리&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;조건&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="min과-max">MIN과 MAX</h2><p>최솟값을 구해주는 명령어 <code>MIN</code>과 최댓값을 구해주는 명령어인 <code>MAX</code>도 위의 연산 명령어들과 동일하다. 사용법은 다음과 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(<span class="hljs-string">&#x27;더하는 열 이름&#x27;</span>) <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br>    <span class="hljs-keyword">WHERE</span> <span class="hljs-string">&#x27;조건에 사용할 카테고리&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;조건&#x27;</span>;<br><br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(<span class="hljs-string">&#x27;더하는 열 이름&#x27;</span>) <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br>    <span class="hljs-keyword">WHERE</span> <span class="hljs-string">&#x27;조건에 사용할 카테고리&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;조건&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="개수를-세어주는-명령어-count">개수를 세어주는 명령어 COUNT</h2><p>명령어 <code>COUNT</code>는 해당 테이블의 레코드 개수를 확인할 수 있다. 사용법은 다음과 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-string">&#x27;열 이름&#x27;</span>) <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span>;<br></code></pre></td></tr></table></figure><p>위 코드는 '열 이름'의 레코드 갯수를 반환한다 참고로 명령어 <code>COUNT</code>는 NULL값을 카운트하지 않는다.</p><h2 id="중복-제거하는-명령어-distinct">중복 제거하는 명령어 DISTINCT</h2><p>명령어 <code>DISTINCT</code>는 해당 데이터의 고유값들만 보여준다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-string">&#x27;열 이름&#x27;</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span>;<br></code></pre></td></tr></table></figure><p>위 코드에서는 '열 이름' 카테고리 값들 중에서 중복된 것을 제외한 고유값들만 반환한다. 참고로 명령어 <code>DISTINCT</code>는 NULL값도 포함해서 반환한다.</p><p>하지만 고유값 갯수를 세기 위해 <code>COUNT</code>를 추가한다면 <code>COUNT</code>는 NULL값을 세지 않는다. 즉, <code>DISTINCT</code>는 NULL값을 반환하지만 <code>COUNT</code>에서 무시하는 것이다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-string">&#x27;열 이름&#x27;</span>) <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span>;<br></code></pre></td></tr></table></figure><p>위 코드에서 만약 '열 이름'의 고유값이 NULL을 포함하여 6개였다면, 'COUNT'는 5개라고 반환할 것이다.</p><h2 id="결과-개수를-제한하는-명령어-limit">결과 개수를 제한하는 명령어 LIMIT</h2><p>만약 내게 학생들의 시험 점수 테이블이 있고 그 중 1,2등이 누군지 알고 싶다고 가정해보자. 그러면 아래와 같이 코드를 입력하면 된다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;학생 이름 열&#x27;</span>, <span class="hljs-string">&#x27;시험 점수&#x27;</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br>    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;시험 점수&#x27;</span> <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><p>위 코드는 정렬된 모든 학생들의 시험 점수를 반환한다. 1,2 등을 찾을 수는 있지만 효율적이지는 않다. 1,2등만 반환하기 위해서는 위 코드에 명령어 <code>LIMIT</code>를 추가해보자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;학생 이름 열&#x27;</span>, <span class="hljs-string">&#x27;시험 점수&#x27;</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br>    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;시험 점수&#x27;</span> <span class="hljs-keyword">DESC</span><br>    LIMIT <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>그러면 원하는 정보만 바로 받아볼 수 있다.</p><p>만약 3등부터 5등까지만을 조회하고 싶다면 어떻게 해야 할까? 그 방법은 다음과 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;학생 이름 열&#x27;</span>, <span class="hljs-string">&#x27;시험 점수&#x27;</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br>    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;시험 점수&#x27;</span> <span class="hljs-keyword">DESC</span><br>    LIMIT <span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>위 코드는 3번째부터 아래로 3개의 데이터를 보여달라는 의미이다. SQL에서는 0부터 순서로 시작하기 때문에 2가 세 번째 레코드를 의미한다. 결과는 다음과 같다.</p>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>sql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql</tag>
      
      <tag>DB</tag>
      
      <tag>database</tag>
      
      <tag>mariaDB</tag>
      
      <tag>RDBMS</tag>
      
      <tag>GROUPBY</tag>
      
      <tag>AVG</tag>
      
      <tag>SUM</tag>
      
      <tag>COUNT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>명령어 ALTER 사용법</title>
    <link href="/ko/Sql/sql-3/"/>
    <url>/ko/Sql/sql-3/</url>
    
    <content type="html"><![CDATA[<p>mariaDB에서 ALTER 명령어를 사용하는 방법을 정리합니다. <span id="more"></span></p><hr /><h2 id="alter">ALTER</h2><p>이전 글에서도 살짝 살펴봤지만 명령어 <code>ALTER</code>은 기존의 테이블을 유지하면서 원하는 부분만 수정할 수 있다. 이번 글에서는 명령어 <code>ALTER</code>로 할 수 있는 일들을 살펴볼 것이다.</p><h2 id="add-column-열-추가하기">ADD COLUMN 열 추가하기</h2><p>기존 생성되어 있는 테이블에 카테고리(Column)을 추가해야 하는 경우에는 <code>ALTER TABLE + ADD COLUMN</code>을 사용하면 된다. 문법은 다음과 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">COLUMN</span> <span class="hljs-string">&#x27;추가하려는 카테고리 이름&#x27;</span> <span class="hljs-string">&#x27;키테고리 데이터 타입&#x27;</span>;<br></code></pre></td></tr></table></figure><p>위의 문법으로 쿼리를 요청하면 sql은 기본적으로 추가되는 열을 끝에 추가한다. 만약 추가하려는 카테고리의 위치를 지정하려면 어떻게 해야 할까? <code>ADD COLUMN</code> 으로 시작하는 문장 마지막에 위치를 지정해주면 된다. 위치는 <code>FIRST</code>, <code>SECOND</code> 등 위치할 순서로 지정할 수도 있고, <code>AFTER</code>을 사용하여 기존의 특정 카테고리 뒤에 위치하도록 설정할 수도 있다. 예시는 다음과 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">COLUMN</span> <span class="hljs-string">&#x27;추가하려는 카테고리 이름&#x27;</span> <span class="hljs-string">&#x27;키테고리 데이터 타입&#x27;</span> <span class="hljs-keyword">FIRST</span>;<br></code></pre></td></tr></table></figure><h2 id="rename-to-테이블-이름-변경하기">RENAME TO 테이블 이름 변경하기</h2><p>테이블의 이름을 다른 것으로 변경하고 싶다면 <code>ALTER TABLE + RENAME TO</code>를 사용하면 된다. 문법은 다음과 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br>RENAME <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;변경하려는 테이블 이름&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="rename-column-to-열-이름-변경하기">RENAME COLUMN TO 열 이름 변경하기</h2><p>특정 열의 이름을 변경하고 싶다면 <code>ALTER TABLE + RENAME COLUMN TO</code>를 사용하면 된다. 문법은 다음과 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br>RENAME <span class="hljs-keyword">COLUMN</span> <span class="hljs-string">&#x27;기존 열 이름&#x27;</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;바꾸려는 열 이름&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="change-column-열-이름-및-데이터-타입-변경하기">CHANGE COLUMN 열 이름 및 데이터 타입 변경하기</h2><p><code>ALTER TABLE + CHANGE COLUMN</code>는 열 이름과 동시에 해당 열의 데이터 타입도 변경해준다. 문법은 다음과 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br>CHANGE <span class="hljs-keyword">COLUMN</span> <span class="hljs-string">&#x27;기존 열 이름&#x27;</span> <span class="hljs-string">&#x27;바꾸려는 열 이름&#x27;</span> <span class="hljs-string">&#x27;새로운 데이터 타입&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="modify-column-데이터-타입만-변경하기">MODIFY COLUMN 데이터 타입만 변경하기</h2><p>만약 열 이름을 그대로 유지하면서 해당 열의 데이터 타입만 변경하고 싶은 경우는 어떻게 하면 될까?</p><p><code>ALTER TABLE + MODIFY COLUMN</code>을 사용하면 간단하게 수정할 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br>MODIFY <span class="hljs-keyword">COLUMN</span> <span class="hljs-string">&#x27;해당 열 이름&#x27;</span> <span class="hljs-string">&#x27;새로운 데이터 타입&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="drop-column-특정-열-삭제하기">DROP COLUMN 특정 열 삭제하기</h2><p>기존의 테이블에서 특정한 카테고리만 제거하고 싶다면 <code>ALTER TABLE + DROP COLUMN</code>을 사용하면 된다. 문법은 다음과 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> <span class="hljs-string">&#x27;삭제할 열 이름&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="기본키-변경하기">기본키 변경하기</h2><p>만약 기존에 사용하던 기본키가 아닌 다른 열을 기본키로 지정하고 싶다면 어떻게 해야할까? 두 가지의 쿼리가 필요하다.</p><ul><li>기존의 기본키 삭제하기</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PRIMARY KEY</span>;<br></code></pre></td></tr></table></figure><p>위 코드는 기존에 지정했던 기본키를 삭제한다.</p><ul><li>새로운 열을 기본키로 지정하기</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY KEY</span>(<span class="hljs-string">&#x27;기본키로 지정할 열 이름&#x27;</span>);<br></code></pre></td></tr></table></figure><p>만약 새로운 기본키에 <code>ATUO_INCREMENT</code>를 설정하고 싶다면 <code>MODIFY COLUMN</code>이나 <code>CHANGE COLUMN</code>을 시용하면 된다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--예시--</span><br><span class="hljs-keyword">ALTER TABLE</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br>MODIFY <span class="hljs-keyword">COLUMN</span> <span class="hljs-string">&#x27;해당 열 이름&#x27;</span> <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT NULL</span> AUTO_INCREMENT;<br><br><span class="hljs-keyword">ALTER TABLE</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br>CHANGE <span class="hljs-keyword">COLUMN</span> <span class="hljs-string">&#x27;해당 열 이름&#x27;</span>  <span class="hljs-string">&#x27;해당 열 이름&#x27;</span> <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT NULL</span> AUTO_INCREMENT;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>sql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql</tag>
      
      <tag>DB</tag>
      
      <tag>database</tag>
      
      <tag>mariaDB</tag>
      
      <tag>RDBMS</tag>
      
      <tag>ALTER</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Raspberry Pi 환경설정하기</title>
    <link href="/ko/Hadoop/hadoop-1/"/>
    <url>/ko/Hadoop/hadoop-1/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 라즈베리파이 3개를 연결하고 하둡(Hadoop)과 스파크(spark)를 사용하여 빅데이터를 다루는 과정을 보여줍니다. <span id="more"></span></p><hr /><p>이번 글에서는 라즈베리 파이 초기 환경설정 하는 방법에 대해서 알아볼 것이다. 순서는 다음과 같다.</p><ul><li>라즈베리 파이 OS 설정하기</li><li>초기 ssh 설정하기</li><li>라즈베리 파이 노트북에서 접속하기</li><li>OpenJDK 8 설치하기</li><li>파이썬 설치하기</li><li>도커 설치하고 mariaDB 구축하기</li></ul><h2 id="라즈베리-파이-os-설정하기">라즈베리 파이 OS 설정하기</h2><p>처음 개봉한 라즈베리 파이는 운영체제부터 설정해야 한다. 키트에 제공되는 SD 메모리 카드를 사용하여 운영체제 이미지를 다운받는다. <a href="https://www.raspberrypi.org/downloads/">해당 링크</a>로 들어가서 각 컴퓨터 운영체제에 맞는 소프트웨어를 다운받은 후 실행시키면 아래와 같은 화면이 보일 것이다.</p><figure><img src="/images/104.png" alt="rasp2-1" /><figcaption aria-hidden="true">rasp2-1</figcaption></figure><p>헤당 화면이 보인다면 <code>Operating system</code>을 클릭하자. 그러면 다음과 같은 선택지가 반환된다.</p><figure><img src="/images/105.png" alt="rasp2-2" /><figcaption aria-hidden="true">rasp2-2</figcaption></figure><p>가장 위에 있는 OS는 일반 데스크탑처럼 사용할 수 있는 운영체제이다. 만약 라즈베리 파이를 모니터와 연결하여 테스크탑처럼 사용하려면 해당 사항을 선택해야 한다. 하지만 테스크탑이 아니라 터미널만 사용할 것이라면 아래에 있는 <code>other</code> 버전을 선택하자.</p><figure><img src="/images/106.png" alt="rasp2-3" /><figcaption aria-hidden="true">rasp2-3</figcaption></figure><p>그럼 위와 같은 화면이 반환될 것이다. 여기서 <code>lite</code>버전 이미지를 선택하면 된다. 그 다음 SD 메모리 카드를 해당 노트북에 삽입하여 이미지를 다운받으면 OS 설치가 완료된다.</p><h2 id="초기-ssh-설정하기">초기 ssh 설정하기</h2><p>라즈베리 파이를 안전하게 사용하기 위해서는 ssh가 설정되어 있어야 한다. ssh란 Secure Shell Protocol의 약자로 네트워크와 안전하게 통신하기 위해 사용하는 보안 프로토콜이다. 설정하는 방법은 아래와 같다.</p><ul><li><p>이미지를 다운받은 SD 메모리 카드를 한번 제거 했다가 다시 노트북에 삽입한다.</p></li><li><p>터미널에서 해당 노트북의 Volumes 디렉토리로 접속한다.</p></li><li><p>Volumes에 있는 boot(라즈베리 파이 SD card) 디렉토리로 접속한다.</p></li><li><p>아래의 코드를 입력하여 ssh 빈 파일을 생성한다.</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> ssh<br></code></pre></td></tr></table></figure><ul><li>해당 경로에서 나온 후, SD 메모리 카드를 노트북으로부터 분리한다.</li></ul><p>이렇게 하면 라즈베리 파이의 기본 환경설정이 완료되었다. 나머지 부분들은 라즈베리 파이에 접속한 후 설정해야 한다.</p><h2 id="라즈베리-파이-노트북에서-접속하기">라즈베리 파이 노트북에서 접속하기</h2><p>이미지 및 ssh 파일이 포함된 SD 메모리 카드를 라즈베리 파이 개발 보드에 삽입한 후 해당 스위칭 허브에 연결한다.</p><p>그 후, 라즈베리 파이에 접속할 컴퓨터도 동일한 스위칭 허브에 연결하고 노트북의 터미널을 연다.</p><p>아래의 코드를 입력하여 노트북과 라즈베리 파이가 잘 연결되는지 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ping raspberrypi.local<br></code></pre></td></tr></table></figure><p>정상적으로 응답이 돌아온다면 이제 연결하면 된다. 아래의 코드를 입력하여 라즈베리 파이 접속으로 시도한다. 라즈베리 파이는 초기 비밀번호가 <code>raspberry</code>로 모두 동일하다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh pi@raspberrypi.local<br></code></pre></td></tr></table></figure><p>만약 위 코드에서 permission denied 된다면 아래의 코드로 ssh를 초기화한 후 다시 입력해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -R raspberrypi.local<br>ssh pi@raspberrypi.local<br></code></pre></td></tr></table></figure><p>초기 비밀번호를 입력하면 접속할 것인지를 묻는다. <code>yes</code>를 입력하면 라즈베리 파이에 접속할 수 있다.</p><p>해당 OS 이미지는 리눅스이기 때문에 아래의 코드를 입력하여 기본적인 라이브러리들을 업데이트 한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt-get update<br><span class="hljs-built_in">sudo</span> apt-get upgrade<br></code></pre></td></tr></table></figure><p>해당 라즈베리 파이의 이름이나 비밀번호 변경은 아래의 코드를 입력하면 나오는 셋팅 창에서 할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> raspi-config<br></code></pre></td></tr></table></figure><h2 id="openjdk-8-설치하기">OpenJDK 8 설치하기</h2><p>이후 설치할 하둡(Hadoop)이 Java를 기반으로 하고 있기에 Java를 미리 다운받자. 아래의 코드를 입력하면 Java 8의 오픈소스 버전이 다운된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install openjdk-8-jdk openjdk-8-jre<br></code></pre></td></tr></table></figure><h2 id="파이썬-설치하기">파이썬 설치하기</h2><p>라즈베리 파이에서 파이썬을 사용하려면 다운받아야 한다. 아래의 코드 한 줄로 간단하게 다운받을 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt-get install python3<br></code></pre></td></tr></table></figure><p>위 코드는 파이썬3 최신 버전을 설치한다.</p><h2 id="도커-설치하고-mariadb-구축하기">도커 설치하고 mariaDB 구축하기</h2><p>아래의 코드를 입력하여 도커를 설치하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> curl -fsSL https://get.docker.com/ | <span class="hljs-built_in">sudo</span> sh<br></code></pre></td></tr></table></figure><p>도커 설치가 제대로 되었는지 확인하기 위해 간단히 버전을 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> docker version<br></code></pre></td></tr></table></figure><p>잘 설치되었다면 도커 유저를 변경해준 후, 재부팅한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> usermod -aG docker pi<br></code></pre></td></tr></table></figure><p>재부팅한 후 버전을 확인해보면 도커가 잘 작동되는 것을 확인할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker version<br></code></pre></td></tr></table></figure><p>이제 설치한 도커에 간단하게 mariaDB 컨테이너를 생성해보자. 도커에 mariaDB 컨테이너를 생성하는 과정은 <a href="https://dev-bearabbit.github.io/2020/10/09/Docker/Docker-0/">해당 글</a>에서 살펴볼 수 있다. 다만 한 가지 다른 점은 다른 이미지를 사용해야 한다는 것이다.</p><p>라즈베리 파이는 ARM의 CPU이기 때문에 해당 CPU에 맞는 이미지로 다운받아야 한다. ARM CPU에서도 사용가능한 여러 이미지가 있으며, 그 중 하나를 사용하면 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull linuxserver/mariadb<br></code></pre></td></tr></table></figure><p>다음 과정은 위에서 소개한 글을 참고하기 바란다.</p><h2 id="라즈베리-파이-종료하기">라즈베리 파이 종료하기</h2><p>라즈베리 파이를 종료하려면 아래의 코드를 입력하면 된다. 주의할 점은 라즈베리 파이는 컴퓨터이기 때문에 종료하면 도커 컨테이너도 자동으로 종료된다. 또한 컨테이너가 종료되면 내부에 있던 데이터들도 유실된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> shutdown -h now<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>BigData</category>
      
      <category>hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>빅데이터</tag>
      
      <tag>bigdata</tag>
      
      <tag>raspberrypi</tag>
      
      <tag>cluster</tag>
      
      <tag>하둡</tag>
      
      <tag>스파크</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Raspberry Pi 4 unboxing</title>
    <link href="/ko/Hadoop/hadoop-0/"/>
    <url>/ko/Hadoop/hadoop-0/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 라즈베리파이 3개를 연결하고 하둡(Hadoop)과 스파크(spark)를 사용하여 빅데이터를 다루는 과정을 보여줍니다. <span id="more"></span></p><hr /><h2 id="introduction">Introduction</h2><p>이제는 대부분의 데이터가 '빅데이터'라고 불리는 만큼 그 용량이 매우 크며, 이런 데이터들을 전부 저장하고 불러오기 위해서는 정말 좋은 컴퓨터 사양이 필요하다. 하지만 컴퓨터는 고성능일수록 가격이 가파르게 상승한다. 그렇다면 데이터를 다루기 위해 모든 사람들이 슈퍼컴퓨터를 살 필요가 있을까? 오히려 적당한 컴퓨터 여러 개를 붙여서 하나처럼 사용할 수 있다면 훨씬 저렴하게 빅데이터를 다룰 수 있을 것이다. 이처럼 여러 개의 컴퓨터를 연결하여 하나의 좋은 컴퓨터처럼 사용하는 시스템을 클러스터(Cluster)라고 한다. 해당 프로젝트에서는 라즈베리 파이4 3개를 연결하여 클러스터링하는 과정들을 공부하고, 이를 기록하는 데 목적이 있다. 라즈베리 파이 3개를 연결한 모습은 다음과 같다.</p><figure><img src="/images/96.jpg" alt="rasp1" /><figcaption aria-hidden="true">rasp1</figcaption></figure><h2 id="라즈베리-파이4-키트">라즈베리 파이4 키트</h2><p>라즈베리 파이는 영국의 라즈베리 파이 재단에서 생성하는 초소형, 최저가 컴퓨터이다. 라즈베리 파이를 구매하면 간단한 개발 보드의 형태로 배송되며, 키트로 구매할 시 설명서와 키보스, 마우스 등을 포함하여 제공한다. 이번엔 EU 2020년 기준 최신 모델인 라즈베리 파이4를 키트로 구매하였다. 라즈베리 파이4 언박싱을 시작해보자.</p><figure><img src="/images/97.jpg" alt="rasp2" /><figcaption aria-hidden="true">rasp2</figcaption></figure><p>위 사진은 키트 박스이다. 해당 박스 한쪽 면에는 키트 구성품들을 설명하고 있다.</p><figure><img src="/images/98.jpg" alt="rasp3" /><figcaption aria-hidden="true">rasp3</figcaption></figure><p>박스를 처음 개봉하면 구성품들이 깔끔하게 패키징되어 있다. 아래 사진의 중간에 있는 케이스 안에 라즈베리 파이4가 들어 있다.</p><figure><img src="/images/99.jpg" alt="rasp4" /><figcaption aria-hidden="true">rasp4</figcaption></figure><p>아래의 사진은 모든 구성품들을 꺼낸 것이다. 키트에는 라즈베리 파이 공식 설명서도 포함되어 있다. 포장지가 참 귀엽다.</p><figure><img src="/images/100.jpg" alt="rasp5" /><figcaption aria-hidden="true">rasp5</figcaption></figure><p>이번에 키트를 구매하면서 사실 키보드와 마우스는 별 기대 안했는데 생각보다 컬러도 예쁘고 퀄리티도 괜찮았다. 아래 사진은 구성품들을 모두 꺼낸 모습이다.</p><figure><img src="/images/101.jpg" alt="rasp6" /><figcaption aria-hidden="true">rasp6</figcaption></figure><p>SD 메모리 카드도 깔끔하게 포장되어 왔다. 안의 메모리 카드를 확인해보면 16GB 이다.</p><figure><img src="/images/102.jpg" alt="rasp7" /><figcaption aria-hidden="true">rasp7</figcaption></figure><h2 id="라즈베리-파이4-3개-연결">라즈베리 파이4 3개 연결</h2><p>라즈베리 파이들을 연결하기 위해서는 몇 가지의 준비물이 필요하다. 바로 PoE 스위칭 허브와 PoE 랜선이다. PoE란 Power over Ethernet의 약자로 한 개의 랜선이 전원과 데이터 송신을 모두 공급하는 기술을 말한다. 기본적으로 컴퓨터는 전기를 공급받는 전원선과 네트워크를 연결하여 데이터를 받는 랜선 2가지가 필요하다. 따라서 여러 개의 컴퓨터를 동시에 연결해야 하는 경우, 각 컴퓨터 당 최소 2개의 선이 발생하고 전원 어댑터를 연결할 콘센트도 컴퓨터 갯수만큼 필요하다. 한마디로 정신없다. 이럴 때 PoE 기술이 포함된 랜선과 스위칭 허브를 사용하면 선 하나로 깔끔하게 정리할 수 있다. 또한 멀티 콘센트도 필요 없다. 이런 방법은 연결할 컴퓨터의 갯수가 많을수록 더욱 의미있다. 라즈베리 파이 3개를 스위칭 허브와 연결한 모습은 아래와 같다.</p><figure><img src="/images/103.jpg" alt="rasp8" /><figcaption aria-hidden="true">rasp8</figcaption></figure><p>지금까지 라즈베리 파이4를 살펴보았다. 다음 글에서는 라즈베리 파이의 초기 환경설정에 대해서 살펴볼 것이다.</p>]]></content>
    
    
    <categories>
      
      <category>BigData</category>
      
      <category>hadoop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>빅데이터</tag>
      
      <tag>bigdata</tag>
      
      <tag>raspberrypi</tag>
      
      <tag>cluster</tag>
      
      <tag>하둡</tag>
      
      <tag>스파크</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQLAlchemy ORM 사용 중 pylint 에러</title>
    <link href="/ko/ERROR/error-0/"/>
    <url>/ko/ERROR/error-0/</url>
    
    <content type="html"><![CDATA[<p>SQLAlchemy 사용 중에 아래와 같은 에러의 해결책을 정리합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Instance of <span class="hljs-string">&#x27;scoped_session&#x27;</span> has no <span class="hljs-string">&#x27;commit&#x27;</span> member pylint(no-member)<br></code></pre></td></tr></table></figure><span id="more"></span><hr /><h2 id="오류-설명">오류 설명</h2><p>VS code를 사용하여 <code>flask</code>로 웹페이지를 만들던 중 문제가 생겼다.</p><p>데이터베이스를 연동하기 위해서 <code>sqlalchemy</code> ORM을 사용하는데 pylint가 세션 충돌을 막아주는 'scoped_session'을 인식하지 못하고 위의 오류만을 반복하였다.</p><p>(참고로 pylint는 코드의 오류를 검사하고 로직의 문제가 없는지 확인해주는 툴이며, VS code에 내장되어 있다.)</p><p>이 문제를 해결하기 위해 VS code의 Setting도 변경해보았지만 소용이 없었다.</p><p>한참 해결방안을 검색하다가 아래의 방법을 찾았고, 적용해보니 실제로 오류가 사라졌다.</p><p>한국어로 정리된 자료가 없는 것 같아서 글로 남긴다.</p><h2 id="해결-방법">해결 방법</h2><p>먼저 터미널을 켠 후 아래의 코드를 입력하여 pylint의 <code>pylintrc</code>을 생성한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pylint --generate-rcfile &gt;.config/pylintrc<br></code></pre></td></tr></table></figure><p>그 다음 새로 생성한 디렉토리에 들어간다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> .config/<br></code></pre></td></tr></table></figure><p>그리고 에디터를 사용하여 <code>pylintrc</code>을 수정한다. 나의 경우 에디터 <code>vim</code>이 설치되어 있어서 그냥 사용하였다. 만약 에디터가 없어서 <code>vim</code>을 사용하려는 사람은 라이브러리를 먼저 다운로드 해야 한다. (참고로 리눅스 기반의 컴퓨터는 vim의 최소버전이 내장되어 있다.)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim pylintrc<br></code></pre></td></tr></table></figure><p>vim의 경우 <code>i</code>를 누르면 수정을 할 수 있는 INSERT 모드로 변경된다. 그 다음 아래의 코드를 <code>ignored-classes</code> 뒤에 붙여준다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">SQLObject,Registrant,scoped_session<br></code></pre></td></tr></table></figure><p>그 후, <code>esc</code>를 눌러 수정에서 빠져나온 후 <code>:write</code>를 입력하여 수정된 내용을 저장한다. 그리고 <code>:q</code>를 다시 입력하여 해당 파일에서 빠져나온다.</p><p>이제 VS code를 재부팅하거나 해당 어플리케이션 폴더를 다시 열면 위의 오류가 사라져 있음을 볼 수 있다.</p>]]></content>
    
    
    <categories>
      
      <category>etc.</category>
      
      <category>errors</category>
      
    </categories>
    
    
    <tags>
      
      <tag>error</tag>
      
      <tag>sqlalchemy</tag>
      
      <tag>flask_sqlalchemy</tag>
      
      <tag>pylint</tag>
      
      <tag>mysql</tag>
      
      <tag>db</tag>
      
      <tag>scoped_session</tag>
      
      <tag>Registrant</tag>
      
      <tag>SQLObject</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DB 정규화와 기본키 설정하기</title>
    <link href="/ko/Sql/sql-2/"/>
    <url>/ko/Sql/sql-2/</url>
    
    <content type="html"><![CDATA[<p>데이터베이스의 정규화와 기본키에 대해서 살펴본 후 mariaDB에서 기본키 설정하는 방법을 설명합니다. <span id="more"></span></p><hr /><h2 id="정규화-nomalization">정규화 (Nomalization)</h2><p>같은 자료를 받아도 설계자의 목표에 따라서 다른 테이블이 만들어 질 수 있다. 예를 들어, 식물에 관한 정보를 식물 관리인과 식물 연구자가 받았다고 가정해보자. 식물 관리인은 식물에게 물을 주는 주기나 식물의 생장 속도와 같은 정보들이 구체적으로 필요할 것이다. 반면 식물 연구자는 해당 식물의 세부적인 종이나 생물학적 특징 등이 필요할 것이다. 두 사람에게는 동일한 정보를 주어도 다른 테이블이 도출될 수 있는 것이다.</p><p>'정규화'란 목표에 맞는 테이블을 올바르게 구성하는 것이다. 그렇다면 어떻게 정규화된 테이블을 만들 수 있을까? 정규화된 테이블은 아래의 두 가지의 원칙을 포함한다.</p><ul><li>테이블이 원자적 데이터로 구성되어 있다. (제 1정규형)</li><li>기본키를 가지고 있다.</li></ul><p>위 조건에서 '원자적 데이터'와 '기본키'는 낯선 용어이지만 관계형 데이터베이스에서는 중요한 개념이다. 따라서 두 개념을 간단하게 살펴본 후 정규화에 대해서 정리할 것이다.</p><h3 id="원자적-데이터">원자적 데이터</h3><p>원자적 데이터란 테이블에 사용되는 데이터가 더이상 쪼개질 수 없는 형태를 말한다. 그렇다면 더이상 쪼개질 수 없는 형태란 무엇인가? 이에 대해서는 절대적인 기준은 없으며, 테이블 생성 목적에 따라서 달라진다. 예를 들어 주소를 저장하는 테이블을 만든다고 가정해보자. 배달부에게 전달하기 위한 주소는 어차피 전체 주소를 전달해야 하기에 한 열에 저장해도 상관없다. 하지만 물류창고에서 지역별로 물건을 정리하는 경우에는 시군구를 따로 열로 지정하는 것이 원자적 데이터인 것이다. 즉, 목적에 따라서 원자적 데이터의 기준은 달라질 수 있다.</p><p>원자적 데이터 규칙은 다음과 같다.</p><ul><li>원자적 데이터로 구성된 열은 그 열에 같은 타입의 데이터 여러개를 가질 수 없다.</li><li>원자적 데이터로 구성된 테이블은 같은 타입의 데이터를 여러 열에 가질 수 없다.</li><li>단 테이블을 사용하는 목적에 따라 원자적 데이터 테이블의 형태가 달라질 수 있다.</li></ul><h3 id="primary-key-기본키">PRIMARY KEY 기본키</h3><p>기본키는 레코드의 고유번호를 지정해주며, 이는 데이터 중복 저장을 막아준다. 기본키는 주민등록번호와 같은 기존에 있는 카테고리를 기본키로 지정할 수 있으며, 또한 기본키만을 위한 열을 새로 만들 수도 있다. 새로 만드는 기본키의 경우 synthetic key라 하고, 이미 존재하는 열을 기본키로 사용할 경우 natural key라 한다.</p><p>기본키를 구성하는데 필요한 4가지 규칙이 있다.</p><ul><li>기본키는 NULL 값이 될 수 없다. NULL 값은 유일무이하지 않기 때문이다.</li><li>기본키는 행이 삽입될 때 값이 있어야 한다.</li><li>기본키는 간결해야한다. 유일무이한 정보를 가지고 있어야한다.</li><li>기본키의 값은 변경 불가능한 값이여야 한다. 유일무이 하기에 변경 가능하면 중복이 생길 수도 있기에 변경 불가능 해야 한다.</li></ul><p>기본키를 지정하는 방법은 테이블을 생성할 때 추가하는 방법이 있고, 기존에 있던 테이블에서 지정하는 방법이 있다.</p><p><strong>테이블을 새로 생성할 때</strong> 아래와 같이 원하는 테이블의 코드를 입력한 후 기본키로 지정할 카테고리의 이름을 명령어 <code>PRIMARY KEY</code>을 사용하여 지정하면 된다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span>( <span class="hljs-string">&#x27;카테고리 1&#x27;</span> <span class="hljs-string">&#x27;특성&#x27;</span> <span class="hljs-keyword">NOT NULL</span> , <span class="hljs-string">&#x27;카테고리 2&#x27;</span> <span class="hljs-string">&#x27;특성&#x27;</span>, <span class="hljs-keyword">PRIMARY KEY</span> (<span class="hljs-string">&#x27;카테고리 1&#x27;</span>));<br></code></pre></td></tr></table></figure><p>위 코드는 '카테고리 1'을 기본키로 지정한 코드이다. 기본키로 지정된 열의 경우 중복된 데이터를 입력할 수 없다.</p><p><strong>기존의 테이블에서 지정할 때</strong> 기존 존재하는 테이블에서 지정할 때는 명령어 <code>ALTER</code>을 사용하여 기본키를 설정한다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> <span class="hljs-string">&#x27;기존 테이블 이름&#x27;</span> <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY KEY</span> (<span class="hljs-string">&#x27;지정할 카테고리 이름&#x27;</span>);<br></code></pre></td></tr></table></figure><p>위 코드는 기존에 있던 테이블의 카테고리를 기본키로 지정하는 코드이다. 참고로, 명령어 <code>ALTER</code>은 다음 글에서 자세하게 알아볼 것이다.</p><p>그렇다면 기존의 테이블에서 새로운 기본키 카테고리를 추가한 후 해당 카테고리를 기본키로 지정하려면 어떻게 해야할까?</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> <span class="hljs-string">&#x27;기존 테이블 이름&#x27;</span><br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">COLUMN</span> <span class="hljs-string">&#x27;새로운 카테고리 이름&#x27;</span> <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT NULL</span> AUTO_INCREMENT <span class="hljs-keyword">FIRST</span>,<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY KEY</span> (<span class="hljs-string">&#x27;새로운 카테고리 이름&#x27;</span>);<br></code></pre></td></tr></table></figure><p>위 코드를 사용하면 된다. 그러면 기존 테이블에 새로운 카테고리를 추가하면서 기본키로 지정한다.</p><h3 id="auto_increment">AUTO_INCREMENT</h3><p>명령어 <code>AUTO_INCREMENT</code> 기본키가 정수일 때, 정수를 자동으로 지정해주는 방법이다. 이 명령어를 사용하면 기본키 입력에 있어서 매우매우 편하다. 기본키 위치에 <code>NULL</code>값을 입력하면 알아서 자동으로 고유값 정수를 제공하기 때문이다. 그렇다면 어떻게 사용하는가? 사용법은 간단하다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span>( <span class="hljs-string">&#x27;카테고리 1&#x27;</span> <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT NULL</span> AUTO_INCREMENT, <span class="hljs-string">&#x27;카테고리 2&#x27;</span> <span class="hljs-string">&#x27;특성&#x27;</span>, <span class="hljs-keyword">PRIMARY KEY</span> (<span class="hljs-string">&#x27;카테고리 1&#x27;</span>));<br></code></pre></td></tr></table></figure><p>위 코드는 테이블을 생성할 때 지정하는 방법이다. 명령어 <code>AUTO_INCREMENT</code>는 기본키가 인수일 때 사용할 수 있기 때문에 해당 카테고리는 <code>INT</code>로 설정한다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> <span class="hljs-string">&#x27;기존 테이블 이름&#x27;</span><br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">COLUMN</span> <span class="hljs-string">&#x27;새로운 카테고리 이름&#x27;</span> <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT NULL</span> AUTO_INCREMENT <span class="hljs-keyword">FIRST</span>,<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY KEY</span> (<span class="hljs-string">&#x27;새로운 카테고리 이름&#x27;</span>);<br></code></pre></td></tr></table></figure><p>기존 테이블에 추가할 때도 카테고리 추가하는 명령어에 같이 입력하여 사용하면 된다.</p>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>sql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql</tag>
      
      <tag>DB</tag>
      
      <tag>database</tag>
      
      <tag>mariaDB</tag>
      
      <tag>RDBMS</tag>
      
      <tag>정규화</tag>
      
      <tag>nomalization</tag>
      
      <tag>기본키</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mariaDB 기본적인 명령어 모음</title>
    <link href="/ko/Sql/sql-1/"/>
    <url>/ko/Sql/sql-1/</url>
    
    <content type="html"><![CDATA[<p>mariaDB에서 기본적으로 사용하는 명령어들을 정리한 글입니다. <span id="more"></span></p><hr /><h2 id="테이블에-복수-데이터-추가">테이블에 복수 데이터 추가</h2><p>만약 테이블에 여러 개의 데이터를 한번에 입력해야 한다면 어떻게 해야할까? <code>VALUES</code> 아래에 여러 개의 데이터를 (,)를 사용하여 입력하면 된다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT INTO</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br><span class="hljs-keyword">VALUES</span><br>(<span class="hljs-string">&#x27;값1_A&#x27;</span>, <span class="hljs-string">&#x27;값2_A&#x27;</span>), (<span class="hljs-string">&#x27;값1_B&#x27;</span>, <span class="hljs-string">&#x27;값2_B&#x27;</span>), (<span class="hljs-string">&#x27;값1_C&#x27;</span>, <span class="hljs-string">&#x27;값2_C&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="특정-데이터-찾기">특정 데이터 찾기</h2><p>테이블에서 특정한 조건의 데이터를 찾을 때는 <code>WHERE</code>절을 사용하면 된다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>  <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-string">&#x27;조건에 사용될 카테고리&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;특정 조건&#x27;</span>;<br></code></pre></td></tr></table></figure><p>위의 코드는 카테고리에서 특정 조건을 만족하는 행(record)의 전체 데이터를 가져오라는 요청이다. 만약 전체데이터가 아닌 특정 열의 데이터를 가져오고 싶다면 앞의 <code>*</code>를 원하는 열의 이름으로 변경해주면 된다. 특정 열 이름은 여러 개 입력할 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>  <span class="hljs-string">&#x27;원하는 열 이름_1&#x27;</span>,<span class="hljs-string">&#x27;원하는 열 이름_2&#x27;</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-string">&#x27;조건에 사용될 카테고리&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;특정 조건&#x27;</span>;<br></code></pre></td></tr></table></figure><p>그렇다면 특정 열의 전체 데이터는 어떻게 볼 수 있을까? 간단하다. <code>WHERE</code>절을 제외하고 입력하면 된다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>  <span class="hljs-string">&#x27;원하는 열 이름_1&#x27;</span>,<span class="hljs-string">&#x27;원하는 열 이름_2&#x27;</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="where-조건-사용법">WHERE 조건 사용법</h2><p>조건에 들어갈 수 있는 기본적인 비교 연산자는 다음과 같다.</p><ul><li>'=' : 같다</li><li>'&lt;&gt;' : 같지 않다</li><li>'&lt;' : 조건보다 작다 (미만)</li><li>'&gt;' : 조건보다 크다 (초과)</li><li>'&lt;=' : 조건과 같거나 작다 (이하)</li><li>'&gt;=' : 조건과 같거나 크다 (이상)</li></ul><h2 id="작은따옴표가-포함된-정보">작은따옴표가 포함된 정보</h2><p>'은 SQL의 문법으로 사용되기 때문에 텍스트로 사용되는 경우 내용 안의 작은따옴표에  붙여서 추가해야 한다. 기호 개행문자를 표시한 것이다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT INTO</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br><span class="hljs-keyword">VALUES</span><br>(<span class="hljs-string">&#x27;값1\&#x27;</span>s<span class="hljs-string">&#x27;, &#x27;</span>값<span class="hljs-number">2</span>\<span class="hljs-string">&#x27;s&#x27;</span>);<br></code></pre></td></tr></table></figure><p>위 코드는 테이블에 <code>값1's</code>, <code>값2's</code>를 추가하는 코드이다. 중간의 어퍼스트로피(Apostrophe)는 텍스트 문자로 들어간다.</p><h2 id="쿼리들의-결합-and-or">쿼리들의 결합 (AND, OR)</h2><p>복수의 조건을 사용하여 쿼리를 요청할 수 있다. 복수로 쿼리를 주는 기본적인 방법은 크게 <code>AND</code>와 <code>OR</code>이 있다.</p><h3 id="and">AND</h3><p><code>AND</code>는 주어지는 조건을 모두 만족하는 레코드를 모두 가져온다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-string">&#x27;조건에 사용될 카테고리_1&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;특정 조건_1&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-string">&#x27;조건에 사용될 카테고리_2&#x27;</span> <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;특정 조건_2&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="or">OR</h3><p><code>OR</code>는 주어지는 조건 중 하나 이상 만족하는 레코드를 모두 가져온다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-string">&#x27;조건에 사용될 카테고리_1&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;특정 조건_1&#x27;</span> <span class="hljs-keyword">OR</span> <span class="hljs-string">&#x27;조건에 사용될 카테고리_2&#x27;</span> <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;특정 조건_2&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="비교연산자로-문자열-처리">비교연산자로 문자열 처리</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-string">&#x27;조건에 사용될 카테고리&#x27;</span> <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;C&#x27;</span>;<br></code></pre></td></tr></table></figure><p>비교 연산자 조건에 알파벳을 입력하는 경우는 알파벳 순서를 기준으로 데이터를 가져온다. 위 코드의 경우 카테고리의 첫 글자가 C 순서보다 먼저인 A, B인 경우만 반환한다.</p><h2 id="null">NULL</h2><p>NULL은 데이터가 없는 경우 기본 값으로 이용되기도 하며, 쓰는 방법에 따라서 유용하기도 하다.</p><h3 id="null-포함된-데이터-추가하기">NULL 포함된 데이터 추가하기</h3><p>입력하려는 레코드의 일부 값이 없는 경우, 값이 없는 위치에 NULL을 입력하면 바로 레코드를 추가할 수 있다. 이런 방법은 앞에 카테고리 이름을 지정할 필요가 없기 때문에 매우 편리하다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT INTO</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br><span class="hljs-keyword">VALUES</span><br>(<span class="hljs-string">&#x27;값1&#x27;</span> , <span class="hljs-keyword">NULL</span>, <span class="hljs-string">&#x27;값3&#x27;</span>, <span class="hljs-string">&#x27;값4&#x27;</span>, <span class="hljs-string">&#x27;값5&#x27;</span>, <span class="hljs-keyword">NULL</span>);<br></code></pre></td></tr></table></figure><h3 id="null-포함된-데이터-찾기">NULL 포함된 데이터 찾기</h3><p>만약 특정 카테고리에 NULL값이 포함된 경우를 찾아야 할 때는 어떻게 하면 좋을까? 아래의 코드를 입력하여 확인할 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-string">&#x27;조건에 사용될 카테고리&#x27;</span> <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure><h2 id="문자-일부만으로-데이터-찾기-like">문자 일부만으로 데이터 찾기 (LIKE)</h2><p>특정 카테고리에서 'World'로 끝나는 레코드를 찾고 싶다면 아래의 코드를 사용할 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-string">&#x27;조건에 사용될 카테고리&#x27;</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%World&#x27;</span>;<br></code></pre></td></tr></table></figure><p>명령어 <code>LIKE</code>는 <code>%</code>와 <code>_</code> 기호를 사용할 수 있다. <code>%World</code>는 World 앞에 오는 글자들의 수가 몇이든 상관하지 않으며, <code>_World</code>는 World 앞에 하나의 글자만 있는 경우를 반환한다.</p><h2 id="사이-값-찾기">사이 값 찾기</h2><p>특정 카테고리에서 두 개의 값 사이에 해당하는 경우를 가져오고 싶다면 어떻게 해야할까? 물론 <code>AND</code>를 사용하여 두 개의 조건을 연결할 수도 있지만 명령어 <code>BETWEEN</code>을 사용해서도 해결할 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-string">&#x27;조건에 사용될 카테고리&#x27;</span> <span class="hljs-keyword">BETWEEN</span> <span class="hljs-string">&#x27;조건1&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-string">&#x27;조건2&#x27;</span>;<br></code></pre></td></tr></table></figure><p>위 코드는 특정 카테고리가 조건1과 조건2 사이인 경우를 모두 반환하라는 쿼리이다.</p><h2 id="or-여러-개-in">OR 여러 개 == IN</h2><p>조건 여러 개를 <code>OR</code>을 통해 사용하고 싶은 경우, 조건들 모두를 <code>OR</code>로 연결하는 경우도 있지만 코드만 길어지고 번거롭다. 명령어 <code>IN</code>을 사용하면 간결하게 여러 개의 조건을 <code>OR</code>과 동일하게 사용할 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-string">&#x27;조건에 사용될 카테고리&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;조건1&#x27;</span> <span class="hljs-keyword">OR</span> <span class="hljs-string">&#x27;조건에 사용될 카테고리&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;조건2&#x27;</span> <span class="hljs-keyword">OR</span> <span class="hljs-string">&#x27;조건에 사용될 카테고리&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;조건3&#x27;</span>;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-string">&#x27;조건에 사용될 카테고리&#x27;</span> <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;soda&#x27;</span>, <span class="hljs-string">&#x27;sprite&#x27;</span>,<span class="hljs-string">&#x27;tonic water&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="not-사용법">NOT 사용법</h2><p>명령어 <code>NOT</code>은 해당 조건을 제외한 나머지 레코드를 반환한다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-string">&#x27;조건에 사용될 카테고리&#x27;</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;soda&#x27;</span>, <span class="hljs-string">&#x27;sprite&#x27;</span>,<span class="hljs-string">&#x27;tonic water&#x27;</span>);<br></code></pre></td></tr></table></figure><p>NULL 값의 경우 IN, NOT IN 모두 포함되지 않는다.</p><h2 id="delete-데이터-삭제하기">DELETE 데이터 삭제하기</h2><p><code>DELETE</code>은 레코드를 삭제할 때 사용하는 명령어이다. 보통 어떤 레코드의 변경사항이 생기면 새로운 레코드를 추가하고 이전의 레코드를 삭제하는 식으로 데이터를 관리한다. 명령어를 사용하는 방법은 아래와 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-string">&#x27;조건에 사용될 카테고리&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;조건&#x27;</span>;<br></code></pre></td></tr></table></figure><p>위 코드는 <code>WHERE</code> 조건에 해당하는 레코드만 삭제한다. 여기서 주의해야 할 점은 <code>WHERE</code>로 특정 레코드의 조건을 주지 않는다면, <code>DELETE</code>는 해당 테이블의 모든 레코드를 삭제한다.</p><p><strong>NOTE</strong> 안전하게 삭제하는 방법</p><p>만약 WHERE 명령어를 잘못 준 상태로 DELETE를 사용한다면 의도치 않게 다른 데이터들이 삭제될 수 있다. 따라서 SELECT을 사용하여 사용하려는 WHERE 명령어가 원하는 데이터만 가져오는지 확인한 후에 DELETE을 사용하는 것이 안전하다. 따라서 순서는 다음과 같다.</p><ol type="1"><li><code>SELECT</code>을 사용하여 변경하려는 데이터 확인</li><li><code>INSERT</code>를 사용하여 변경된 데이터 추가</li><li><code>DELETE</code>을 사용하여 이전 데이터 삭제</li></ol><h2 id="update-데이터-변경하기">UPDATE 데이터 변경하기</h2><p>만약 기존 레코드에서 특정 조건에 해당하는 값만 수정하고 싶다면, 명령어 <code>UPDATE</code>를 사용할 수 있다. <code>UPDATE</code>를 적용하는 코드는 다음과 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span> <span class="hljs-keyword">SET</span> <span class="hljs-string">&#x27;변경할 카테고리&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;새로운 값&#x27;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-string">&#x27;조건에 사용될 카테고리&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;조건&#x27;</span>;<br></code></pre></td></tr></table></figure><p>위 코드는 <code>SET</code>과 <code>WHERE</code> 두 가지가 같이 사용되고 있다. 먼저 <code>SET</code>은 변경할 카테고리의 값들을 전부 새로운 값으로 변경한다. 따라서 <code>WHERE</code>로 특정 레코드를 지정해주지 않는다면 모든 레코드의 데이터가 변경된다. 그래서 보통 <code>UPDATE</code>와 <code>SET</code>에는 <code>WHERE</code>이 필수적으로 같이 사용된다.</p>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>sql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql</tag>
      
      <tag>database</tag>
      
      <tag>명령어</tag>
      
      <tag>mariaDB</tag>
      
      <tag>RDBMS</tag>
      
      <tag>WHERE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>데이터베이스와 테이블 생성하기</title>
    <link href="/ko/Sql/sql-0/"/>
    <url>/ko/Sql/sql-0/</url>
    
    <content type="html"><![CDATA[<p>mariaDB에서 데이터베이스와 테이블을 생성하는 방법에 대해 살펴봅니다. <span id="more"></span></p><hr /><h2 id="데이터베이스-생성">데이터베이스 생성</h2><p>새로운 데이터베이스를 만드는 명령어는 다음과 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE <span class="hljs-string">&#x27;데이터베이스 이름&#x27;</span>;<br></code></pre></td></tr></table></figure><p>그러면 해당 요청(query)가 정상적으로 수행되었다고 아래와 같이 알려준다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.024</span> sec)<br></code></pre></td></tr></table></figure><h2 id="데이터베이스-접속">데이터베이스 접속</h2><p>원하는 데이터베이스에 접속해야 해당 DB를 사용할 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE DATABASE <span class="hljs-string">&#x27;데이터베이스 이름&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="테이블-생성">테이블 생성</h2><p>어떤 데이터베이스에 자료를 정리하여 넣으려고 한다. 그때 관계형 DB에서는 테이블을 사용하여 데이터를 저장한다. 테이블은 행과 열로 구성되어 있으며, 행(record)은 객체 하나의 모든 정보를 포함하고 열(field)은 데이터의 카테고리를 포함한다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span>( <span class="hljs-string">&#x27;카테고리 1&#x27;</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>), <span class="hljs-string">&#x27;카테고리 2&#x27;</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">6</span>));<br></code></pre></td></tr></table></figure><p>위 코드에서 <code>VARCHAR</code>은 'variable character'의 약자로 해당 카테고리의 데이터타입을 나타낸다. 뒤에 따라오는 (10), (6)과 같은 숫자는 해당 카테고리에서 저장할 수 있는 최대 길이를 설정한 것이다.</p><h2 id="테이블-구조">테이블 구조</h2><p>생성한 테이블의 구조는 명령어 <code>DESC</code>를 사용하여 볼 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DESC</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="테이블-목록">테이블 목록</h2><p>데이터베이스에 있는 테이블들의 목록은 해당 데이터베이스에서 <code>SHOW TABLES</code>를 입력하면 볼 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> TABLES;<br></code></pre></td></tr></table></figure><h2 id="테이블-삭제">테이블 삭제</h2><p>테이블 전체를 삭제하는 명령어는 다음과 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="테이블에-데이터-추가">테이블에 데이터 추가</h2><p>테이블에 데이터를 추가하는 것은 <code>INSERT</code> 명령어를 사용한다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT INTO</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;값1&#x27;</span>, <span class="hljs-string">&#x27;값2&#x27;</span>);<br></code></pre></td></tr></table></figure><p>워 코드는 해당 테이블의 모든 열에 대한 데이터를 순서에 맞게 추가할 때 사용할 수 있다. 특정 데이터를 추가하거나 순서를 변경하기 위해서는 카테고리 이름을 같이 입력해주어야 한다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 순서 변경<br><span class="hljs-keyword">INSERT INTO</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span>  (<span class="hljs-string">&#x27;카테고리 2&#x27;</span>, <span class="hljs-string">&#x27;카테고리 1&#x27;</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;값2&#x27;</span>, <span class="hljs-string">&#x27;값1&#x27;</span>);<br># 특정 카테고리만 데이터 추가<br><span class="hljs-keyword">INSERT INTO</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span>  (<span class="hljs-string">&#x27;카테고리 1&#x27;</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;값1&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>WARNING</strong> 값에 작은따옴표(')가 있는 경우<br />작은 따옴표는 SQL에서 문법으로 사용되기 때문에 값 안에 포함된 작은 따옴표와 구분해야 한다. 따라서 값 내부의 작은따옴표는 개행문자를 사용하여 표현한다. 예시는 다음과 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT INTO</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span><br><span class="hljs-keyword">VALUES</span><br>(<span class="hljs-string">&#x27;Indian\&#x27;</span>s Summer<span class="hljs-string">&#x27; , &#x27;</span>cherry juice<span class="hljs-string">&#x27;, 2, &#x27;</span>pineapple juice<span class="hljs-string">&#x27;, 7, &#x27;</span>serve <span class="hljs-keyword">over</span> ice <span class="hljs-keyword">with</span> straw<span class="hljs-string">&#x27;);</span><br></code></pre></td></tr></table></figure><h2 id="테이블-데이터-확인">테이블 데이터 확인</h2><p>테이블에 데이터가 추가되었는지 확인하고 싶다면 아래의 코드를 사용하면 된다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span>;<br></code></pre></td></tr></table></figure><p>위 코드에서 사용되는 <code>*</code>는 모든 데이터를 불러오라는 뜻이다.</p><h2 id="null-처리">NULL 처리</h2><p>일부 카테고리에만 데이터를 입력하면 해당 행의 나머지 카테고리에는 자동적으로 <code>NULL</code>로 처리된다. 하지만 어떤 카테고리는 필수적으로 입력되어야 한다고 가정하자. 그렇게 하기 위해서는 테이블을 생성할 때 아래와 같이 입력하여 <code>NULL</code>을 받지 않도록 설정해야 한다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span>( <span class="hljs-string">&#x27;카테고리 1&#x27;</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT NULL</span>, <span class="hljs-string">&#x27;카테고리 2&#x27;</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">6</span>));<br></code></pre></td></tr></table></figure><p>위 코드로 만들어진 테이블은 데이터를 추가할 때 카테고리 1이 무조건 채워져야 한다. 어떤 테이블의 카테고리들의 NULL 허용여부를 확인하고 싶다면 <code>DESC</code>를 사용하여 테이블 구조를 확인하면 된다.</p><h2 id="디폴트값-설정">디폴트값 설정</h2><p>만약 기본 값이 주어진 열인 경우에는 테이블을 생성 시 디퐅트 값을 지정할 수 있다. 디폴트 값은 해당 카테고리에 데이터가 입력되지 않았을 시에 자동으로 적용된다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> <span class="hljs-string">&#x27;테이블 이름&#x27;</span>( <span class="hljs-string">&#x27;카테고리 1&#x27;</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;카테고리 2&#x27;</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">6</span>));<br></code></pre></td></tr></table></figure><p>위 코드에서는 카테고리 1에 디폴트 값 1을 지정하였다.</p>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>sql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql</tag>
      
      <tag>database</tag>
      
      <tag>mariaDB</tag>
      
      <tag>RDBMS</tag>
      
      <tag>table</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker로 MariaDB 사용하기</title>
    <link href="/ko/Containers/docker-0/"/>
    <url>/ko/Containers/docker-0/</url>
    
    <content type="html"><![CDATA[<p>도커 컨테이너에 MariaDB를 올려서 데이터베이스를 구축합니다. <span id="more"></span></p><hr /><p>이번 글에서는 MariaDB에 대해 간단하게 알아보고 도커 컨테이너에 MariaDB를 올려 데이터베이스 구축하는 방법에 대해서 살펴볼 것이다. 해당 글은 도커가 이미 깔렸다는 전제 하에 설명하기 때문에 만약 도커가 없다면 다운받아야 한다.</p><h2 id="database란">Database란</h2><p>데이터베이스(Database, DB)는 여러 사람들이 사용할 목적으로 통합하고 관리하는 데이터 집합을 말하며, 대부분 관계형 데이터베이스(Relational Database, RDB) 형태로 많이 사용하고 있다. 관계형 데이터베이스란 데이터를 컬럼(column)과 로우(row)를 이루는 하나 이상의 테이블(또는 관계)로 정리하는 방식이며, 흔히 우리가 알고 있는 엑셀의 시트 형태와 같다.</p><p>이런 데이터베이스를 통합하고 관리하는 소프트웨어를 '데이터베이스 관리시스템(DataBase Management System, DBMS)'라고 하며, 보통 RDB를 관리하는 시스템을 '관계형 데이터베이스 관리시스템(Relational DBMS, RDBMS)'이라고 한다. 이런 관계형 데이터베이스는 'SQL(Structured Query Language)'이라는 언어를 통해서 데이터 전송을 주고 받는다.</p><p>정리하면 다음과 같다.</p><ul><li>데이터 뭉치: 관계형 데이터베이스</li><li>데이터를 담는 통: 관계형 데이터베이스 관리시스템</li><li>통에서 특정 데이터 조작: SQL</li></ul><h2 id="mariadb">MariaDB</h2><p>MariaDB는 MysSQL와 동일한 소스코드를 기반으로 한 오픈소스 관계형 데이터베이스 관리시스템(RDBMS)이다. 소스코드가 같으므로 데이터베이스의 구조나 사용방법이 MysSQL과 동일하다.</p><h2 id="docker에-mariadb-컨테이너-생성하기">Docker에 MariaDB 컨테이너 생성하기</h2><p>먼저 MariaDB image를 다운받아야 한다. 아래의 코드를 입력하여 다운을 받은 뒤, 도커 이미지를 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull mariadb <span class="hljs-comment"># mariaDB image download</span><br>docker images <span class="hljs-comment"># check downloaded images</span><br></code></pre></td></tr></table></figure><p>그 다음 아래의 코드를 입력하여 MariaDB 컨테이너를 생성하면 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --name <span class="hljs-string">&#x27;컨테이너 이름&#x27;</span> -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=<span class="hljs-string">&#x27;접속 비밀번호&#x27;</span> mariadb<br></code></pre></td></tr></table></figure><p>'접속 비밀번호'는 이후 해당 컨테이너에 접속할 때 사용할 예정이기에 메모하는 것을 추천한다. 위 코드에서 <code>-d</code>는 백그라운드 모드(detached mode)로 생성함으로 의미하며, 포트는 MySQL 포트번호인 '3306'로 설정한다.</p><p><strong>NOTE</strong> 백그라운드 모드(detached mode)란? 사용자가 해당 컨테이너를 사용하지 않는 경우에도 컨테이너 서버가 작동하고 있는 것을 말한다. 보통 서빙 서버와 같이 지속적으로 데이터를 주고받아야 하는 서버들은 백그라운드 모드로 실행한다.</p><p>컨테이너 생성이 완료되었다면 아래의 코드를 입력하여 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps<br></code></pre></td></tr></table></figure><h2 id="mariadb-접속하기">MariaDB 접속하기</h2><p>이제 만든 컨테이너에 접속해보자. 아래의 코드를 입력한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -i -t mariadb /bin/bash<br></code></pre></td></tr></table></figure><p>도커에서 <code>exec</code>는 컨테이너 내부로 접속하는 명령어이다. 그다음 명령어 <code>exec</code>의 옵션인 <code>-i</code>는 'interactive'의 약자로 사용자가 해당 서버에 입출력할 수 있도록 해주며, <code>-t</code>는 가상 터미널인 TTY(pseudo-TTY)를 통해 bash셀을 사용할 수 있도록 해준다.</p><p>접속이 완료되면 아래와 같이 컨테이너 ID가 프롬프트가 된다.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">root@<span class="hljs-string">&#x27;컨테이너 ID&#x27;</span>:/<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p>그다음 아래의 코드를 입력하여 MariaDB에 접속한다.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">mysql -u root -p<br></code></pre></td></tr></table></figure><p>비밀번호는 처음 컨테이너를 생성할 때 만들었던 것을 입력하면 된다. 그러면 아래와 같이 프롬프트창이 변할 것이다.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">MariaDB [(none)]&gt;<br></code></pre></td></tr></table></figure><h2 id="my.snf-수정하기">my.snf 수정하기</h2><p>MariaDB에서 <code>status</code>를 입력하면, DB 정보를 확인할 수 있다. 그중 characterset이 "latin" 경우에는 힌글이 깨질 수 있기 때문에 UTF-8로 변경해주어야 한다.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">MariaDB [(none)]&gt; status<br>.<br>.<br>Server characterset:    utf8mb4<br>Db     characterset:    utf8mb4<br>Client characterset:    latin1<br>Conn.  characterset:    latin1<br></code></pre></td></tr></table></figure><p>변경하는 방법은 간단하다. 해당 터미널에서 <code>exit</code>를 입력하여 DB를 빠져나온 후 컨테이너에서 아래의 코드를 입력하여 수정할 파일을 오픈한다. 우리는 에디터 vim을 사용하여 터미널 내에서 수정을 진행할 것이다.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">root@<span class="hljs-string">&#x27;컨테이너 ID&#x27;</span>:/<span class="hljs-comment"># apt-get update</span><br>root@<span class="hljs-string">&#x27;컨테이너 ID&#x27;</span>:/<span class="hljs-comment"># apt-get install vim</span><br></code></pre></td></tr></table></figure><p>컨테이너 내에 vim 설치가 완료되었다면 아래의 디렉토리로 이동하여 해당 파일을 오픈한다.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">root@<span class="hljs-string">&#x27;컨테이너 ID&#x27;</span>:/<span class="hljs-comment"># cd /etc/mysql</span><br>root@<span class="hljs-string">&#x27;컨테이너 ID&#x27;</span>:/<span class="hljs-comment"># vim my.cnf</span><br></code></pre></td></tr></table></figure><p>그러면 에디터가 열리고 파일 내용이 터미널에 나타난다. 여기서 <code>i</code>를 입력하여 INSERT 모드로 변경한 후 아래의 코드를 복사해 붙여넣자.</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vim">[client]<br>default-character-<span class="hljs-keyword">set</span> = utf8mb4<br><br>[mysql]<br>default-character-<span class="hljs-keyword">set</span> = utf8mb4<br><br>[mysqld]<br>collation-server = utf8_unicode_ci<br>init-connect=<span class="hljs-string">&#x27;SET NAMES utf8&#x27;</span><br>character-<span class="hljs-keyword">set</span>-server = utf8<br></code></pre></td></tr></table></figure><p>그다음 esc를 누르고 <code>:write</code>를 입력하고 엔터를 누르면 수정사항이 저장된다. 그 후 <code>:q</code>을 입력하여 에디터를 빠져나오면 된다.</p><p>확인을 위하여 다시 DB에 접속해보자. 접속한 후, <code>status</code>를 다시 입력해보면 변경된 것을 확인할 수 있다.</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs docker">MariaDB [(none)]&gt; status<br>.<br>.<br>Server characterset:    utf8mb4<br>Db     characterset:    utf8mb4<br>Client characterset:    utf8mb4<br>Conn.  characterset:    utf8mb4<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
      <category>docker/k8s</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql</tag>
      
      <tag>docker</tag>
      
      <tag>mariadb</tag>
      
      <tag>database</tag>
      
      <tag>vi</tag>
      
      <tag>vim</tag>
      
      <tag>도커</tag>
      
      <tag>데이터베이스</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker로 모델 서빙서버 생성하기</title>
    <link href="/ko/Containers/docker-3/"/>
    <url>/ko/Containers/docker-3/</url>
    
    <content type="html"><![CDATA[<p>Docker로 훈련된 모델을 서빙하는 방법에 대해서 정리합니다. <span id="more"></span></p><hr /><h2 id="모델-서빙서버-생성하기">모델 서빙서버 생성하기</h2><p><strong>1. S3 버킷에서 모델 파일 다운 받기</strong> AWS에 접속한 상태에서 아래의 코드를 입력하면 로컬에 다운받을 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws s3 <span class="hljs-built_in">cp</span> s3://<span class="hljs-string">&#x27;버킷 이름&#x27;</span>/<span class="hljs-string">&#x27;파일 이름&#x27;</span> <span class="hljs-string">&#x27;다운받을 로컬 디렉토리 경로&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>2. tar 묶음 해제하기</strong> 모델을 다운받은 디렉토리로 이동하여 아래의 코드를 입력하면 간단하게 해제할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar xvf <span class="hljs-string">&#x27;파일 이름.tar&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>3.도커에서 사용할 이미지 다운받기</strong> 서빙서버를 생성하기 위해서는 아래의 이미지를 다운받아야 한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull tensorflow/serving<br></code></pre></td></tr></table></figure><p>위 이미지는 텐서플로우측에서 서빙을 위해 제공하는 이미지이다. 이 이미지를 사용하면 간단하게 서빙서버를 만들 수 있다.</p><p><strong>4. 도커에 서빙서버 생성하기</strong> 커맨드라인에서 아래의 코드를 입력하여 다운받은 모델을 서빙할 서버를 생성한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -p 8501:8501 --mount <span class="hljs-built_in">type</span>=<span class="hljs-built_in">bind</span>,<span class="hljs-built_in">source</span>=<span class="hljs-variable">$PWD</span>/mnist_convNet,target=/models/mnist -e MODEL_NAME=mnist -td tensorflow/serving<br></code></pre></td></tr></table></figure><p>이제 모델 서빙서버가 만들어졌다. 아래의 코드를 입력하면 현재 서빙서버가 작동되고 있음을 확인할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps <span class="hljs-comment"># 현재 실행중인 컨테이너만 보여준다.</span><br></code></pre></td></tr></table></figure><h2 id="예제로-모델-서빙서버-테스트하기">예제로 모델 서빙서버 테스트하기</h2><p>이제 서빙서버에 있는 모델이 잘 작동하는지 확인해보자. 커맨드라인에서 Python을 실행한 후 아래의 라이브러리들을 다운로드한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> tensorflow.keras <span class="hljs-keyword">import</span> datasets, layers, models<br></code></pre></td></tr></table></figure><p>위 모델은 MNIST 데이터를 학습하였다. 따라서 테스트는 텐서플로우 측에서 제공하는 MNIST 데이터셋으로 진행할 것이다. 아래의 코들르 입력하여 MNIST 데이터들을 가져오자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">(train_images, train_labels), (test_images, test_labels) = datasets.mnist.load_data()<br>test_images = test_images.reshape((<span class="hljs-number">10000</span>, <span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">1</span>))<br>test_images = test_images / <span class="hljs-number">255.0</span><br>test_images.shape<br>(<span class="hljs-number">10000</span>, <span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>테스트셋은 10000개나 들어있다. 따라서 시각적으로 확인해보기 위해 앞의 2개의 이미지만 분리하여 예측해볼 것이다. 아래의 코드를 입력하여 이미지 2개를 분리하자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">temp = test_images[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>,:,:,:]<br>answer = test_labels[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>이제 이미지 2개인 <code>temp</code>를 서빙서버에 보내고 예측값을 받아오자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">address = <span class="hljs-string">&#x27;http://localhost:8501/v1/models/mnist:predict&#x27;</span><br>data = json.dumps(&#123;<span class="hljs-string">&#x27;instances&#x27;</span>:temp.tolist()&#125;)<br>result = requests.post(address, data=data)<br>predictions = json.loads(<span class="hljs-built_in">str</span>(result.content, <span class="hljs-string">&#x27;utf-8&#x27;</span>))[<span class="hljs-string">&#x27;predictions&#x27;</span>]<br></code></pre></td></tr></table></figure><p>우리가 보낸 이미지의 예측값이 <code>predictions</code>에 저장되었다. 아래의 코드를 입력하면 값들을 확인할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">np.argmax(predictions[<span class="hljs-number">0</span>])<br> <span class="hljs-number">7</span><br>np.argmax(predictions[<span class="hljs-number">1</span>])<br> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>모델은 첫 번째 이미지를 7이라고 예측했고, 두 번째 이미지를 2라고 예측하였다. 아까 미리 저장해두었던 정답을 확인해보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">answer<br> array([<span class="hljs-number">7</span>, <span class="hljs-number">2</span>], dtype=uint8)<br></code></pre></td></tr></table></figure><p>모델의 예측이 정확히 맞았다.</p>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
      <category>docker/k8s</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AWS</tag>
      
      <tag>Amazon</tag>
      
      <tag>딥러닝</tag>
      
      <tag>Deeplearning</tag>
      
      <tag>Docker</tag>
      
      <tag>image</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 컨테이너에서 모델 훈련하기</title>
    <link href="/ko/Containers/docker-2/"/>
    <url>/ko/Containers/docker-2/</url>
    
    <content type="html"><![CDATA[<p>AWS EC2 인스턴스에 있는 Docker 컨테이너에서 딥러닝 모델을 훈련하는 과정에 대해서 정리합니다. <span id="more"></span></p><hr /><h2 id="ec2-인스턴스-생성하기">EC2 인스턴스 생성하기</h2><p>먼저 커맨드라인에서 AWS에 접속하여 사용할 EC2 인스턴스를 생성한다. 만약 생성하는 방법을 모른다면 <a href="https://dev-bearabbit.github.io/2020/09/21/AWS/AWS-4/">EC2 인스턴스 생성하기</a>에서 확인할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># IAM계정 로그인</span><br>aws configure<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># EC2 인스턴스 생성</span><br>aws ec2 run-instances --image-id <span class="hljs-string">&#x27;인스턴스 이미지&#x27;</span> --count <span class="hljs-string">&#x27;인스턴스 수&#x27;</span> --instance-type <span class="hljs-string">&#x27;인스턴스 타입&#x27;</span> --key-name <span class="hljs-string">&#x27;키 페어 이름&#x27;</span> --security-groups <span class="hljs-string">&#x27;보안 그룹 이름&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="ec2-인스턴스에-접속하기">EC2 인스턴스에 접속하기</h2><p>다음으로는 생성한 인스턴스에 접속한다. 해당 인스턴스의 인바운드 규칙이 SSH 접속이기 때문에 아래의 코드를 입력한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> 400 <span class="hljs-string">&#x27;키 페어 이름.pem&#x27;</span>  <span class="hljs-comment"># SSH 퍼미션 변경</span><br>ssh -i <span class="hljs-string">&#x27;키 페어 이름.pem&#x27;</span> ec2-user@ <span class="hljs-string">&#x27;헤당 인스턴스 PublicDnsName&#x27;</span><br></code></pre></td></tr></table></figure><p><code>chmod 400</code>은 해당 파일의 소유주만 읽을 수 있도록 권한을 변경하는 것이다. <code>해당 인스턴스 PublicDnsName</code>는 인스턴스의 정보에서 찾을 수 있다. 만약 PublicDnsName를 모른다면 아래의 코드를 입력해서 복사해오면 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws ec2 describe-instanses<br></code></pre></td></tr></table></figure><p>해당 인스턴스 접속에 성공하면 프롬프트가 인스턴스 ID로 변경된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[ec2-user@ip-**-**-*-*** ~]$ <span class="hljs-comment"># 인스턴스에 접속된 프롬프트</span><br></code></pre></td></tr></table></figure><h2 id="ec2-인스턴스에-훈련-데이터-가져오기">EC2 인스턴스에 훈련 데이터 가져오기</h2><p>이제 인스턴스에 S3에 저장해둔 훈련데이터를 가져올 것이다. 인스턴스는 가상 서버이기 때문에 S3에 접속하려면 다시 IAM 계정에 로그인해야 한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># IAM계정 다시 로그인</span><br>aws configure<br></code></pre></td></tr></table></figure><p>그 다음에는 아래의 코드를 입력하여 훈련데이터가 들어있는 버킷을 인스턴스에 복사해온다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws s3 <span class="hljs-built_in">sync</span> s3://;<span class="hljs-string">&#x27;가져올 버킷 이름&#x27;</span> /home/ec2-user<br></code></pre></td></tr></table></figure><p>그러면 커맨드라인에 아래와 같이 다운되었다고 나올 것이다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">download: s3://mnist-data-60000/Dockerfile to ./Dockerfile<br>download: s3://mnist-data-60000/model.py to ./model.py<br>download: s3://mnist-data-60000/test_y.pickle to ./test_y.pickle<br>download: s3://mnist-data-60000/train_y.pickle to ./train_y.pickle<br>download: s3://mnist-data-60000/test_x.pickle to ./test_x.pickle<br>download: s3://mnist-data-60000/train_x.pickle to ./train_x.pickle<br></code></pre></td></tr></table></figure><p>인스턴스 디렉토리를 확인하여 잘 다운되었는지 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; <span class="hljs-built_in">ls</span><br>Dockerfile  model.py  test_x.pickle  test_y.pickle  train_x.pickle  train_y.pickle<br></code></pre></td></tr></table></figure><h2 id="ec2-인스턴스에-도커-설치하기">EC2 인스턴스에 도커 설치하기</h2><p>이제 인스턴스에 도커를 설치해야 한다. 아래의 코드를 입력하여 도커를 설치해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> yum update -y<br><span class="hljs-built_in">sudo</span> yum install docker<br><span class="hljs-built_in">sudo</span> service docker start<br><span class="hljs-built_in">sudo</span> usermod -a -G docker ec2-user<br></code></pre></td></tr></table></figure><p>도커가 정상작동하기 위해서는 인스턴스를 재부팅해야 한다. 아래의 코드를 입력하여 EC2 인스턴스를 재부팅한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws ec2 reboot-instances --instance-ids <span class="hljs-string">&#x27;인스턴스  ID&#x27;</span> <span class="hljs-comment"># 그냥 logout만 입력해도 된다.</span><br>ssh -i <span class="hljs-string">&#x27;키 페어 이름.pem&#x27;</span> ec2-user@ <span class="hljs-string">&#x27;헤당 인스턴스 PublicDnsName&#x27;</span><br></code></pre></td></tr></table></figure><p>그 다음 아래의 코드를 입력하면 도커가 정상작동하는 것을 확인할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker info<br></code></pre></td></tr></table></figure><h2 id="docker-image-빌드하고-컨테이너-생성하기">docker image 빌드하고 컨테이너 생성하기</h2><p>인스턴스 재부팅이 완료되었다면 저장해두었던 도커파일을 빌드하여 컨테이너를 생성해보자. 아래의 코드를 입력하여 도커파일을 빌드한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t train:0.0 .<br></code></pre></td></tr></table></figure><p>위 코드는 현재 디렉토리에 있는 도커파일을 <code>train:0.0</code>라는 이름으로 빌드한다. 뒤에 <code>(띄어쓰기).</code>는 현재 디렉토리를 나타낸 것이다. 그렇기 때문에 위 코드를 입력할 때 잊지 말고 같이 입력해야 한다. 이미지 빌드가 완성되면 아래의 코드를 입력하여 확인할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker images<br><br>REPOSITORY          TAG                   IMAGE ID            CREATED             SIZE<br>train               0.0                   947c77773268        8 seconds ago       2.05GB<br>ufoym/deepo         tensorflow-py36-cpu   437bbe6aecab        5 weeks ago         1.79GB<br></code></pre></td></tr></table></figure><p>위와 같이 나왔다면 이미지 빌드에 성공한 것이다. 이제 train:0.0을 사용하여 컨테이너를 생성할 것이다. 아래의 코드를 입력해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -v /home/ec2-user:/app train:0.0<br></code></pre></td></tr></table></figure><p>위 코드에 대해 살펴보자면 먼저 <code>-v</code>는 호스트의 디렉토리를 생성할 컨테이너 디렉토리로 마운트하는 것이다. <code>/home/ec2-user</code>은 EC2 인스턴스의 디렉토리이고, <code>/app</code>은 컨테이너 디렉토리이다. (도커파일에서 컨테이너 디렉토리를 <code>/app</code>으로 설정하였다 ) 그 다음 사용할 이미지 이름과 태그를 입력하면 도커 컨테이너가 작동한다.</p><h2 id="훈련-결과-확인하기">훈련 결과 확인하기</h2><p>컨테이너가 작동되면 커맨드라인에 아래와 같이 훈련이 진행되는 상황이 보인다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python3">Epoch 1/100<br>600/600 [==============================] - 55s 92ms/step - loss: 0.1782 - accuracy: 0.9444 - val_loss: 6.7693 - val_accuracy: 0.9827<br>Epoch 2/100<br>600/600 [==============================] - 55s 91ms/step - loss: 0.0519 - accuracy: 0.9840 - val_loss: 5.7595 - val_accuracy: 0.9855<br>Epoch 3/100<br>600/600 [==============================] - 55s 91ms/step - loss: 0.0357 - accuracy: 0.9886 - val_loss: 8.1897 - val_accuracy: 0.9838<br>.heco<br>.<br></code></pre></td></tr></table></figure><p>이것은 우리가 명령했던 <code>model.py</code>가 잘 작동하고 있다는 의미이며, 학습이 끝나면 가중치, 모델 스트럭쳐와 같은 모델 정보들을 EC2 인스턴스에 저장한다. 모델 정보는 <code>mnist_convNet</code>이라는 폴더로 저장된다. (model.py의 마지막 줄에서 폴더 이름 수정 가능하다)</p><p>아래의 코드를 입력하여 EC2 인스턴스의 디렉토리를 확인해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span><br><br>Dockerfile     model.py       test_y.pickle   train_y.pickle<br>mnist_convNet  test_x.pickle  train_x.pickle<br></code></pre></td></tr></table></figure><h2 id="훈련-결과-s3에-저장하기">훈련 결과 S3에 저장하기</h2><p>훈련이 끝났다. 이제 훈련이 완료된 모델 정보를 S3의 버킷에 저장해야 한다. 아래의 코드를 입력해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar cvf `저장할 이름.tar` mnist_convNet<br></code></pre></td></tr></table></figure><p>위 코드는 <code>mnist_convNet</code>폴더를 하나로 묶어준다. 이후 해당 파일을 S3 버킷에 복사하면 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws s3 <span class="hljs-built_in">cp</span> `저장한 이름.tar` s3://<span class="hljs-string">&#x27;저장할 버킷 이름&#x27;</span><br></code></pre></td></tr></table></figure><p>그럼 아래와 같이 훈련 결과가 S3에 저장된 것을 확인할 수 있다.</p><figure><img src="/images/95.png" alt="AWS6_1" /><figcaption aria-hidden="true">AWS6_1</figcaption></figure><p>이제 AWS를 사용하여 모델 훈련까지 완료하였다. 다음 글에서는 훈련된 모델에 사용하는 방법에 대해서 살펴볼 것이다.</p>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
      <category>docker/k8s</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AWS</tag>
      
      <tag>Amazon</tag>
      
      <tag>딥러닝</tag>
      
      <tag>Deeplearning</tag>
      
      <tag>Docker</tag>
      
      <tag>image</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>모델 훈련 Docker image 생성하기</title>
    <link href="/ko/Containers/docker-1/"/>
    <url>/ko/Containers/docker-1/</url>
    
    <content type="html"><![CDATA[<p>모델 훈련을 위한 Docker image 생성하는 과정을 정리합니다. <span id="more"></span></p><hr /><h2 id="docker란">Docker란</h2><p>"개발자 A는 MAS OS 유저이다. 현재 MAS OS에서 개발을 완료하여 서버로 배포하려고 한다. 하지만 Linux기반의 서버에서는 해당 애플리케이션이 작동하지 않는다."</p><p>위의 상황은 실행 환경이 맞지 않아 발생하는 문제이다. 이런 문제를 방지하기 위해서는 어떤 해결 방법이 있을까?</p><ul><li>개발자가 서버와 똑같은 운영체제를 사용한다.</li><li>개발자가 가상머신을 사용하여 Linux 기반으로 개발을 진행한다.</li><li>개발자 컴퓨터와 서버에 Docker를 깔아 컨테이너를 사용한다.</li></ul><p>첫 번째 방법은 환경 제약이 너무 많다. 그렇다면 두 번째 방법과 세 번째 방법을 살펴보자.</p><p>먼저 가상머신(Virtual Machine, VM)은 해당 컴퓨터의 운영체제 위에 가상 운영체제를 구축하여 가상 환경을 만드는 방법이다. 보통 가상머신은 하이퍼바이저를 통해 실제 컴퓨터의 하드웨어 일부를 할당받고 그 위에 원하는 운영체제 쌓아 애플리케이션들을 생성한다. 해당 방법은 완전한 독립된 환경을 구축할 수 있지만, 운영체제도 포함되어 있다보니 배포하는 애플리케이션이 무겁고 다운받는 시간도 오래걸린다.</p><p>하지만 도커는 컨테이너 덕분에 비교적 간단하게 애플리케이션을 만들어 배포할 수 있다. 컨테이너란 컴퓨터 내의 독립적인 실행 환경이다. 그렇다면 실행 환경과 가상 환경의 차이점은 무엇일까? 가상 환경은 위에서 설명한 바와 같이 실제 하드웨어의 일부를 할당하여 완전하게 분리된 운영체제를 가진다. 반면 컨테이너는 기존 운영체제를 기반으로 운영체제에 없는 부분만 다운받아 사용한다. 정리하여 가상머신과 도커를 구분한다면 가상머신은 가상 운영체제를 쌓는 반면, 도커는 기존 운영체제를 사용한다는 점이다. 아래의 그림은 일반적인 환경과 가상 머신, 도커의 환경을 보여준다.</p><figure><img src="/images/93.png" alt="AWS5_1" /><figcaption aria-hidden="true">AWS5_1</figcaption></figure><h2 id="docker-image란">Docker Image란</h2><p>이제 도커 이미지에 대해서 자세히 살펴보자.</p><p>이미지(image)는 사용중인 컨테이너의 상태를 그대로 저장하는 방법이다. 예를 들어, 개발자 A가 도커에서 리눅스 기반으로 어떤 애플리케이션을 개발했다고 생각해보자. 그럼 개발자 A는 어떻게 애플리케이션을 배포하는가? 그때 사용되는 방법이 개발자 A의 해당 컨테이너를 이미지로 저장하여 도커 허브(Docker Hub)에 올리는 것이다. 그러면 해당 애플리케이션을 사용하려는 사람들은 이미지를 다운받아 그대로 사용하면 된다. 이미지는 배포를 매우 간단하게 만들어주는 방법으로 실제로 도커 허브에는 수많은 이미지들이 올라와 있다. 우리는 이렇게 이미지를 만드는 과정을 '도커라이징(Dockering)'이라고 부른다.</p><p>이제 우리가 사용할 도커 이미지를 만들어보자. 도커 이미지를 만들기 위해서는 <code>dockerfile</code> 을 작성해야 한다. <code>dockerfile</code>은 도커 이미지를 만들기 위한 스크립트이다. 아래의 순서대로 <code>dockerfile</code>을 빌드하여 도커 이미지를 생성해보자.</p><h3 id="먼저-커맨드라인에서-도커파일을-생성한다">1. 먼저 커맨드라인에서 도커파일을 생성한다</h3><p>이래의 코드를 커맨드라인에 입력해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim Dockerfile<br></code></pre></td></tr></table></figure><p>그러면 커맨드라인이 아래와 같이 변경될 것이다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">~<br>~<br>.<br>.<br>~<br>~<br>-- INSERT --<br></code></pre></td></tr></table></figure><h3 id="도커파일에-필요한-설정들을-추가한다">2. 도커파일에 필요한 설정들을 추가한다</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Bash">FROM ufoym/deepo:tensorflow-py36-cpu<br>MAINTAINER name <span class="hljs-string">&quot;e-mail&quot;</span> <span class="hljs-comment"># 만든 이 정보</span><br>COPY . /app<br>WORKDIR /app<br>RUN pip install --upgrade pip<br>CMD [<span class="hljs-string">&quot;python3&quot;</span>, <span class="hljs-string">&quot;model.py&quot;</span>]<br></code></pre></td></tr></table></figure><p>위 도커파일을 하나씩 살펴보자.</p><ul><li><p>FROM : 해당 이미지의 Base 이미지를 명시한 것이다. <code>ufoym/deepo</code>는 원래 GPU를 사용하여 딥러닝 모델을 훈련할 때 사용하기 좋은 이미지이다. 해당 프로젝트에서는 AWS에서 프리티어인 CPU를 사용할 예정이기에 특정 이미지만 다운받았다. ufoym/deepo의 모든 버전을 다운받으면 용량이 매우 커져서 오히려 불편하다. 해당 이미지에 대한 정보는 <a href="https://github.com/ufoym/deepo">이 페이지</a>에서 확인할 수 있다.</p></li><li><p>MAINTAINER : 도커파일 만든이에 관한 정보를 작성하면 된다.</p></li><li><p>COPY : 호스트 디렉토리를 복사하여 이미지 안의 디렉토리를 생성한다.</p></li><li><p>WORKDIR : 도커파일에서 작동하는 명령들을 진행할 디렉토리를 설정한다.</p></li><li><p>RUN : 해당 이미지로 컨테이너를 생성할 때 작동한다.</p></li><li><p>CMD : 컨테이너가 생성된 후 해당 스크립트 혹은 명령을 작동시킨다.</p></li></ul><p>위의 정보를 바탕으로 도커파일을 설명한다면</p><ol type="1"><li>먼저 <code>ufoym/deepo:tensorflow-py36-cpu</code>를 가져온다.</li><li>호스트 디렉토리를 복사하여 <code>\app</code>이라는 디렉토리를 만들고 내부로 접속한다.</li><li><code>pip</code> 라이브러리를 업그레이드하고 <code>python3</code>에서 <code>model.py</code>를 돌리는 것이다.</li></ol><p>이렇게 도커파일을 완성하였다면 아래의 코드를 입력하여 저장한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">:w Dockerfile<br></code></pre></td></tr></table></figure><p>그러면 현재 디렉토리에 <code>Dockerfile</code>이 저장되었을 것이다.</p><h3 id="model.py-생성하기">3. model.py 생성하기</h3><p>이제 도커에서 훈련할 모델을 생성해야 한다. MNIST 데이터는 비교적 간단한 모델로도 충분하다. 만약 더 복잡한 모델을 훈련하고 싶다면 이 파일에서 해당 모델 스크립트를 작성해주면 된다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_data</span>(<span class="hljs-params">data_name</span>):<br><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(data_name, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        data = pickle.load(f)<br><br>    <span class="hljs-keyword">return</span> data<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Model</span>():<br><br>    Input = tf.keras.layers.Input(shape = (<span class="hljs-number">28</span>,<span class="hljs-number">28</span>,<span class="hljs-number">1</span>))<br>    conv1 = tf.keras.layers.Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>,<span class="hljs-number">3</span>), kernel_initializer=<span class="hljs-string">&#x27;he_normal&#x27;</span>,strides = <span class="hljs-number">1</span>, activation = <span class="hljs-string">&#x27;relu&#x27;</span>)(Input)<br>    pool1 = tf.keras.layers.MaxPooling2D((<span class="hljs-number">2</span>,<span class="hljs-number">2</span>))(conv1)<br>    conv2 = tf.keras.layers.Conv2D(<span class="hljs-number">64</span>, (<span class="hljs-number">3</span>,<span class="hljs-number">3</span>), kernel_initializer=<span class="hljs-string">&#x27;he_normal&#x27;</span>,strides = <span class="hljs-number">1</span>, activation = <span class="hljs-string">&#x27;relu&#x27;</span>)(pool1)<br>    pool2 = tf.keras.layers.MaxPooling2D((<span class="hljs-number">2</span>,<span class="hljs-number">2</span>))(conv2)<br>    conv3 = tf.keras.layers.Conv2D(<span class="hljs-number">128</span>, (<span class="hljs-number">3</span>,<span class="hljs-number">3</span>), kernel_initializer=<span class="hljs-string">&#x27;he_normal&#x27;</span>,strides = <span class="hljs-number">1</span>, activation = <span class="hljs-string">&#x27;relu&#x27;</span>)(pool2)<br>    flat = tf.keras.layers.Flatten()(conv3)<br>    den1= tf.keras.layers.Dense(<span class="hljs-number">64</span>,kernel_initializer=<span class="hljs-string">&#x27;he_normal&#x27;</span>, activation = <span class="hljs-string">&#x27;relu&#x27;</span>)(flat)<br>    output = tf.keras.layers.Dense(<span class="hljs-number">10</span>,kernel_initializer=<span class="hljs-string">&#x27;he_normal&#x27;</span>, activation = <span class="hljs-string">&#x27;softmax&#x27;</span>)(den1)<br><br>    model = tf.keras.Model(Input, output)<br><br>    <span class="hljs-keyword">return</span> model<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mycallbacks</span>(tf.keras.callbacks.Callback):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_epoch_end</span>(<span class="hljs-params">self,epoch,logs</span>):<br><br>        <span class="hljs-keyword">if</span> logs.get(<span class="hljs-string">&#x27;val_accuracy&#x27;</span>) &gt; <span class="hljs-number">0.99</span> <span class="hljs-keyword">or</span> logs.get(<span class="hljs-string">&#x27;accuracy&#x27;</span>) &gt; <span class="hljs-number">0.9999</span> :<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;done!&#x27;</span>)<br>            <span class="hljs-variable language_">self</span>.model.stop_training = <span class="hljs-literal">True</span><br><br><span class="hljs-comment"># training</span><br><br>train_x = np.array(get_data(<span class="hljs-string">&#x27;train_x.pickle&#x27;</span>)).astype(np.float32)<br>train_y = tf.one_hot(get_data(<span class="hljs-string">&#x27;train_y.pickle&#x27;</span>),<span class="hljs-number">10</span>)<br>test_x = np.array(get_data(<span class="hljs-string">&#x27;test_x.pickle&#x27;</span>)).astype(np.float32)<br>test_y = tf.one_hot(get_data(<span class="hljs-string">&#x27;test_y.pickle&#x27;</span>),<span class="hljs-number">10</span>)<br><br>model  = Model()<br>callbacks = Mycallbacks()<br>model.<span class="hljs-built_in">compile</span>(optimizer= <span class="hljs-string">&#x27;Adam&#x27;</span>, loss = <span class="hljs-string">&#x27;categorical_crossentropy&#x27;</span>, metrics = [<span class="hljs-string">&#x27;accuracy&#x27;</span>])<br>model.fit(train_x, train_y, epochs = <span class="hljs-number">100</span>, batch_size = <span class="hljs-number">100</span>, validation_data=(test_x, test_y), callbacks= [callbacks])<br><br>tf.saved_model.save(model, <span class="hljs-string">&#x27;mnist_convNet/1&#x27;</span>)<br></code></pre></td></tr></table></figure><p>다만 도커파일에서 작성해주어야 하기 때문에 <strong>해당 파일의 이름을 꼭 <code>model.py</code>로 저장해야 한다.</strong></p><h2 id="dockerfile-model.py을-s3에-업로드하기">4. Dockerfile, model.py을 S3에 업로드하기</h2><p>마지막으로 EC2 인스턴스에서 다운받을 수 있도록 생성한 <code>Dockerfile</code>과 <code>model.py</code>을 S3에 업로드해야 한다. 커맨드라인에서 <code>aws configure</code>을 입력하여 IAM 계정으로 접속한다. 그 다음 아래의 코드를 입력한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3<br>import boto3<br></code></pre></td></tr></table></figure><p>그러면 파이썬이 열리고 <code>boto3</code> 라이브러리를 사용할 수 있다. S3에 접속하기 위해 client를 설정하고, 파일을 업로드 한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s3 = boto3.client(<span class="hljs-string">&#x27;s3&#x27;</span>)<br>s3.upload_file(<span class="hljs-string">&#x27;업로드할 파일 이름&#x27;</span>, <span class="hljs-string">&#x27;버킷 이름&#x27;</span>, <span class="hljs-string">&#x27;버킷에 저장할 이름&#x27;</span>)<br></code></pre></td></tr></table></figure><p>파일을 S3에 업로드 하는 방법을 자세히 알고 싶다면 <a href="https://dev-bearabbit.github.io/2020/09/17/AWS/AWS-project-3/">3편</a>을 살펴보자.</p><p>업로드가 완료된 후 AWS S3 콘솔에 들어가보면 해당 버킷은 아래와 같이 나타날 것이다.</p><figure><img src="/images/94.png" alt="AWS5_2" /><figcaption aria-hidden="true">AWS5_2</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
      <category>docker/k8s</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AWS</tag>
      
      <tag>Amazon</tag>
      
      <tag>딥러닝</tag>
      
      <tag>Deeplearning</tag>
      
      <tag>Docker</tag>
      
      <tag>image</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EC2 인스턴스 생성하기</title>
    <link href="/ko/AWS/AWS-4/"/>
    <url>/ko/AWS/AWS-4/</url>
    
    <content type="html"><![CDATA[<p>터미널에서 코드만을 사용하여 AWS EC2 인스턴스를 생성하고 접속하는 과정을 정리합니다. <span id="more"></span></p><hr /><h2 id="aws-ec2">AWS EC2</h2><p>EC2(Elastic Compute Cloud)는 가상 컴퓨터를 임대해주는 서비스이다. 만약 좋은 성능의 컴퓨터가 없는데 일정 기간동안 빅데이터를 다뤄야 하거나 무거운 딥러닝 모델을 학습시켜야 하는 상황에 부딪힌다면 막막하게 느껴질 것이다. 그런 상황에서 EC2를 사용하여 성능 좋은 컴퓨터를 빌릴 수 있다. 사실 '가상 컴퓨터'라는 말 때문에 물리적인 컴퓨터가 존재하지 않는건가 할 수 있겠지만, amazon 회사 건물에 있는 서버 일부를 우리에게 빌려주는 것이라 생각하면 된다.</p><h2 id="인스턴스-생성하기">인스턴스 생성하기</h2><p>인스턴스는 EC2에서 대여받는 가상 켬퓨터이다. EC2는 서비스 이름이라면 인스턴스는 그 서비스에서 제공해주는 제품인 셈이다. 인스턴스 유형은 <a href="https://aws.amazon.com/ko/ec2/instance-types/">해당 페이지</a>에서 확인할 수 있다. 보통 딥러닝 모델을 학습할 때는 GPU 인스턴스인 P나 G를 사용한다.</p><p><strong>NOTE</strong> 만약 사용하려는 인스턴스의 시간 당 비용이 궁금하다면 <a href="https://calculator.aws/#/">비용 계산기</a>에 들어가서 먼저 확인해볼 수 있다. 해당 프로젝트에서 사용하려는 인스턴스는 시간 당 0.7달러 정도가 청구된다고 보여준다.</p><h3 id="키-페어-생성">1. 키 페어 생성</h3><p>키 페어(key pairs)는 인스턴스 사용자의 정보를 암호화하고 해독하는 키와 값이다. 이는 EC2를 해당 키 페어를 가진 사용자만 SSH로 접속할 수 있도록 하여 다른 이가 사용할 수 없도록 해준다. EC2 인스턴스를 생성하기 위해서는 필수적으로 만들어야 한다. 아래의 코드를 입력하여 키 페어를 생성해주자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws ec2 create-key-pair --key-name <span class="hljs-string">&#x27;키 페어 이름&#x27;</span> --query <span class="hljs-string">&#x27;KeyMaterial&#x27;</span> --output text &gt; <span class="hljs-string">&#x27;키 페어 이름&#x27;</span>.pem<br></code></pre></td></tr></table></figure><p>이후 AWS EC2 콘솔 페이지에서 키 페어가 생성되었는지 확인할 수 있으며, 해당 커맨드라인의 디렉토리에서 <code>키 페어 이름.pem</code> 를 찾을 수 있다. 만약 키 페어를 삭제하고 싶다면 아래의 코드를 입력하면 삭제된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws ec2 delete-key-pair --key-name <span class="hljs-string">&#x27;키 페어 이름&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="보안-그룹-생성">2. 보안 그룹 생성</h3><p>보안 그룹(Security Groups)이란 네트워크 트래픽(접근)을 모니터링하고 제어하는 가상 방화벽이며, 모든 EC2 인스턴스는 보안 그룹에 속해 있어야 한다. 이런 보안 그룹을 사용하는 이유는 해당 인스턴스에 요청하는 .보안 그룹의 세부적인 설정을 살펴보면 다음과 같다.</p><ul><li>보안 그룹 ID</li><li>보안 그룹 이름</li><li>VPC ID (가상 네트워크망 ID)</li><li>소유자</li><li>인바운드 규칙</li><li>아웃바운드 규칙</li></ul><p><strong>NOTE</strong> 인바운드 규칙: 인스턴스로 들어오는 트래픽들을 제어한다. 보통 혼자 사용하는 가상 서버인 경우 SSH를 설정하여 키를 가진 사람들만 들어올 수 있게 하며, 만약 웹페이지를 호스팅하는 서버라면 HTTP와 같은 PC 사용자들만 들어올 수 있게 허용할 수도 있다. 아웃바운드 규칙: 인스턴스에서 다른 인스턴스로 나가는 트레픽을 제어한다. 보통 아웃바운드는 모두 허용으로 설정한다.</p><p>이제 간단하게 커맨드라인에 아래의 코드를 입력하여 보안그룹을 생성해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws ec2 create-security-group --group-name <span class="hljs-string">&#x27;보안 그룹 이름&#x27;</span> --description <span class="hljs-string">&#x27;보안 그룹 설명&#x27;</span><br></code></pre></td></tr></table></figure><p>위의 코드를 입력하면 보안 그룹 ID가 나타날 것이다. 이후 EC2 인스턴스를 생성할 때 필요하니 적어두거나 복사해두는 것이 좋다. 만약 예전에 설정했던 보안 그룹 이름은 기억이 나는데 ID를 잊어버렸다면 아래의 코드를 입력하여 해당 보안 그룹의 전반적인 정보들을 확인할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws ec2 describe-security-groups --group-names <span class="hljs-string">&#x27;보안 그룹 이름&#x27;</span><br></code></pre></td></tr></table></figure><p>다음으로는 해당 인스턴스에 우리만 접속할 수 있도록 인바운드에 SSH를 설정해준다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws ec2 authorize-security-group-ingress --group-name <span class="hljs-string">&#x27;보안 그룹 이름&#x27;</span> --protocol tcp --port 22 --cidr <span class="hljs-string">&#x27;내 IP&#x27;</span><br></code></pre></td></tr></table></figure><p>위 코드에서 <code>tcp</code>는 연결된 컴퓨터의 데이터를 오류없이 전송할 수 있도록 해주는 개방형 프로토콜이며, <code>port</code>는 컴퓨터 프로그램이 가지는 고유한 번호이다 (SSH의 경우는 22번을 사용한다). 마지막으로 <code>cidr</code>은 '사이더'라는 IP 할당 방법이며, 우리는 해당 인스턴스를 본인만 사용할 것이기에 개인적으로 사용하는 IP를 설정해주면 된다. 이후 다시 그룹 정보를 확인하면 인바운드 규칙이 변경된 것을 확인할 수 있다. 만약 보안 그룹을 삭제하고 싶다면 아래의 코드를 입력하면 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws ec2 delete-security-group --group-name <span class="hljs-string">&#x27;보안 그룹 이름&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="인스턴스-생성">3. 인스턴스 생성</h3><p>이제 인스턴스를 생성해보자. 커맨드라인에서 바로 인스턴스를 생성하기 위해서는 사용할 인스턴스의 AMI를 알아야 한다. <a href="https://aws.amazon.com/ko/">AWS 사이트</a> 로그인한 후 콘솔에 들어가면 여러 종류의 이미지들을 살펴볼 수 있다. 우리는 프리티어가 사용할 수 있는 Linux기반의 인스턴스를 사용할 것이다. 해당 AMI와 인스턴스 타입은 다음과 같다.</p><ul><li>image-id : ami-064c81ce3a290fde1 (Amazon Linux AMI 2018.03.0 (HVM), SSD Volume Type (Free tier))</li><li>instance-type: t2.micro</li></ul><p>이제 아래의 코드를 입력하여 EC2 인스턴스를 생성해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws ec2 run-instances --image-id <span class="hljs-string">&#x27;인스턴스 이미지&#x27;</span> --count <span class="hljs-string">&#x27;인스턴스 수&#x27;</span> --instance-type <span class="hljs-string">&#x27;인스턴스 타입&#x27;</span> --key-name <span class="hljs-string">&#x27;키 페어 이름&#x27;</span> --security-groups <span class="hljs-string">&#x27;보안 그룹 이름&#x27;</span><br></code></pre></td></tr></table></figure><p>그럼 아래와 같이 생성된 인스턴스의 정보가 나타난다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br>    <span class="hljs-string">&quot;Groups&quot;</span>: [],<br>    <span class="hljs-string">&quot;Instances&quot;</span>: [<br>        &#123;<br>.<br>.<br>.        &#125;<br>    ],<br>    <span class="hljs-string">&quot;OwnerId&quot;</span>: <span class="hljs-string">&quot;---------&quot;</span>,<br>    <span class="hljs-string">&quot;ReservationId&quot;</span>: <span class="hljs-string">&quot;---------&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>현재 인스턴스가 생성되었는지 확인해보자. 아래의 코드를 입력하면 인스턴스 ID 목록을 확인할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws ec2 describe-instances --filters <span class="hljs-string">&quot;Name=instance-type,Values=t2.micro&quot;</span> --query <span class="hljs-string">&quot;Reservations[].Instances[].InstanceId&quot;</span><br></code></pre></td></tr></table></figure><h3 id="인스턴스-종료">3. 인스턴스 종료</h3><p>현재 우리가 만든 EC2 인스턴스가 있다. 주의할 점은 EC2 인스턴스가 작동되는 순간부터 요금책정이 시작된다. (다행히 우리가 사용하는 인스턴스는 프리 티어 전용이라서 요금이 청구되지는 않는다) 즉, 인스턴스를 사용하지 않을 때에는 꼭 종료해주어야 한다. 아래의 코드를 입력하여 생성했던 인스턴스를 종료해보자. 인스턴스 ID는 위 코드를 입력하여 확인할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">aws ec2 terminate-instances --instance-ids <span class="hljs-string">&#x27;인스턴스 ID&#x27;</span><br></code></pre></td></tr></table></figure><p>지금까지 AWS EC2 인스턴스를 생성하는 방법에 대해 알아보았다.</p>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
      <category>aws</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AWS</tag>
      
      <tag>cloud</tag>
      
      <tag>클라우드</tag>
      
      <tag>Amazon</tag>
      
      <tag>아마존</tag>
      
      <tag>터미널</tag>
      
      <tag>boto3</tag>
      
      <tag>S3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>S3에 데이터 업로드하기</title>
    <link href="/ko/AWS/AWS-3/"/>
    <url>/ko/AWS/AWS-3/</url>
    
    <content type="html"><![CDATA[<p>터미널에서 코드만을 사용하여 AWS S3 버킷에 접속하는 방법을 정리합니다. <span id="more"></span></p><hr /><h2 id="aws-s3">AWS S3</h2><p>S3(Simple Storage Service)는 AWS에서 제공하는 데이터 저장소이다. S3는 웹 기반으로 이루어져 있기 때문에 정적 휍 호스팅을 직접 관리할 수 있으며, 가상 서버인 EC2와도 데이터를 주고 받을 수 있다. 또한 데이터 저장량을 미리 결정해야 하는 EBS와 달리 S3는 무제한으로 데이터를 저장할 수 있다. 경제적인 이점을 제외하고서도 이런 장점들로 인해서 S3는 많이 사용된다.</p><h3 id="객체-object">객체 (object)</h3><p>객체는 S3에 데이터가 저장되는 기본 단위이다. 객체 종류로는 파일과 메타데이터가 있다. 일반적인 파일은 1개당 1Byte부터 5TB 까지 저장 가능하며, 메타데이터는 MIME 형식으로 파일 확장자를 자동으로 변경하여 저장된다. 메타데이터의 확장자는 사용자가 임의로 설정할 수도 있다.</p><h3 id="버킷-bucket">버킷 (bucket)</h3><p>버킷 (bucket)은 S3에서 데이터를 저장하는 최상위 저장소이다. 모든 데이터들은 버킷 안에 저장할 수 있으며, 버킷 없이 데이터를 업로드하는 것은 불가능하다. 각 AWS 계정별로 100개까지 생성할 수 있으며, 각 버킷에는 무제한으로 객체들을 저장할 수 있다.</p><h2 id="boto3-library">boto3 library</h2><p><code>boto3</code>는 파이썬에서 S3를 사용할 수 있도록 해주는 라이브러리이다. 아직 다운받지 않았다면 아래의 코드를 입력하면 된다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt; pip3 install boto3<br></code></pre></td></tr></table></figure><p>다운이 완료되었다면 그 다음으로는 파이썬에 접속한 후 아래의 코드를 입력하여 해당 라이브러리를 가져온다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt; <span class="hljs-keyword">import</span> boto3<br></code></pre></td></tr></table></figure><h2 id="버킷-생성하기">버킷 생성하기</h2><p>커맨드라인에서 S3를 사용할 준비가 완료되었다. 이제부터는 훈련 데이터를 넣을 버킷을 생성해보자. 아래의 코드를 입력하여 S3에 접속한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt; s3 = boto3.client(<span class="hljs-string">&#x27;s3&#x27;</span>)<br></code></pre></td></tr></table></figure><p>그 다음 버킷 이름을 설정하고, 버킷을 생성한다. 아래의 코드는 서울을 지역으로 설정하여 설정한 이름의 버킷을 생성한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt; bucket_name = <span class="hljs-string">&#x27;원하는 이름&#x27;</span><br>&gt; s3.create_bucket(Bucket = bucket_name, CreateBucketConfiguration = &#123;<span class="hljs-string">&#x27;LocationConstraint&#x27;</span>: <span class="hljs-string">&#x27;ap-northeast-2&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure><p><strong>Warining</strong><br />버킷의 이름은 전세계적으로 단 하나의 이름이어야 한다. 따라서 만약 누군가 사용하고 있는 이름을 입력하면 아래와 같은 오류가 발생하고, 버킷이 생성되지 않는다.</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">Traceback (most recent call last):<br> File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br> File <span class="hljs-string">&quot;/usr/local/lib/python3.7/site-packages/botocore/client.py&quot;</span>, line <span class="hljs-number">337</span>, <span class="hljs-keyword">in</span> _api_call<br>   <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._make_api_call(operation_name, kwargs)<br> File <span class="hljs-string">&quot;/usr/local/lib/python3.7/site-packages/botocore/client.py&quot;</span>, line <span class="hljs-number">656</span>, <span class="hljs-keyword">in</span> _make_api_call<br>   <span class="hljs-keyword">raise</span> error_class(parsed_response, operation_name)<br>botocore.errorfactory.BucketAlreadyExists: An error occurred (BucketAlreadyExists) when calling the CreateBucket operation: The requested bucket name <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> available. The bucket namespace <span class="hljs-keyword">is</span> shared by <span class="hljs-built_in">all</span> users of the system. Please select a different name <span class="hljs-keyword">and</span> <span class="hljs-keyword">try</span> again.<br></code></pre></td></tr></table></figure></p><p>버킷 이름을 만들 때 주의해야 할 요소는 아래와 같다.</p><ul><li><p>버킷 이름은 3~63자로 이루어져야 하며 소문자와 숫자, 마침표 및 대시만 포함할 수 있다.</p></li><li><p>버킷 이름은 소문자 또는 숫자로 시작해야 한다.</p></li><li><p>버킷 이름은 밑줄을 포함하거나, 대시로 끝나거나, 마침표가 있거나, 마침표와 인접해 대시를 사용할 수 없다.</p></li><li><p>버킷 이름에 IP 주소 형식(198.51.100.24)을 사용할 수 없다.</p></li></ul><p>이제 버킷 생성이 잘 되었는지 확인해보자. 아래의 코드를 입력하면 해당 계정의 버킷들의 목록을 볼 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt; s3.list_buckets()<br></code></pre></td></tr></table></figure><p>또한 AWS 사이트에 직접 로그인하여 S3를 확인해봐도 버킷이 생성되었음을 확인할 수 있다.</p><figure><img src="/images/91.png" alt="AWS3_1" /><figcaption aria-hidden="true">AWS3_1</figcaption></figure><h2 id="버킷에-훈련-데이터-업로드하기">버킷에 훈련 데이터 업로드하기</h2><p>해당 프로젝트에서는 간단하게 손글씨 데이터인 <code>MNIST</code>를 사용할 예정이다. <a href="https://github.com/Hyeonji-Ryu/AWS_project/tree/master/MNIST_CPU">깃허브</a>에 가면 MNIST 데이터를 바로 다운받을 수 있다. 데이터 압축을 풀면 확장자 <code>plckle</code>인 MNIST 데이터 파일이 4개가 있을 것이다. 데이터 정보는 다음과 같다.</p><ul><li>train_x.pickle : 훈련 이미지 데이터 (shape: 60000 x 28 x 28 x 1)</li><li>train_y.pickle : 훈련 정답 데이터 (shape: 60000)</li><li>test_x.pickle : 검증 이미지 데이터 (shape: 10000 x 28 x 28 x 1)</li><li>test_y.pickle : 검증 정답 데이터 (shape: 10000)</li></ul><p><strong>NOTE</strong><br />왜 파일 확장자로 <code>plckle</code>를 사용했는가?<br />그 이유는 해당 데이터 중 일부가 4차원 배열이기 때문이다. csv나 text 등의 확장자들은 2차원까지만 저장이 가능하다. 하지만 plckle은 파이썬 객체 자체를 파일로 저장하는 방식이기 때문에 다양한 구조의 데이터들을 비교적 쉽게 저장하고 불러올 수 있다.</p><p>다운로드가 완료되었다면 먼저 저장된 데이터가 있는 폴더로 디렉토리를 변경해주어야 한다.</p><p>아래의 코드를 입력하여 현재 경로를 확인해보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt; <span class="hljs-keyword">import</span> os<br>&gt; os.getcwd()<br></code></pre></td></tr></table></figure><p>확인했을 때 데이터 저장된 위치와 다르다면, 아래의 코드를 사용하여 알맞게 변경해준다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.chdir(<span class="hljs-string">&#x27;변경할 주소 입력&#x27;</span>)<br></code></pre></td></tr></table></figure><p>그 다음 데이터들을 생성한 버킷에 업로드한다. 해당 코드는 아래와 같다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s3.upload_file(<span class="hljs-string">&#x27;업로드할 파일 이름&#x27;</span>, <span class="hljs-string">&#x27;버킷 이름&#x27;</span>, <span class="hljs-string">&#x27;버킷에 저장할 이름&#x27;</span>)<br></code></pre></td></tr></table></figure><p>그후 사이트에 들어가 확인해보면 아래 그림과 같은 변화를 확인할 수 있다.</p><figure><img src="/images/92.png" alt="AWS3_2" /><figcaption aria-hidden="true">AWS3_2</figcaption></figure><p>지금까지 커맨드라인에서 S3의 버킷을 생성하고 데이터를 업로드하는 방법을 살펴보았다.</p>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
      <category>aws</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AWS</tag>
      
      <tag>cloud</tag>
      
      <tag>클라우드</tag>
      
      <tag>Amazon</tag>
      
      <tag>아마존</tag>
      
      <tag>터미널</tag>
      
      <tag>boto3</tag>
      
      <tag>S3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>커맨드라인으로 AWS 접속하기</title>
    <link href="/ko/AWS/AWS-2/"/>
    <url>/ko/AWS/AWS-2/</url>
    
    <content type="html"><![CDATA[<p>터미널에서 코드만을 사용하여 AWS에 접속하는 과정을 정리합니다. <span id="more"></span></p><hr /><h2 id="download-awscli">download awscli</h2><p>awscli(AWS command line interface)는 커맨드라인에서 AWS의 API를 직접 호출할 수 있도록 도와주는 도구이다. 커맨드라인에 아래의 코드를 입력하여 해당 툴을 다운받아보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip3 install awscli<br></code></pre></td></tr></table></figure><p>다운이 완료되었다면 로컬에 엑세스 키를 등록해야 한다. 그렇다면 엑세스 키는 무엇이고 어디서 받을 수 있을까? 이에 대해 잠깐 살펴보고 넘어가자.</p><h2 id="use-access-key">Use Access Key</h2><p>엑세스 키(Access Key)는 IAM 사용자 계정을 해당 컴퓨터와 연결할 때 사용되는 정보이다. 즉, 각 IAM 사용자 계정에는 고유한 엑세스 키가 있으며, 이를 등록해야 해당 커맨드라인에서 AWS로 접속이 가능하다. 본인의 엑세스 키는 해당 계정을 생성한 직후에만 공개되기 때문에 미리 다른 곳에 적어두어야 한다. 그럼 이제 엑세스 키를 이용하여 AWS에 접속해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aws configure<br></code></pre></td></tr></table></figure><p>커맨드라인에 위의 코드를 입력하면 총 4개의 입력란이 등장한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">AWS Access Key ID [None]: <span class="hljs-comment"># IAM 사용자 계정 키 입력</span><br>AWS Secret Access Key [None]: <span class="hljs-comment"># IAM 사용자 계정 비밀 키 입력</span><br>Default region name [None]: <span class="hljs-comment"># 지역 (서울: ap-northeast-2) 입력</span><br>Default output format [None]:<br></code></pre></td></tr></table></figure><p>위의 설명에 따라 값들을 입력한 후 엔터를 누르면 AWS와 연결된다.</p><p><span class="math inline">\(\bullet\)</span> AWS Access Key ID IAM 계정 만들 당시 시크릿 키와 같이 제공된다. 해당 키는 IAM 콘솔에서 다시 확인할 수 있다.</p><p><span class="math inline">\(\bullet\)</span> AWS Secret Access Key 해당 키는 계정을 생성한 직후에만 볼 수 있기 때문에 꼭 잊지 말고 복사해두어야 한다.</p><p><span class="math inline">\(\bullet\)</span> Default region name API를 가져오는 지역을 설정하는 것이다. 서울은 <code>ap-northeast-2</code>를 입력하면 된다. 다른 지역은 <a href="https://aws.amazon.com/ko/about-aws/global-infrastructure/regional-product-services/">지역 표</a>에서 확인할 수 있다.</p><p><span class="math inline">\(\bullet\)</span> Default output format AWS에서 도출한 결과를 어떤 형태로 저장할지 설정한다. text, json, table 중에 하나를 선택할 수 있다.</p><p>설명한 기본적인 지식 외에도 AWS 명령어에 대해 자세히 알고 싶다면 <a href="https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/cli-configure-options.html">AWS 명령줄 옵션</a>에서 확인하면 된다.</p><p>이제 커맨드라인에서 AWS를 실행할 준비가 모두 완료되었다.</p>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
      <category>aws</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AWS</tag>
      
      <tag>cloud</tag>
      
      <tag>클라우드</tag>
      
      <tag>Amazon</tag>
      
      <tag>아마존</tag>
      
      <tag>터미널</tag>
      
      <tag>boto3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AWS 계정 생성하기</title>
    <link href="/ko/AWS/AWS-1/"/>
    <url>/ko/AWS/AWS-1/</url>
    
    <content type="html"><![CDATA[<p>AWS에서 계정을 만드는 방법을 정리합니다. <span id="more"></span></p><hr /><h2 id="aws-계정의-종류">AWS 계정의 종류</h2><p>AWS 사이트에 들어가 로그인을 눌러보면 아래의 그림과 같이 루트 사용자와 IAM 사용자라는 2가지의 로그인 방식이 나온다.</p><figure><img src="/images/83.png" alt="AWS1" /><figcaption aria-hidden="true">AWS1</figcaption></figure><p>그렇다면 이 두 사용자의 차이는 무엇일까? 이에 대해서 하나씩 살펴보자.</p><ul><li><p>루트 사용자 루트 사용자(root user)는 이름에서도 알 수 있듯이 AWS의 모든 서비스를 통제할 수 있는 가장 근본적인 계정이다. 가상 서버나 데이터 스토리지를 활성화하는 등의 AWS의 기초적인 서비스들을 활성화할 수 있으며, IAM 사용자 계정에 특정 권한을 부여할 수도 있다. 만약 작은 회사가 AWS를 사용한다면 루트 사용자 계정은 인사 관리자나 업무를 할당해주는 담당자가 맡아서 관리할 것이다.</p></li><li><p>IAM 사용자 IAM 사용자는 루트 사용자가 위임해준 권한만을 사용할 수 있는 계정이다. 예를 들어 DB 관리자에게 데이터베이스에 접근할 수 있는 권한을 줄 때, 루트 계정에 IAM 사용자를 추가하여 데이터베이스 접근 권한만을 위임하면 된다. IAM 사용자를 사용하는 이유는 권한을 나눔으로써 데이터 유실 등 예상치 못한 피해를 막기 위함이다.</p></li></ul><h2 id="aws-계정-생성하기">AWS 계정 생성하기</h2><p>이제 위에서 살펴봤던 계정들을 직접 생성해보자. 먼저 루트 사용자 계정을 만들 것이다. 계정 로그인 하단에 보면 <code>AWS 계정 새로 만들기</code>라는 버튼이 있다. 이 버튼을 누르면 아래와 같은 페이지가 나타난다.</p><figure><img src="/images/84.png" alt="AWS2" /><figcaption aria-hidden="true">AWS2</figcaption></figure><p>빈칸에 알맞은 개인 정보를 입력하고 아래의 <code>계정 만들기</code>를 누르면 새로운 계정을 만들 수 있다. 여기서 생성되는 계정은 <strong>루트 사용자 계정</strong>이다. 위 이미지 왼쪽에 보면 <code>프리 티어 엑세스 포함</code>이라는 문구를 확인할 수 있다. 프리 티어(free tier)란 아마존에서 제공하는 서비스 중 일부를 무료로 체험해볼 수 있는 서비스이다. 보통 계정을 새로 만들 때 해당 서비스가 자동으로 포함된다. 만약 프리 티어에 대해 자세히 알고 싶다면 <a href="https://aws.amazon.com/ko/free/?all-free-tier.sort-by=item.additionalFields.SortRank&amp;all-free-tier.sort-order=asc">해당 페이지</a>를 확인해보자.</p><p>루트 사용자 계정을 생성했다면 다음으로 IAM 사용자 계정을 추가해보자. IAM 계정을 추가하는 방법은 다음과 같다.</p><p><strong>(1) 루트 계정 로그인한 후, 오른족 상단의 내 계정에서 보안 자격 증명으로 들어간다.</strong></p><figure><img src="/images/85.png" alt="AWS3" /><figcaption aria-hidden="true">AWS3</figcaption></figure><p><strong>(2) 아래의 사진과 같은 페이지가 나오면 대시보드의 '그룹'을 클릭하여 들어간다.</strong></p><figure><img src="/images/86.png" alt="AWS4" /><figcaption aria-hidden="true">AWS4</figcaption></figure><p><strong>(3) 그룹에서 새로운 그룹 생성을 누른 후, 해당 그룹의 이름을 입력하고 다음 단계로 넘어간다. 보통 그룹 이름으로는 직군을 사용한다.</strong></p><figure><img src="/images/87.png" alt="AWS5" /><figcaption aria-hidden="true">AWS5</figcaption></figure><p><strong>(4) 헤당 그룹에 부여할 권한을 선택한다. 해당 프로젝트에서는 가상 서버를 돌리고 훈련 데이터를 저장해야 하기 때문에 <code>AmazonEC2FullAccess</code>와 <code>AmazonS3FullAccess</code>, <code>AdministratorAccess</code> 권한을 얻을 것이다. 이것들을 찾아서 체크한 후 다음 단계로 넘어간다.</strong></p><figure><img src="/images/88.png" alt="AWS6" /><figcaption aria-hidden="true">AWS6</figcaption></figure><p><strong>(5) 검토에서 최종적으로 확인한 후 그룹을 생성한다. 이제 IAM 사용자 계정을 만들 수 있는 그룹이 생겼다. 해당 그룹 안에 IAM 사용자를 추가해보자.</strong></p><p><strong>(6) 대시보드에 '사용자' 파트로 들어가서 사용자 추가를 클릭한 후, 이름을 입력하고 프로그래밍 방식 엑세스를 선택한다. 우리는 커맨드라인에서 바로 AWS을 연결하기 때문에 콘솔 로그인은 제외하였다. 만약 콘솔로도 해당 계정을 사용하고 싶다면 아래의 엑세스 방식도 추가로 선택할 수 있다.</strong></p><figure><img src="/images/89.png" alt="AWS7" /><figcaption aria-hidden="true">AWS7</figcaption></figure><p><strong>(7) 아까 만들었던 그룹에 해당 사용자를 추가한다. 아래에 나타나는 그룹을 클릭한 뒤, 다음 단계로 넘어가면 된다.</strong></p><figure><img src="/images/90.png" alt="AWS8" /><figcaption aria-hidden="true">AWS8</figcaption></figure><p><strong>(8) 다음으로는 태그 설정이다. 보통 회사에서는 직위와 이메일, 사내 번호 등을 추가하여 사용자의 정보를 추가한다. 하지만 우리는 개인 계정이기 때문에 그냥 다음 단계로 바로 넘어간다. 이후 한번 더 검토를 한 후 <code>사용자 만들기</code>를 누르면 IAM 사용자 추가가 완료된다.</strong></p><p><strong>Warning</strong> IAM 사용자를 생성하면 엑세스 키와 엑세스 시크릿 키가 제공된다. 사용자를 생성할 때만 볼 수 있기 때문에 잊지 말고 다른 곳에 옮겨 적어두어야 한다.</p><p>지금까지 AWS 계정의 종류와 생성 방법에 대해서 알아보았다. 다음 글에서는 생성한 IAM 계정을 통해 커맨드라인에서 AWS을 연결하는 방법에 대해서 알아볼 것이다.</p>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
      <category>aws</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AWS</tag>
      
      <tag>cloud</tag>
      
      <tag>클라우드</tag>
      
      <tag>Amazon</tag>
      
      <tag>아마존</tag>
      
      <tag>계정</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AWS 기초</title>
    <link href="/ko/AWS/AWS-0/"/>
    <url>/ko/AWS/AWS-0/</url>
    
    <content type="html"><![CDATA[<p>클라우드 컴퓨팅 종류에 대해 알아보고 AWS의 기본 서비스들을 정리합니다. <span id="more"></span></p><hr /><h2 id="cloud-computing">Cloud Computing</h2><p>클라우드 컴퓨팅이란 클라우드에서 가상 서버, 데이터 스토리지, 소프트웨어 등 필요한 IT 자원을 임대하여 사용하는 기술이다. 클라우드 컴퓨팅 서비스는 크게 3가지 종류로 나뉜다.</p><h3 id="iaas-infrastructure-as-a-service">IaaS (Infrastructure as a Service)</h3><p>IaaS (Infrastructure as a Service)는 실제 하드웨어로 마련해야 하는 서버나, 데이터 스토리지 등의 자원들을 가상으로 제공해주는 서비스이다. 이를 사용하면 물리적인 GPU나 SDD 없이도 무거운 딥러닝 모델을 훈련시킬 수 있다. 해당 프로젝트에서 우리는 이 서비스를 사용할 예정이다.</p><h3 id="paas-platform-as-a-service">PaaS (Platform as a Service)</h3><p>PaaS (Platform as a Service)는 IaaS에서 제공하는 하드웨어와 사용자가 원하는 서비스를 개발할 수 있는 환경을 모두 제공하는 서비스이다. 즉, "IaaS + Platform" 이라고도 할 수 있다. 보통 웹을 구축하기 위해서는 물리적인 하드웨어인 서버를 사고 해당 서버 위에 운영체제 등을 설치해야 서비스를 개발할 수 있지만, 이 서비스를 이용하면 바로 서비스 개발에 들어갈 수 있다.</p><h3 id="saas-software-as-a-service">SaaS (Software as a Service)</h3><p>SaaS (Software as a Service)는 클라우드 기반의 프로그램을 제공하는 서비스이다. 해당 클라우드는 소프트웨어를 앱처럼 다운받아서 사용하거나 데스크탑에서 바로 저장소로도 사용할 수 있다. 일반적으로 사용하는 네이버 클라우드나 구글 드라이브 등이 이 서비스에 해당한다.</p><h2 id="amazon-web-services-aws">Amazon Web Services (AWS)</h2><p>클라우드 서비스를 제공하는 기업은 크게 아마존(Amazon), 구글(Google), 마이크로소프트(MS), IBM 등이 있다. 우리는 이중에서 현재 업계 1위인 아마존을 사용할 것이다. 프로젝트를 진행해가면서 자세하게 다루겠지만, 먼저 AWS에서 우리가 사용할 서비스에 대해서 간단하게 살펴보자.</p><h3 id="elastic-compute-cloud-ec2">Elastic Compute Cloud (EC2)</h3><p>EC2는 클라우드 기반의 가상 서버를 제공하는 서비스이다. 보통 EC2의 인스턴스를 만들어 가상 서버 환경을 구축한다. EC2를 통해 가상 환경을 구축하기 위해서는 AMI를 선택하고, 해당 서버에서 운용할 데이터를 넣어둘 저장장치(볼륨)를 선택해야 한다.</p><h3 id="amazon-machine-image-ami">Amazon Machine Image (AMI)</h3><p>AMI는 서버 바로 위에 구축해야 하는 환경들을 조합해둔 템플릿이다. 아마존에는 딥러닝을 위한 이미지(Deep Learning AMI)도 존재하며, 해당 이미지에는 텐서플로우, 파이토치 등 구현에 필요한 프레임워크까지 모두 포함되어 있다. 즉, 해당 이미지를 선택하여 EC2에 올리면 바로 딥러닝 모델 학습을 시작할 수 있는 것이다.</p><h3 id="elastic-block-storage-ebs">Elastic Block Storage (EBS)</h3><p>EBS는 EC2에서 사용될 데이터나 학습 이후의 결과물 등을 저장하고 사용할 수 있는 임시 저장장치이다. 흔히 하드웨어에서 HDD나 SSD와 같은 역할을 한다. 다만, 가상 서버인 EC2가 멈추면 EBS에 있던 자료도 제거되기 때문에 주의해야 한다. 물론 EBS도 영구적으로 만들어 사용할 수는 있지만 있지만, 가격이 비싸기 때문에 보통 가상 서버에서만 사용한다.</p><h3 id="simple-storage-service-s3">Simple Storage Service (S3)</h3><p>S3 또한 데이터를 저장할 수 있는 저장장치이며, EBS보다 저렴하고 데이터를 무한대로 저장할 수 있다는 장점이 있다. S3는 데이터를 저장한 용량에 대비하여 저렴한 비용이 청구되지만 EBS는 선택한 용량 전체에 대해서 비용이 청구되기 때문에 가상 서버를 돌리지 않을 때에는 데이터들을 S3에 저장해두는 것이 훨씬 저렴하다.</p>]]></content>
    
    
    <categories>
      
      <category>DevOps</category>
      
      <category>aws</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AWS</tag>
      
      <tag>cloud</tag>
      
      <tag>클라우드</tag>
      
      <tag>Amazon</tag>
      
      <tag>아마존</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[18/18] 간단한 CNN 모델 구현</title>
    <link href="/ko/DeeplearningJulia/Deeplearning-18/"/>
    <url>/ko/DeeplearningJulia/Deeplearning-18/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다. <span id="more"></span></p><hr /><p>지금까지 <code>im2col()</code>, <code>col2im()</code>을 적용한 새로운 합성곱과 풀링에 대해 알아보았다. 이번 글에서는 새로운 합성곱과 풀링을 사용하여 새로운 <code>simpleNet</code>을 구현할 것이다. <code>im2col()</code>, <code>col2im()</code>을 적용하지 않은 기존 <code>simpleNet</code>은 1에폭에 1시간이 걸린 반면 새로운 <code>simpleNet</code>은 1에폭에 5분이면 학습이 완료된다.</p><h2 id="cnn-모델-구현">CNN 모델 구현</h2><h3 id="준비-단계">준비 단계</h3><p>이제 설계한 모델을 직접 구현해보자. 먼저 모델을 생성하고 학습하는데 필요한 재료들을 가져와야 한다. <a href="https://github.com/Hyeonji-Ryu/Deep_Learning_in_Julia">해당 깃허브 사이트</a>에 가서 코드를 다운받으면 바로 학습을 진행할 수 있다. 만약 다운받기 싫다면 <a href="https://github.com/Hyeonji-Ryu/Deep_Learning_in_Julia/tree/master/CNN">이 사이트</a>에서 아래의 파일들의 코드를 모두 복사해서 사용해도 된다.</p><p>깃허브 데스크탑에 코드를 클론하거나 저장한 분들은 현재 사용하고 있는 커맨드의 경로를 <code>CNN</code> 파일로 변경해야 한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">pwd <span class="hljs-comment"># 현재 경로 확인</span><br>cd 코드가 있는 파일 경로 입력/Deep_Learning_in_Julia/CNN<br></code></pre></td></tr></table></figure><p>다시 <code>pwd</code>를 입력했을 때 아래와 같이 변경되어 있으면 변경이 완료된 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">/Users/코드가 있는 파일 경로/Deep_Learning_in_Julia/CNN<br></code></pre></td></tr></table></figure><p>변경이 완료된 후 아래의 코드를 입력하자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">include(<span class="hljs-string">&quot;MNIST_data.jl&quot;</span>)<br>include(<span class="hljs-string">&quot;functions.jl&quot;</span>)<br>include(<span class="hljs-string">&quot;layers.jl&quot;</span>)<br>include(<span class="hljs-string">&quot;making_network.jl&quot;</span>)<br>include(<span class="hljs-string">&quot;optimizers.jl&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>Note</strong> 만약 터미널 변경에는 성공했는데 위 코드가 작동하지 않는다면 해당 터미널이 줄리아 언어로 세팅되어 있는지를 확인해보자. 줄리아 언어로 변경하는 방법은 줄리아가 저장되어 있는 경로를 찾아서 입력하면 사용할 수 있다.</p><p>위 코드는 파일에 들어 있는 모든 코드들을 작동시킨다. 만약 코드를 복사하여 사용할 분들은 <a href="https://github.com/Hyeonji-Ryu/Deep_Learning_in_Julia/tree/master/CNN">해당 페이지</a>에서 위의 파일들의 코드를 복사하여 입력해주면 된다.</p><p>이제 간단한 CNN 모델을 만들 준비가 끝났다.</p><h3 id="cnn-모델-설계">CNN 모델 설계</h3><p><code>MNIST</code> 데이터는 간단하게 손글씨로 쓴 숫자이기에 비교적 얕은 모델로도 높은 성능의 분류기를 만들 수 있다. 아래의 그림을 참고해보자.</p><figure><img src="/images/81.png" alt="model" /><figcaption aria-hidden="true">model</figcaption></figure><p>위의 각 계층들에 대한 세부적인 정보는 아래와 같다.</p><ul><li>input data: MNIST, batch = 100, data_shape = 28 x 28 x 1 x 100</li><li>합성곱 계층: padding 없음, stride = 1, filter size = 5 x 5 x 1 x 30, output = 24 x 24 x 30 x 100</li><li>ReLU 계층: 음수 0으로 변경, output = 24 x 24 x 30 x 100</li><li>풀링 계층: padding 없음, stride = 2, pooling size = 2 x 2, output = 12 x 12 x 30 x 100</li><li>flatten 계층: 4차원 데이터를 2차원으로 변경, output = 100 x 4320</li><li>Dense 계층: weight size = 4320 x 100, bias = 1 x 100, output = 100 x 100</li><li>ReLU 계층: 음수 0으로 변경, output = 100 x 100</li><li>Dense 계층: weight size = 100 x 10, bias = 1 x 10, output = 100 x 10</li><li>softmax with loss 계층: 손실 값 도출</li></ul><p>각 계층들을 살펴보면 데이터가 어떻게 변화하면서 흐르는지 파악할 수 있다. 매우 간단한 모델이지만, MLP보다는 훨씬 좋은 성능을 보여준다.</p><p>학습 알고리즘은 아래와 같이 설계하여 진행할 것이다.</p><ul><li>Algorithm: backward propagation</li><li>batch size: 100</li><li>optimizer: Adam</li><li>weight initialization: std</li></ul><h3 id="학습-구현">학습 구현</h3><p>학습을 구현하기 위해서는 총 3가지의 과정을 거쳐야 한다.</p><ul><li><code>predict()</code> 및 저장소 설정</li><li>가중치와 편향 초기값 설정</li><li>모델 계층 쌓기</li></ul><p>먼저 <code>predict()</code>를 위의 모델 설계에 따라 구성해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span>  predict(input)<br><br>    pconv_1 = convolution2D_forward(pre_dense,input, params[<span class="hljs-string">&quot;W1&quot;</span>], params[<span class="hljs-string">&quot;b1&quot;</span>],<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br>    pconv_Re = relu.(pconv_1)<br>    ppool_1 = Maxpooling_forward(pre_pool,pconv_Re, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>)<br>    flatten_1 = flatten_forward_batch(pre_flatten,ppool_1)<br>    dense_1 = (flatten_1 * params[<span class="hljs-string">&quot;W2&quot;</span>]) .+ params[<span class="hljs-string">&quot;b2&quot;</span>]<br>    dense_relu = relu.(dense_1)<br>    dense_2 = (dense_relu * params[<span class="hljs-string">&quot;W3&quot;</span>]) .+ params[<span class="hljs-string">&quot;b3&quot;</span>]<br>    result = softmax(dense_2)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>predict()</code>는 손실 값을 구할 때 사용되는 함수이다. 모델의 구성과 동일하며, 이때 사용되는 저장소들은 실제 필요한 데이터들이 아니라 함수의 작동을 위해 기술해둔 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-comment"># predict용 저장소(사용x)</span><br>pre_dense = dense_layer(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>pre_pool= repository(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>pre_flatten = repository(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br><br><br><span class="hljs-comment"># 실제 저장소</span><br>result = SoftmaxwithLoss(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>dense1 = dense_layer(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>dense2 = dense_layer(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>dense3 = dense_layer(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>Relu1 = repository(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>Relu2 = repository(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>optimizer = optimizers(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>pool1= repository(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>flatten1 = repository(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 미분값, 손실값 저장</span><br>grads = <span class="hljs-built_in">Dict</span>()<br>train_loss_list= []<br></code></pre></td></tr></table></figure><p>그 다음 각 계층에 필요한 저장소들을 생성한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-comment"># 가중치, 편향 생성</span><br>W =[<span class="hljs-string">&quot;W1&quot;</span>,<span class="hljs-string">&quot;W2&quot;</span>,<span class="hljs-string">&quot;W3&quot;</span>]<br>b = [<span class="hljs-string">&quot;b1&quot;</span>,<span class="hljs-string">&quot;b2&quot;</span>,<span class="hljs-string">&quot;b3&quot;</span>]<br>weight_size = [(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">30</span>),(<span class="hljs-number">4320</span>,<span class="hljs-number">100</span>),(<span class="hljs-number">100</span>,<span class="hljs-number">10</span>)];<br>output_shape = [(<span class="hljs-number">28</span>,<span class="hljs-number">28</span>,<span class="hljs-number">1</span>),(<span class="hljs-number">24</span>,<span class="hljs-number">24</span>,<span class="hljs-number">30</span>),(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>)]<br><br>params = making_network(W, b, weight_size,output_shape,<span class="hljs-string">&quot;std&quot;</span>);<br></code></pre></td></tr></table></figure><p>두 번째 단계인 가중치와 편향 초기값을 생성한다. <code>weight_size</code>는 합성곱 계층과 Dense 계층에 사용되는 가중치의 형상을 나타내며, <code>output_shape</code>은 각 층마다 도출되는 결과값의 형상이다. 이를 사용하여 초기값인 <code>params</code>를 생성한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-meta">@time</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:<span class="hljs-number">600</span><br><br>        batch_size = rand(<span class="hljs-number">1</span>:size(train_x)[<span class="hljs-number">4</span>],<span class="hljs-number">100</span>)<br>        train_x_batch = train_x[:,:,:,batch_size]<br>        t_batch = reshape(t[batch_size,:],<span class="hljs-number">100</span>,<span class="hljs-number">10</span>)<br><br>        <span class="hljs-comment">#신경망 계산</span><br>        conv_1 = convolution2D_forward(dense1,train_x_batch,params[<span class="hljs-string">&quot;W1&quot;</span>],params[<span class="hljs-string">&quot;b1&quot;</span>],<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br>        conv_Re = relu_forward(Relu1, conv_1)<br>        pool_1 = Maxpooling_forward(pool1, conv_Re, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>)<br>        flatten_1 = flatten_forward_batch(flatten1, pool_1)<br>        dense_1 = dense_layer_forward(dense2,flatten_1,params[<span class="hljs-string">&quot;W2&quot;</span>],params[<span class="hljs-string">&quot;b2&quot;</span>])<br>        dense_relu = relu_forward(Relu2, dense_1)<br>        dense_2 = dense_layer_forward(dense3,dense_relu,params[<span class="hljs-string">&quot;W3&quot;</span>],params[<span class="hljs-string">&quot;b3&quot;</span>])<br>        num = SoftmaxwithLoss_forward(dense_2,t_batch)<br><br>        <span class="hljs-comment">#역전파 알고리즘</span><br>        last_layer = SoftmaxwithLoss_backward(result)<br>        dense_2_back = dense_layer_backward(dense3, last_layer)<br>        grads[<span class="hljs-string">&quot;W3&quot;</span>] = dense3.dw<br>        grads[<span class="hljs-string">&quot;b3&quot;</span>] = dense3.db<br>        dense_relu_back = relu_backward(Relu2, dense_2_back)<br>        dense_1_back = dense_layer_backward(dense2, dense_relu_back)<br>        grads[<span class="hljs-string">&quot;W2&quot;</span>] = dense2.dw<br>        grads[<span class="hljs-string">&quot;b2&quot;</span>] = dense2.db<br>        flatten_1_back = flatten_backward_batch(flatten1,dense_1_back)<br>        pool_1_back = Maxpooling_backward(pool1, flatten_1_back, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>)<br>        conv_Re_back = relu_backward(Relu1, pool_1_back)<br>        conv_back = convolution2D_backward(dense1,conv_Re_back,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br>        grads[<span class="hljs-string">&quot;W1&quot;</span>] = dense1.dw<br>        grads[<span class="hljs-string">&quot;b1&quot;</span>] = dense1.db<br><br>        <span class="hljs-comment">#가중치 갱신</span><br>        Adam(params,grads)<br><br>        temp_loss = loss_CNN_batch(train_x_batch,t_batch)<br>        print(<span class="hljs-string">&quot;NO.<span class="hljs-variable">$i</span>: &quot;</span>)<br>        println(temp_loss)<br>        append!(train_loss_list, temp_loss)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>이제 마지막으로 모델 설계에 알맞게 계층을 쌓아 학습을 시작한다. 위 코드는 한번 학습할 때마다 입력 데이터 100개가 입력되며, 1에폭은 600번이다. 따라서 위 코드를 그래도 사용하면 1에폭을 학습한다. 학습 종료 후 정확도를 확인하고 싶다면 아래의 코드를 입력해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-comment"># 테스트셋 정확도 계산</span><br>evaluate_CNN_batch(test_x, test_y)<br></code></pre></td></tr></table></figure><h2 id="결과">결과</h2><p>위 코드를 사용하여 총 5에폭(3000번)을 학습시켰으며, 그 결과 정확도를 아래와 같이 증가하였다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-comment"># 1에폭: 96.37</span><br><span class="hljs-comment"># 2에폭: 97.22</span><br><span class="hljs-comment"># 3에폭: 98.1</span><br><span class="hljs-comment"># 4에폭: 98.46000000000001</span><br><span class="hljs-comment"># 5에폭: 98.57000000000001</span><br></code></pre></td></tr></table></figure><p><code>im2col()</code>, <code>col2im()</code>을 적용하지 않았던 모델과 비교해봤을 때 초기값의 랜덤 설정을 고려한다면 같은 결과를 얻었다고 볼 수 있다. 손실값의 그래프를 확인해도 잘 학습되는 것을 확인할 수 있다.</p><figure><img src="/images/82.png" alt="loss" /><figcaption aria-hidden="true">loss</figcaption></figure><p>하지만 5에폭을 진행하는데 걸린 시간은 고작 약 25분 정도이다. 기존의 <code>simpleNet</code>은 1에폭에 1시간이었다는 것을 떠올려보면 엄청난 발전이라고 볼 수 있다. 하지만 <code>simpleNet</code>은 테스트셋의 정확도 99%를 넘기지는 못한다. 만약 99% 정확도를 달성해보고 싶다면 tensorflow에서 MNIST의 예제로 제공하는 <code>convNet</code>을 살펴보고 이와 동일하게 모델을 설계하여 도전해볼 수도 있다.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>deep learning in julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>딥러닝</tag>
      
      <tag>Deeplearning</tag>
      
      <tag>줄리아</tag>
      
      <tag>CNN</tag>
      
      <tag>합성곱</tag>
      
      <tag>이미지신경망</tag>
      
      <tag>풀링</tag>
      
      <tag>Julia</tag>
      
      <tag>모델</tag>
      
      <tag>im2col</tag>
      
      <tag>col2im</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[17/18] col2im을 적용한 합성곱과 풀링</title>
    <link href="/ko/DeeplearningJulia/Deeplearning-17/"/>
    <url>/ko/DeeplearningJulia/Deeplearning-17/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다. <span id="more"></span></p><hr /><p>이전 글에서는 합성곱과 풀링의 역전파 계산과 그에 사용되는 <code>col2im()</code>에 대해서 알아보았다. 이번 글에서는 <code>col2im()</code>을 사용한 합성곱과 풀링 역전파를 직접 코드로 구현할 것이다.</p><h2 id="합성곱-with-col2im">합성곱 with col2im</h2><p>합성곱이 역전파 알고리즘에서 어떻게 미분되는지에 관해서는 <a href="https://dev-bearabbit.github.io/2020/07/01/DeeplearningJulia/Deeplearning-16/">이전 글</a>에서 다뤘기 때문에 이번 글에서는 기술적으로 합성곱이 작동되는 방식에 대해서 논의하고자 한다. 이를 위해 먼저 합성곱 역전파를 구현한 코드를 확인해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> convolution2D_backward(dense ,input, stride, pad)<br><br>    input_r, input_c,input_d,input_num = size(dense.x)<br>    filter_r, filter_c, filter_d, filter_num = size(dense.w)<br><br>    result = permutedims(input,(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>))<br>    dout = <span class="hljs-built_in">Array</span>(reshape(result,filter_num,:)&#x27;)<br><br>    dense.db = sum(dout,dims=<span class="hljs-number">1</span>)<br>    weight = <span class="hljs-built_in">Array</span>(dense.col&#x27;) * dout<br>    dense.dw = reshape(weight,size(dense.w))<br><br>    <span class="hljs-comment"># 1324 순서</span><br>    dcol = dout * <span class="hljs-built_in">Array</span>(dense.col_w&#x27;)<br>    dx = col2im(dense, dcol, filter_r, filter_c, stride, pad)<br><br>    <span class="hljs-keyword">return</span> dx<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>이제 위 코드의 작동 과정을 하나씩 살펴보자. 먼저 순전파 계산 과정에서 저장해둔 입력데이터의 크기와 필터의 크기를 불러온다. 코드에서 사용된 <code>dense</code>는 순전파 계산에서 각 데이터들을 저장해둔 구조체이다. 구조체에 대해 자세히 알고 싶다면 <a href="https://dev-bearabbit.github.io/2020/03/15/ThinkJulia/Think-Julia-Chapter-15/">이 페이지</a>을 읽어보면 좋다. 그 다음으로는 미분값의 차원을 변경하고, 2차원의 배열의 형상으로 바꾼다. 여기서 그 2차원의 형상은 아래의 그림과 같다.</p><figure><img src="/images/78.png" alt="dout" /><figcaption aria-hidden="true">dout</figcaption></figure><p>위 그림과 같이 미분값은 행은 데이터의 개수, 열은 차원의 개수를 기준으로 2차원 배열로 변경된다. 이를 열을 기준으로 합산하면 편향의 미분값인 <code>db</code>가 완성된다. 또한 순전파 계산에서 사용되었던 입력데이터에 <code>im2col()</code>을 적용한 <code>col</code> 변수를 <code>dense</code>에 저장해두었다가 <code>dw</code>를 구할 때 불러와 사용한다. <code>dw</code>는 <code>col</code>과 <code>dout</code>을 곱한 후, <code>dense.w</code>의 형상으로 변경한다. 마지막으로 남은 것은 <code>dx</code>이다. <code>grads</code>로 저장되어 이후 가중치와 편향을 갱신할 때 사용되는 <code>dw</code>, <code>db</code>와 달리 <code>dx</code>는 다음 층으로 넘어갈 미분값을 구하는 것이다. 다르게 말하자면, <code>dx</code>는 다음 계층의 <code>dout</code>이 되는 것이다. <code>dx</code>를 구하는 과정에서 <code>col2im()</code>이 사용된다. 이 모든 과정을 그림으로 나타내면 아래와 같다.</p><figure><img src="/images/79.png" alt="dwdb" /><figcaption aria-hidden="true">dwdb</figcaption></figure><p>만약 <code>col2im()</code>이 어떻게 계산되는지 궁금하다면, 이전 글에서 해당 정보를 찾을 수 있다. 합성곱 역전파 계산에 대해서는 이게 전부이다. 이제는 풀링의 역전파에 대해 살펴보자.</p><h2 id="최대값-풀링-with-col2im">최대값 풀링 with col2im</h2><p>최대값 풀링은 어떠한 사칙연산도 사용되지 않는다. 단순히 지정된 범위에서 최대값을 뽑아 더 작은 크기의 결과값을 도출한다. 그렇다면 이를 되돌린다는 것은 어떤 의미인가? 바로 미분값을 입력 데이터에서의 최대값 위치로 보내주는 것이다. 최대값 풀링의 역전파는 이것이 전부이다. 이 과정을 구현한 코드를 확인해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> Maxpooling_backward(pool,dout,pool_h,pool_w,stride,pad)<br><br>    dout = permutedims(dout,(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>))<br>    pool_size = pool_h * pool_w<br><br>    dmax = zeros(pool_size,length(dout))<br>    dmax_ex = zeros(pool_size,length(dout))<br>    dmax[reshape(pool.mask,length(dout),<span class="hljs-number">1</span>)] = reshape(dout,length(dout),<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment"># 1234에서 1324순으로 변환</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:size(dmax)[<span class="hljs-number">1</span>]<br>        dmax_ex[i,:] = dmax[pool.count[i],:]<br>    <span class="hljs-keyword">end</span><br><br>    dmax_ex = <span class="hljs-built_in">Array</span>(dmax_ex&#x27;)<br>    dx = col2im(pool, dmax_ex, pool_h, pool_w, stride, pad)<br><br>    <span class="hljs-keyword">return</span> dx<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>이제 위 코드의 작동 과정을 하나씩 살펴보자. 먼저 <code>dout</code>을 차원변경한 후, 이 길이에 맞는 <code>dmax</code> 행렬을 생성한다. <code>dmax</code> 최대값을 원래 위치에 할당할 때 사용된다. 위 코드에서 <code>pool</code> 또한 순전파 과정에서 최대값 풀링의 최대값 위치를 표현한 인덱스 모음이다. 이를 사용하여 <code>dout</code>에 있는 미분값들을 최대값 위치에 할당하는 것이다. 그 후에 <code>col2im</code>을 사용하여 원래 형태로 변경해준다. for문의 경우에는 Julia의 인덱스 순서 특성으로 인해 추가된 것이다. Julia의 경우, 인덱스를 모두 세로를 기준으로 잡기 때문에 이를 가로로 변경해주어야 한다. 그 과정을 거치면 <code>dmax</code>가 가로정렬된 인덱스를 가진 <code>dmax_ex</code>로 변경된다. 이 모든 과정을 그림으로 나타내면 아래와 같다.</p><figure><img src="/images/80.png" alt="max" /><figcaption aria-hidden="true">max</figcaption></figure><p>지금까지 <code>col2im()</code>을 사용하여 합성곱과 최대값 풀링의 역전파 과정을 구현하였다. 데이터 4차원을 유지한 채 이를 진행하면 매우 느리지만, <code>col2im()</code>을 사용하면 매우 빠른 속도로 계산이 가능하다. 다음 글에서는 지금까지 만든 CNN layers을 바탕으로 모델을 구현하고 학습시켜볼 것이다.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>deep learning in julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>딥러닝</tag>
      
      <tag>Deeplearning</tag>
      
      <tag>줄리아</tag>
      
      <tag>CNN</tag>
      
      <tag>합성곱</tag>
      
      <tag>이미지신경망</tag>
      
      <tag>풀링</tag>
      
      <tag>Julia</tag>
      
      <tag>모델</tag>
      
      <tag>im2col</tag>
      
      <tag>col2im</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[16/18] col2im의 원리</title>
    <link href="/ko/DeeplearningJulia/Deeplearning-16/"/>
    <url>/ko/DeeplearningJulia/Deeplearning-16/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다. <span id="more"></span></p><hr /><p>이전 글에서는 <code>im2col()</code>에 대해서 알아보았다. <code>im2col()</code>은 4차원의 데이터를 2차원으로 변경하며, 보통 순전파에서 사용된다. 그와 반대로 <code>col2im()</code>은 2차원 데이터를 4차원으로 변경하여 반환하며, 보통 역전파 알고리즘에서 사용된다. 따라서 이번 글에서는 CNN 모델의 학습 속도를 높여줄 <code>col2im()</code>의 원리를 살펴보고 줄리아로 구현하며, 동시에 합성곱 계층과 풀링 계층의 역전파에 대해서도 알아볼 것이다.</p><h2 id="col2im-이란">col2im 이란</h2><p><code>col2im()</code>은 <code>im2col()</code>과 달리 차원을 변경하는 용도로만 쓰이지는 않는다. 간단하게 설명한다면 <code>col2im()</code>은 차원 변경과 동시에 미분값들을 최종적으로 도출해주는 역할을 같이 한다. 그렇기에 <code>col2im</code>을 이해하기 위해서는 합성곱이나 풀링의 역전파 미분 과정을 먼저 알아야 한다.</p><h2 id="합성곱의-역전파-계산">합성곱의 역전파 계산</h2><p>먼저 합성곱을 미분하는 과정을 살펴보자. 합성곱 또한 수식으로 미분을 전개할 수는 있다. 하지만 좀 더 직관적으로 설명하기 위하여 아래의 예시를 통해서 미분을 설명해보고자 한다.</p><figure><img src="/images/73.png" alt="conv_for" /><figcaption aria-hidden="true">conv_for</figcaption></figure><p>위 그림처럼 하나의 합성곱 레이어가 있다고 가정해보자. 합성곱 계산을 식으로 표현하면 그림과 같다. 즉, 행렬 <span class="math inline">\(Y\)</span>는 입력데이터인 행렬 <span class="math inline">\(X\)</span>와 필터인 행렬 <span class="math inline">\(F\)</span>로 표현할 수 있다. 그렇다면 역전파 과정은 어떻게 진행될까? 역전파는 가중치와 편향의 미분값을 찾기 위하여 매 층마다 계산한다. 따라서 역전파는 겹겹이 쌓여 있는 합성함수를 미분하는 과정과 동일하다. 이를 정리하면 다음과 같다.</p><p><span class="math display">\[Backward\  Propagation: dout \times dx\]</span></p><p>위 설명에서 <span class="math inline">\(dout\)</span>은 이전 계층들의 미분값이다. <span class="math inline">\(dout\)</span>은 순전파에서 결과값인 <span class="math inline">\(Y\)</span>와 똑같은 형상으로 해당 레이어의 미분 과정에 투입된다. 즉, <span class="math inline">\(dout\)</span>은 역전파에서 사용되는 입력데이터라고 볼 수 있다. <span class="math inline">\(dx\)</span>는 해당 레이어의 순전파 계산에서 사용된 입력데이터 <span class="math inline">\(X\)</span>의 편미분이다. <span class="math inline">\(X\)</span>의 각각 요소들은 해당 인덱스에 따라서 미분된다. <span class="math inline">\(dx\)</span>를 계산하는 과정은 아래와 같다.</p><figure><img src="/images/74.png" alt="conv_back" /><figcaption aria-hidden="true">conv_back</figcaption></figure><p>위 그림은 $ dx$를 각 성분 별로 미분한 식을 보여준다. <span class="math inline">\(dx\)</span>는 순전파의 결과값을 도출하는 식인 <span class="math inline">\(Y\)</span>를 <span class="math inline">\(X\)</span>의 각 성분들로 미분한 결과이다. 이렇게 계산된 <span class="math inline">\(dx\)</span>는 다음 레이어의 <span class="math inline">\(dout\)</span>으로 전달된다.</p><p>합성곱 레이어의 역전파에서는 <span class="math inline">\(dx\)</span>뿐만 아니라 해당 레이어의 순전파에서 사용되었던 가중치와 편향의 미분도 동시에 진행된다. 가중치의 미분은 <span class="math inline">\(dw\)</span>이고, 편향의 미분은 <span class="math inline">\(db\)</span>이다. 아래의 그림은 가중치와 편향의 미분 과정을 나타낸 것이다.</p><figure><img src="/images/75.png" alt="dout" /><figcaption aria-hidden="true">dout</figcaption></figure><p><span class="math inline">\(dw\)</span>와 <span class="math inline">\(db\)</span> 또한 순전파 계산에서 사용된 식을 미분함으로써 정의된다. 먼저 <span class="math inline">\(dw\)</span>의 경우, <span class="math inline">\(Y\)</span>를 <span class="math inline">\(F\)</span>의 성분으로 미분하면 각 필터의 성분들과 곱해졌던 입력데이터의 값들만 남는다. 이를 이전 레이어의 미분값인 <span class="math inline">\(dout\)</span>에 곱해주면 <span class="math inline">\(\frac{\partial L}{\partial f_n}\)</span>이 도출된다. 그 다음 <span class="math inline">\(db\)</span>를 살펴보면, 순전파 계산 과정에서 편향은 필터의 개수만큼 더해준다. 위 그림에서는 필터가 1개였기에 편향도 <span class="math inline">\(1 \times 1\)</span> 형태임을 알 수 있다. <span class="math inline">\(Y\)</span>를 미분하면 편향의 미분값은 1이 되고, 이를 <span class="math inline">\(dout\)</span>에 곱하여 더해주면 <span class="math inline">\(db\)</span>가 도출된다.</p><h2 id="풀링의-역전파-계산">풀링의 역전파 계산</h2><p>풀링의 역전파는 합성곱과 달리 어떤 사칙연산도 없다. 단순히 줄였던 크기를 다시 크게 만들어 주는 것이다. 합성곱 미분에 비해 매우 간단하니 아래의 그림을 참고하자.</p><figure><img src="/images/76.png" alt="pool_dout" /><figcaption aria-hidden="true">pool_dout</figcaption></figure><p>위 그림은 Max pooling의 순전파, 역전파 계산 과정을 모두 보여준다. Max pooling은 순전파 계산에서 각 범위마다의 Max 값 위치를 저장한다. 그 이유는 이후 역전파에서 입력되는 미분값들을 해당 위치에 알맞게 보내야 하기 때문이다. 보통 Max pooling은 <span class="math inline">\(2 \times 2\)</span> 사이즈에 스트라이드가 2인 형태로 많이 쓰이기에 위 그림도 이를 기준으로 사용하였다.</p><p>지금까지 <code>col2im()</code>의 원리를 알기 위해서 필요한 역전파 계산을 설명하였다. 이제<code>col2im()</code>이 언제 쓰이는지 또 원리는 무엇인지 알아보자.</p><h2 id="col2im-의-원리">col2im 의 원리</h2><p>위에서 간단하게 설명했다시피 <code>col2im()</code>은 단순한 차원 변경만 해주는 것이 아니라 역전파 계산의 일부를 담당한다. 아래의 그림을 살펴보자.</p><figure><img src="/images/77.png" alt="col2im" /><figcaption aria-hidden="true">col2im</figcaption></figure><p><code>col2im()</code>은 이전 레이어의 미분값인 <span class="math inline">\(dout\)</span>와 순전파 계산에서 사용했던 가중치를 곱한 행렬을 입력데이터로 받는다. 그 다음, 위 그림과 같이 미분식에 알맞게 각 성분들을 더하여 결과값으로 도출한다. 즉, <code>col2im()</code> 은 2차원을 받아 4차원으로 변경해주는 것 뿐만 아니라 미분 과정에서 각각의 성분들을 알맞게 더해주는 역할도 하는 것이다.</p><p><code>col2im()</code>을 줄리아로 구현한 코드는 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> col2im(dense, dcol, filter_r,filter_c, stride, pad)<br><br>    input_r, input_c,input_d,input_num = size(dense.x)<br><br>    out_r = <span class="hljs-built_in">Int</span>(((input_r + <span class="hljs-number">2</span>*pad - filter_r) ÷ stride) + <span class="hljs-number">1</span>)<br>    out_c = <span class="hljs-built_in">Int</span>(((input_c + <span class="hljs-number">2</span>*pad - filter_c) ÷ stride) + <span class="hljs-number">1</span>)<br><br>    temp = <span class="hljs-built_in">Array</span>(dcol&#x27;)<br>    mc = reshape(temp,filter_r,filter_c,input_d,out_r,out_c,input_num)<br>    col = permutedims(mc,(<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>))<br><br>    img = zeros((input_r+<span class="hljs-number">2</span>*pad+stride-<span class="hljs-number">1</span>),(input_c+<span class="hljs-number">2</span>*pad+stride-<span class="hljs-number">1</span>), input_d, input_num)<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:filter_r<br>        r_max = (i + stride *out_r) -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:filter_c<br>            c_max = (j + stride *out_c) -<span class="hljs-number">1</span><br><br>            img[i:stride:r_max, j:stride:c_max,:,:] += col[:, :, j, i, :, :]<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><br>    result = img[<span class="hljs-number">1</span>+pad:input_r+pad,<span class="hljs-number">1</span>+pad:input_c+pad,:,:]<br><br>    <span class="hljs-keyword">return</span> result<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위 코드에서 <code>dcol</code>은 <span class="math inline">\(dout \times weight\)</span>한 행렬이다. 그 다음 입력값을 더해줄 크기로 조각내기 위해서 6차원 배열인 <code>col</code>로 형태를 변경한다. 그 다음 알맞게 더해준 후, 값을 도출한다.</p><p>지금까지 <code>col2im()</code>의 원리에 대해서 알아보았다. 다음 글에서는 오늘 만든 <code>col2im()</code>을 가지고 합성곱과 풀링을 구현할 것이다.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>deep learning in julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>딥러닝</tag>
      
      <tag>Deeplearning</tag>
      
      <tag>줄리아</tag>
      
      <tag>CNN</tag>
      
      <tag>합성곱</tag>
      
      <tag>이미지신경망</tag>
      
      <tag>풀링</tag>
      
      <tag>Julia</tag>
      
      <tag>모델</tag>
      
      <tag>im2col</tag>
      
      <tag>col2im</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[15/18] im2col의 원리</title>
    <link href="/ko/DeeplearningJulia/Deeplearning-15/"/>
    <url>/ko/DeeplearningJulia/Deeplearning-15/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다. <span id="more"></span></p><hr /><p>이전 글에서 CNN의 원리를 살펴보고 줄리아로 구현하였다. CNN은 4차원 데이터를 다루기 때문에 시간이 매우 오래걸린다. 지난 글에서 학습했던 모델은 그나마 간단한 형태라서 학습을 진행했지만, 더 복잡하고 깊은 신경망에서는 1에폭 학습하는 데 하루 종일 학습해야 할 것이다. 이런 문제로 인해 우리는 좀 더 빠르게 연산처리를 할 수 있는 방법을 구상해야 했고, 그 결과가 <code>im2col()</code>과 <code>col2im()</code>이다. 이번 글에서는 CNN 모델의 학습 속도를 높여줄 <code>im2col()</code>의 원리를 살펴보고 줄리아로 구현할 것이다.</p><h2 id="im2col-의-원리">im2col 의 원리</h2><p><code>im2col()</code>은 4차원의 데이터를 2차원의 데이터로 변경해준다. 해당 설명이 <code>im2col()</code>의 역할 전부이지만, 차원에 익숙하지 않은 사람은 데이터가 어떻게 변화하는지 이해하기 어려울 수 있다. <code>im2col()</code>의 원리를 그림으로 살펴보자.</p><figure><img src="/images/69.png" alt="im2col" /><figcaption aria-hidden="true">im2col</figcaption></figure><p><code>im2col()</code>은 합성곱하기 하기 위해 입력 데이터의 형태를 살짝 변형한다. 위 그림을 보면 <span class="math inline">\(5 \times 5 \times 3\)</span> 입력 데이터 2개가 있으며, 이를 <span class="math inline">\(3 \times 3 \times 3 \times 1\)</span> 필터로 합성곱을 진행하기 위해 데이터의 차원을 변경해준다. 즉, <code>im2col()</code>은 입력 데이터가 사칙연산되는 것이 아니라 그냥 데이터의 형태만 바꿔주는 것이다.</p><p>위 그림을 살펴보면 입력 데이터의 차원은 옆으로 추가되며, 배치 데이터의 개수는 밑으로 추가되는 것을 확인할 수 있다. 그렇다면 이런 im2col을 어떻게 코드로 구현할 수 있을까? <code>im2col()</code> 코드는 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> im2col(input, filter_r,filter_c, stride, pad)<br><br>    input_r, input_c,input_d,input_num = size(input)<br><br>    out_r = <span class="hljs-built_in">Int</span>(((input_r + <span class="hljs-number">2</span>*pad - filter_r) ÷ stride) + <span class="hljs-number">1</span>)<br>    out_c = <span class="hljs-built_in">Int</span>(((input_c + <span class="hljs-number">2</span>*pad - filter_c) ÷ stride) + <span class="hljs-number">1</span>)<br><br>    img = padding(input, pad)<br>    col = zeros(out_r, out_c,filter_r,filter_c,input_d,input_num)<br><br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:filter_r<br>        r_max = (i + stride *out_r) -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:filter_c<br>            c_max = (j + stride *out_c) -<span class="hljs-number">1</span><br><br>            col[:, :, j, i, :, :] = img[i:stride:r_max, j:stride:c_max,:,:]<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위 코드에서 이해하기 어려운 개념이 등장한다. 바로 6차원 배열이다. <code>col</code>이라는 배열은 6차원이며, 이는 합성곱을 진행할 때 필요한 데이터들을 모두 저장한다. 참고로 6차원은 인간이 이미지화할 수 없다. 따라서 데이터가 어떻게 저장되는지 완벽하게 표현할 수는 없지만, 최선을 다하여 그림으로 표현하였다. 아래의 그림을 참고하자.</p><figure><img src="/images/70.png" alt="6-D array" /><figcaption aria-hidden="true">6-D array</figcaption></figure><p>위 그림은 <code>im2col()</code> 그림에서 사용했던 예시를 그대로 가져왔다. 6차원 배열에서 <code>out_r, out_c</code>은 결과값이다. 위 예시에서는 <span class="math inline">\(3 \times 3\)</span>이며, 요소는 총 9개이다. 각 요소는 필터와 입력데이터 해당 위치의 곱들의 합이다. 이를 좀 더 편하게 계산하기 위해서 필터의 크기에 맞춰서 입력데이터들을 쪼개어 저장해두는 것이다. 즉, <code>filter_r,filter_c</code>는 필터의 요소에 따라서 곱해져야 하는 입력데이터들을 저장한다. 해당 배열에 데이터를 다 쪼갠 후에는 차원 변경을 통해 첫 번째 배치데이터의 첫 번째 합성곱 대상이 나올 수 있도록 수정한다. 그리고 <code>reshape()</code>을 사용하여 이를 <span class="math inline">\(1 \times n\)</span> 의 형태로 변환하여 반환한다.</p><p><strong>WARNING</strong> 참고로 위 코드를 파이썬에서 구현한 것과 줄리아에서 구현한 것은 차이가 있다. 그 이유는 배열의 인덱스 순서 때문이다. 파이썬의 경우 인덱스를 가로방향을 기준으로 잡아 모양을 변형하지만, 줄리아는 인덱스를 세로로 잡는다. 다만 이는 기술적인 문제라서 계층의 결과값을 다르게 도출하지는 않는다.</p><h2 id="im2col을-사용한-layers">im2col을 사용한 layers</h2><p>CNN에서 <code>im2col()</code>을 사용하는 계층은 합성곱층과 풀링층이다. 사실 이전 글에서 사용했던 합성곱층과 풀링층은 사람이 이해하는 방식과 같이 인덱스를 잡아 일일이 곱하고 합한 후 할당하는 방식이었다. 이 방식은 컴퓨터가 인덱스에 따른 데이터를 계속 호출해야 하기에 느려질 수밖에 없다. 하지만 <code>im2col()</code>을 사용하면 한번에 데이터를 호출하여 연산을 끝낼 수 있다.</p><h3 id="합성곱-convolution">합성곱 (Convolution)</h3><p><code>im2col()</code>이 사용된 합성곱의 원리는 다음과 같다.</p><figure><img src="/images/71.png" alt="conv" /><figcaption aria-hidden="true">conv</figcaption></figure><p>먼저 입력 데이터를 im2col 연산을 통해 2차원으로 만들어준 후, 필터 또한 <span class="math inline">\(1 \times n\)</span> 형태로 펴준다. 그 다음 두 개를 행렬곱 한다. 그러면 2차원 입력데이터의 가로줄과 필터의 곱의 합이 결과값으로 도출된다. 이것이 합성곱이 완료된 결과의 요소이다. 행렬곱이 끝난 후에는 다시 4차원으로 reshape 하면 합성곱은 끝난다.</p><p>이제 위의 원리를 코드로 구현해보자</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> convolution2D_forward(dense ,input, filter, bias, stride, pad)<br><br>    input_r, input_c,input_d,input_num = size(input)<br>    filter_r, filter_c, filter_d, filter_num = size(filter)<br><br>    out_r = <span class="hljs-built_in">Int</span>(((input_r + <span class="hljs-number">2</span>*pad - filter_r) ÷ stride) + <span class="hljs-number">1</span>)<br>    out_c = <span class="hljs-built_in">Int</span>(((input_c + <span class="hljs-number">2</span>*pad - filter_c) ÷ stride) + <span class="hljs-number">1</span>)<br><br>    col = im2col(input, filter_r, filter_c, stride, pad)<br>    col_w = reshape(filter,filter_r*filter_c*filter_d,filter_num)<br><br>    out = col * col_w .+ bias<br>    temp = <span class="hljs-built_in">Array</span>(out&#x27;)<br>    temp2 = reshape(temp,filter_num,out_r,out_c,input_num)<br>    result = permutedims(temp2,(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>))<br><br>    dense.x = input<br>    dense.w = filter<br>    dense.col = col<br>    dense.col_w = col_w<br><br>    <span class="hljs-keyword">return</span> result<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="최대값-풀링-max-pooling">최대값 풀링 (Max Pooling)</h3><p>풀링은 입력 데이터를 축소하기 위해서 사용한다. 풀링 중에서도 최대값 풀링은 해당 범위 내에서 가장 큰 수를 결과값으로 도출한다. 이를 im2col 연산을 사용하여 계산하는 과정은 다음과 같다.</p><figure><img src="/images/72.png" alt="pool" /><figcaption aria-hidden="true">pool</figcaption></figure><p>풀링도 마찬가지로 먼저 입력 데이터를 im2col 연산을 통해 2차원으로 만들어준 후, 아래의 있는 다른 데이터의 행렬도 옆으로 붙여준다. 이후 역전파에서 사용하기 위해 최대값 인덱스를 뽑아 <code>mask</code>로 저장하고, 뽑은 최대값은 결과로 반환한다.</p><p>최대값 풀링을 줄리아로 구현하면 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> Maxpooling_forward(pool, input, pool_h, pool_w, stride, pad)<br><br>    input_r, input_c,input_d,input_num = size(input)<br><br>    out_r = <span class="hljs-built_in">Int</span>(<span class="hljs-number">1</span> + (input_r +<span class="hljs-number">2</span>*pad - pool_h) ÷ stride)<br>    out_c = <span class="hljs-built_in">Int</span>(<span class="hljs-number">1</span> + (input_c +<span class="hljs-number">2</span>*pad - pool_w) ÷ stride)<br><br>    <span class="hljs-comment">## 1234 순서로 인덱스를 뽑아야 한다.</span><br>    col_ex = im2col(input, pool_h, pool_w, stride, pad)<br>    col= zeros(size(col_ex));<br>    order = reshape(<span class="hljs-built_in">Vector</span>(<span class="hljs-number">1</span>:size(col_ex)[<span class="hljs-number">2</span>]),pool_w,pool_h,input_d)<br>    count = []<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:size(order)[<span class="hljs-number">3</span>]<br>        temp = reshape(<span class="hljs-built_in">Array</span>(order[:,:,i]&#x27;),<span class="hljs-number">1</span>,:)<br>        append!(count, temp)<br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:size(col_ex)[<span class="hljs-number">2</span>]<br>        col[:,count[i]] = col_ex[:,i]<br>    <span class="hljs-keyword">end</span><br><br>    col = <span class="hljs-built_in">Array</span>(col&#x27;) <span class="hljs-comment">#1234</span><br>    coll = reshape(col, pool_h * pool_w, out_r*out_c*input_num*input_d)<br>    arg_max = argmax(coll, dims = <span class="hljs-number">1</span>)<br>    result = maximum(coll,dims = <span class="hljs-number">1</span>)<br>    out = reshape(result,input_d,out_c,out_r,input_num)<br>    out = permutedims(out,(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>))<br><br>    pool.x = input<br>    pool.count = count<br>    pool.mask = arg_max<br><br>    <span class="hljs-keyword">return</span> out<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>지금까지 <code>im2col()</code>을 사용하여 구성한 계층들을 살펴보았다. 다음 글에서는 CNN의 역전파와 그때 사용되는 <code>col2im</code>에 대해서 알아보자.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>deep learning in julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>딥러닝</tag>
      
      <tag>Deeplearning</tag>
      
      <tag>줄리아</tag>
      
      <tag>CNN</tag>
      
      <tag>합성곱</tag>
      
      <tag>이미지신경망</tag>
      
      <tag>풀링</tag>
      
      <tag>Julia</tag>
      
      <tag>모델</tag>
      
      <tag>im2col</tag>
      
      <tag>col2im</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[14/18] CNN 시작하기</title>
    <link href="/ko/DeeplearningJulia/Deeplearning-14/"/>
    <url>/ko/DeeplearningJulia/Deeplearning-14/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다. <span id="more"></span></p><hr /><p>지금까지 우리는 다층퍼셉트론(MLP) 기반의 완전연결신경망(Fully Connected network)을 구현하면서 원리를 알아보았다. 하지만 이미지 데이터를 기반으로 신경망을 구현할 때, 완전연결신경망은 이미지 데이터를 일자로 펴서 학습하므로 데이터의 공간적 특성을 이해하기 어렵다. 이를 해결하기 위해 등장한 개념이 바로 합성곱(convolution)이다.</p><h2 id="cnn-convolutional-neural-network-이란">CNN (Convolutional Neural Network) 이란</h2><p>'합성곱 신경망(CNN, Convolutional Neural Network)'은 3차원의 이미지 데이터를 그대로 입력받아 학습하는 신경망이다. 완전연결신경망과 다른 점은 '합성곱(convolution)'과 '풀링(pooling)'이라는 레이어가 추가된다는 것이다. 따라서 CNN을 이해하기 위해서는 두 레이어의 원리를 알아야 한다.</p><h2 id="합성곱-convolution">합성곱 (Convolution)</h2><p>합성곱은 하나의 이미지를 여러 조각으로 나누어 각 조각의 특성을 전달하는 방식이다. 아래의 그림은 합성곱의 원리를 보여준다. 참고로 <a href="https://github.com/Hyeonji-Ryu/Deep_Learning_in_Julia/blob/master/CNN/layers_without_im2col.jl">깃허브</a>에서 줄리아로 구현한 합성곱 코드를 볼 수 있다.</p><figure><img src="/images/65.png" alt="합성곱" /><figcaption aria-hidden="true">합성곱</figcaption></figure><p>먼저 그림에서 <code>Input_data</code>는 입력된 이미지이고, <code>Filter_1</code> 와 <code>Filter_2</code>는 가중치이다. 합성곱층에서는 가중치 크기에 맞게 조각난 입력데이터들을 곱하여 합한 후 결과값 요소로 반환한다. 위의 예시는 다음과 같은 셋팅이다.</p><ul><li><p>입력데이터: <span class="math inline">\(5 \times 5 \times 1 \times 1\)</span> 배열인 4차원 데이터이다. 기본적으로 이미지 데이터는 3차원으로 구성되어 있지만, 보통 배치데이터로 훈련하기 때문에 4차원이라고 보는 것이 더 좋다. 줄리아에서 배열의 순서는 <strong>행 <span class="math inline">\(\times\)</span> 열 <span class="math inline">\(\times\)</span> 색(차원) <span class="math inline">\(\times\)</span> 개수</strong> 이다. 여기서 <strong>색(차원)</strong>은 흑백인 경우 <code>1</code>, 컬러인 경우 RGB로 나뉘어 <code>3</code>이 된다.</p></li><li><p>가중치(필터): <span class="math inline">\(3 \times 3 \times 1 \times 2\)</span> 배열인 4차원 데이터이다. 가중치는 입력데이터와 곱해진다. 가중치의 배열 순서는 <strong>행 <span class="math inline">\(\times\)</span> 열 <span class="math inline">\(\times\)</span> 색(차원) <span class="math inline">\(\times\)</span> 개수</strong>으로 입력데이터와 동일하다. 참고로 가중치의 개수는 결과값의 차원이 된다.</p></li></ul><p>입력데이터의 조각들과 가중치를 각각 곱한 후 그 곱들의 합이 결과값의 원소가 된다. 이미지를 조각내는 기준을 스트라이드(stride)라고 하며, 위의 예시는 스트라이드가 1인 경우이다. 또한 합성곱은 입력데이터보다 더 작은 크기의 결과를 반환한다. 결과값 행렬의 크기를 구하는 식은 다음과 같다.</p><p><span class="math display">\[\frac{input\ size + 2*padding - filter\ size}{stride} +  1\]</span></p><p>위 식을 따라 위의 그림 예시의 값들을 넣어본다면 다음과 같다.</p><p><span class="math display">\[ \frac{5 + 0 - 3}{1} + 1 = 3\]</span></p><p>참고로 <span class="math inline">\(padding\)</span>은 데이터 크기가 줄어드는 것을 막기 위해서 사용하는 방법이다.</p><p><strong>Note</strong> 패딩 (padding) 이란? 패딩은 데이터에 표면에 0을 둘러서 데이터 크기를 키우는 기술을 의미한다. 예를 들어 <span class="math inline">\(2 \times 2\)</span> 행렬이 있고 패딩을 1 추가한다면, 모든 표면에 0이 둘러지면서 <span class="math inline">\(4 \times 4\)</span> 행렬을 반환한다.</p><p>결국 입력데이터 <span class="math inline">\(5 \times 5 \times 1 \times 1\)</span> 배열은 가중치 <span class="math inline">\(3 \times 3 \times 1 \times 2\)</span> 배열과 합성곱되어 결과값 <span class="math inline">\(3 \times 3 \times 2 \times 1\)</span> 배열을 도출한다. 이를 모두 정리하면 다음과 같다.</p><ul><li>입력데이터 형상: <span class="math inline">\(5 \times 5 \times 1 \times 1\)</span></li><li>필터 형상: <span class="math inline">\(3 \times 3 \times 1 \times 2\)</span></li><li>합성곱 결과 형상: <span class="math inline">\(3 \times 3 \times 2 \times 1\)</span></li></ul><p>합성곱 결과의 배열 순서는 <strong>행 <span class="math inline">\(\times\)</span> 열 <span class="math inline">\(\times\)</span> 가중치 개수 <span class="math inline">\(\times\)</span> 입력값 개수</strong>이다. 즉, 가중치의 개수가 결과값의 차원이 되는 것이다.</p><h2 id="풀링-pooling">풀링 (pooling)</h2><p>풀링은 데이터의 크기를 줄여주는 방법이다. 데이터가 큰 경우 파라미터가 기하급수적으로 증가하여 연산 시간이 많이 소요된다. 이를 방지하고자 중간에 풀링 계층을 넣어 데이터의 크기를 줄여준다. 풀링은 크게 '최대값 풀링(Max pooling)'과 '평균 풀링(Average pooling)'이 있다. 보통 최대값 풀링이 많이 사용된다. <a href="https://github.com/Hyeonji-Ryu/Deep_Learning_in_Julia/blob/master/CNN/layers_without_im2col.jl">깃허브</a>에서 줄리아로 구현한 풀링 코드를 볼 수 있다.</p><h3 id="최대값-풀링-max-pooling">최대값 풀링 (Max pooling)</h3><p>최대값 풀링의 원리를 그림으로 나타내면 다음과 같다.</p><figure><img src="/images/66.png" alt="최대 풀링" /><figcaption aria-hidden="true">최대 풀링</figcaption></figure><p>풀링에서는 합성곱과 달리 필터가 필요하지 않다. 다만, 풀링의 범위를 정해야 한다. 위의 그림에서는 <span class="math inline">\(2 \times 2\)</span> 크기로 풀링을 진행하며, 해당 범위에서 최대값을 반환하는 것이 최대값 풀링이다.</p><h3 id="평균-풀링-average-pooling">평균 풀링 (Average pooling)</h3><p>평균 풀링은 풀링 크기의 요소들의 평균을 결과값으로 반환한다. 그림으로는 다음과 같다.</p><figure><img src="/images/67.png" alt="평균 풀링" /><figcaption aria-hidden="true">평균 풀링</figcaption></figure><h2 id="simple-cnn-구현">Simple CNN 구현</h2><p>지금까지 합성곱층과 풀링층의 원리에 대해서 알아보았다. 이제 실제 코드로 구현하여 신경망을 학습해보자.</p><h3 id="준비-단계">준비 단계</h3><p>먼저 <a href="https://github.com/Hyeonji-Ryu/Deep_Learning_in_Julia">깃허브</a>에 들어가서 해당 <code>clone</code>이나 <code>Download zip</code>을 하여 코드들을 저장해야 한다. 만약 이에 대해 잘 모르거나 어려운 사람들은 <a href="https://github.com/Hyeonji-Ryu/Deep_Learning_in_Julia/tree/master/CNN">해당 페이지</a>에서 코드를 직접 복사해서 입력할 수도 있다.</p><p>깃허브 데스크탑에 코드를 클론하거나 저장한 분들은 현재 사용하고 있는 커맨드의 경로를 <code>CNN</code> 파일로 변경해야 한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">pwd <span class="hljs-comment"># 현재 경로 확인</span><br>cd 코드가 있는 파일 경로 입력/Machine_Learning_in_Julia/CNN<br></code></pre></td></tr></table></figure><p>다시 <code>pwd</code>를 입력했을 때 아래와 같이 변경되어 있으면 변경이 완료된 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">/Users/코드가 있는 파일 경로/Machine_Learning_in_Julia/CNN<br></code></pre></td></tr></table></figure><p>변경이 완료된 후 아래의 코드를 입력하자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">include(<span class="hljs-string">&quot;MNIST_data.jl&quot;</span>)<br>include(<span class="hljs-string">&quot;functions.jl&quot;</span>)<br>include(<span class="hljs-string">&quot;layers_without_im2col.jl&quot;</span>)<br>include(<span class="hljs-string">&quot;making_network.jl&quot;</span>)<br>include(<span class="hljs-string">&quot;optimizers.jl&quot;</span>)<br></code></pre></td></tr></table></figure><p>위 코드는 파일에 들어 있는 모든 코드들을 작동시킨다. 만약 코드를 복사하여 사용할 분들은 <a href="https://github.com/Hyeonji-Ryu/Deep_Learning_in_Julia/tree/master/CNN">해당 페이지</a>에서 위의 파일들의 코드를 복사하여 입력해주면 된다.</p><p>이제 간단한 CNN 모델을 만들 준비가 끝났다.</p><h3 id="모델-설계">모델 설계</h3><p>합성곱 신경망 1층과 완견연결 신경망 2층을 사용하여 모델을 구성하고자 한다. 모델의 순서는 다음과 같다.</p><figure><img src="/images/68.png" alt="simple CNN" /><figcaption aria-hidden="true">simple CNN</figcaption></figure><p>위 모델은 책 '밑바닥부터 시작하는 딥러닝'에서 예제로 사용한 것이다. 매우 간단하지만 <code>MNIST</code> 데이터를 학습하는 데 문제가 없다. 이제 모델 층에 알맞은 <code>predict()</code>를 정의해야 한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span>  predict(input)<br><br>    pconv_1 = conv2D_forward_batch(pre_dense, input, params[<span class="hljs-string">&quot;W1&quot;</span>], params[<span class="hljs-string">&quot;b1&quot;</span>],<span class="hljs-number">1</span>)<br>    pconv_Re = relu.(pconv_1)<br>    ppool_1 = maxpooling2D_forward_batch(pre_pool,pconv_Re, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>    flatten_1 = flatten_forward_batch(pre_flatten,ppool_1)<br>    dense_1 = (flatten_1 * params[<span class="hljs-string">&quot;W2&quot;</span>]) .+ params[<span class="hljs-string">&quot;b2&quot;</span>]<br>    dense_relu = relu.(dense_1)<br>    dense_2 = (dense_relu * params[<span class="hljs-string">&quot;W3&quot;</span>]) .+ params[<span class="hljs-string">&quot;b3&quot;</span>]<br>    result = softmax(dense_2)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="학습-구현">학습 구현</h3><p><code>loss()</code>에 사용되는 예측 함수를 설정한 후에 파라미터인 가중치와 편향 초기값도 설정한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">W =[<span class="hljs-string">&quot;W1&quot;</span>,<span class="hljs-string">&quot;W2&quot;</span>,<span class="hljs-string">&quot;W3&quot;</span>]<br>b = [<span class="hljs-string">&quot;b1&quot;</span>,<span class="hljs-string">&quot;b2&quot;</span>,<span class="hljs-string">&quot;b3&quot;</span>]<br>weight_size = [(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">30</span>),(<span class="hljs-number">4320</span>,<span class="hljs-number">100</span>),(<span class="hljs-number">100</span>,<span class="hljs-number">10</span>)];<br>input_size = (<span class="hljs-number">28</span>,<span class="hljs-number">28</span>,<span class="hljs-number">1</span>)<br><br>params = making_network(W, b, weight_size,input_size,<span class="hljs-string">&quot;std&quot;</span>);<br></code></pre></td></tr></table></figure><p>초기값은 기본값으로 사용하는 <code>std</code>로 설정하였다. 초기값에 대해서는 <a href="https://dev-bearabbit.github.io/2020/05/15/DeeplearningJulia/Deeplearning-12/">인공신경망 최적화 - 가충치 초기값</a>에서 더 자세히 알 수 있다.</p><p>파라미터를 만들었다면, 이제 모델에서 필요한 값들을 저장할 저장소를 생성한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-comment"># predict()용 저장소</span><br>pre_dense = dense_layer(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>pre_pool= repository(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>pre_flatten = repository(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br><br><br><span class="hljs-comment"># 실제 저장소</span><br>result = SoftmaxwithLoss(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>dense1 = dense_layer(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>dense2 = dense_layer(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>dense3 = dense_layer(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>Relu1 = repository(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>Relu2 = repository(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>optimizer = optimizers(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>pool1= repository(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>flatten1 = repository(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><code>pre</code>라고 붙은 저장소는 모델에 사용되는 함수의 파라미터 개수를 맞춰주기 위해 만든 것이다. 사실상 모델에 필요한 값을 저장하는 저장소는 아니다. 다음으로는 로스값과 미분값을 저장할 리스트와 딕셔너리를 정의한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">grads = <span class="hljs-built_in">Dict</span>()<br>train_loss_list= []<br></code></pre></td></tr></table></figure><p>이제 모델을 작동시켜보자. 해당 모델의 구성은 다음과 같다.</p><ul><li>Algorithm: backpropagation</li><li>Optimizer: Adam</li><li>batch_size: 100</li><li>one_epoch: 600</li></ul><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-meta">@time</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:<span class="hljs-number">600</span><br><br>        batch_size = rand(<span class="hljs-number">1</span>:size(train_x)[<span class="hljs-number">4</span>],<span class="hljs-number">100</span>)<br>        train_x_batch = train_x[:,:,:,batch_size]<br>        t_batch = reshape(t[batch_size,:],<span class="hljs-number">100</span>,<span class="hljs-number">10</span>)<br><br>        <span class="hljs-comment">#신경망 계산</span><br>        conv_1 = conv2D_forward_batch(dense1,train_x_batch,params[<span class="hljs-string">&quot;W1&quot;</span>],params[<span class="hljs-string">&quot;b1&quot;</span>],<span class="hljs-number">1</span>)<br>        conv_Re = relu_forward(Relu1, conv_1)<br>        pool_1 = maxpooling2D_forward_batch(pool1, conv_Re, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>        flatten_1 = flatten_forward_batch(flatten1, pool_1)<br>        dense_1 = dense_layer_forward(dense2,flatten_1,params[<span class="hljs-string">&quot;W2&quot;</span>],params[<span class="hljs-string">&quot;b2&quot;</span>])<br>        dense_relu = relu_forward(Relu2, dense_1)<br>        dense_2 = dense_layer_forward(dense3,dense_relu,params[<span class="hljs-string">&quot;W3&quot;</span>],params[<span class="hljs-string">&quot;b3&quot;</span>])<br>        num = SoftmaxwithLoss_forward(dense_2,t_batch)<br><br>        <span class="hljs-comment">#역전파 알고리즘</span><br>        last_layer = SoftmaxwithLoss_backward(result)<br>        dense_2_back = dense_layer_backward(dense3, last_layer)<br>        grads[<span class="hljs-string">&quot;W3&quot;</span>] = dense3.dw<br>        grads[<span class="hljs-string">&quot;b3&quot;</span>] = dense3.db<br>        dense_relu_back = relu_backward(Relu2, dense_2_back)<br>        dense_1_back = dense_layer_backward(dense2, dense_relu_back)<br>        grads[<span class="hljs-string">&quot;W2&quot;</span>] = dense2.dw<br>        grads[<span class="hljs-string">&quot;b2&quot;</span>] = dense2.db<br>        flatten_1_back = flatten_backward_batch(flatten1,dense_1_back)<br>        pool_1_back = maxpooling2D_backward_batch(pool1, flatten_1_back, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>        conv_Re_back = relu_backward(Relu1, pool_1_back)<br>        conv_back = conv2D_backward_batch(dense1,conv_Re_back)<br>        grads[<span class="hljs-string">&quot;W1&quot;</span>] = dense1.dw<br>        grads[<span class="hljs-string">&quot;b1&quot;</span>] = dense1.db<br><br>        <span class="hljs-comment">#가중치 갱신</span><br>        Adam(params,grads)<br><br>        temp_loss = loss_CNN_batch(train_x_batch,t_batch)<br>        print(<span class="hljs-string">&quot;NO.<span class="hljs-variable">$i</span>: &quot;</span>)<br>        println(temp_loss)<br>        append!(train_loss_list, temp_loss)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위 모델의 정확도는 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-comment"># 1에폭: 96.8</span><br><span class="hljs-comment"># 2에폭: 97.73</span><br><span class="hljs-comment"># 3에폭: 98.35</span><br><span class="hljs-comment"># 4에폭: 98.39</span><br><span class="hljs-comment"># 5에폭: 98.50999999999999</span><br></code></pre></td></tr></table></figure><p>확실히 MLP보다 학습이 잘 된다는 것을 확인할 수 있다.</p><h2 id="결론">결론</h2><p>위 코드는 1에폭(600)에 1시간 정도 소요된다. 이전까지 배웠던 MLP 모델을 작동시켜봤다면 '이 모델이 역전파를 사용한 것이 맞는가?' 라는 의문이 들 수 있다. 사실 위 모델에 사용된 방식의 합성곱층과 풀링층은 이론적으로는 맞지만, 아무도 사용하지 않는다. 그 이유는 너무 느려서이다. 4차원 데이터를 가공하지 않고 인덱스를 잡아 함수를 실행하는 것은 컴퓨터의 입장에서 엄청난 노동이다. 그래서 우리는 기술적으로 4차원 데이터를 2차원으로 변환한 뒤, 계산을 하고 다시 4차원으로 조립하는 과정을 사용한다. 이 방법은 아~~주 느린 합성곱층과 풀링층을 훨씬 빠르게 작동하게 만들어준다.</p><p>만약 위 코드를 1에폭이라도 돌려봤다면 그 필요성을 실감할 것이기에, 한 번쯤 돌려보기를 권장한다. 앞서 설명했던 차원을 변경해주는 함수는 일반적으로 동일한 이름으로 쓰인다. 순방향에서는 <code>im2col()</code>, 역방향에서는 <code>col2im()</code>이다. 의미는 이미지에서 행렬로, 또 행렬에서 이미지로 변경해준다는 의미이다. 즉, 4차원 데이터를 2차원으로, 2차원 데이터를 4차원으로 변경해준다는 의미와 동일하다.</p><p>다음 글에서는 <code>im2col()</code>과 <code>col2im()</code>의 원리를 설명하고, 줄리아로 구현해볼 것이다. 또한 이를 바탕으로 합성곱층과 풀링층의 함수를 구현할 것이다.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>deep learning in julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>딥러닝</tag>
      
      <tag>Deeplearning</tag>
      
      <tag>줄리아</tag>
      
      <tag>CNN</tag>
      
      <tag>합성곱</tag>
      
      <tag>이미지신경망</tag>
      
      <tag>풀링</tag>
      
      <tag>flatten</tag>
      
      <tag>convolution</tag>
      
      <tag>Julia</tag>
      
      <tag>모델</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[13/18] 드랍아웃(Dropout)</title>
    <link href="/ko/DeeplearningJulia/Deeplearning-13/"/>
    <url>/ko/DeeplearningJulia/Deeplearning-13/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다. <span id="more"></span></p><hr /><h2 id="드랍아웃dropout이란">드랍아웃(Dropout)이란</h2><p>드랍아웃은 인공신경망 훈련 과정을 최적화하기 위한 방법 중 하나이며, 오버피팅(overfitting)을 방지함으로써 모델의 정확도를 높여준다.</p><p><strong>Note</strong> 오버피팅(overfitting)이란? 신경망을 학습하는 과정에서 훈련데이터에만 적합한 형태로 학습되는 현상을 오버피팅이라고 한다. 훈련데이터의 정확도는 거의 100%를 달성하는데 실제데이터에서는 일정 이상의 정확도에서 상승하지 않는 것이다. 이런 현상은 보통 훈련데이터를 너무 적게 사용한 경우 또는 모델 파라미터가 너무 많은 경우에 발생한다.</p><p>드랍아웃은 각각의 훈련데이터들이 결과값으로 연결되는 신호(엣지, Edge)를 일정한 퍼센트로 삭제함으로써 훈련데이터의 일부만 파라미터에 영향을 줄 수 있도록 조정하는 역할을 한다. 드랍아웃을 함수로 만들면 다음과 같다.</p><h2 id="드랍아웃-구현">드랍아웃 구현</h2><p>드랍아웃은 입력된 비율에 따라 몇몇의 신호값들을 0으로 반환한다. 이를 함수로 구현하면 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">using</span> Random<br><br><span class="hljs-keyword">function</span> drop_out_single(input_size, rate)<br>    <span class="hljs-keyword">function</span> changing_T_or_F_with_percentage(number, input_size, rate)<br>        temp_num = input_size * rate<br>        <span class="hljs-keyword">if</span> number &gt; temp_num<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    temp = shuffle(reshape(<span class="hljs-number">1</span>:input_size, <span class="hljs-number">1</span>, input_size))<br>    <span class="hljs-keyword">return</span> changing_T_or_F_with_percentage.(temp, input_size, rate)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위 함수는 신호값과 곱하는 마스크를 생성한다. 드랍아웃에서는 비율을 입력값으로 받아 입력된 신호값의 일부 위치를 무작위로 선정하고, 그 자리의 신호를 0으로 반환해야 하는데 이를 구현하기 위해 기술적으로 신호값과 곱해주는 마스크를 생성하는 것이다. 하지만 이는 데이터 하나의 형태(한 줄)에만 작동하는 함수이다. 우리는 지금까지 배치데이터(여러 줄)를 사용해왔기 때문에 각각의 모든 줄에 위의 드랍아웃을 적용하는 함수가 필요하다.</p><p><strong>Note</strong> 배치데이터에서 드랍아웃의 작동원리 드랍아웃은 각각의 데이터들이 동일한 비율로 신호값이 제거되어야 한다. 다시 말해, 한 줄로 나열된 데이터를 여러 개 합쳐놓은 매트릭스 형태의 배치데이터에서는 한 줄마다 일정한 비율을 유지해주면서 신호값을 제거해야 한다. 그렇기에 한 줄씩 인덱스를 무작위로 선정하여 제거해주는 작업이 필수적이다. 만약 이를 고려하지 않고 배치데이터를 드랍아웃한다면, 이는 효과가 거의 없다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> drop_out(input_size, hidden_size, rate)<br>    temp = drop_out_single(hidden_size, rate)<br>    temp_num = input_size - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>:temp_num<br>        temp_1 = drop_out_single(hidden_size, rate)<br>        temp = [temp; temp_1]<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> temp<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위 함수는 <code>drop_out_single()</code>을 배치데이터에 사용할 수 있도록 변환한 것이다. 위 함수에서 사용된 <code>input_size</code>와 <code>hidden_size</code>는 배치데이터에서 행렬의 형상이다. 예를 들어 입력된 신호값이 <span class="math inline">\(10 \times 784\)</span>의 행렬이라면 이는 <span class="math inline">\(1 \times 784\)</span> 데이터가 총 10개가 포함된 배치데이터이기에 <code>drop_out_single()</code>을 <code>input_size</code>만큼 반복하는 것이다.</p><p>신호값과 곱해줄 드랍아웃 마스크는 완성되었다. 이제는 신호값과 마스크를 곱해주는 함수를 생성해보자. 참고로 드랍아웃도 신호값을 제거하는 과정이기에 이후 역전파에서 같은 위치의 미분값이 제거되어야 한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">mutable struct</span> Dropout<br>    mask<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> dropout_forward(dropout, x, dropout_ratio)<br>    <span class="hljs-keyword">if</span> dropout_ratio &lt; <span class="hljs-number">1</span><br>        dropout.mask = drop_out(size(x)[<span class="hljs-number">1</span>],size(x)[<span class="hljs-number">2</span>], dropout_ratio)<br>        <span class="hljs-keyword">return</span> x .* dropout.mask<br>    <span class="hljs-keyword">else</span> dropout_ratio = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> x .*  (<span class="hljs-number">1.0</span> - dropout_ratio)<br>        <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> dropout_backward(dropout, dout)<br>    <span class="hljs-keyword">return</span> dout .* dropout.mask<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>이제 드랍아웃을 위한 함수 구현은 모두 끝났다. 다음으로는 위 함수들을 이용하여 드랍아웃을 적용한 모델과 적용하지 않은 모델을 비교해보자.</p><h2 id="신경망-모델-구현">신경망 모델 구현</h2><p>신경망 모델은 지금까지 구현했던 <code>MNIST</code>데이터를 사용하는 2층 신경망 모델을 다시 사용할 것이다. 역전파 모델에 대한 정보는 <a href="https://dev-bearabbit.github.io/2020/04/20/DeeplearningJulia/Deeplearning-9/">해당 글</a>에서 확인할 수 있다. 또한 모델 구성에 필요한 함수들은 <a href="https://github.com/Hyeonji-Ryu/Deep_Learning_in_Julia/blob/master/MLP/train_forward_propagation.jl">깃허브</a>에서 찾아볼 수 있다. 준비가 완료되었다면 본격적으로 구현해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-comment">#훈련데이터 300개</span><br><br>train_x = train_x[<span class="hljs-number">1</span>:<span class="hljs-number">300</span>,:]<br>train_y = train_y[<span class="hljs-number">1</span>:<span class="hljs-number">300</span>,:]<br>t = t[<span class="hljs-number">1</span>:<span class="hljs-number">300</span>,:]<br></code></pre></td></tr></table></figure><p>이번 구현에서는 오버피팅을 발생시키기 위해서 60000개인 <code>train_x</code>데이터 중에서 300개만을 사용하여 학습시킬 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Julia">params = <span class="hljs-built_in">Dict</span>()<br>grads = <span class="hljs-built_in">Dict</span>()<br><br><span class="hljs-comment"># 층에 들어갈 가중치와 편향 입력</span><br>W = [<span class="hljs-string">&quot;W1&quot;</span>, <span class="hljs-string">&quot;W2&quot;</span>]<br>b = [<span class="hljs-string">&quot;b1&quot;</span>, <span class="hljs-string">&quot;b2&quot;</span>]<br>hidden_size = [<span class="hljs-number">50</span>]<br><br>making_network(W,b,<span class="hljs-number">784</span>,hidden_size,<span class="hljs-number">10</span>,<span class="hljs-string">&quot;std&quot;</span>)<br><br><span class="hljs-comment"># 계층마다 인스턴스를 만들어줘야 한다. (for 역전파)</span><br><br>result = SoftmaxwithLoss(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>dense1 = dense_layer(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>dense2 = dense_layer(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>Sigmoid1 = Sigmoid(<span class="hljs-number">0</span>)<br>Relu = ReLu(<span class="hljs-number">0</span>)<br>optimizer = optimizers(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br><br><br>accuracy_test = <span class="hljs-built_in">Float64</span>[]<br>accuracy_train = <span class="hljs-built_in">Float64</span>[]<br>train_size = size(train_x)[<span class="hljs-number">1</span>]<br>batch_size = <span class="hljs-number">100</span><br>learning_rate = <span class="hljs-number">0.01</span><br></code></pre></td></tr></table></figure><p>모델 학습을 위한 변수들을 정의한다. 참고로 여기서 사용된 <code>making_network()</code>는 이전글인 <a href="https://dev-bearabbit.github.io/2020/05/15/DeeplearningJulia/Deeplearning-12/">가중치 초기값</a>에서 사용했던 함수와 다르다. 역전파 알고리즘에서 사용했던 함수와 동일하다. 만약 새로운 <code>making_network()</code>를 사용하고 싶다면, 가중치와 편향 입력 부분을 아래와 같이 변경하면 된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-comment"># 층에 들어갈 가중치와 편향 입력</span><br>W = [<span class="hljs-string">&quot;W1&quot;</span>, <span class="hljs-string">&quot;W2&quot;</span>]<br>b = [<span class="hljs-string">&quot;b1&quot;</span>, <span class="hljs-string">&quot;b2&quot;</span>]<br>input_size = (<span class="hljs-number">1</span>, <span class="hljs-number">784</span>)<br>hidden_size = [(<span class="hljs-number">784</span>,<span class="hljs-number">50</span>),(<span class="hljs-number">50</span>,<span class="hljs-number">10</span>)]<br><br>params = making_network(W, b, weight_size, input_size, <span class="hljs-string">&quot;std&quot;</span>)<br></code></pre></td></tr></table></figure><p>이제 모델을 작동시킬 준비가 끝났다. 아래의 코드를 입력하여 학습을 시작하자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-meta">@time</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:<span class="hljs-number">6000</span><br>        batch_mask = rand(<span class="hljs-number">1</span>:<span class="hljs-number">300</span>, <span class="hljs-number">100</span>)<br>        x_batch = train_x[batch_mask, :]<br>        t_batch = t[batch_mask, :]<br><br>        <span class="hljs-comment"># 순전파</span><br>        z1 = dense_layer_forward(dense1,x_batch,params[<span class="hljs-string">&quot;W1&quot;</span>],params[<span class="hljs-string">&quot;b1&quot;</span>])<br>        a1 = relu_forward(Relu,z1)<br>        z2 = dense_layer_forward(dense2,a1,params[<span class="hljs-string">&quot;W2&quot;</span>],params[<span class="hljs-string">&quot;b2&quot;</span>])<br>        num = SoftmaxwithLoss_forward(z2,t_batch)<br><br>        <span class="hljs-comment"># 역전파</span><br>        last_layer = SoftmaxwithLoss_backward(result)<br>        z2_back = dense_layer_backward(dense2, last_layer)<br>        grads[<span class="hljs-string">&quot;W2&quot;</span>] = dense2.dw<br>        grads[<span class="hljs-string">&quot;b2&quot;</span>] = dense2.db<br>        a1_back = relu_backward(Relu,z2_back)<br>        z1_back = dense_layer_backward(dense1, a1_back)<br>        grads[<span class="hljs-string">&quot;W1&quot;</span>] = dense1.dw<br>        grads[<span class="hljs-string">&quot;b1&quot;</span>] = dense1.db<br><br>        <span class="hljs-comment">#가중치 갱신</span><br>        SGD(params, grads)<br><br>        temp_loss = loss(x_batch, t_batch)<br>        print(<span class="hljs-string">&quot;NO.<span class="hljs-variable">$i</span>: &quot;</span>)<br>        println(temp_loss)<br>        append!(train_loss_list, temp_loss)<br>        append!(accuracy_test, evaluate(test_x, test_y))<br>        append!(accuracy_train, evaluate(train_x, train_y))<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위 모델은 300개의 데이터를 100개 배치데이터 단위로 2000에폭 학습한다. 이제 위의 결과를 그래프를 그려 확인해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Julia">without_train = vcat(accuracy_train)<br>without_test = vcat(accuracy_test)<br><br>x = range(<span class="hljs-number">1</span>,length(without_train),step=<span class="hljs-number">1</span>)<br>data = [without_train without_test]<br>labels = [<span class="hljs-string">&quot;accuracy_train&quot;</span> <span class="hljs-string">&quot;accuracy_test&quot;</span>]<br>markercolors = [<br>    :red :blue<br>]<br><br>pl_nodrop=plot(<br>    x,<br>    data,<br>    label = labels,<br>    color = markercolors,<br>    markersize = <span class="hljs-number">4</span>,<br>    title = <span class="hljs-string">&quot;Accuracy without Dropout&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>그 결과는 아래와 같다.</p><figure><img src="/images/63.png" alt="드랍아웃 없음" /><figcaption aria-hidden="true">드랍아웃 없음</figcaption></figure><p>그래프를 확인해보면 훈련데이터는 정확도가 거의 100%에 가깝지만 실제데이터의 정확도는 80% 근방에서 멈춘 것을 확인할 수 있다. 따라서 이런 경우 드랍아웃을 추가하면 위의 현상을 완화시킬 수 있다. 이제 드랍아웃이 적용된 모델을 확인하자.</p><p><strong>WARNING</strong> 모델을 다시 훈련시키기에 앞서 가중치와 편향을 다시 초기화해주어야 한다. 따라서 다시 아래의 코드를 작동시켜야 한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Julia">params = <span class="hljs-built_in">Dict</span>()<br>grads = <span class="hljs-built_in">Dict</span>()<br><br><span class="hljs-comment"># 층에 들어갈 가중치와 편향 입력</span><br>W = [<span class="hljs-string">&quot;W1&quot;</span>, <span class="hljs-string">&quot;W2&quot;</span>]<br>b = [<span class="hljs-string">&quot;b1&quot;</span>, <span class="hljs-string">&quot;b2&quot;</span>]<br>hidden_size = [<span class="hljs-number">50</span>]<br><br>making_network(W,b,<span class="hljs-number">784</span>,hidden_size,<span class="hljs-number">10</span>,<span class="hljs-string">&quot;std&quot;</span>)<br><br><span class="hljs-comment"># 계층마다 인스턴스를 만들어줘야 한다. (for 역전파)</span><br><br>result = SoftmaxwithLoss(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>dense1 = dense_layer(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>dense2 = dense_layer(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>Sigmoid1 = Sigmoid(<span class="hljs-number">0</span>)<br>Relu = ReLu(<span class="hljs-number">0</span>)<br>optimizer = optimizers(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br><br><br>accuracy_test = <span class="hljs-built_in">Float64</span>[]<br>accuracy_train = <span class="hljs-built_in">Float64</span>[]<br>train_size = size(train_x)[<span class="hljs-number">1</span>]<br>batch_size = <span class="hljs-number">100</span><br>learning_rate = <span class="hljs-number">0.01</span><br></code></pre></td></tr></table></figure><p>이제 모델을 학습해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-meta">@time</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:<span class="hljs-number">6000</span><br>        batch_mask = rand(<span class="hljs-number">1</span>:<span class="hljs-number">300</span>, <span class="hljs-number">100</span>)<br>        x_batch = train_x[batch_mask, :]<br>        t_batch = t[batch_mask, :]<br><br>        <span class="hljs-comment"># 신경망 계산</span><br>        z1 = dense_layer_forward(dense1,x_batch,params[<span class="hljs-string">&quot;W1&quot;</span>],params[<span class="hljs-string">&quot;b1&quot;</span>])<br>        a1 = relu_forward(Relu,z1)<br>        dt = dropout_forward(dropout, a1, <span class="hljs-number">0.3</span>) <span class="hljs-comment"># 드랍아웃 레이어</span><br>        z2 = dense_layer_forward(dense2,dt,params[<span class="hljs-string">&quot;W2&quot;</span>],params[<span class="hljs-string">&quot;b2&quot;</span>])<br>        num = SoftmaxwithLoss_forward(z2,t_batch)<br><br>        <span class="hljs-comment"># 역전파</span><br>        last_layer = SoftmaxwithLoss_backward(result)<br>        z2_back = dense_layer_backward(dense2, last_layer)<br>        grads[<span class="hljs-string">&quot;W2&quot;</span>] = dense2.dw<br>        grads[<span class="hljs-string">&quot;b2&quot;</span>] = dense2.db<br>        dt_back = dropout_backward(dropout,z2_back) <span class="hljs-comment"># 드랍아웃 레이어</span><br>        a1_back = relu_backward(Relu, dt_back)<br>        z1_back = dense_layer_backward(dense1, a1_back)<br>        grads[<span class="hljs-string">&quot;W1&quot;</span>] = dense1.dw<br>        grads[<span class="hljs-string">&quot;b1&quot;</span>] = dense1.db<br><br>        <span class="hljs-comment">#가중치 갱신</span><br>        SGD(params, grads)<br><br>        temp_loss = loss(x_batch, t_batch)<br>        print(<span class="hljs-string">&quot;NO.<span class="hljs-variable">$i</span>: &quot;</span>)<br>        println(temp_loss)<br>        append!(train_loss_list, temp_loss)<br>        append!(accuracy_test, evaluate(test_x, test_y))<br>        append!(accuracy_train, evaluate(train_x, train_y))<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위 모델은 중간에 드랍아웃이 적용되어 있다. 드랍아웃 레이어를 확인해보면 비율 파라미터 자리에 <code>0.3</code>이 있다. 즉, 30%의 신호값을 제거하라는 의미이다. 이제 위의 결과를 그래프를 그려 확인해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Julia">with_train = vcat(accuracy_train)<br>with_test = vcat(accuracy_test)<br><br>x = range(<span class="hljs-number">1</span>,length(with_train),step=<span class="hljs-number">1</span>)<br>data = [with_train with_test]<br>labels = [<span class="hljs-string">&quot;accuracy_train&quot;</span> <span class="hljs-string">&quot;accuracy_test&quot;</span>]<br>markercolors = [<br>    :red :blue<br>]<br><br>pl_drop=plot(<br>    x,<br>    data,<br>    label = labels,<br>    color = markercolors,<br>    markersize = <span class="hljs-number">4</span>,<br>    title = <span class="hljs-string">&quot;Accuracy with Dropout&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>결과는 다음과 같다.</p><figure><img src="/images/64.png" alt="드랍아웃 있음" /><figcaption aria-hidden="true">드랍아웃 있음</figcaption></figure><p>훈련데이터의 정확도와 실제데이터의 정확도 간격이 드랍아웃을 적용하지 않은 모델보다 훨씬 줄어든 것을 확인할 수 있다.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>deep learning in julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>딥러닝</tag>
      
      <tag>Deeplearning</tag>
      
      <tag>머신러닝</tag>
      
      <tag>줄리아</tag>
      
      <tag>신경망</tag>
      
      <tag>Dropout</tag>
      
      <tag>드랍아웃</tag>
      
      <tag>MLP</tag>
      
      <tag>뉴럴네트워크</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[12/18] 인공신경망 최적화: 가중치 초기값</title>
    <link href="/ko/DeeplearningJulia/Deeplearning-12/"/>
    <url>/ko/DeeplearningJulia/Deeplearning-12/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다. <span id="more"></span></p><hr /><h2 id="가중치-초기값이란">가중치 초기값이란</h2><p>이전 글에서 우리는 최적화 방법 중 하나인 옵티마이저에 대해서 살펴보았다. 이번 글에서는 두 번째 최적화 방법인 '가중치 초기값 설정 방법'에 대해서 공부할 것이다. 모든 신경망 구조는 초기에 매개 변수를 랜덤으로 설정한다. 매개 변수를 생성하는 코드를 다시 확인해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> making_network(input_size, hidden_size, output_size, weight_init_std =<span class="hljs-number">0.01</span>)<br>    params[<span class="hljs-string">&quot;W1&quot;</span>] = weight_init_std * randn(<span class="hljs-built_in">Float64</span>, input_size, hidden_size)<br>    params[<span class="hljs-string">&quot;b1&quot;</span>] = zeros(<span class="hljs-built_in">Float32</span>, <span class="hljs-number">1</span>, hidden_size)<br>    params[<span class="hljs-string">&quot;W2&quot;</span>] = weight_init_std * randn(<span class="hljs-built_in">Float64</span>, hidden_size, output_size)<br>    params[<span class="hljs-string">&quot;b2&quot;</span>] = zeros(<span class="hljs-built_in">Float32</span>, <span class="hljs-number">1</span>, output_size)<br>    <span class="hljs-keyword">return</span>(params)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위 코드에서 우리는 상수 <code>weight_init_std</code>가 <code>W</code>에 곱해지는 것을 확인할 수 있다. 이는 정규분포를 기반으로 랜덤값을 생성한 <code>W</code>에 <code>0.01</code>을 곱해 <code>W</code>를 더 작게 만든 것이다. <code>W</code>를 작게 만드는 이유는 '기울기 소실(Gradoent Vanishing)'을 방지하기 위해서이다.</p><p><strong>Note</strong> 기울기 소실(Gradoent Vanishing)이란? 깊은 신경망을 학습하다보면 기울기의 값이 점점 작아지면서 아예 0이 되는 상황을 말한다. 이는 신경망 자체의 문제라기보다는 활성화 함수에 연계된 문제이다. 예를 들어 시그모이드 함수의 경우, 0-1사이의 범위에서 결과값들을 도출하는데, 그 결과값들이 0과 1에 가까워질수록 기울기가 0으로 수렴한다. 즉, 기울기가 사라지는 것이다. 이런 문제는 활성화 함수에 맞춰 초기값 설정을 잘하면 어느정도 방지할 수 있다.</p><h2 id="std">std</h2><p><code>std</code>는 "standard deviation"의 약자로 표준편차를 의미하며, 지금까지 우리가 사용했던 방식이다. 식은 다음과 같다.</p><p><span class="math display">\[W := 0.01 \times W\]</span></p><p><code>std</code>는 가중치 초기값 설정에서 정규분포 기반의 랜덤값을 생성한 후, <code>0.01</code>을 곱한다. 이런 방식은 가중치 초기값을 0과 1사이의 값으로 설정하면서 얕은 신경망의 기울기 소실 문제는 막아준다. 하지만 깊은 신경망을 학습시키는 경우에는 각 층을 지날수록 output값이 0.5에 수렴하는 문제가 발생한다. 이는 다양한 범위를 가진데이터의 표현력을 제한하는 결과를 초래한다. 따라서 깊은 신경망에서는 다른 초기값을 사용하는 것이 데이터의 특징을 잘 학습할 수 있다. 다른 초기값으로는 시그모이드 함수와 같은 S자 함수에 사용되는 "Xavier" 초기값과 ReLU와 같은 함수에 사용되는 "He" 초기값이 있다.</p><h2 id="xavier">Xavier</h2><p><code>Xavier</code> 초기값은 처음 이를 제안한 '사비에르 글로로트(Xavier Glorot)'의 이름을 가져왔으며, 수식은 다음과 같다.</p><p><span class="math display">\[W := \sqrt\frac{1}{n} \times W\]</span></p><p>위 수식에서 <code>n</code>은 앞 계층의 노드 갯수이다. 예를 들어, 입력값이 <span class="math inline">\(1 \times 784\)</span>개이고, 첫 번째 가중치의 초기값을 구하려고 한다. 그렇다면 <code>n</code>은 <span class="math inline">\(784\)</span>가 될 것이다. 또한 앞의 노드가 <span class="math inline">\(1 \times 50\)</span>이라고 한다면, <code>n</code>은 <span class="math inline">\(50\)</span>이 된다.</p><p><code>Xavier</code> 초기값은 가중치에 이전 노드 갯수와 반비례 관계를 생성하여 출력값들이 정규분포 형태를 유지하도록 해준다. 즉, 이전 노드가 많았다면 가중치의 값은 더 작아지며, 이전 노드가 적었다면 가중치의 값을 크게하여 초기의 정규분포 형태를 계속 유지해주는 것이다. 하지만 이 방법은 S자 함수에 적합하며, ReLU와 같은 비선형 함수에는 적합하지 않다. 그 이유는 위 방법이 대칭 구조에 적합하기 때문이다. ReLU의 경우 음수는 모두 0으로 처리되기 때문에 이전 대부분의 노드가 음수라면 출력값이 0쪽으로 치우친다. 따라서 ReLU와 같은 비선형 함수는 그에 맞는 초기값 설정이 필요하다.</p><h2 id="he">He</h2><p><code>He</code> 초기값은 처음 이를 제안한 '카이밍 히(kaiming He)'의 이름을 가져왔으며, 수식은 다음과 같다. 참고로 <code>He</code> 초기값에서 쓰인 <code>n</code> 또한 위에서 설명한 바와 같다.</p><p><span class="math display">\[W := \sqrt\frac{2}{n} \times W\]</span></p><p>수식을 살펴보면 <span class="math inline">\(\frac{2}{n}\)</span>에서 2를 제외하고는 <code>Xavier</code> 초기값과 동일한 것을 알 수 있다. 실제로 <code>He</code> 초기값은 ReLU의 특수성을 반영하기 위해 <code>Xavier</code> 초기값을 변형한 결과이다. ReLU 함수는 음수를 전부 0으로 처리함으로써 그 결과값의 그래프가 자연스레 0으로 편향될 수밖에 없다. 따라서 기존 표준편차에 2를 곱해 차이를 극대화해줌으로써 출력값의 편향을 억제한다.</p><h2 id="가중치-초기값-설정하기">가중치 초기값 설정하기</h2><p>이제는 우리에게 3가지의 가중치의 초기값이 있다. 이를 편하게 사용하기 위해서 매개 변수를 생성하는 코드를 일반화하려고 한다. 먼저 완성된 함수는 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> making_network(W, b, weight_size, output_shape, weight_init)<br><br>    params = <span class="hljs-built_in">Dict</span>()<br><br>    <span class="hljs-keyword">if</span> weight_init == <span class="hljs-string">&quot;std&quot;</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>:length(W))<br>            params[W[i]] = <span class="hljs-number">0.01</span> * randn(<span class="hljs-built_in">Float64</span>, weight_size[i])<br>            params[b[i]] = zeros(<span class="hljs-built_in">Float64</span>,<span class="hljs-number">1</span>, weight_size[i][<span class="hljs-keyword">end</span>])<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">return</span>(params)<br><br>    <span class="hljs-keyword">elseif</span> weight_init == <span class="hljs-string">&quot;Xavier&quot;</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>:length(W))<br>            params[W[i]] = ((<span class="hljs-number">1.0</span> / prod(output_shape[i]))^(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>)) * randn(<span class="hljs-built_in">Float64</span>, weight_size[i])<br>            params[b[i]] = zeros(<span class="hljs-built_in">Float64</span>,<span class="hljs-number">1</span>, weight_size[i][<span class="hljs-keyword">end</span>])<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">return</span>(params)<br><br>    <span class="hljs-keyword">elseif</span> weight_init == <span class="hljs-string">&quot;He&quot;</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>:length(W))<br>            params[W[i]] = ((<span class="hljs-number">2.0</span> /prod(output_shape[i]))^(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>)) * randn(<span class="hljs-built_in">Float64</span>, weight_size[i])<br>            params[b[i]] = zeros(<span class="hljs-built_in">Float64</span>,<span class="hljs-number">1</span>, weight_size[i][<span class="hljs-keyword">end</span>])<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">return</span>(params)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span>(params)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>이제 사용법을 확인해보자. <code>making_network()</code>은 입력 변수로 <code>W</code>, <code>b</code>, <code>weight_size</code>, <code>output_shape</code>, <code>weight_init</code> 을 받는다. 하나씩 살펴보자.</p><p>(Summary)</p><ul><li><code>W</code>: 신경망에 필요한 가중치 ( 배열로 구성, ex. 2층 신경망 = ["W1", "W2"] )</li><li><code>b</code>: 신경망에 필요한 편향 ( 배열로 구성, ex. 2층 신경망 = ["b1", "b2"] )</li><li><code>weight_size</code>: 은닉층의 사이즈 ( 배열로 구성 )</li><li><code>output_shape</code>: 층마다 결과값으로 도출되는 사이즈 ( 배열로 구성 )</li><li><code>weight_init</code>: 초기값 설정 ( "std", "Xavier", "He" 중 선택 )</li></ul><p>만약 하나의 신경망을 구성하고 학습시키려고 한다. 그럼 첫 번째로 해야할 일은 신경망 구조를 설정하는 것이다. 여기서는 2층 신경망을 만들기로 했다고 가정하자. 그러면 필요한 가중치와 편향은 2개씩이다. 이를 배열로 정의하여 설정한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">W = [<span class="hljs-string">&quot;W1&quot;</span>, <span class="hljs-string">&quot;W2&quot;</span>]<br>b = [<span class="hljs-string">&quot;b1&quot;</span>, <span class="hljs-string">&quot;b2&quot;</span>]<br></code></pre></td></tr></table></figure><p>그 다음 설정해야 하는 것은 은닉층의 개수이다. 보통 신경망에 사용할 데이터에 따라서 입력값과 출력값은 결정된다. 결국 신경망 구조에서 우리가 결정하는 부분은 은닉층에 관해서이다. MNIST데이터를 사용한다고 가정하고 아래의 수식을 확인해보자.</p><p><span class="math display">\[Input(1 \times 784) \times Hidden(784 \times ?) \times Output(? \times 10)\]</span></p><p>위 수식은 MNIST데이터 기반의 2층 신경망 구조를 나타낸 것이다. 가중치는 <span class="math inline">\(Input\)</span>과 <span class="math inline">\(Hidden\)</span> 사이에 1개, <span class="math inline">\(Hidden\)</span>과 <span class="math inline">\(Output\)</span>사이에 1개가 필요하다. 따라서 총 두 개의 가중치를 변수 <code>weight_size</code> 자리에 입력해줄 것이다. <code>weight_size</code>는 가중치 크기의 튜플을 배열의 요소로 저장한다. 이제 2층 신경망에 맞게 <code>weight_size</code>를 설정해보자. 해당 예시에서는 <code>?</code>을 50으로 설정할 것이다. <code>output_shape</code>은 각 층의 결과값 크기를 배열의 요소로 저장한다. <code>weight_size</code>에 따라서 다음 층의 결과값 크기가 결정된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">weight_size = [(<span class="hljs-number">784</span>, <span class="hljs-number">50</span>), (<span class="hljs-number">50</span>,<span class="hljs-number">10</span>)]<br>output_shape = [(<span class="hljs-number">1</span>,<span class="hljs-number">784</span>),(<span class="hljs-number">1</span>,<span class="hljs-number">50</span>)]<br></code></pre></td></tr></table></figure><p>이제 마지막으로 우리가 설정할 수 있는 입력 변수는 <code>weight_init</code>가 있다. 지금 생성한 2층 신경망의 활성화 함수를 ReLU로 설정할 것이기 때문에 가중치 초기값으로 "He"를 선택할 것이다. 이제 매개 변수를 생성할 준비가 완료되었다. 아래의 코드를 입력하면 2층 신경망에 필요한 매개 변수가 생성된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">params = making_network(W, b, weight_size, output_shape, <span class="hljs-string">&quot;He&quot;</span>)<br></code></pre></td></tr></table></figure><p><code>making_network()</code>는 매개 변수들의 초기값을 담은 딕셔너리를 도출한다. 이를 네트워크로 사용하고 싶은 이름에 할당하자. 여기서 할당되는 딕셔너리는 학습 후에 해당 신경망의 매개 변수들을 담고 있는 '핵심'이 될 것이다. 새롭게 튜닝된 <code>making_network()</code>는 어떤 구조의 신경망이라도 가중치와 편향 초기값을 생성하기에 이전의 버전보다 훨씬 사용하기 편리하다.</p><h2 id="가중치-초기값-별-결과">가중치 초기값 별 결과</h2><p>위에서 설명한 <code>making_network()</code>을 통해서 각 초기값들을 신경망에 적용해보고자 한다. 이번에 학습시킬 신경망의 구조는 다음과 같다.</p><figure><img src="/images/58.png" alt="4층 신경망" /><figcaption aria-hidden="true">4층 신경망</figcaption></figure><ul><li>4층 구조</li><li>MNIST 데이터셋</li><li>역전파 알고리즘</li><li>optimizer: Adam</li><li>배치데이터(100단위) 사용</li><li>3에폭 훈련 예정</li></ul><p><code>He</code>초기값과 <code>Xavier</code> 초기값의 정확한 측정을 위해 활성화 함수는 "ReLU"와 "Sigmoid" 두 가지 버전으로 나누어 학습할 것이다.</p><p>먼저 활성화 함수로 Sigmoid를 사용한 학습 결과를 확인해보자.</p><figure><img src="/images/61.png" alt="시그모이드 정확도" /><figcaption aria-hidden="true">시그모이드 정확도</figcaption></figure><p>위 그래프는 sigmoid 기반 4층 신경망의 정확도를 각 가중치 초기값 별로 나타낸 것이다. 확실히 <code>std</code> 초기값을 사용한 것보다 <code>Xavier</code>, <code>He</code>초기값을 사용하여 학습한 것이 더 높은 정확도를 도출한다.</p><figure><img src="/images/62.png" alt="시그모이드 손실함수" /><figcaption aria-hidden="true">시그모이드 손실함수</figcaption></figure><p>손실함수를 비교해보면 차이가 더 명확히 보인다. 또한 <code>Xavier</code>, <code>He</code>초기값은 비슷한 결과를 도출한다. 시그모이드와 같은 S자 함수에서는 <code>Xavier</code>와 <code>He</code> 둘다 어느정도 효율을 높여주는 것 같다.</p><p>그 다음으로 살펴볼 것은 활성화 함수로 ReLU를 사용한 학습 결과이다. ReLU는 특이한 형태의 비선형 함수이기 때문에 치우침 현상을 막기 위해서는 <code>He</code> 초기값이 더 좋다.</p><figure><img src="/images/59.png" alt="ReLU 정확도" /><figcaption aria-hidden="true">ReLU 정확도</figcaption></figure><p>위 그래프는 ReLU 기반 4층 신경망의 정확도를 보여준다. 확실히 <code>std</code>초기값보다 다른 두 개의 초기값이 더 높은 정확도를 도출한다.</p><figure><img src="/images/60.png" alt="ReLU 손실함수" /><figcaption aria-hidden="true">ReLU 손실함수</figcaption></figure><p>손실함수 또한 <code>Xavier</code>와 <code>He</code> 모두 훨씬 더 낮다.</p><p>위 그래프 결과로 유추해볼 수 있는 결론은 다음과 같다.</p><ul><li>전체적으로 시그모이드 함수보다 ReLU 함수가 더 학습이 잘된다.</li><li><code>std</code>초기값보다 <code>Xavier</code>나 <code>He</code> 초기값을 사용하는 것이 훨씬 효율적이다.</li><li><code>Xavier</code> 초기값보다 <code>He</code> 초기값이 학습진도는 더 빠르다.</li></ul><h2 id="결론">결론</h2><p>이번 글에서는 다양한 가중치 초기값에 대해서 공부하였다. 그에 대한 결론은 다음과 같다.</p><ul><li>얕은 신경망을 구현한다면 <code>std</code>를 써도 문제는 없다.</li><li>하지만 깊은 신경망을 구현한다면 <code>Xavier</code>와 <code>He</code>를 사용해야 한다.</li><li>해당 신경망의 활성화 함수가 시그모이드나 tanH과 같은 S자 함수일 때는 <code>Xavier</code> 초기값 사용하기</li><li>해당 신경망의 활성화 함수가 ReLU와 같은 비선형 함수일 때는 <code>He</code> 초기값 사용하기</li></ul><p>다음 글에서는 오버피팅을 막아주는 드랍아웃(Dropout)에 대해서 살펴볼 것이다.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>deep learning in julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>딥러닝</tag>
      
      <tag>Deeplearning</tag>
      
      <tag>머신러닝</tag>
      
      <tag>줄리아</tag>
      
      <tag>신경망</tag>
      
      <tag>std</tag>
      
      <tag>Xavier</tag>
      
      <tag>He</tag>
      
      <tag>가중치</tag>
      
      <tag>초기값</tag>
      
      <tag>가중치초기값</tag>
      
      <tag>비교</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linear Algebra (3)</title>
    <link href="/ko/Mathematic/mathematic-2/"/>
    <url>/ko/Mathematic/mathematic-2/</url>
    
    <content type="html"><![CDATA[<p>글을 시작하기에 앞서 해당 글은 Marc Peter Deisenroth, A. Aldo Faisal, Cheng Soon Ong의 저서인 mathematics for machine learning을 바탕으로 요약 및 정리한 글임을 알려드립니다. <span id="more"></span></p><hr /><h2 id="벡터-공간-vector-spaces">벡터 공간 (Vector Spaces)</h2><p>이전 글에서도 봤듯이, 선형 방정식은 매트릭스-벡터 형태로도 표현될 수 있다. 이번 글에서는 벡터들이 존재하는 벡터 공간에 대해서 알아볼 것이다.</p><p>시작하기에 앞서 벡터의 특징을 간단하게 정리해보자. 벡터는 서로 더할 수 있으며, 스칼라를 곱할 수 있다. 또한 사칙연산 이후 결과도 벡터로 도출된다. 이런 벡터들의 연산이 가능한 공간을 벡터 공간이라고 한다. 기본 지식은 이 정도면 충분하다. 지금부터는 요소들(elements)의 집합인 군(group)의 개념과 요소들의 구조를 저장하는 작업에 대해서 살펴볼 것이다.</p><h3 id="군-groups">군 (Groups)</h3><p>군(group)은 컴퓨터 과학에서 중요한 역할을 한다. 집합 작업에 대한 프레임 워크를 제공할 뿐만 아니라 암호기법, 코딩 이론, 그래픽에서도 많이 사용된다.</p><p>집합 <span class="math inline">\(\mathcal G\)</span>와 연산자 <span class="math inline">\(\otimes\)</span>를 사용하여 생각해보자. <span class="math inline">\(\mathcal G \times \mathcal G \rightarrow \mathcal G\)</span>의 수식은 <span class="math inline">\(\mathcal G\)</span>로 정의된다. 이와 같이 아래의 조건들을 모두 만족한다면 <span class="math inline">\(G := (\mathcal G, \otimes)\)</span>를 군(group)이라고 정의한다.</p><ul><li><dl><dt>집합 <span class="math inline">\(\mathcal G\)</span>는 연산자 <span class="math inline">\(\otimes\)</span>에 닫혀 있다.</dt><dd><span class="math inline">\(\forall x, y \in \mathcal G : x \otimes y \in \mathcal G\)</span></dd></dl></li><li><p>결합 법칙 : <span class="math inline">\(\forall x,y,z \in \mathcal G: (x\otimes y)\otimes z = x\otimes (y\otimes z)\)</span></p></li><li><p>항등원(neutral element): <span class="math inline">\(\forall x \in \mathcal G \exists e \in \mathcal G: x \otimes e = x \ and \ e \otimes x = x\)</span></p></li><li><p>역원(inverse element): <span class="math inline">\(\forall x \in \mathcal G \exists y \in \mathcal G: x \otimes y = e \ and \ y \otimes x = e\)</span></p></li></ul><p><strong>Note</strong> 역원은 연산자 곱(<span class="math inline">\(\otimes\)</span>)에 대해서만 정의되었기에 <span class="math inline">\(\frac{1}{x}\)</span>가 필요하지는 않다. 또한 만약 '교환 법칙(commutative)'인 <span class="math inline">\(\forall x,y \in \mathcal G : x \otimes y = y \otimes x\)</span>를 추가적으로 포함한다면, <span class="math inline">\(G := (\mathcal G, \otimes)\)</span>은 '아벨군(isanAbelian group)'이라고 한다.</p><p>지금까지 군의 정의에 대해서 살펴보았다. 이제 아래의 예시들이 그룹인지 아닌지 구분해보자.</p><p><span class="math inline">\(\mathbb{Z}\)</span> : 정수, <span class="math inline">\(\mathbb{N}\)</span> : 자연수, <span class="math inline">\(\mathbb{R}\)</span> : 실수</p><ul><li><p><span class="math inline">\((\mathbb{Z}, +)\)</span>는 그룹이다. <span class="math inline">\(\rightarrow\)</span> 모든 정수의 합은 정수이다.</p></li><li><p><span class="math inline">\((\mathbb{N}_0, +)\)</span>은 그룹이 아니다. <span class="math inline">\(\rightarrow\)</span> 항등원 0은 포함하지만 역원이 포함되지 않았다.</p></li><li><p><span class="math inline">\((\mathbb{Z},\cdot)\)</span>은 그룹이 아니다. <span class="math inline">\(\rightarrow\)</span> 항등원 1은 포함하지만 결과값 1을 반환하는 역원이 포함되지 않았다.</p></li><li><p><span class="math inline">\((\mathbb{R},\cdot)\)</span>은 그룹이 아니다. <span class="math inline">\(\rightarrow\)</span> 실수 중 하나인 0은 역원을 포함하지 않는다.</p></li><li><p><span class="math inline">\((\mathbb{R}\)</span>  {0}, <span class="math inline">\(\cdot)\)</span>은 아벨군이다. <span class="math inline">\(\rightarrow\)</span> 0을 제외한 실수는 아벨군의 모든 요건을 충족한다.</p></li><li><p><span class="math inline">\((\mathbb{R}^n, +),(\mathbb{Z}^n, +),n \in \mathbb{N}\)</span>은 <span class="math inline">\(+\)</span>가 성분별로 정의된 경우에 아벨군이다.</p></li><li><p><span class="math inline">\((\mathbb{R}^{m \times n},+)\)</span>, <span class="math inline">\(m \times n\)</span> 행렬은 성분별로 더했을 때 아벨군이다.</p></li><li><p><span class="math inline">\((\mathbb{R}^{n\times n}, \cdot)\)</span>인 경우를 예시를 통해 확인하자. <span class="math inline">\(n \times n\)</span> 행렬의 곱은 다음 식으로 정의된다.</p></li></ul><p><span class="math display">\[ c_{ij} = \sum_{l=1}^n a_{il}b_{lj}, \qquad i = 1,\dots,n,\quad j = 1,\dots,n.\]</span></p><p>위 식에 따르면, <span class="math inline">\(n \times n\)</span> 행렬의 곱은 <span class="math inline">\(n \times n\)</span> 행렬의 형태이기에 곱셈에 닫혀 있고 결합 법칙도 성립한다. 또한 항등 행렬인 <span class="math inline">\(I_n\)</span> 또한 곱셈 결과가 <span class="math inline">\(n \times n\)</span> 행렬을 만족하기에 성립한다. 마지막으로 해당 행렬이 가역행렬이라서 역행렬이 존재한다면, 그 역행렬 또한 <span class="math inline">\(n \times n\)</span> 행렬형태이다. 위 조건을 모두 만족하기에 <span class="math inline">\((\mathbb{R}^{n\times n}, \cdot)\)</span>는 군이라고 할 수 있으며, 이를 '일반선형군(general linear group)'이라고 부른다.</p><p>일반선형군(general linear group)은 가역행렬 A가 <span class="math inline">\(\mathbb{R}^{n \times n}\)</span>에 포함될 때, 행렬곱셈에 대한 군을 의미하며, 기호는 <span class="math inline">\(GL(n,\mathbb{R})\)</span>을 사용한다. 행렬곱은 교환법칙이 성립하지 않기 때문에 일반선형군은 아벨군이 아니라는 점을 기억하자.</p><h3 id="벡터-공간-vector-spaces-1">벡터 공간 (Vector spaces)</h3><p>이전까지는 집합 <span class="math inline">\(\mathcal G\)</span>와 <span class="math inline">\(\mathcal G\)</span> 요소끼리의 내부 연산에 대해서 알아보았다. 지금부터는 집합 '내부 연산자(inner operation)'와 집합끼리의 '외부 연산자(outer operation)' 모두 살펴볼 것이다.</p><p>먼저 벡터 <span class="math inline">\(x \in \mathcal G\)</span>가 내부 연산자로 <span class="math inline">\(+\)</span>이 사용하고, 외부 연산자로 <span class="math inline">\(\cdot\)</span>을 사용하여 <span class="math inline">\(\lambda \in \mathbb{R}\)</span>과 곱한다고 가정하자. 이때 우리는 내부 연산을 덧셈의 형태로, 또 외부 연산을 스케일링(스칼라 곱)으로 생각할 수 있다. 각 연산들은 서로의 결과에 어떠한 영향도 주지않는다는 점을 기억하자.</p><p>실제 값의 벡터 공간 <span class="math inline">\(V = (V,+,\cdot)\)</span>은 집합 <span class="math inline">\(V\)</span>와 두 연산자를 의미한다.</p><p><span class="math display">\[+: V \times V \rightarrow V\]</span> <span class="math display">\[\cdot : \mathbb{R} \times V \rightarrow V\]</span></p><ul><li><span class="math inline">\((V,+)\)</span>은 아벨군이다. (교환 법칙 성립)</li><li>분배 법칙: <span class="math inline">\(\forall \lambda \in \mathbb{R}, x,y \in V: \lambda\cdot(x+y) = \lambda\cdot x + \lambda\cdot y\)</span> <span class="math inline">\(\forall\lambda,\psi \in \mathbb{R}, x \in V (\lambda + \psi)\cdot x = \lambda\cdot x + \psi\cdot x\)</span></li><li>결합 법칙 (외부 연산자): <span class="math inline">\(\forall\lambda \in \mathbb{R}, x \in V: \lambda\cdot(\psi\cdot x) = (\lambda\psi)\cdot x\)</span></li><li>외부연산자에 대해서는 항등원이 존재한다: <span class="math inline">\(\forall x \in V: 1 \cdot x = x\)</span></li></ul><p>집합 <span class="math inline">\(V\)</span>에 속하는 요소인 <span class="math inline">\(x\)</span>는 벡터이다. 따라서 <span class="math inline">\((V,+)\)</span>의 항등원 또한 영벡터 <span class="math inline">\([0,\dots,0^T ]\)</span>이다.</p>]]></content>
    
    
    <categories>
      
      <category>MachineLearning</category>
      
      <category>mathematics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>머신러닝</tag>
      
      <tag>mathematics</tag>
      
      <tag>machine learning</tag>
      
      <tag>mathematics for machine learning</tag>
      
      <tag>머신러닝 수학</tag>
      
      <tag>수학</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[11/18] 인공신경망 최적화: Optimizer</title>
    <link href="/ko/DeeplearningJulia/Deeplearning-11/"/>
    <url>/ko/DeeplearningJulia/Deeplearning-11/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다. <span id="more"></span></p><hr /><h2 id="인공신경망-최적화란">인공신경망 최적화란</h2><p>무작위값으로 가중치와 편향이 주어진 인공신경망은 바보와 같다. 따라서 신경망은 학습을 통해서 데이터에 적절한 가중치와 편향 값을 찾아야 한다. <strong>인공신경망 최적화란 데이터에 따라 더 적절한 학습 방법을 찾는 과정을 의미한다.</strong> 즉, 적절한 매개 변수 값을 찾기 위한 학습을 좀 더 효율적으로 하고 싶은 사람들이 만든 기술이라는 것이다. 이번 글부터는 최적화에 대해서 다룰 것이며, 어떤 부분들을 최적화할 수 있는지 알아보자.</p><p>신경망 학습을 최적화하기 위해서는 몇 가지의 설정이 필요하다. 필요한 설정은 다음과 같다.</p><ul><li>미분을 어떻게 구할 것인가? (순전파 또는 역전파)</li><li>매개 변수 갱신을 어떻게 할 것인가? (optimizers)</li><li>가중치의 초기값을 어떻게 설정할 것인가? (std, Xavier, He)</li><li>오버피팅을 어떻게 막을 것인가? (가중치 감소 또는 Dropout)</li><li>배치 정규화를 사용할 것인가?</li></ul><p>위의 질문 중에서 첫 번째는 이전 글들에서 직접 확인하였다. 따라서 첫 번째 질문에 대한 답변은 <a href="https://dev-bearabbit.github.io/2020/04/04/DeeplearningJulia/Deeplearning-7/">순전파 알고리즘</a>과 <a href="https://dev-bearabbit.github.io/2020/04/20/DeeplearningJulia/Deeplearning-9/">역전파 알고리즘</a>으로 대신할 것이다.</p><p>다음 질문은 매개 변수 갱신 방법에 대한 논의이며, 이번 글에서 우리가 다룰 주제이다.</p><h2 id="optimizers">Optimizers</h2><p>옵티마이저(Optimizer)는 도출된 미분 값을 어떻게 계산하여 적용하는지를 다루는 기법이다. 종류는 매우 다양하지만 이 글에서는 'SGD', 'Momentum', 'AdaGrad', 'RMSProp', 'Adam'만 다룰 것이다. 몇몇 옵티마이저는 갱신할 때 이전 값들을 필요로 한다. 따라서 옵티마이저 구조체를 설정하여 값을 보관해야 한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">mutable struct</span> optimizers<br>    v<br>    h<br>    m<br>    iter<br><span class="hljs-keyword">end</span><br><br>optimizer = optimizers(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h3 id="sgd">SGD</h3><p>SGD는 'Stochastic Gradient Descent'의 약자로서 한국어로 '확률적 경사 하강법'이라고도 불린다. SGD 수식은 다음과 같다.</p><p><span class="math display">\[ W \leftarrow W - \eta \frac{\partial L}{\partial W}\]</span></p><p>위 식을 분석해보면 SGD는 매개 변수의 편미분 값에 학습률 <span class="math inline">\(\eta\)</span>를 곱한 뒤, 기존 매개 변수에서 뺀다. 계산된 결과를 다시 매개 변수로 갱신한다.</p><p>위의 식을 코드로 구현하면 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> SGD(params,grads)<br><br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> keys(params)<br>        params[key] -= learning_rate * grads[key]<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> params<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>SGD()</code>는 기존 매개 변수가 있는 <code>params</code>와 편미분값이 저장된 <code>grads</code>를 인수로 받는다. 이후 위 수식처럼 계산을 하여 다시 <code>params</code>를 갱신한 후 결과로 내보낸다.</p><h3 id="momentum">Momentum</h3><p>Momentum(이하 모멘텀)은 운동량을 뜻하는 단어로 물리에서 사용하는 원리가 추가되었다. 보통 물리에서 모멘텀은 어떤 물체가 한 방향으로 지속적으로 변동하려는 경향을 뜻한다. 여기서도 같은 맥락으로 사용되었다. 모멘텀의 수식은 다음과 같다.</p><p><span class="math display">\[v \leftarrow \alpha v - \eta \frac{\partial L}{\partial W}\]</span> <span class="math display">\[W \leftarrow W + v\]</span></p><p>위 수식에서 확인할 수 있듯이 모멘텀은 SGD와는 다르게 새로운 변수 <span class="math inline">\(v\)</span>가 추가되었다. <span class="math inline">\(v\)</span>는 물리에서 속도와 같은 의미이다. 즉, 모멘텀이 한 방향으로 지속하려는 경향을 숫자로 나타낸 것이 <span class="math inline">\(v\)</span>인 것이다. 따라서 기울기의 각도가 수직적일수록 속도는 증가하며, 수평적일수록 속도는 감소한다.</p><p>모멘텀은 <span class="math inline">\(v\)</span>로 인해 로컬 미니멈에 도착하여도 그 공간을 벗어날 수 있다. 이는 로컬 미니멈에 도착하면 기울기가 0이 되어 멈추는 SGD의 단점을 보완한 기법이기도 하다.</p><p>모멘텀을 코드로 구현하면 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> Momentum(params,grads)<br><br>    momentum = <span class="hljs-number">0.</span><br><br>    <span class="hljs-keyword">if</span> optimizer.v == <span class="hljs-number">0</span><br>        optimizer.v = <span class="hljs-built_in">Dict</span>()<br>        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> keys(params)<br>            optimizer.v[key] = zeros(size(params[key]))<br><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> keys(params)<br>        optimizer.v[key] = (optimizer.v[key].* momentum) - (learning_rate * grads[key])<br>        params[key] += optimizer.v[key]<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> params<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>Momentum()</code>도 SGD와 같이 <code>params</code>와 <code>grads</code>를 인수로 받은 후 계산하여 <code>params</code>를 갱신한 후 결과로 내보낸다.</p><h3 id="adagrad">AdaGrad</h3><p>매개 변수를 갱신함에 있어서 가장 중요한 부분 중 하나는 '학습률'이다. SGD나 모멘텀에서는 학습률 <span class="math inline">\(\eta\)</span>가 상수로 사용되었다. 하지만 AdaGrad에서는 학습률이 변수로서 사용되며, 최솟점에 다다를수록 학습률이 감소한다. AdaGrad를 수식으로 나타내면 다음과 같다.</p><p><span class="math display">\[h \leftarrow h + \frac{\partial L}{\partial W} \odot \frac{\partial L}{\partial W}\]</span> <span class="math display">\[ W \leftarrow W - \eta \frac{1}{\sqrt{h}}\frac{\partial L}{\partial W}\]</span></p><p>위 수식에서 <span class="math inline">\(\odot\)</span>는 '아다마르 곱(Hadamard product)'이다. 아다마르 곱은 동일한 크기의 행렬 두 개를 원소별로 곱한다. 따라서 첫 번째 수식은 해당 매개 변수의 미분값을 원소 별로 곱셈한 후, 기존의 <span class="math inline">\(h\)</span>와 더하여 <span class="math inline">\(h\)</span>를 갱신한다. 이렇게 계산된 <span class="math inline">\(h\)</span>는 매개 변수를 갱신하는 두 번째 수식으로 들어가며, <span class="math inline">\(\frac{1}{\sqrt{h}}\)</span>는 <span class="math inline">\(h\)</span>가 클수록 작아진다. 따라서 학습이 진행되면서 <span class="math inline">\(h\)</span>는 점점 커지고, 학습률은 점점 작아진다.</p><p>AdaGrad를 코드로 구현하면 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> AdaGrad(params,grads)<br><br>    <span class="hljs-keyword">if</span> optimizer.h == <span class="hljs-number">0</span><br>        optimizer.h = <span class="hljs-built_in">Dict</span>()<br>        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> keys(params)<br>            optimizer.h[key] = zeros(size(params[key]))<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> keys(params)<br>        optimizer.h[key] +=  grads[key] .* grads[key]<br>        params[key] -= (learning_rate * grads[key]) ./ (optimizer.h[key].^(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>).+ <span class="hljs-number">1e-7</span>)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> params<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="rmsprop">RMSProp</h3><p>RMSProp는 AdaGrad의 단점을 보완한 기법이다. AdaGrad는 변수 <span class="math inline">\(h\)</span>가 지속적으로 증가하면서 이동 속도를 줄이며, 단순한 볼록 형태를 가진 환경에서는 최소점을 잘 찾을 수 있다. 하지만 로컬 미니멈이 존재하는 비볼록 형태의 환경에서는 로컬 미니멈에서 벗어나기 어렵다. 이런 부분을 보완하고자 감소하는 속도를 나타내는 새로운 상수 <span class="math inline">\(\beta\)</span>를 대입하여 로컬 미니멈에서 벗어날 수 있도록 수정한 것이 RMSProp 기법이다. 이를 수식으로 보면 다음과 같다.</p><p><span class="math display">\[h \leftarrow \beta * h + (1-\beta)(\frac{\partial L}{\partial W} \odot \frac{\partial L}{\partial W})\]</span> <span class="math display">\[ W \leftarrow W - \eta \frac{1}{\sqrt{h}}\frac{\partial L}{\partial W}\]</span></p><p>위 수식에서 확인할 수 있듯이 감소 속도인 <span class="math inline">\(\beta\)</span>가 추가된 것 외에는 AdaGrad와 동일하다. 보통 <span class="math inline">\(\beta\)</span>는 0.9를 사용한다. 이를 코드로 구현하면 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> RMSProp(params,grads)<br><br>    beta = <span class="hljs-number">0.9</span><br><br>    <span class="hljs-keyword">if</span> optimizer.h == <span class="hljs-number">0</span><br>        optimizer.h = <span class="hljs-built_in">Dict</span>()<br>        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> keys(params)<br>            optimizer.h[key] = zeros(size(params[key]))<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> keys(params)<br>        optimizer.h[key] = (beta * optimizer.h[key]) + (<span class="hljs-number">1.0</span> - beta)*(grads[key] .* grads[key])<br>        params[key] -= (learning_rate * grads[key]) ./ (optimizer.h[key].^(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>).+ <span class="hljs-number">1e-7</span>)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> params<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="adam">Adam</h3><p>Adam은 'Adaptive moments'의 약자로 모멘텀과 RMSProp를 섞은 형태의 기법이다. Adam에는 총 2개의 변수가 등장하는데, 모멘텀의 속도 원리가 적용된 변수 <span class="math inline">\(m\)</span>과 RMSProp에서 감소 속도 원리가 적용된 변수 <span class="math inline">\(v\)</span>이다. 또한 RMSProp에서 사용했던 감소 속도 상수인 <span class="math inline">\(\beta\)</span>도 사용된다. 보통 <span class="math inline">\(m\)</span>에서는 <span class="math inline">\(\beta_1\)</span>이 사용되며 <span class="math inline">\(v\)</span>에서는 <span class="math inline">\(\beta_2\)</span>가 사용된다. 수식은 다음과 같다.</p><p><span class="math display">\[ m \leftarrow \beta_1 * m + (1-\beta_1)\frac{\partial L}{\partial W}\]</span> <span class="math display">\[v \leftarrow \beta_2 * v + (1-\beta_2)(\frac{\partial L}{\partial W} \odot \frac{\partial L}{\partial W})\]</span> <span class="math display">\[\hat{m} \leftarrow \frac{m}{1-\beta_1^t}\]</span> <span class="math display">\[\hat{v} \leftarrow \frac{v}{1-\beta_2^t}\]</span> <span class="math display">\[W \leftarrow W - \frac{\hat{m}*\eta}{\sqrt{\hat{v}}}\]</span></p><p>보통 <span class="math inline">\(\beta_1\)</span>은 0.9를 사용하고 <span class="math inline">\(\beta_2\)</span>는 0.999를 사용한다. Adam은 학습률로 보통 0.01을 쓰는 다른 기법과 다르게 학습률을 0.001을 사용한다. 이를 코드로 구현하면 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> Adam(params,grads,learning_rate = <span class="hljs-number">0.001</span>)<br><br>    beta1 = <span class="hljs-number">0.9</span><br>    beta2 = <span class="hljs-number">0.999</span><br><br>    <span class="hljs-keyword">if</span> optimizer.m == <span class="hljs-number">0</span><br>        optimizer.m = <span class="hljs-built_in">Dict</span>()<br>        optimizer.v = <span class="hljs-built_in">Dict</span>()<br>        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> keys(params)<br>            optimizer.m[key] = zeros(size(params[key]))<br>            optimizer.v[key] = zeros(size(params[key]))<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><br>    optimizer.iter += <span class="hljs-number">1</span><br>    lr_t = learning_rate * (<span class="hljs-number">1.0</span> - beta2^(optimizer.iter))^(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>) / (<span class="hljs-number">1.0</span> - beta1^(optimizer.iter))<br><br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> keys(params)<br>        optimizer.m[key] += (<span class="hljs-number">1</span> - beta1) * (grads[key] - optimizer.m[key])<br>        optimizer.v[key] += (<span class="hljs-number">1</span> - beta2) * (grads[key].^<span class="hljs-number">2</span> - optimizer.v[key])<br>        params[key] -= (lr_t * optimizer.m[key]) ./ ((optimizer.v[key]).^(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>) .+ <span class="hljs-number">1e-7</span>)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> params<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="옵티마이저-비교">옵티마이저 비교</h2><p>지금까지 총 5가지의 옵티마이저 기법들을 살펴보았다. 이제 <code>MNIST</code>데이터를 사용하여 각 기법들을 비교해보자.</p><p>비교하기 위해 사용할 신경망은 2층 구조이며, 활성화 함수로는 ReLU, 미분은 역전파 알고리즘을 사용할 것이다. 각 옵티마이저 별로 3에폭씩 학습하였다. 우리가 비교할 부분은 크게 3가지인 시간, 정확도, 손실 함수이다. 시간은 적게 걸릴 수록, 정확도는 높을 수록, 손실 함수는 낮을 수록 더 좋은 알고리즘이다.</p><p><strong>WARNING</strong> 이 글에서 진행하는 성능 비교는 2층 신경망이며, MNIST데이터를 기반으로 한 분류 모델이다. 다른 모델에서 성능은 이 글의 결과와 차이가 있을 수 있다.</p><p>먼저 5가지의 시간부터 확인해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">SGD: <span class="hljs-number">46.004452</span> seconds<br>Momentum: <span class="hljs-number">47.702307</span> seconds<br>AdaGrad: <span class="hljs-number">49.991280</span> seconds<br>RMSProp: <span class="hljs-number">49.674666</span> seconds<br>Adam: <span class="hljs-number">50.698803</span> seconds<br></code></pre></td></tr></table></figure><p>대부분 45초~50초 사이의 결과가 나왔다. 각 기법 별로 살펴보면 SGD가 가장 시간이 적게 걸리고 Adam이 가장 오래걸리는 것을 확인할 수 있다. 수식과 시간을 대조하여 확인해보면 수식이 복잡할수록 시간이 오래 걸리는 것을 확인할 수 있다.</p><p>다음으로는 정확도를 나타낸 그래프이다.</p><figure><img src="/images/56.png" alt="옵티마이저 정확도" /><figcaption aria-hidden="true">옵티마이저 정확도</figcaption></figure><p>정확도에서는 SGD만 유일하게 90%를 넘지 못하였다. 또한 RMSProp가 다른 기법보다 더 높은 정확도를 도출하는 것을 확인할 수 있다.</p><p>다음으로는 손실 함수를 나타낸 그래프를 살펴보자.</p><figure><img src="/images/57.png" alt="옵티마이저 손실 함수" /><figcaption aria-hidden="true">옵티마이저 손실 함수</figcaption></figure><p>손실 함수 값 또한 RMSProp가 더 낮은 결과를 도출하는 것을 확인할 수 있다.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>deep learning in julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>딥러닝</tag>
      
      <tag>Deeplearning</tag>
      
      <tag>머신러닝</tag>
      
      <tag>줄리아</tag>
      
      <tag>신경망</tag>
      
      <tag>optimizer</tag>
      
      <tag>옵티마이저</tag>
      
      <tag>Adam</tag>
      
      <tag>AdaGrad</tag>
      
      <tag>SGD</tag>
      
      <tag>Momentum</tag>
      
      <tag>RMSProp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[10/18] ReLU vs. Sigmoid 성능 비교</title>
    <link href="/ko/DeeplearningJulia/Deeplearning-10/"/>
    <url>/ko/DeeplearningJulia/Deeplearning-10/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다. <span id="more"></span></p><hr /><p>우리는 이전 장에서 활성화 함수로 시그모이드를 사용한 2층 신경망 학습을 구현하였다. 그렇다면 ReLU를 기반으로 한 신경망과 어떤 차이가 있을까? 이번 글에서는 두 활성화 함수의 성능을 비교할 것이다. 만약 활성화 함수에 대해서 더 공부하고 싶다면 <a href="https://dev-bearabbit.github.io/2020/03/29/DeeplearningJulia/Deeplearning-2/">이 글</a>을 참고하면 된다.</p><p>먼저 간단하게 시그모이드와 ReLU 함수를 복습해보자.</p><h2 id="시그모이드-함수">시그모이드 함수</h2><p>시그모이드 함수는 입력값들을 <span class="math inline">\(0\)</span>과 <span class="math inline">\(1\)</span>사이의 수로 변환해주는 함수이다. 수식은 아래와 같다.</p><p><span class="math display">\[h(x)=\frac{1}{1+e^{-x}}\]</span></p><p>위의 수식에서 볼 수 있듯이 시그모이드는 지수 함수로 이루어져 있다. 그래서 비교적 계산이 복잡하며, 계산량이 많을수록 느려질 수밖에 없다. 만약 지수함수가 왜 느린지 알고 싶다면 <a href="https://dev-bearabbit.github.io/2020/03/19/Algorithms/Algorithms-0/">이 글</a>에서 자세히 살펴볼 수 있다.</p><h2 id="relu-함수">ReLU 함수</h2><p>ReLU 함수는 음수를 모두 <span class="math inline">\(0\)</span>으로 바꾸고 양수는 그대로 출력하는 함수이다. 수식은 다음과 같다.</p><p><span class="math display">\[h(x) = \begin{cases}0 &amp; \text{(x≤0)\]</span>}\ x &amp; \ \end{cases} $$</p><p>ReLU 함수는 x값을 그대로 보내거나 0을 보낸다는 점에서 복잡한 계산은 없다. 그렇기에 같은 조건에서 계산을 진행한다면 시그모이드 함수보다는 빠르며, 최근 많이 사용하는 활성화 함수 중 하나이다.</p><h2 id="성능-비교">성능 비교</h2><p>활성화 함수에 대해 간단하게 복습을 했으니 이제 두 함수를 비교해보자. 우리는 이번 시간에 세 가지의 항목을 기준으로 비교할 것이다. 바로 정확도(accuracy), 손실함수 값(loss value) 그리고 시간이다. 정확도는 높을 수록, 손실 함수 값은 낮을 수록, 시간은 적게 소요될수록 좋은 것이라고 판단할 것이다.</p><p><strong>WARNING</strong> 이 글에서 진행하는 성능 비교는 2층 신경망이며, MNIST데이터를 기반으로 한 분류 모델이다. 다른 모델에서 성능은 이 글의 결과와 차이가 있을 수 있다.</p><p>먼저 비교를 위해서 활성화 함수를 제외한 나머지 조건들은 모두 동일하게 셋팅한다. 우리가 비교에 사용할 신경망은 2층 구조이며, 데이터는 이전 글에서도 사용한 <code>MNIST</code> 데이터를 사용한다. 또한 입력층은 <code>784</code>, 은닉층은 <code>50</code>, 출력층은 <code>10</code>으로 설정한다. 마지막으로 배치 사이즈는 <code>100</code>으로, 학습률은 <code>0.1</code>로 설정하여 기본 셋팅을 완료한다. 해당 케이스에서 1에폭은 600번이다. 기본 셋팅에 대해서 자세히 알고 싶다면 <a href="https://dev-bearabbit.github.io/2020/04/04/DeeplearningJulia/Deeplearning-7/">이 글</a>에서 살펴볼 수 있다.</p><p>성능을 비교하는 과정은 다음과 같다.</p><ol type="1"><li><p>각각 활성화 함수로 이루어진 2층 인공신경망을 1에폭 학습한다.</p></li><li><p>한 번 학습할 때마다 해당 신경망이 <code>test</code>데이터 10000개 중 몇 개를 맞추는지 파악하여 정확도를 측정한다.</p></li><li><p>손실 함수와 정확도를 그래프로 나타낸다.</p></li></ol><h3 id="비교-in-순전파-알고리즘">비교 in 순전파 알고리즘</h3><p>첫 번째로는 순전파 알고리즘을 학습에 사용한 신경망이다. 순전파 알고리즘 구현 방법에 대해서 알고 싶다면 <a href="https://dev-bearabbit.github.io/2020/04/04/DeeplearningJulia/Deeplearning-7/">인공신경망 구현 - 순전파 알고리즘</a>에서 살펴볼 수 있다.</p><p>두 활성화 함수를 비교하기 위해서는 신경망 모델 생성에 필요한 함수와 구조체들을 정의해야 한다. <a href="https://github.com/Hyeonji-Ryu/Deep_Learning_in_Julia/tree/master/MLP">깃허브 페이지</a>에 들어가면 코드를 확인할 수 있다. 참고로 순전파 알고리즘을 작동시키기 위해서는 <code>MNSIT_data.jl</code>과 <code>forward_propagation.jl</code>에 있는 코드를 정의해야 한다.</p><p>순전파에서 활성화 함수를 바꿔주기 위해서는 <code>predict()</code>를 변경해주면 된다. 나머지는 모두 동일하게 사용된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> predict(x)<br>    a1 = (x * params[<span class="hljs-string">&quot;W1&quot;</span>]) .+ params[<span class="hljs-string">&quot;b1&quot;</span>]<br>    z1 = sigmoid.(a1)<br>    a2 = (z1 * params[<span class="hljs-string">&quot;W2&quot;</span>]) .+ params[<span class="hljs-string">&quot;b2&quot;</span>]<br>    <span class="hljs-keyword">return</span> softmax(a2)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위 코드는 <code>predict()</code>이다. 함수 중간에 보면 <code>z1</code> 부분에 시그모이드가 있는 것을 확인할 수 있다. 위의 함수로 진행하면 시그모이드 기반의 신경망 모델이 작동된다. 따라서 <code>ReLU()</code>를 사용할 때는 아래의 함수 정의로 사용해야 한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> predict(x)<br>    a1 = (x * params[<span class="hljs-string">&quot;W1&quot;</span>]) .+ params[<span class="hljs-string">&quot;b1&quot;</span>]<br>    z1 = relu.(a1)<br>    a2 = (z1 * params[<span class="hljs-string">&quot;W2&quot;</span>]) .+ params[<span class="hljs-string">&quot;b2&quot;</span>]<br>    <span class="hljs-keyword">return</span> softmax(a2)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>이제 준비가 끝났다. 학습을 진행해보자. 참고로 아래의 학습 코드는 바꿀 것이 없다. <strong>활성화 함수를 변경하려면 위의 <code>predict()</code>만 변경하면 된다.</strong></p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-meta">@time</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:<span class="hljs-number">600</span><br>        batch_mask = rand(<span class="hljs-number">1</span>:train_size, <span class="hljs-number">100</span>)<br>        x_batch = train_x[batch_mask, :]<br>        t_batch = t[batch_mask, :]<br>        TwoLayerNet_numerical_gradient(loss, x_batch, t_batch)<br><br>        SGD(params, grads)<br><br>        temp_loss = loss(x_batch, t_batch)<br>        print(<span class="hljs-string">&quot;NO.<span class="hljs-variable">$i</span>: &quot;</span>)<br>        println(temp_loss)<br>        append!(train_loss_list, temp_loss)<br>        append!(accuracy, evaluate(test_x, test_y))<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>우리는 <code>@time</code>을 사용했기에 학습이 끝나면 하단에 소요 시간이 나타난다. 두 함수에 따라 소요되는 시간은 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">sigmoid: <span class="hljs-number">17632.126342</span> seconds<br>ReLU: <span class="hljs-number">14847.352078</span> seconds<br></code></pre></td></tr></table></figure><p>1에폭이었지만 시그모이드는 약 5시간, ReLU는 약 4시간 소요된 것을 확인할 수 있다. 시간 측면에서 성능은 ReLU의 승리이다.</p><p>또한 정확도인 <code>accuracy</code>와 손실함수값 리스트인 <code>train_loss_list</code>가 도출된다. 이를 사용한 활성화 함수에 따라 분리하여 저장하자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-comment"># 시그모이드 기반 신경망 학습 후 저장</span><br>sig_forward_acc = vcat(accuracy)<br>sig_forward_loss = vcat(train_loss_list)<br><br><span class="hljs-comment"># ReLU 기반 신경망 학습 후 저장</span><br>relu_forward_acc = vcat(accuracy)<br>relu_forward_loss = vcat(train_loss_list)<br></code></pre></td></tr></table></figure><p>이후 <code>Plots</code>를 사용하여 그래프를 그리면 아래와 같은 결과가 도출된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Julia">x = range(<span class="hljs-number">1</span>,length(relu_forward_acc),step=<span class="hljs-number">1</span>)<br>data = [relu_forward_acc sig_forward_acc]<br>labels = [<span class="hljs-string">&quot;ReLU_acc&quot;</span> <span class="hljs-string">&quot;sigmoid_acc&quot;</span>]<br>markercolors = [:red :blue]<br><br>for_acc=plot(<br>    x,<br>    data,<br>    label = labels,<br>    color = markercolors,<br>    markersize = <span class="hljs-number">2</span>,<br>    title = <span class="hljs-string">&quot;Accuracy in Forward propagation&quot;</span>)<br></code></pre></td></tr></table></figure><figure><img src="/images/52.png" alt="순전파 정확도" /><figcaption aria-hidden="true">순전파 정확도</figcaption></figure><p>정확도를 비교해보면 ReLU 함수가 더 높은 것을 확인할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Julia">x1 = range(<span class="hljs-number">1</span>,length(relu_forward_loss),step=<span class="hljs-number">1</span>)<br>data1 = [relu_forward_loss sig_forward_loss]<br>labels = [<span class="hljs-string">&quot;ReLU_loss&quot;</span> <span class="hljs-string">&quot;sigmoid_loss&quot;</span>]<br>markercolors = [:red :blue]<br><br>for_acc=plot(<br>    x3,<br>    data3,<br>    label = labels,<br>    color = markercolors,<br>    markersize = <span class="hljs-number">2</span>,<br>    title = <span class="hljs-string">&quot;Loss in Forward propagation&quot;</span>)<br></code></pre></td></tr></table></figure><figure><img src="/images/53.png" alt="순전파 손실함수" /><figcaption aria-hidden="true">순전파 손실함수</figcaption></figure><p>손실함수 또한 ReLU가 더 낮다. 즉 순전파에서 ReLU의 완벽한 승리이다.</p><h3 id="비교-in-역전파-알고리즘">비교 in 역전파 알고리즘</h3><p>지금부터는 이전 글에서 만들었던 역전파 알고리즘을 사용하여 신경망 모델을 학습시킬 것이다. 역전파 알고리즘 구현 방법에 대해서 알고 싶다면 <a href="https://dev-bearabbit.github.io/2020/04/20/DeeplearningJulia/Deeplearning-9/">인공신경망 구현 - 역전파 알고리즘</a>에서 살펴볼 수 있다. 또한 역전파의 경우 개념이 추상적이라서 원리를 더 정확히 이해하고 싶다면 <a href="https://dev-bearabbit.github.io/2020/04/15/DeeplearningJulia/Deeplearning-8/">인공신경망 구현 - 역전파 설명</a>을 읽어보기를 추천한다.</p><p>순전파와 마찬가지로 두 활성화 함수를 비교하기 위해서는 신경망 모델 생성에 필요한 함수와 구조체들을 정의해야 한다. <a href="https://github.com/Hyeonji-Ryu/Machine_Learning_in_Julia/tree/master/MLP">깃허브 페이지</a>에 들어가면 코드를 확인할 수 있다. 역전파 알고리즘 또한 작동시키기 위해서는 <code>MNSIT_data.jl</code>과 <code>backward_propagation.jl</code>에 있는 코드를 정의해야 한다.</p><p>역전파 알고리즘에서 활성화 함수를 변경하기 위해서는 3가지를 체크해야 한다.</p><ul><li><code>predict()</code> 함수 내에 있는 활성화 함수</li><li>신경망 계산에 속해 있는 활성화 함수 층(layer)</li><li>역전파 알고리즘에 속해 있는 활성화 함수 층(layer)</li></ul><p><code>predict()</code>의 경우는 순전파와 똑같기 때문에 설명은 생략하고, 나머지를 변경해보자. 우선 역전파 알고리즘을 살펴보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-meta">@time</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:<span class="hljs-number">600</span><br>        batch_mask = rand(<span class="hljs-number">1</span>:train_size, <span class="hljs-number">100</span>)<br>        x_batch = train_x[batch_mask, :]<br>        t_batch = t[batch_mask, :]<br><br>        <span class="hljs-comment"># 신겸망 계산</span><br>        z1 = dense_layer_forward(dense1,x_batch,params[<span class="hljs-string">&quot;W1&quot;</span>],params[<span class="hljs-string">&quot;b1&quot;</span>])<br>        a1 = sigmoid_forward(Sigmoid1,z1) <span class="hljs-comment"># 활성화 함수 층</span><br>        z2 = dense_layer_forward(dense2,a1,params[<span class="hljs-string">&quot;W2&quot;</span>],params[<span class="hljs-string">&quot;b2&quot;</span>])<br>        num = SoftmaxwithLoss_forward(z2,t_batch)<br><br>        <span class="hljs-comment"># 역전파</span><br>        last_layer = SoftmaxwithLoss_backward(result)<br>        z2_back = dense_layer_backward(dense2, last_layer)<br>        grads[<span class="hljs-string">&quot;W2&quot;</span>] = dense2.dw<br>        grads[<span class="hljs-string">&quot;b2&quot;</span>] = dense2.db<br>        a1_back = sigmoid_backward(Sigmoid1, z2_back) <span class="hljs-comment"># 활성화 함수 층</span><br>        z1_back = dense_layer_backward(dense1, a1_back)<br>        grads[<span class="hljs-string">&quot;W1&quot;</span>] = dense1.dw<br>        grads[<span class="hljs-string">&quot;b1&quot;</span>] = dense1.db<br><br>        <span class="hljs-comment">#가중치 갱신</span><br>        SGD(params, grads)<br><br>        temp_loss = loss(x_batch, t_batch)<br>        print(<span class="hljs-string">&quot;NO.<span class="hljs-variable">$i</span>: &quot;</span>)<br>        println(temp_loss)<br>        append!(train_loss_list, temp_loss)<br>        append!(accuracy, evaluate(test_x, test_y))<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위 코드에 두 개의 활성화 함수 층이 있다. 이 함수를 시그모이드나 ReLU로 변경하면 된다. 위 코드는 시그모이드가 현재 활성화 함수로 사용되고 있다.</p><p>해당 학습을 진행하면 결과로 시간이 나온다. 역전파 알고리즘에서 1에폭 당 소요되는 시간은 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">relu_back : <span class="hljs-number">16.509151</span> seconds<br>sigmoid_back : <span class="hljs-number">19.750770</span> seconds<br></code></pre></td></tr></table></figure><p>역전파 또한 시그모이드 함수보다 ReLU 함수가 더 빠른 것을 확인할 수 있다. 역전파에서도 시간 측면에서의 성능은 ReLU의 승리이다.</p><p>또한 정확도인 <code>accuracy</code>와 손실함수값 리스트인 <code>train_loss_list</code>가 도출된다. 이를 사용한 활성화 함수에 따라 분리하여 저장하자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-comment"># 시그모이드</span><br>sig_backward_acc = vcat(accuracy)<br>sig_backward_loss = vcat(train_loss_list)<br><br><span class="hljs-comment"># ReLU</span><br>relu_backward_acc = vcat(accuracy)<br>relu_backward_loss = vcat(train_loss_list)<br></code></pre></td></tr></table></figure><p>이후 <code>Plots</code>를 사용하여 그래프를 그리면 아래와 같은 결과가 도출된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Julia">x2 = range(<span class="hljs-number">1</span>,length(relu_backward_acc),step=<span class="hljs-number">1</span>)<br>data2 = [relu_backward_acc sig_backward_acc ]<br>labels = [<span class="hljs-string">&quot;ReLU_acc&quot;</span> <span class="hljs-string">&quot;sigmoid_acc&quot;</span>]<br>markercolors = [:red :blue]<br><br>for_acc=plot(<br>    x2,<br>    data2,<br>    label = labels,<br>    color = markercolors,<br>    markersize = <span class="hljs-number">2</span>,<br>    title = <span class="hljs-string">&quot;Accuracy in Backward propagation&quot;</span>)<br></code></pre></td></tr></table></figure><figure><img src="/images/54.png" alt="순전파 정확도" /><figcaption aria-hidden="true">순전파 정확도</figcaption></figure><p>정확도를 비교해보면 ReLU 함수가 더 높은 것을 확인할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Julia">x3 = range(<span class="hljs-number">1</span>,length(relu_backward_loss),step=<span class="hljs-number">1</span>)<br>data3 = [relu_backward_loss  sig_backward_loss]<br>labels = [<span class="hljs-string">&quot;ReLU_loss&quot;</span> <span class="hljs-string">&quot;sigmoid_loss&quot;</span>]<br>markercolors = [:red :blue]<br><br>for_acc=plot(<br>    x3,<br>    data3,<br>    label = labels,<br>    color = markercolors,<br>    markersize = <span class="hljs-number">2</span>,<br>    title = <span class="hljs-string">&quot;Loss in Backward propagation&quot;</span>)<br></code></pre></td></tr></table></figure><figure><img src="/images/55.png" alt="순전파 손실함수" /><figcaption aria-hidden="true">순전파 손실함수</figcaption></figure><p>손실함수 또한 ReLU가 더 낮다. 역전파에서도 ReLU의 완벽한 승리이다.</p><h2 id="결론">결론</h2><p>지금까지 순전파와 역전파 알고리즘에서 어떤 활성화 함수가 학습을 잘 진행하는지, 또 실제 모델로서 잘 예측하는지를 비교해보았다. 결론은 간단한다.</p><blockquote><p>ReLU가 짱이다!</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>deep learning in julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>딥러닝</tag>
      
      <tag>Deeplearning</tag>
      
      <tag>머신러닝</tag>
      
      <tag>줄리아</tag>
      
      <tag>신경망</tag>
      
      <tag>ReLU</tag>
      
      <tag>렐루</tag>
      
      <tag>시그모이드</tag>
      
      <tag>Sigmoid</tag>
      
      <tag>활성화 함수</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[9/18] 인공신경망 구현: 역전파 알고리즘</title>
    <link href="/ko/DeeplearningJulia/Deeplearning-9/"/>
    <url>/ko/DeeplearningJulia/Deeplearning-9/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다. <span id="more"></span></p><hr /><h2 id="역전파-알고리즘-구현">역전파 알고리즘 구현</h2><p>이전 글에서 순전파 알고리즘을 사용하여 구현했던 'MNIST' 프로젝트를 역전파로 구현할 것이다. 'MNIST' 프로젝트에 대한 자세한 사항은 <a href="https://dev-bearabbit.github.io/2020/04/04/DeeplearningJulia/Deeplearning-7/">이전 글</a>에 있으니 먼저 읽어보고 오자. 특히 줄리아에서 MNIST 데이터셋을 불러오는 방법도 이전 글에 있으니 참고하기를 바란다.</p><p>역전파 알고리즘은 다음과 같은 순서로 진행된다.</p><ol type="1"><li>초기값과 매개 변수 설정</li><li>역전파 알고리즘에 필요한 함수 정의</li><li>역전파 알고리즘 - 신경망 계산 (순전파 방향)</li><li>역전파 알고리즘 - 매개 변수 기울기 구하기 (역전파 방향)</li><li>매개 변수 갱신</li><li>3번 - 5번 과정을 횟수만큼 반복</li></ol><h3 id="초기값과-매개-변수-설정">초기값과 매개 변수 설정</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Julia">params = <span class="hljs-built_in">Dict</span>()<br>grads = <span class="hljs-built_in">Dict</span>()<br><br><span class="hljs-keyword">function</span> making_network(input_size, hidden_size, output_size, weight_init_std =<span class="hljs-number">0.01</span>)<br>    params[<span class="hljs-string">&quot;W1&quot;</span>] = weight_init_std * randn(<span class="hljs-built_in">Float64</span>, input_size, hidden_size)<br>    params[<span class="hljs-string">&quot;b1&quot;</span>] = zeros(<span class="hljs-built_in">Float32</span>, <span class="hljs-number">1</span>, hidden_size)<br>    params[<span class="hljs-string">&quot;W2&quot;</span>] = weight_init_std * randn(<span class="hljs-built_in">Float64</span>, hidden_size, output_size)<br>    params[<span class="hljs-string">&quot;b2&quot;</span>] = zeros(<span class="hljs-built_in">Float32</span>, <span class="hljs-number">1</span>, output_size)<br>    <span class="hljs-keyword">return</span>(params)<br><span class="hljs-keyword">end</span><br><br>making_network(<span class="hljs-number">784</span>, <span class="hljs-number">50</span>, <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>매개 변수인 가중치와 편향을 설정하였다. 만약 초기값을 설정하는 방법을 자세히 알고 싶다면 <a href="https://dev-bearabbit.github.io/2020/04/04/DeeplearningJulia/Deeplearning-7/">이전 글</a>에서 확인할 수 있다.</p><p>역전파는 신경망 계산이 진행될 때의 변수 값을 저장해서 매개 변수의 기울기를 구할 때 사용한다. 따라서 각각의 변수 값을 저장해두는 저장소가 필요하다. 우리는 이를 구조체로 설정할 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">mutable struct</span> dense_layer<br>    x<br>    w<br>    b<br>    dw<br>    db<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">mutable struct</span> Sigmoid<br>    z<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">mutable struct</span> ReLu<br>    mask<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">mutable struct</span> SoftmaxwithLoss<br>    y<br>    t<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment"># 계층마다 인스턴스를 만들어줘야 한다.</span><br><br>result = SoftmaxwithLoss(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>dense1 = dense_layer(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>dense2 = dense_layer(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>Sigmoid = Sigmoid(<span class="hljs-number">0</span>)<br>Relu = ReLu(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>각 층을 기준으로 구조체를 만들어준 후, 초기값을 셋팅하였다. 이제 학습 시 신경망 계산이 진행되면서 초기값들이 갱신될 것이다.</p><h3 id="역전파-알고리즘에-필요한-함수-정의">역전파 알고리즘에 필요한 함수 정의</h3><p>이제 역전파 알고리즘에 사용되는 함수를 정의할 것이다. 역전파 알고리즘에서는 신경망 계산 시 변수 값들을 저장해야 하기 때문에 순전파 함수와는 약간 다르다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> cross_entropy_error(y,t)<br>    delta = <span class="hljs-number">1e-7</span><br>    batch_size = length(y[:,<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> (-sum(log.(y.+delta).*t) / batch_size)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> sigmoid(x)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>/(<span class="hljs-number">1</span>+exp(-x))<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> softmax_single(a)<br>    c = maximum(a)<br>    exp.(a .- c) / sum(exp.(a .- c))<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> softmax(a)<br>    temp = map(softmax_single, eachrow(a))<br>    <span class="hljs-keyword">return</span>(transpose(hcat(temp ...)))<br><br><span class="hljs-keyword">function</span> evaluate(test_x,test_y)<br>    temp = (sum((argmax.(eachrow(predict(test_x))).-<span class="hljs-number">1</span>) .== test_y)/size(test_x)[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> (temp * <span class="hljs-number">100</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 함수들은 순전파 알고리즘에서 사용했던 함수와 똑같다. 이는 역전파 알고리즘 신경망 계산 파트에서 사용된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> SoftmaxwithLoss_forward(x,t)<br>    y = softmax(x)<br>    loss = cross_entropy_error(y, t)<br>    result.y = y<br>    result.t = t<br>    <span class="hljs-keyword">return</span> loss<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> SoftmaxwithLoss_backward(result,dout=<span class="hljs-number">1</span>)<br>    batch_size = size(result.t)[<span class="hljs-number">1</span>]<br>    dx = (result.y-result.t) / batch_size<br>    <span class="hljs-keyword">return</span> dx<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>역전파에서는 소프트맥스 함수와 손실 함수를 같이 사용한다. 그 이유는 간단하다. 미분했을 때의 수식이 훨씬 간편해진다. 위의 코드를 보면 알 수 있듯이 소프트맥스와 손실 함수를 같이 미분하면 <span class="math inline">\(\hat{y}_k - t_K\)</span>라는 간단한 식이 도출된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> dense_layer_forward(dense,x,w,b)<br>    cal = (x * w) .+ b<br>    dense.x = x<br>    dense.w = w<br>    dense.b = b<br>    <span class="hljs-keyword">return</span> cal<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> dense_layer_backward(dense, dout)<br>    dx = *(dout,<span class="hljs-built_in">Array</span>(dense.w&#x27;))<br>    dense.dw = *(<span class="hljs-built_in">Array</span>(dense.x&#x27;), dout)<br>    dense.db = <span class="hljs-built_in">Array</span>(sum(eachrow(dout))&#x27;)<br>    <span class="hljs-keyword">return</span> dx<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>dense_layer</code>는 입력값과 가중치를 곱한 후, 편향을 더해주는 층(layer)이다. 역전파에서는 가중치와 편향, 입력값 각각의 편미분을 진행하였다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> sigmoid_forward(Sigmoid, x)<br>    dx = sigmoid.(x)<br>    Sigmoid.z = dx<br>    <span class="hljs-keyword">return</span> dx<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> sigmoid_backward(Sigmoid, dout)<br>    dx = dout .* (<span class="hljs-number">1.0</span> .- Sigmoid.z) .* Sigmoid.z<br>    <span class="hljs-keyword">return</span> dx<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>시그모이드 함수는 신경망 계산 시에 결과값을 저장해두어야 하기 때문에 구조체 <code>Sigmoid</code>에 저장한다. 그후 역전파 함수에서 가져와 미분을 진행한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> relu_forward(Relu, x)<br>    x = relu.(x)<br>    Relu.mask = x .&gt; <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> x<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> relu_backward(Relu,dout)<br>    dx = dout.* Relu.mask<br>    <span class="hljs-keyword">return</span> dx<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>ReLU 함수의 경우 신경망 계산에서 음수인 입력값은 전부 0으로 변경되는데 이를 미분에서도 그대로 구현해주어야 한다. 따라서 0으로 변경되는 위치를 <code>mask</code>에 저장해두었다가 역전파 과정에서 사용한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> SGD(params,grads)<br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> keys(params)<br>        params[key] -= learning_rate * grads[key]<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> params<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>SGD()</code>는 확률적 경사하강법을 구현한 함수로 매개 변수 갱신을 진행한다.</p><h2 id="역전파에-필요한-변수-정의">역전파에 필요한 변수 정의</h2><p>그다음 역전파에 필요한 변수들을 정의한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">train_loss_list = <span class="hljs-built_in">Float64</span>[]<br>accuracy = <span class="hljs-built_in">Float64</span>[]<br>train_size = size(train_x)[<span class="hljs-number">1</span>]<br>batch_size = <span class="hljs-number">100</span><br>learning_rate = <span class="hljs-number">0.1</span><br>iters_num = <span class="hljs-number">600</span><br></code></pre></td></tr></table></figure><h2 id="역전파-알고리즘">역전파 알고리즘</h2><p>역전파를 구현하기 전 준비는 모두 끝났다. 이제 알고리즘을 작동시켜보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-meta">@time</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>: iters_num<br>        batch_mask = rand(<span class="hljs-number">1</span>:train_size, <span class="hljs-number">100</span>)<br>        x_batch = train_x[batch_mask, :]<br>        t_batch = t[batch_mask, :]<br><br>        <span class="hljs-comment"># 순전파</span><br>        z1 = dense_layer_forward(dense1,x_batch,params[<span class="hljs-string">&quot;W1&quot;</span>],params[<span class="hljs-string">&quot;b1&quot;</span>])<br>        a1 = sigmoid_forward(Sigmoid1,z1)<br>        z2 = dense_layer_forward(dense2,a1,params[<span class="hljs-string">&quot;W2&quot;</span>],params[<span class="hljs-string">&quot;b2&quot;</span>])<br>        num = SoftmaxwithLoss_forward(z2,t_batch)<br><br>        <span class="hljs-comment"># 역전파</span><br>        last_layer = SoftmaxwithLoss_backward(result)<br>        z2_back = dense_layer_backward(dense2, last_layer)<br>        grads[<span class="hljs-string">&quot;W2&quot;</span>] = dense2.dw<br>        grads[<span class="hljs-string">&quot;b2&quot;</span>] = dense2.db<br>        a1_back = sigmoid_backward(Sigmoid1, z2_back)<br>        z1_back = dense_layer_backward(dense1, a1_back)<br>        grads[<span class="hljs-string">&quot;W1&quot;</span>] = dense1.dw<br>        grads[<span class="hljs-string">&quot;b1&quot;</span>] = dense1.db<br><br>        <span class="hljs-comment">#가중치 갱신 (SGD)</span><br>        SGD(params, grads)<br><br>        temp_loss = loss(x_batch, t_batch)<br>        print(<span class="hljs-string">&quot;NO.<span class="hljs-variable">$i</span>: &quot;</span>)<br>        println(temp_loss)<br>        append!(train_loss_list, temp_loss)<br>        append!(accuracy, evaluate(test_x, test_y))<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br></code></pre></td></tr></table></figure><p>이전에 구현했던 순전파와 똑같이 1에폭 학습을 진행한다. 위 알고리즘의 프로세스는 다음과 같다.</p><ul><li><p>먼저 입력 데이터 60000개 중에 100개를 무작위로 뽑아서 배치 데이터셋을 생성한다.</p></li><li><p>신경망 계산을 통해 역전파에 필요한 값들을 구조체의 인스턴스에 저장한다.</p></li><li><p>역전파 과정을 진행하여 미분값들을 도출하고 저장한다.</p></li><li><p>역전파로 얻은 미분값들을 사용하여 매개 변수를 갱신한다.</p></li><li><p>갱신한 가중치와 편향으로 손실 함수의 값을 구한 후 <code>train_loss_list</code>에 추가한다.</p></li><li><p>해당 모델을 사용하여 실제 실험데이터를 얼마나 맞추는지 확률을 계산하고, <code>accuracy</code>에 추가한다.</p></li><li><p><code>iters_num</code>만큼 위의 프로세스를 반복한다.</p></li></ul><p>위의 알고리즘을 구현한 결과는 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Julia">NO<span class="hljs-number">.1</span>: <span class="hljs-number">2.2850101570382737</span><br>NO<span class="hljs-number">.2</span>: <span class="hljs-number">2.2850446322621685</span><br>NO<span class="hljs-number">.3</span>: <span class="hljs-number">2.2877722109055973</span><br>NO<span class="hljs-number">.4</span>: <span class="hljs-number">2.295771461232412</span><br>NO<span class="hljs-number">.5</span>: <span class="hljs-number">2.291090515421742</span><br>NO<span class="hljs-number">.6</span>: <span class="hljs-number">2.292813792030001</span><br>NO<span class="hljs-number">.7</span>: <span class="hljs-number">2.2923265665429757</span><br>NO<span class="hljs-number">.8</span>: <span class="hljs-number">2.2667084942417035</span><br>NO<span class="hljs-number">.9</span>: <span class="hljs-number">2.277930664348887</span><br>NO<span class="hljs-number">.10</span>: <span class="hljs-number">2.2888958183165564</span><br>.<br>.<br>.<br>NO<span class="hljs-number">.590</span>: <span class="hljs-number">0.902825806105116</span><br>NO<span class="hljs-number">.591</span>: <span class="hljs-number">0.8906761172487827</span><br>NO<span class="hljs-number">.592</span>: <span class="hljs-number">0.7956979255136711</span><br>NO<span class="hljs-number">.593</span>: <span class="hljs-number">0.9324068193760575</span><br>NO<span class="hljs-number">.594</span>: <span class="hljs-number">0.8170173565209091</span><br>NO<span class="hljs-number">.595</span>: <span class="hljs-number">0.8525111451656349</span><br>NO<span class="hljs-number">.596</span>: <span class="hljs-number">0.8223313778429329</span><br>NO<span class="hljs-number">.597</span>: <span class="hljs-number">0.8781017363141977</span><br>NO<span class="hljs-number">.598</span>: <span class="hljs-number">0.8522437572097963</span><br>NO<span class="hljs-number">.599</span>: <span class="hljs-number">0.7652566853974547</span><br>NO<span class="hljs-number">.600</span>: <span class="hljs-number">0.8263608966251377</span><br> <span class="hljs-number">19.715322</span> seconds (<span class="hljs-number">39.55</span> M allocations: <span class="hljs-number">13.826</span> GiB, <span class="hljs-number">7.82</span>% gc time)<br></code></pre></td></tr></table></figure><p>100 단위의 배치 데이터를 600번 반복한 결과, 처음 2.28였던 손실 함수 값이 0.82까지 떨어졌다. 이는 오답률이 많이 감소되었다는 것을 의미한다. 시간은 대략 20초 정도 소요되었다. 순전파와 비교해봤을 때 매우 빠른 것을 확인할 수 있다.</p><p>역전파 알고리즘에서 저장했던 <code>train_loss_list</code>와 <code>accuracy</code>를 그래프로 나타내보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">using</span> Plots<br>x = range(<span class="hljs-number">1</span>,length(train_loss_list),step=<span class="hljs-number">1</span>)<br>y = train_loss_list<br></code></pre></td></tr></table></figure><figure><img src="/images/47.png" alt="손실 함수 그래프" /><figcaption aria-hidden="true">손실 함수 그래프</figcaption></figure><p>저장된 손실 함수 값을 그래프로 그려본 결과, 지속적으로 감소하는 양상을 확인할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">x = range(<span class="hljs-number">1</span>,length(accuracy),step=<span class="hljs-number">1</span>)<br>y = accuracy<br><br>plot(x,y)<br></code></pre></td></tr></table></figure><figure><img src="/images/48.png" alt="정확도 그래프" /><figcaption aria-hidden="true">정확도 그래프</figcaption></figure><p>저장된 정확도 또한 계속 상승하는 것을 볼 수 있다. 가장 높은 정확도는 아래의 코드를 통해 확인하자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">argmax(accuracy)   <span class="hljs-comment"># 최대값 인덱스 반환</span><br><span class="hljs-number">599</span><br>accuracy[<span class="hljs-number">598</span>]<br><span class="hljs-number">80.14</span><br></code></pre></td></tr></table></figure><p>정확도는 80%를 웃돈다. 역전파 알고리즘은 1에폭 당 20초 정도 소요되기 때문에 3에폭도 1분 내외로 소요된다. 3에폭 정도 학습하면 손실 함수는 더 떨어지고 정확도는 더 오른다.</p><p>3에폭의 결과는 다음과 같다.</p><figure><img src="/images/49.png" alt="손실 함수 그래프" /><figcaption aria-hidden="true">손실 함수 그래프</figcaption></figure><p>손실 함수가 0.5 이하로 떨어진 것을 확인할 수 있다.</p><figure><img src="/images/50.png" alt="정확도 그래프" /><figcaption aria-hidden="true">정확도 그래프</figcaption></figure><p>정확도 또한 80%를 훨씬 넘었다. 정확도를 직접 확인해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">argmax(accuracy)   <span class="hljs-comment"># 최대값 인덱스 반환</span><br><span class="hljs-number">1789</span><br>accuracy[<span class="hljs-number">598</span>]<br><span class="hljs-number">90.38000000000001</span><br></code></pre></td></tr></table></figure><p>정확도가 90%가 넘은 것을 확인할 수 있다.</p><p>역전파 알고리즘은 순전파와 비슷한 학습 효과를 가지고 있지만 속도는 월등히 빠르다.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>deep learning in julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>딥러닝</tag>
      
      <tag>Deeplearning</tag>
      
      <tag>머신러닝</tag>
      
      <tag>줄리아</tag>
      
      <tag>신경망</tag>
      
      <tag>역전파</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>카테고리 및 태그 설정</title>
    <link href="/ko/AboutHexo/about-hexo-2/"/>
    <url>/ko/AboutHexo/about-hexo-2/</url>
    
    <content type="html"><![CDATA[<p>NexT 테마에서 카테고리와 태그를 생성하고자 합니다.</p><p>아직 블로그를 만들지 않았다면 <a href="https://dev-bearabbit.github.io/2020/02/27/AboutHexo/about_hexo-0/">이전 글</a>을 참고해주시기 바랍니다.</p><span id="more"></span><hr /><p>이전 글을 따라 블로그를 만들고 테마를 적용했다면, 다음으로는 카테고리와 태그를 생성해보자.</p><p>먼저 themes &gt; next로 이동한 후 next의 <code>_config.yml</code>을 오픈한다. 그 다음 아래와 같이 카테고리와 태그의 주석을 제거해주세요.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">menu:<br>  home: / || home<br>  <span class="hljs-comment">#about: /about/ || user</span><br>  tags: /tags/ || tags      <span class="hljs-comment"># `#` 제거</span><br>  categories: /categories/ || th    <span class="hljs-comment"># `#` 제거</span><br>  archives: /archives/ || archive<br>  <span class="hljs-comment">#schedule: /schedule/ || calendar</span><br>  <span class="hljs-comment">#sitemap: /sitemap.xml || sitemap</span><br>  <span class="hljs-comment">#commonweal: /404/ || heartbeat</span><br></code></pre></td></tr></table></figure><p>이후 배포를 하면 블로그에 카테고리와 태그가 생긴 것을 확인할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate<br>hexo deploy<br></code></pre></td></tr></table></figure><p>하지만 아직 페이지를 생성하지 않았기 때문에 카테고리와 태그를 누르면 404 오류가 발생한다. 이제 해당 페이지들을 만들어보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new page categories<br>hexo new page tags<br></code></pre></td></tr></table></figure><p>이후 배포하면 카테고리와 태그에 빈 페이지가 생성된 것을 확인할 수 있다. 생성된 카테고리와 태그 페이지 폴더에 들어가면 각각 <code>index.md</code> 파일이 있으며, 이 파일을 오픈하여 아래와 같이 입력 후 저장해야 한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 카테고리 index</span><br>---<br>title: Categories<br><span class="hljs-built_in">date</span>: 2020-03-02 14:27:00<br><span class="hljs-built_in">type</span>: categories<br>---<br><br><span class="hljs-comment"># 태그 index</span><br>---<br>title: tags<br><span class="hljs-built_in">date</span>: 2020-03-03 22:25:24<br><span class="hljs-built_in">type</span>: tags<br>---<br></code></pre></td></tr></table></figure><p>이제 카테고리와 태그 준비가 완료되었다. 지금부터는 글을 생성한 후 해당 카테고리에 넣고 태그를 달아보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 새로운 포스트 생성</span><br>hexo new post <span class="hljs-string">&quot;post_name&quot;</span> <span class="hljs-comment"># 이름은 원하는대로 넣기</span><br></code></pre></td></tr></table></figure><p>위의 코드를 입력하면 <code>source &gt; post</code>에 <code>post_name.md</code>퍄일이 생성된다. 이 파일을 클릭하면 다음과 같이 결과가 나온다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">---<br>title: post_name<br><span class="hljs-built_in">date</span>: 2020.04.20<br>tags:<br>---<br></code></pre></td></tr></table></figure><p>여기서 카테고리와 태그를 추가하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">---<br>title: post_name<br><span class="hljs-built_in">date</span>: 2020.04.20<br>tags: <span class="hljs-comment"># 아래의 키워드들 입력</span><br>- Hexo<br>- Github<br>- blog<br>- 헥소<br>categories: about Hexo <span class="hljs-comment"># 원하는 카테고리 이름 입력</span><br>---<br></code></pre></td></tr></table></figure><p><code>tags</code>에는 태그할 키워드를 입력하고, <code>categories</code>에는 해당 포스트를 넣을 카테고리의 이름을 넣으면 된다. 카테고리의 경우 입력한 이름의 카테고리가 알아서 생성된다.</p><p>위의 포스트를 저장한 후, 다시 배포를 진행해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate<br>hexo deploy<br></code></pre></td></tr></table></figure><p>그 다음 카테고리를 눌러보면 <code>about Hexo</code> 이름의 카테고리를 확인할 수 있다. 태그 또한 위에 입력한 키워드가 들어간 것을 볼 수 있다.</p>]]></content>
    
    
    <categories>
      
      <category>etc.</category>
      
      <category>about hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Github</tag>
      
      <tag>blog</tag>
      
      <tag>헥소</tag>
      
      <tag>깃허브</tag>
      
      <tag>블로그</tag>
      
      <tag>NexT</tag>
      
      <tag>next</tag>
      
      <tag>테마</tag>
      
      <tag>themes</tag>
      
      <tag>카테고리</tag>
      
      <tag>태그</tag>
      
      <tag>category</tag>
      
      <tag>tag</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[8/18] 인공신경망 구현: 역전파 설명</title>
    <link href="/ko/DeeplearningJulia/Deeplearning-8/"/>
    <url>/ko/DeeplearningJulia/Deeplearning-8/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다. <span id="more"></span></p><hr /><p>이전 글에서는 왼쪽 방향에서 오른쪽 방향으로 이동하는 미분법인 순전파 알고리즘을 살펴보았다. 순전파 알고리즘은 학습을 진행할 때마다 각각 매개변수의 미분값을 구해야 하기 때문에 신경망 계산이 매개변수 개수의 두 배가 진행된다. 이전 글에서의 신경망 모델을 예시로 보면 가중치와 편향이 총 4개이기 때문에 순전파 기반으로 학습을 한 번 할 때마다 신경망 계산은 총 8번 이루어진다. 이 방식은 매우 비효율적이고 시간이 오래걸린다. 순전파보다 더 효율적으로 미분하는 방법이 바로 역전파 알고리즘이다. 이번 장에서는 역전파 알고리즘에 대해서 살펴볼 것이다.</p><h2 id="역전파란">역전파란</h2><p>역전파(backward propagation)는 순전파와 다르게 미분을 반대로 하는 것을 의미한다. 즉, 순전파는 왼쪽에서 오른쪽 방향으로 미분이 이루어진다면, 역전파는 오른쪽에서 왼쪽 방향으로 미분이 이루어진다. 도식에서 확인하자면 아래와 같다.</p><figure><img src="/images/43.png" alt="신경망 계산 방향" /><figcaption aria-hidden="true">신경망 계산 방향</figcaption></figure><p>또한 순전파와 역전파는 신경망 계산이 이루어지는 과정도 약간 다르다. 우리가 만든 2층 신경망 모델의 순전파 알고리즘은 각각 가중치와 편향의 편미분 값을 구하기 위해서 신경망 계산이 8번 이루어지지만, 역전파 알고리즘은 한번 진행될 때 가중치와 편향의 편미분 값을 바로 구할 수 있다. 이것이 역전파가 순전파보다 훨씬 빠르게 진행되는 이유이다. 신경망 계산은 행렬 계산으로 이루어지기 때문에 매우 복잡하고 계산량이 많다. 따라서 계산을 여러 번 할수록 훨씬 많은 시간이 소요된다. 따라서 시간의 관점에서 역전파는 순전파보다 훨씬 더 효율적인 알고리즘이라고 볼 수 있다. 순전파와 역전파의 차이를 정리하면 다음과 같다.</p><figure><img src="/images/44.png" alt="미분 알고리즘 비교" /><figcaption aria-hidden="true">미분 알고리즘 비교</figcaption></figure><h2 id="역전파의-원리-합성함수의-미분">역전파의 원리: 합성함수의 미분</h2><p>역전파가 한번에 편미분을 구할 수 있는 원리는 합성함수의 미분을 이용한 것이다. 먼저 우리가 만들었던 2층 신경망 모델의 수식을 확인해보자.</p><p><span class="math display">\[\hat{y}=\sigma(h(XW1+B1)\times W2+B2)\]</span></p><p>위의 수식을 다음과 같이 정리할 수 있다.</p><p><span class="math display">\[Z1=XW1+B1\\ A1 = h(Z1)\\Z2=A1W2+B2\\\sigma(Z2) = \hat{y}\]</span></p><p>위 수식은 신경망 계산 순서를 그대로 나열한 것이다. 순전파 알고리즘에서는 각각 매개변수를 편미분하여 예측값을 비교한다. 하지만 역전파 알고리즘은 위의 수식들을 미분한 식을 바탕으로 기존 매개변수들을 받아 각 매개변수들의 미분값을 한번에 계산한다.</p><p>즉, 역전파 알고리즘은 다음과 같다.</p><p><span class="math display">\[\partial\hat{y} =\partial\sigma(Z2)\\\partial Z2= \partial(A1W2 + B2)\\\partial A1 = \partial h(Z1)\\\partial Z1 = \partial(XW1+B1)\]</span></p><p>위 순서는 합성함수의 미분이다. 합성함수는 변수가 두개 이상의 함수에 둘러싸인 경우를 의미한다. 예시로 아래의 사례를 보자.</p><p><span class="math display">\[ y = t^2 , t = x+2\]</span></p><p>위의 식 <span class="math inline">\(y\)</span>에서 <span class="math inline">\(x\)</span>를 미분하기 위해서는 중간의 <span class="math inline">\(t\)</span>를 미분해야 한다. 따라서 다음과 같은 방법으로 미분된다.</p><p><span class="math display">\[\frac{dy}{dx}= \frac{dy}{dt} \cdot \frac{dt}{dx}\]</span></p><p>위의 미분식에서 <span class="math inline">\(dt\)</span>는 약분되기 때문에 결국 <span class="math inline">\(\frac{dy}{dx}\)</span>가 남는 것이다. 이를 정리하면 다음과 같다.</p><p><span class="math display">\[\begin{matrix}\frac{\partial y}{\partial x}&amp; = &amp; \partial (t^2) \times \partial t\\&amp;=&amp; 2t \times \partial (x+2) \\&amp;=&amp; 2(x+2) \times 1 \\&amp;=&amp; 2x+4\\\end{matrix}\]</span></p><p>이 방식을 2층 신경망 역전파 알고리즘에 대입하여 미분식을 구할 수 있다. 미분식은 아래와 같다.</p><p><span class="math display">\[\begin{matrix}\frac{\partial \hat{y}}{\partial W1}&amp; = &amp; \frac{\partial \hat{y}}{\partial Z2} &amp;\times&amp; \frac{\partial Z2}{\partial A1} &amp;\times&amp; \frac{\partial A1}{\partial Z1} &amp;\times&amp; \frac{\partial Z1}{\partial W1}\\&amp;&amp;\\\frac{\partial \hat{y}}{\partial W2}&amp; = &amp; \frac{\partial \hat{y}}{\partial Z2} &amp;\times&amp; \frac{\partial Z2}{\partial W2}\\&amp;&amp;\\\frac{\partial \hat{y}}{\partial b1}&amp; = &amp; \frac{\partial \hat{y}}{\partial Z2} &amp;\times&amp; \frac{\partial Z2}{\partial A1} &amp;\times&amp; \frac{\partial A1}{\partial Z1} &amp;\times&amp; \frac{\partial Z1}{\partial b1}\\&amp;&amp;\\\frac{\partial \hat{y}}{\partial b2}&amp; = &amp; \frac{\partial \hat{y}}{\partial Z2} &amp;\times&amp; \frac{\partial Z2}{\partial b2}\\\end{matrix}\]</span></p><p>위의 공식을 비교해보면 각각 매개 변수에 동일하게 적용되는 미분이 있을 것이다. 이를 알고리즘으로 구현하여 좀 더 빠르게 미분값을 구할 수 있도록 고안한 것이 역전파 알고리즘이다.</p><h2 id="역전파-알고리즘-미분-과정">역전파 알고리즘 미분 과정</h2><figure><img src="/images/51.png" alt="역전파 알고리즘" /><figcaption aria-hidden="true">역전파 알고리즘</figcaption></figure><p>2층 신경망 역전파 알고리즘은 위와 같은 구조로 이루어져 있다. 우리는 위의 역전파 알고리즘에서 각 층을 함수로 구현할 것이다. 참고로 아래의 수식에서 사용되는 대문자는 행렬이며, 소문자는 스칼라이다. 특히 <span class="math inline">\(Z_n\)</span>과 같은 기호는 행렬 <span class="math inline">\(Z\)</span>의 <span class="math inline">\(n\)</span>(인덱스)위치에 속해있는 요소를 가리킨다.</p><h3 id="softmax-with-loss-layer">Softmax with Loss Layer</h3><p>역전파 알고리즘에서는 출력층에서 사용되는 소프트맥스 함수와 손실 함수인 교차 엔트로피 오차 수식을 같이 미분한다. 그 이유는 두 함수를 동시에 미분한 결과가 훨씬 간단하기 때문이다. 역전파의 미분은 손실 함수인 교차 엔트로피 오차 수식 미분을 먼저 진행하고 그다음 소프트맥스 함수를 미분하여 결과를 도출할 것이다.</p><ul><li>교차 엔트로피 오차 수식 미분</li></ul><p><span class="math display">\[L = -\sum_{n} T_n \ln Y_n\]</span></p><p>위 식은 교차 엔트로피 오차이이며, <span class="math inline">\(T\)</span>는 정답레이블, <span class="math inline">\(Y\)</span>는 예측값, <span class="math inline">\(n\)</span>은 신경망 노드의 개수를 의미한다. 즉, 소프트맥스 함수에서 예측값이 <span class="math inline">\([y_1, y_2, y_3]\)</span>로 왔다면 <span class="math inline">\(n\)</span>은 3이다. 위 식을 미분하면 다음과 같은 결과를 얻을 수 있다.</p><p><span class="math display">\[\partial L = -\sum_{n} \frac{T_n}{Y_n} \]</span></p><p>위의 식에서 <span class="math inline">\(-\frac{1}{Y_n}\)</span>가 각각의 소프트맥스 함수의 신경망으로 전달된다. 예를 들어 소프트맥스 함수의 결과값이 총 3개가 들어왔다면 <span class="math inline">\(-\frac{T_1}{Y_1}, -\frac{T_2}{Y_2}, -\frac{T_3}{Y_3}\)</span>이 소프트맥스 미분식의 입력값으로 들어간다.</p><ul><li>소프트맥스 함수 미분</li></ul><p><span class="math display">\[\sigma(Z_k)=\frac{e^{Z_k}}{\sum_{i=n}^n e^{Z_n}}\]</span></p><p>위 수식은 소프트맥스 함수이다. 위의 교차 엔트로피 오차와 마찬가지로 <span class="math inline">\(n\)</span>은 신경망 노드 개수이다. 즉, 입력값이 <span class="math inline">\([z_1, z_2, z_3]\)</span>이라면 <span class="math inline">\(n\)</span>은 3이고, <span class="math inline">\(k\)</span>는 <span class="math inline">\(1,2,3\)</span> 중에 하나이다. 이를 미분하면 다음과 같은 결과를 얻을 수 있다.</p><ol type="1"><li>소프트맥스의 입력값과 편미분 대상이 동일할 때 (둘 다 <span class="math inline">\(Z_k\)</span>)</li></ol><p><span class="math display">\[\frac{\partial\sigma(Z_k)}{\partial Z_k} = \frac{e^{Z_k}(\sum_{i} e^{Z_i})-e^{Z_k}e^{Z_k}}{(\sum_{i} e^{Z_i})^2}\]</span></p><p><span class="math display">\[\quad \quad \quad \ = \frac{e^{Z_k}\{(\sum_{i} e^{Z_i})-e^{Z_k}\}}{(\sum_{i} e^{Z_i})^2}\]</span></p><p><span class="math display">\[\quad \quad \quad \quad = \frac{e^{Z_k}}{\sum_{i} e^{Z_i}} \frac{(\sum_{i} e^{Z_i})-e^{Z_k}}{\sum_{i} e^{Z_i}}\]</span></p><p><span class="math display">\[\quad \quad \quad \quad = \frac{e^{Z_k}}{\sum_{i} e^{Z_i}}\Bigg(1-\frac{e^{Z_k}}{\sum_{i} e^{Z_i}}\Bigg)\]</span></p><p><span class="math display">\[\quad \quad  = \sigma(Z_k)(1-\sigma(Z_k))\]</span></p><ol start="2" type="1"><li>소프트맥스의 입력값과 편미분 대상이 다를 때 (<span class="math inline">\(Z_k\)</span>와 <span class="math inline">\(Z_j\)</span>)</li></ol><p><span class="math display">\[\frac{\partial\sigma(Z_j)}{\partial Z_k} = \frac{0-e^{Z_k}e^{Z_j}}{(\sum_{i=1} e^{Z_i})^2}\]</span></p><p><span class="math display">\[\quad \quad \quad \quad \quad \quad \quad = -\frac{e^{Z_k}}{\sum_{i=1} e^{Z_i}} \frac{e^{Z_j}}{\sum_{i=1} e^{Z_i}}\]</span></p><p><span class="math display">\[\quad \quad \quad \quad = -\sigma(Z_k)\sigma(Z_j)\]</span></p><p>소프트맥스 함수는 미분될 때 동일한 변수와 동일하지 않은 변수를 모두 미분해야 한다. 그 이유는 손실 함수에서 <span class="math inline">\(n\)</span>개의 변수를 미분하는데 <span class="math inline">\(n\)</span>에는 편미분 변수인 <span class="math inline">\(k\)</span>도 들어가지만 편미분 변수가 아닌 <span class="math inline">\(j\)</span>도 포함되기 때문이다.</p><p>위의 미분식들을 활용하여 역전파 알고리즘에 사용되는 함수를 정리해보자.</p><p><span class="math display">\[\frac{\partial L}{\partial Z_k} = \frac{\partial L}{\partial \sigma(Z_n)}\frac{\partial\sigma(Z_n)}{\partial Z_k}\]</span></p><p><span class="math display">\[\quad \quad \ \ =-\sum_{n}\frac{Y_n}{Z_n}\frac{\partial\sigma(Z_n)}{\partial Z_k}\]</span></p><p><span class="math inline">\(\frac{\partial\sigma(Z_n)}{\partial Z_k}\)</span>은 <span class="math inline">\(k\)</span>에 대한 미분과 <span class="math inline">\(j\)</span>에 대한 미분을 모두 포함한다. 따라서 분리하여 미분을 진행한다.</p><p><span class="math display">\[\quad \quad \quad =-\frac{Y_k}{Z_k}Z_k(1-Z_k)-\sum_{n \ne k}\frac{Y_n}{Z_n}(-Z_kZ_n)\]</span></p><p><span class="math display">\[=-Y_k(1-Z_k)-\sum_{n \ne k}-Y_nZ_k\]</span></p><p><span class="math display">\[=-Y_k+Y_kZ_k+\sum_{n \ne k}Y_nZ_k\]</span></p><p><span class="math display">\[=-Y_k+Z_k\sum_{n}Y_n\]</span></p><p>여기서 <span class="math inline">\(\sum_{n}Y_n\)</span>는 기존 소프트맥스 확률의 합이기 때문에 1이 된다.</p><p><span class="math display">\[=-Y_k+Z_k \times 1\]</span></p><p><span class="math display">\[=Z_k-Y_k\]</span></p><p>결론적으로 'Softmax with Loss'는 위와 같은 간단한 수식이다. 어차피 우리는 결론인 위의 간단한 수식만 사용할 것이기 때문에 만약 위의 수식들이 어렵다면 결론만 봐도 무방하다.</p><h3 id="dense-layer">Dense Layer</h3><p>'Dense Layer'는 들어온 입력값에 가중치를 곱하고 편향을 더하는 방정식이다. 수식으로 쓰면 아래와 같다.</p><p><span class="math display">\[Z=XW+B\]</span></p><p>위 수식을 미분해보자. 참고로 Dense Layer에서 사용되는 모든 변수들은 행렬을 기본으로 하고 있다. 즉, <span class="math inline">\(XW\)</span>은 행렬곱이다. 그렇다면 행렬곱은 어떻게 미분되는가? 기본적으로 신경망에서 사용되는 행렬은 벡터 단위이다. 즉, 행렬도 벡터가 여러 개 합쳐져 있는 형태로 바라본다는 것이다.</p><p>미분을 이해하기 위해서 간단하게 예시를 보자.</p>입력값인 행렬 <span class="math inline">\(X\)</span>와 가중치인 행렬 <span class="math inline">\(W\)</span>를 다음과 같이 설정한다. 벡터는 열벡터 형태가 기본이기 때문에 아래의 행렬은 벡터 별 색깔을 다르게 설정하였다. <span class="math display">\[\begin{matrix}\quad \quad X_1 &amp; X_2 &amp;&amp;&amp;&amp; W_1 &amp; W_2 &amp;W_3\end{matrix}\]</span> $$X=<span class="math display">\[\begin{bmatrix}\color{ForestGreen}{x_{11}} &amp;\color{LimeGreen}{x_{12}}\\\color{ForestGreen}{x_{21}} &amp; \color{LimeGreen}{x_{22}}\end{bmatrix}\]</span>W=<span class="math display">\[\begin{bmatrix}\color{OrangeRed}{w_{11}} &amp; \color{Orange}{w_{12}} &amp; \color{Salmon}{w_{13}}\\\color{OrangeRed}{w_{21}} &amp; \color{Orange}{w_{22}} &amp; \color{Salmon}{w_{23}}\end{bmatrix}\]</span><p>$$</p><p>두 행렬을 곱할 때는 열 단위로 내적되는 것이 아니라 X가 행벡터로 변환되어 내적된다. 즉, 수식으로 표현하면 다음과 같다.</p><p><span class="math display">\[X \cdot W = X^TW\]</span></p><p>따라서 <span class="math inline">\(X \cdot W\)</span>인 식이 결과값 <span class="math inline">\(Y\)</span>라고 했을 때, <span class="math inline">\(Y\)</span>는 다음과 같다.</p><p><span class="math display">\[Y=\begin{bmatrix}\color{ForestGreen}{x_{11}}\color{OrangeRed}{w_{11}}+ \color{ForestGreen}{x_{21}}\color{OrangeRed}{w_{21}}&amp; \color{ForestGreen}{x_{11}}\color{Orange}{w_{12}} +\color{ForestGreen}{x_{21}}\color{Orange}{w_{22}}&amp; \color{ForestGreen}{x_{11}}\color{Salmon}{w_{13}}+\color{ForestGreen}{x_{21}}\color{Salmon}{w_{23}}\\\color{LimeGreen}{x_{12}}\color{OrangeRed}{w_{11}}+ \color{LimeGreen}{x_{22}}\color{OrangeRed}{w_{21}}&amp; \color{LimeGreen}{x_{12}}\color{Orange}{w_{12}}+ \color{LimeGreen}{x_{22}}\color{Orange}{w_{22}}&amp; \color{LimeGreen}{x_{12}}\color{Salmon}{w_{13}}+\color{LimeGreen}{x_{22}}\color{Salmon}{w_{23}}\end{bmatrix}\]</span></p><p>위의 행렬을 벡터의 곱으로 표현해보자.</p><p><span class="math display">\[Y=\begin{bmatrix}X_1W_1 &amp; X_1W_2 &amp; X_1W_3\\X_2W_1 &amp; X_2W_2 &amp; X_2W_3\\\end{bmatrix}\]</span></p><p>위 식은 행렬 <span class="math inline">\(W\)</span>가 행렬 <span class="math inline">\(X^T\)</span>와 곱한 형태라는 것을 증명한다. 위의 행렬을 <span class="math inline">\(W_1~ or~ W_2~ or~ W_3\)</span>로 각각 미분해도 결과는 동일하다.</p><p><span class="math display">\[\frac{\partial Y}{\partial W} =\begin{bmatrix}X_1\\X_2\\\end{bmatrix}\]</span></p><p>이를 행렬로 풀면 다음과 같다.</p><p><span class="math display">\[\frac{\partial Y}{\partial W} =\begin{bmatrix}\color{ForestGreen}{x_{11}} &amp;\color{ForestGreen} {x_{21}}\\\color{LimeGreen}{x_{12}} &amp; \color{LimeGreen}{x_{22}}\\\end{bmatrix}=X^T\]</span></p><p>위와 같은 원리로 다음과 같은 결론을 낼 수 있다.</p><p><span class="math display">\[\frac{\partial Y}{\partial W} = X^T\]</span> <span class="math display">\[\frac{\partial Y}{\partial X} = W^T\]</span></p><p>우리는 역전파 알고리즘에서 입력값과 가중치의 미분값으로 위의 식을 사용할 것이다.</p><p>편향의 경우, 신경망 계산 시에 모든 원소에 더해지기 때문에 미분값을 열 기준으로 전부 더하면 된다.</p><h3 id="sigmoid-layer">Sigmoid Layer</h3><p>시그모이드 함수의 미분은 간단하다. 아래의 식을 확인하자.</p><p><span class="math display">\[\frac{\partial h(Z_k)}{\partial Z_k} = \frac{0\times(1+e^{-Z_k})-1\times (0+e^{(-Z_k)})(-1) }{(1+e^{-Z_k})^2}\]</span></p><p><span class="math display">\[\quad =\frac{e^{(-Z_k)}}{(1+e^{-Z_k})^2}= \frac{1+e^{(-Z_k)}-1}{(1+e^{-Z_k})^2}\]</span></p><p><span class="math display">\[=\frac{(1+e^{(-Z_k)})}{(1+e^{-Z_k})^2}-\frac{1}{(1+e^{-Z_k})^2}\]</span></p><p><span class="math display">\[= \frac{1}{(1+e^{-Z_k})}-\frac{1}{(1+e^{-Z_k})^2}\]</span></p><p><span class="math display">\[\quad = \frac{1}{(1+e^{-Z_k})}\Big(1-\frac{1}{(1+e^{-Z_k})}\Big)\]</span></p><p><span class="math display">\[ = h(Z_k)(1-h(Z_k))\]</span></p><p>시그모이드 함수를 미분하여 정리하면 <span class="math inline">\(h(Z_k)(1-h(Z_k))\)</span> 이 도출된다. 따라서 역전파 알고리즘에 사용되는 시그모이드 함수는 위의 수식을 사용하여 구현될 것이다.</p><h3 id="relu-layer">ReLU Layer</h3><p>ReLU 함수는 입력값 <span class="math inline">\(x\)</span>가 음수인 경우만 0으로 변경하고 그대로 출력한다. 이를 수식으로 표현하면 다음과 같다.</p><p><span class="math display">\[y = \begin{cases}0 &amp; \text{(x≤0)\]</span>}\ x &amp; \ \end{cases} $$</p><p>위 수식을 입력값 <span class="math inline">\(x\)</span>로 미분하면 아래와 같은 결과가 도출된다.</p><p><span class="math display">\[\frac{\partial y}{\partial x} = \begin{cases}0 &amp; \text{(x≤0)\]</span>}\ 1 &amp; \ \end{cases} $$</p><p>따라서 역전파 알고리즘에서 Relu 함수는 입력값 <span class="math inline">\(x\)</span>가 0보다 같거나 작으면 미분값에 0을 곱해서 출력하고, <span class="math inline">\(x\)</span>보다 크면 1을 곱해서 출력한다. 그렇기 때문에 입력값에서 음수의 위치를 저장해두어야 한다.</p><h2 id="순전파-vs.-역전파">순전파 vs. 역전파</h2><p>다음 글에서 살펴볼 역전파 알고리즘이 과연 잘 구현되었는지 확인해보자. 먼저 훈련데이터 이미지 3개를 <code>x_batch</code>와 <code>t_batch</code>에 할당한다. (참고로 사용된 훈련데이터는 MNIST 데이터이며, <a href="https://dev-bearabbit.github.io/2020/04/04/DeeplearningJulia/Deeplearning-7/">이전 글</a>에서 가져오는 방법을 볼 수 있다.)</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">x_batch = train_x[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>, :]<br>t_batch = t[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>, :]<br></code></pre></td></tr></table></figure><p>그 다음 순전파 알고리즘을 먼저 작동해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">TwoLayerNet_numerical_gradient(loss, x_batch, t_batch)<br></code></pre></td></tr></table></figure><p>위 코드를 실행하면 순전파 알고리즘으로부터 도출된 미분값을 얻을 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">grad_forward_W1 = grads[<span class="hljs-string">&quot;W1&quot;</span>]<br>grad_forward_b1 = grads[<span class="hljs-string">&quot;b1&quot;</span>]<br>grad_forward_W2 = grads[<span class="hljs-string">&quot;W2&quot;</span>]<br>grad_forward_b2 = grads[<span class="hljs-string">&quot;b2&quot;</span>]<br></code></pre></td></tr></table></figure><p>위 코드를 입력하여 미분값을 저장하자. 이제 역전파 알고리즘을 사용하여 매개 변수의 미분값을 얻으려 한다. 역전파 알고리즘은 아직 살펴보지 못했기에 그 결과를 아래의 식에 도입해서 확인해보자.</p><p><span class="math display">\[Difference = \frac{\sum{|forward~gradient - backward~gradient|}}{the~number~of~elements~in~Matrix}\]</span></p><p>위 식을 코드로 구현하면 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; diffW1 = sum((abs.(grad_forward_W1-grad_backward_W1))) / (size(grad_backward_W1)[<span class="hljs-number">1</span>]*size(grad_backward_W1)[<span class="hljs-number">2</span>])<br>Julia&gt; diffW2 = sum((abs.(grad_forward_W2-grad_backward_W2))) / (size(grad_backward_W2)[<span class="hljs-number">1</span>]*size(grad_backward_W2)[<span class="hljs-number">2</span>])<br>Julia&gt; diffb1 = sum((abs.(grad_forward_b1-grad_backward_b1))) / (size(grad_backward_b1)[<span class="hljs-number">1</span>]*size(grad_backward_b1)[<span class="hljs-number">2</span>])<br>Julia&gt; diffb2 = sum((abs.(grad_forward_b2-grad_backward_b2))) / (size(grad_backward_b2)[<span class="hljs-number">1</span>]*size(grad_backward_b2)[<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><p>위 코드는 다음 글에서 역전파 알고리즘을 구현한 후 작동할 것이다. 결과는 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; diffW1<br> <span class="hljs-number">1.9589789748798898e-10</span><br>Julia&gt; diffW2<br> <span class="hljs-number">7.040410144965037e-8</span><br>Julia&gt; diffb1<br> <span class="hljs-number">8.881836618344343e-10</span><br>Julia&gt; diffb2<br> <span class="hljs-number">1.394640827490079e-7</span><br></code></pre></td></tr></table></figure><p>순전파와 역전파 알고리즘으로 도출된 미분값들의 차이가 매우 작은 것을 확인할 수 있다. 즉, 역전파가 잘 구현되었다는 것이다. 그렇다면 역전파는 어떻게 줄리아로 구현하였을까? 다음 글에서 확인해보자.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>deep learning in julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>딥러닝</tag>
      
      <tag>Deeplearning</tag>
      
      <tag>머신러닝</tag>
      
      <tag>줄리아</tag>
      
      <tag>신경망</tag>
      
      <tag>역전파</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linear Algebra (2)</title>
    <link href="/ko/Mathematic/mathematic-1/"/>
    <url>/ko/Mathematic/mathematic-1/</url>
    
    <content type="html"><![CDATA[<p>글을 시작하기에 앞서 해당 글은 Marc Peter Deisenroth, A. Aldo Faisal, Cheng Soon Ong의 저서인 mathematics for machine learning을 바탕으로 요약 및 정리한 글임을 알려드립니다. <span id="more"></span></p><hr /><h2 id="연립-선형방정식-풀기">연립 선형방정식 풀기</h2><p>이전 글에서 연립 선형방정식을 행렬로 나타내는 과정을 살펴보았다. 이제는 행렬로 표현된 연립 선형방정식을 풀어보자. 참고로 연립 선형방정식은 다양한 풀이를 가진다.</p><p><span class="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 8 &amp; -4\\0 &amp; 1 &amp; 2 &amp; 12\\\end{bmatrix}\begin{bmatrix}x_1\\x_2\\x_3\\x_4\end{bmatrix}=\begin{bmatrix}42\\8\\\end{bmatrix}\]</span></p><p>위의 행렬곱은 4개의 변수를 가진 2개의 선형방정식으로 이루어져 있다. 위의 행렬곱을 수식으로 정리하면 다음과 같다. 우리는 위의 식에서 4개의 변수 해(solution)를 찾는 것이 목표이다.</p><p><span class="math display">\[\sum_{i=1}^4 x_ic_i = b\]</span></p><p>해당 식에서 <span class="math inline">\(c_i\)</span>는 첫 번째 행렬의 <span class="math inline">\(i\)</span>번째 열이며, <span class="math inline">\(b\)</span>는 두 행렬곱의 결과이다. <span class="math inline">\(b\)</span>는 <span class="math inline">\(c_1 \times 42\)</span>과 <span class="math inline">\(c_2 \times 8\)</span>로 나타낼 수 있다.</p><p><span class="math display">\[b =\begin{bmatrix}42\\8\\\end{bmatrix}=42\begin{bmatrix}1\\0\\\end{bmatrix}+8\begin{bmatrix}0\\1\\\end{bmatrix}\]</span></p><p>따라서 변수 4개의 해(solution)로 <span class="math inline">\([42, 8, 0, 0]^T\)</span>를 도출할 수 있다. 이와 같이 결과값 <span class="math inline">\(b\)</span>를 역추하여 변수를 추정한 해를 '특수 해(special solution)'라고 한다. 하지만 연립 선형방정식에는 더 많은 해가 존재하기도 한다. 특수 해를 찾는 방법은 <span class="math inline">\(Ax=b\)</span>에 해당하는 <span class="math inline">\(x\)</span>값을 찾는 것이다. 다음으로 살펴볼 방법은 <span class="math inline">\(Ax=0\)</span>으로 만드는 <span class="math inline">\(x\)</span>값을 찾는 것이다. <span class="math inline">\(Ax=0\)</span>에 해당하는 방정식을 '동차(homogeneous) 연립 선형방정식'이라고 한다. 첫 번째 행렬의 세 번째 열인 <span class="math inline">\(c_3\)</span>은 다음과 같이 풀어서 쓸 수 있다.</p><p><span class="math display">\[c_3=\begin{bmatrix}8\\2\\\end{bmatrix}=8 \begin{bmatrix}1\\0\\\end{bmatrix}+2 \begin{bmatrix}0\\1\\\end{bmatrix}\]</span></p><p>위의 식은 <span class="math inline">\(c_1\)</span>과 <span class="math inline">\(c_2\)</span>를 사용하여 <span class="math inline">\(c_3\)</span>을 나타낸 것이다. 따라서 <span class="math inline">\(c_3\)</span>는 <span class="math inline">\(8c_1 + 2c_2\)</span>로 표현할 수 있다. 우리의 목표는 행렬 A와 변수 x를 곱했을 때 0이 나오는 해를 찾는 것이므로 <span class="math inline">\(c_3\)</span>에 -1를 곱하여 앞의 <span class="math inline">\(8c_1 + 2c_2\)</span>을 제거하고 <span class="math inline">\(c_4\)</span>에 0을 곱하여 결과를 0으로 맞춰준다. 그렇게 하면 식은 다음과 같다.</p><p><span class="math display">\[8c_1 + 2c_2 + -1c_3 + 0c_4 =0\]</span></p><p>따라서 <span class="math inline">\(Ax=0\)</span>의 결과를 만족시키는 변수 <span class="math inline">\((x_1,x_2,x_3,x_4)\)</span>는 <span class="math inline">\((8,2,-1,0)\)</span>이다. 위의 식은 무작위 실수 <span class="math inline">\(\lambda_1 \in \mathbb R\)</span>를 곱해도 값은 0이다.</p><p><span class="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 8 &amp; -4\\0 &amp; 1 &amp; 2 &amp; 12\\\end{bmatrix}\left (\lambda_1\begin{bmatrix}8\\2\\-1\\0\end{bmatrix}\right )=\lambda_1\big (8c_1 + 2c_2 - c_3\big )=0\]</span></p><p>위 흐름과 같이 <span class="math inline">\(c_4\)</span>도 <span class="math inline">\(c_1, c_2\)</span>을 사용하여 <span class="math inline">\(-4c_1 + 12c_2\)</span>로 나타낼 수 있고, 이를 이용하여 <span class="math inline">\(Ax=0\)</span>을 도출할 수 있다.</p><p><span class="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 8 &amp; -4\\0 &amp; 1 &amp; 2 &amp; 12\\\end{bmatrix}\left (\lambda_2\begin{bmatrix}-4\\12\\0\\-1\end{bmatrix}\right )=\lambda_2\big (-4c_1 + 12c_2 - c_4\big )=0\]</span></p><p><span class="math inline">\(\lambda_1\)</span>과 마찬가지로 <span class="math inline">\(\lambda_2\)</span>도 어떤 실수든지 가능하다.</p><p>지금까지 구한 변수 <span class="math inline">\(x\)</span>를 종합하면, 우리는 해당 연립 선형방정식의 '일반 해( general solution)'를 구할 수 있다.</p><p><span class="math display">\[x \in \mathbb R^4 : x=\begin{bmatrix}42\\8\\0\\0\end{bmatrix}+\lambda_1\begin{bmatrix}8\\2\\-1\\0\end{bmatrix}+\lambda_2\begin{bmatrix}-4\\12\\0\\-1\end{bmatrix}\quad\lambda_1,\lambda_2 \in \mathbb R\]</span></p><p><strong>Remark</strong> 일반 해를 구하는 접근 방식은 세 단계로 구성되며, 다음과 같다.</p><ul><li><span class="math inline">\(Ax=b\)</span>의 특수 해를 찾기</li><li><span class="math inline">\(Ax=0\)</span>의 모든 해 찾기</li><li>찾은 모든 해들을 결합하기 (일반 해 완성)</li></ul><p>지금까지 예시를 통해서 연립 선형방정식을 풀어보았다. 예시는 간단한 형식의 행렬이었기에 해를 구하기 편했지만, 실제 사용되는 선형식들은 매우 복잡하다. 운좋게도 우리는 매우 편리한 알고리즘인 '가우시안 소거법(Gaussian elimination)'이 있다. 가우시안 소거법은 복잡한 방정식 시스템을 간단한 형태로 변환해준다. 그후 위에서 배운 세 단계를 적용할 수 있다.</p><h3 id="요소-변환-elementary-transformations">요소 변환 (elementary transformations)</h3><p>선형 방정식을 쉽게 해결하는 핵심 방법은 바로 '요소 변환 (elementary transformations)'이다. 요소를 변환하는 것은 해는 동일하지만 선형방정식의 식을 더 간편하게 만들어준다.</p><ul><li>방정식 2개(행 단위)의 위치를 바꾸기</li><li>한 방정식에 <span class="math inline">\(0\)</span>을 제외한 실수 <span class="math inline">\(\lambda\)</span> 곱하기</li><li>두 방정식을 합치기</li></ul><p>제시된 3개가 요소를 변환하는 방법이다. 아래의 예시를 통해서 하나씩 알아보자.</p><p><span class="math display">\[\begin{matrix}-2x_1&amp;+&amp;4x_2&amp;-&amp;2x_3&amp;-&amp;x_4&amp;+&amp;4x_5&amp;=&amp; -3\\4x_1&amp;-&amp;8x_2&amp;+&amp;3x_3&amp;-&amp;3x_4&amp;+&amp;x_5&amp;=&amp; 2\\x_1&amp;-&amp;2x_2&amp;+&amp;x_3&amp;-&amp;x_4&amp;+&amp;x_5&amp;=&amp; 0\\x_1&amp;-&amp;2x_2&amp; &amp; &amp;-&amp;3x_4&amp;+&amp;4x_5&amp;=&amp; a\end{matrix}\]</span></p><p>위의 수식은 5개의 변수를 가진 연립 선형방정식이다. 총 4개의 수식이 포함되어 있으며, 우리는 위 문제에서 <span class="math inline">\(a \in \mathbb R\)</span>일 때의 모든 해를 찾으려 한다.</p><p>먼저 <span class="math inline">\(Ax=b\)</span>인 특수 해를 찾아보자. 특수 해를 찾기 위해서는 각 방정식의 변수들을 최소화해야 한다. 변수를 최소화하기 위해서 방정식들의 요소를 변환해야 한다. 지금부터는 변수 <span class="math inline">\(x\)</span>를 명시하지 않고 설명하는 방법을 사용할 것이다. 이 방법을 '확장 행렬(augmented matrix)'이라고 하며, <span class="math inline">\([A\ |\ b]\)</span>의 형태이다.</p><p><span class="math display">\[\left[\begin{array}{ccccc|c}-2 &amp; 4 &amp; -2 &amp; -1 &amp; 4 &amp; -3\\4 &amp; -8 &amp; 3 &amp; -3 &amp; 1 &amp; 2\\1 &amp; -2 &amp; 1 &amp; -1 &amp; 1 &amp; 0\\1 &amp; -2 &amp; 0 &amp; -3 &amp; 4 &amp; a\end{array}\right]\]</span></p><p>위의 확장 행렬에서 첫 번째 행과 세 번째 행의 위치를 바꿔주자.</p><p><span class="math display">\[\left[\begin{array}{ccccc|c}1 &amp; -2 &amp; 1 &amp; -1 &amp; 1 &amp; 0\\4 &amp; -8 &amp; 3 &amp; -3 &amp; 1 &amp; 2\\-2 &amp; 4 &amp; -2 &amp; -1 &amp; 4 &amp; -3\\1 &amp; -2 &amp; 0 &amp; -3 &amp; 4 &amp; a\end{array}\right]\]</span></p><p>그 다음 두 번째 행에서 <span class="math inline">\(-4\mathbb R_1\)</span>을 더해준다. 그러면 두번째 행은 아래와 같은 결과가 나온다.</p><p><span class="math display">\[\mathbb R_2 =\left[\begin{array}{ccccc|c}4-4 &amp; -8+ 8 &amp; 3-4 &amp; -3+4 &amp; 1-4 &amp; 2-0\\\end{array}\right]\]</span></p><p><span class="math display">\[\quad \ =\left[\begin{array}{ccccc|c}0 &amp; 0 &amp; -1 &amp; 1 &amp; -3 &amp; 2\\\end{array}\right]\]</span></p><p>위와 같은 방법으로 세 번째 행에는 <span class="math inline">\(+2\mathbb R_1\)</span>을 더해주고, 네 번째 행에는 <span class="math inline">\(-1\mathbb R_1\)</span>을 더해준다. 그 결과는 다음과 같다.</p><p><span class="math display">\[\left[\begin{array}{ccccc|c}1 &amp; -2 &amp; 1 &amp; -1 &amp; 1 &amp; 0\\0 &amp; 0 &amp; -1 &amp; 1 &amp; -3 &amp; 2\\0 &amp; 0 &amp; 0 &amp; -3 &amp; 6 &amp; -3\\0 &amp; 0 &amp; -1 &amp; -2 &amp; 3 &amp; a\end{array}\right]\]</span></p><p>변수 <span class="math inline">\(x_1, x_2\)</span>의 계수는 <span class="math inline">\(\mathbb R_1\)</span>에만 남은 것을 확인할 수 있다. 이와 같은 방법으로 연립 선형방정식을 정리하면 다음과 같다.</p><p>-네 번째 행에 <span class="math inline">\(-\mathbb R_2 -\mathbb R_3\)</span>을 더해준다.</p><p><span class="math display">\[\left[\begin{array}{ccccc|c}1 &amp; -2 &amp; 1 &amp; -1 &amp; 1 &amp; 0\\0 &amp; 0 &amp; -1 &amp; 1 &amp; -3 &amp; 2\\0 &amp; 0 &amp; 0 &amp; -3 &amp; 6 &amp; -3\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; a+1\end{array}\right]\]</span></p><ul><li>두번째 행에 <span class="math inline">\(-1\)</span>을 곱해주고 세 번째 행에 <span class="math inline">\(-\frac{1}{3}\)</span>을 곱해준다.</li></ul><p><span class="math display">\[\left[\begin{array}{ccccc|c}1 &amp; -2 &amp; 1 &amp; -1 &amp; 1 &amp; 0\\0 &amp; 0 &amp; 1 &amp; -1 &amp; 3 &amp; -2\\0 &amp; 0 &amp; 0 &amp; 1 &amp; -2 &amp; 1\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; a+1\end{array}\right]\]</span></p><ul><li>위의 식을 연립 선형방정식으로 표현하면 다음과 같다.</li></ul><p><span class="math display">\[\begin{matrix}x_1&amp;-&amp;2x_2&amp;+&amp;x_3&amp;-&amp;x_4&amp;+&amp;x_5&amp;=&amp; 0\\&amp;&amp;&amp;&amp;x_3&amp;-&amp;x_4&amp;+&amp;3x_5&amp;=&amp; -2\\&amp;&amp;&amp;&amp;&amp;&amp;x_4&amp;-&amp;2x_5&amp;=&amp; 1\\&amp;&amp;&amp;&amp;&amp;&amp;&amp;+&amp;0&amp;=&amp; a+1\end{matrix}\]</span></p><p>복잡했던 확장 행렬에서 요소 변환을 통해 간단하게 정리되었다. 이와 같은 형태를 '행 사다리꼴(row-echelon form, REF)'이라고 한다. 행 사다리꼴은 아래와 같은 특징을 가진다.</p><ul><li>열의 앞에 오는 계수(leading coefficient)는 주성분(pivot)이라고 한다.</li><li>행 사다리꼴은 각 열의 주성분이 위의 열보다 한칸 이상 뒤에 있다. 따라서 계단식(staircase) 구조를 가진다.</li><li>0만 포함하는 열은 행렬의 가장 아래에 위치한다.</li><li>주성분에 속하는 변수를 '기본 변수(basic variables)'라고 하며, 그 외의 변수들은 '자유 변수(free variables)'라고 한다. 예로 위의 행 사다리꼴은 보면 변수 <span class="math inline">\(x_1, x_3, x_4\)</span>는 기본 변수이며, <span class="math inline">\(x_2, x_5\)</span>는 자유 변수이다.</li></ul><p>이제 위의 행 사다리꼴로 <span class="math inline">\(a=-1\)</span>일 때의 특수 해를 찾아보자. 해당 연립 선형방정식은 <span class="math inline">\(a=-1\)</span>일 때만 특수 해를 구할 수 있다.</p><p>자유 변수는 행 사다리꼴에서 주성분이 없다. 따라서 임의적으로 자유 변수를 0으로 처리한다. 그럼 위의 행 사다리꼴의 자유 변수인 <span class="math inline">\(x_2, x_5\)</span>은 0으로 처리된다. 그 다음 주성분이 존재하는 기본 변수의 값을 구하면 된다.</p><p>위의 확장 행렬을 다시 살펴보자.</p><p><span class="math display">\[\left[\begin{array}{ccccc|c}1 &amp; -2 &amp; 1 &amp; -1 &amp; 1 &amp; 0\\0 &amp; 0 &amp; 1 &amp; -1 &amp; 3 &amp; -2\\0 &amp; 0 &amp; 0 &amp; 1 &amp; -2 &amp; 1\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; a+1\end{array}\right]\]</span></p><p>여기서 기본 변수인 <span class="math inline">\(x_1, x_3, x_4\)</span>와 곱해지는 열은 아래와 같다.</p><p><span class="math display">\[x_1\begin{bmatrix}1\\0\\0\\0\end{bmatrix}+x_3\begin{bmatrix}1\\1\\0\\0\end{bmatrix}+x_4\begin{bmatrix}-1\\-1\\1\\0\end{bmatrix}=\begin{bmatrix}0\\-2\\1\\0\end{bmatrix}\]</span></p><p>위의 행렬을 다시 연립 선형방정식으로 나타내면 다음과 같다.</p><p><span class="math display">\[\begin{matrix}x_1&amp;+&amp;x_3&amp;-&amp;x_4&amp;=&amp; 0\\&amp;&amp;x_3&amp;-&amp;x_4&amp;=&amp; -2\\&amp;&amp;&amp;&amp;x_4&amp;=&amp; 1\\\end{matrix}\]</span></p><p>따라서 이를 정리하면 <span class="math inline">\(x_4 = 1, x_3 = -1, x_1 = 2\)</span>를 구할 수 있다. 따라서 위의 연립 선형방정식의 특수 해는 <span class="math inline">\([2, 0, -1, 1, 0]^T\)</span>인 것이다.</p><p>이제 헤당 연립 선형방정식의 일반 해를 구해보자. 일반 해를 구하기 위해서는 '기약 행 사다리꼴(educed row-echelon form, RREF)를 알아야 한다. 기약 행 사다리꼴의 특징은 다음과 같다.</p><ul><li>행 사다리꼴이다.</li><li>모든 주성분(pivot)이 1이다.</li><li>주성분이 포함된 열에서는 주성분을 제외한 모든 수가 0이다.</li></ul><p>기약 행 사다리꼴은 선형방정식들의 일반 해를 간단하게 구할 수 있게 해주기에 매우 중요한 개념이다. 또한 우리는 앞서 '가우시안 소거법(Gaussian Elimination)'을 복잡한 방정식 시스템을 간단한 형태로 변환해준다고 언급한 적이 있었다. 이제 기약 행 사다리꼴의 개념을 이해했으니 가우시안 소거법의 정의를 더 정확하게 할 수 있다. <strong>가우시안 소거법은 일반 선형방정식을 기약 행 사다리꼴로 만들어주는 알고리즘이다.</strong></p><p>그럼 우리가 예시로 사용하는 확장행렬을 기약 행 사다리꼴로 변환해보자.</p><p><span class="math display">\[\left[\begin{array}{ccccc|c}1 &amp; -2 &amp; 1 &amp; -1 &amp; 1 &amp; 0\\0 &amp; 0 &amp; 1 &amp; -1 &amp; 3 &amp; -2\\0 &amp; 0 &amp; 0 &amp; 1 &amp; -2 &amp; 1\\\end{array}\right]\]</span></p><p>위 확장 행렬에서 주성분을 포함한 열은 <span class="math inline">\(c_1, c_3, c_4\)</span>이다. <span class="math inline">\(c_1\)</span>은 주성분을 제외한 나머지가 모두 0이라서 기약 행 사다리꼴의 기준을 만족하지만 <span class="math inline">\(c_3, c_4\)</span>는 아니다. 따라서 요소변환을 통해 <span class="math inline">\(c_3, c_4\)</span>도 변환해주어야 한다.</p><p>이를 위해 <span class="math inline">\(\mathbb R_3\)</span>을 <span class="math inline">\(\mathbb R_1, \mathbb R_2\)</span>에 각각 더해준다. 그럼 다음과 같은 행렬이 된다.</p><p><span class="math display">\[\left[\begin{array}{ccccc|c}1 &amp; -2 &amp; 1 &amp; 0 &amp; -1 &amp; 2\\0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; -1\\0 &amp; 0 &amp; 0 &amp; 1 &amp; -2 &amp; 1\\\end{array}\right]\]</span></p><p>그후 <span class="math inline">\(\mathbb R_2\)</span>를 <span class="math inline">\(\mathbb R_1\)</span>에서 빼주면, 아래와 같은 기약 행 사다리꼴이 완성된다.</p><p><span class="math display">\[\left[\begin{array}{ccccc|c}1 &amp; -2 &amp; 0 &amp; 0 &amp; -2 &amp; 2\\0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; -1\\0 &amp; 0 &amp; 0 &amp; 1 &amp; -2 &amp; 1\\\end{array}\right]\]</span></p><p>드디어 기약 행 사다리꼴이 완성되었다. 이제 <span class="math inline">\(Ax=0\)</span>을 만족하는 해를 찾을 수 있다. 변수 <span class="math inline">\(x\)</span>와 행렬 A의 열인 <span class="math inline">\(c\)</span>가 곱해졌을 때 0이 되기 위해서는 자유 변수와 열의 곱을 제거하는 방식으로 풀면 된다.</p><p>여기서 자유 변수는 <span class="math inline">\(x_2, x_5\)</span>이며, <span class="math inline">\(c_2\)</span>를 먼저 살펴보자. <span class="math inline">\(c_2\)</span>는 <span class="math inline">\([-2, 0, 0, 0]^T\)</span>이기 때문에 <span class="math inline">\(c_1\)</span>에 2를 곱하여 더하면 0이 된다.</p><p><span class="math display">\[\lambda_1\big (2c_1 + 1c_2 + 0c_3 + 0c_4 + 0c_5\big )=0\]</span></p><p>따라서 첫 번째 해는 <span class="math inline">\([2, 1, 0, 0, 0]^T\)</span>이다.</p><p>다음으로 <span class="math inline">\(c_5\)</span>를 본다면, <span class="math inline">\([-2, 1, -2 , 1]^T\)</span>은 <span class="math inline">\(c_1, c_4\)</span>에 2를 곱한 것과 <span class="math inline">\(c_3\)</span>를 더해주면 0이 된다.</p><p><span class="math display">\[\lambda_2\big (2c_1 + 0c_2 - 1c_3 + 2c_4 + 1c_5\big )=0\]</span></p><p>따라서 두 번째 해는 <span class="math inline">\([2, 0, -1, 2, 1]^T\)</span>이다.</p><p>드디어 선형방정식의 해를 모두 구하였다. 이를 바탕으로 일반 해를 구하면 아래와 같다.</p><p><span class="math display">\[x \in \mathbb R^5 : x=\begin{bmatrix}2\\0\\-1\\1\\0\end{bmatrix}+\lambda_1\begin{bmatrix}2\\1\\0\\0\\0\end{bmatrix}+\lambda_2\begin{bmatrix}2\\0\\-1\\2\\1\end{bmatrix}\quad\lambda_1,\lambda_2 \in \mathbb R\]</span></p><h3 id="마이너스-1-트릭-the-minus-1-trick">'마이너스 1' 트릭 (The Minus-1 Trick)</h3><p>지금까지 우리는 연립 선형방정식의 일반 해를 구하는 방법을 살펴보았다. 물론 수식으로 푸는 것보다는 위의 방식이 편리하지만 우리는 더 쉽게 <span class="math inline">\(Ax =0\)</span>일 때의 해를 구할 수 있다. 먼저 기약 행 사다리꼴을 다시 보자.</p><p><span class="math display">\[\left[\begin{array}{ccccc|c}1 &amp; -2 &amp; 0 &amp; 0 &amp; -2 &amp; 2\\0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; -1\\0 &amp; 0 &amp; 0 &amp; 1 &amp; -2 &amp; 1\\\end{array}\right]\]</span></p><p>여기서 자유 변수인 <span class="math inline">\(x_2, x_5\)</span>의 수와 같은 <span class="math inline">\(\mathbb R_2, \mathbb R_5\)</span>의 위치에 <span class="math inline">\(&#39;-1&#39;\)</span>을 대입한다. 즉, 자유 변수와 곱해지는 열 <span class="math inline">\(c\)</span>에 값을 대입하여 기본 변수로 만들어주는 것이다</p><p><span class="math display">\[\left[\begin{array}{ccccc|c}1 &amp; -2 &amp; 0 &amp; 0 &amp; -2 &amp; 2\\\color{RoyalBlue}0 &amp; \color{RoyalBlue}{-1} &amp; \color{RoyalBlue}0 &amp; \color{RoyalBlue}0 &amp; \color{RoyalBlue}0 \\0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; -1\\0 &amp; 0 &amp; 0 &amp; 1 &amp; -2 &amp; 1\\\color{RoyalBlue}0 &amp; \color{RoyalBlue}0 &amp; \color{RoyalBlue}0 &amp; \color{RoyalBlue}0 &amp; \color{RoyalBlue}{-1} \\\end{array}\right]\]</span></p><p>위의 확장 행렬에서 <span class="math inline">\(c_2, c_5\)</span>를 보면 <span class="math inline">\(Ax=0\)</span>을 만족하는 해가 있음을 확인할 수 있다. 위의 식에서는 '-1'을 <span class="math inline">\(\lambda\)</span>로 묶어서 빼주면 위에서 구했던 해와 똑같은 결과를 얻을 수 있다.</p><p><span class="math display">\[\left[\begin{array}{ccccc|c}1 &amp; \color{Orchid}{-2} &amp; 0 &amp; 0 &amp; \color{Orchid}{-2} &amp; 2\\0 &amp; \color{Orchid}{-1} &amp;0 &amp; 0 &amp; \color{Orchid}0 &amp; \\0 &amp; \color{Orchid}0 &amp; 1 &amp; 0 &amp; \color{Orchid}1 &amp; -1\\0 &amp; \color{Orchid}0 &amp; 0 &amp; 1 &amp; \color{Orchid}{-2} &amp; 1\\0 &amp; \color{Orchid}0 &amp;0 &amp; 0 &amp; \color{Orchid}-1 &amp; \\\end{array}\right]\]</span></p><h3 id="역행렬-계산">역행렬 계산</h3><p>우리는 행렬 <span class="math inline">\(A, A \in \mathbb R^{n \times n}\)</span>의 역행렬을 구하기 위해서 <span class="math inline">\(AX=I_n\)</span>을 만족하는 <span class="math inline">\(X\)</span>를 찾았으며,해당 <span class="math inline">\(X\)</span>를 역행렬 <span class="math inline">\(A^{-1}\)</span>이라고 불렀다. 확장 행렬도 다음과 같은 식을 만족한다.</p><p><span class="math display">\[[A|I_n] \rightsquigarrow [I_n|A^{-1}]\]</span></p><p>위식을 직접 풀어보자. 먼저 행렬 <span class="math inline">\(A\)</span>와 항등행렬을 첨가 행렬 형태로 작성한다.</p><p><span class="math display">\[\left[\begin{array}{cccc|cccc}1 &amp; 0 &amp; 2 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0\\1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\1 &amp; 2 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0\\1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1\\\end{array}\right]\]</span></p><p>위 식에서 행렬 <span class="math inline">\(A\)</span>를 가우시안 소거법을 사용하여 항등 행렬로 바꿔준다.</p><p><span class="math display">\[\left[\begin{array}{cccc|cccc}1 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 2 &amp; -2 &amp; 2\\0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; -1 &amp; 2 &amp; -2\\0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; -1 &amp; 1 &amp; -1\\0 &amp; 0 &amp; 0 &amp; 1 &amp; -1 &amp; 0 &amp; -1 &amp; 2\\\end{array}\right]\]</span></p><p>원래 항등 행렬이었던 오른쪽 부분이 바로 역행렬이다.</p><p><span class="math display">\[A^{-1}=\left[\begin{array}{cccc}-1 &amp; 2 &amp; -2 &amp; 2\\1 &amp; -1 &amp; 2 &amp; -2\\1 &amp; -1 &amp; 1 &amp; -1\\-1 &amp; 0 &amp; -1 &amp; 2\\\end{array}\right]\]</span></p><p>가우시안 소거법을 사용하면 역행렬도 편리하게 구할 수 있다.</p><h3 id="선형방정식을-해결하는-알고리즘">선형방정식을 해결하는 알고리즘</h3><p>지금까지 우리는 해(solution)가 있는 <span class="math inline">\(Ax = b\)</span>형태의 선형방정식들을 풀어보았다. 하지만 해가 없는 선형방정식은 어떻게 풀어야 하는가? 이 부분은 이후 chapter 8에서 자세하게 살펴볼 것이다. <span class="math inline">\(A\)</span>가 정방행렬이며 동시에 가역행렬인 경우, 우리는 <span class="math inline">\(Ax = b\)</span>의 해로 <span class="math inline">\(x = A^{-1}b\)</span>가 주어지도록 역행렬 <span class="math inline">\(A^{-1}\)</span>을 구할 수 있다. 하지만 그외의 경우에는 (<span class="math inline">\(A\)</span>의 행(column)이 독립적인 선형방정식이라는 전제 하에) 전치행렬과 '무어-펜로즈의 의사역행렬(Moore-Penrose pseudo-inverse)'을 사용하여 해를 구해야 한다.</p><p>무어-펜로즈의 의사역행렬(Moore-Penrose pseudo-inverse)'은 의사역행렬(pseudo inverse)이라고도 불리며, 정방행렬이 아닌 행렬에 대해서 <span class="math inline">\(x\)</span>값을 근사적으로 구할 수 있는 방법이다. 이 방법은 미지수보다 선형방정식의 수가 더 많을 때 사용한다.</p><p><strong>NOTE</strong> 미지수 <span class="math inline">\(x\)</span>와 선형방정식의 관계 미지수는 방정식의 개수와 동일할 때 해를 갖는다. 즉, <span class="math inline">\(x_1, x_2, x_3\)</span>이 미지수로 주어졌다면, 선형방정식도 3개가 주어져야 한다는 뜻이다. 하지만 그 외에도 방정식의 개수보다 미지수 수가 더 많거나 적은 경우가 존재한다. 미지수보다 방정식 개수가 더 적다면 이는 무수히 많은 해가 존재한다. 또한 미지수보다 방정식 개수가 더 많다면 해가 없는데, 이 경우에는 '근사 해'를 구해야 한다.</p><ul><li>(미지수 개수 &gt; 방정식 개수) -&gt; 해가 무수히 많음</li><li>(미지수 개수 &lt; 방정식 개수) -&gt; 해가 없음 -&gt; 근사 해 구할 수 있음</li></ul><p><span class="math display">\[Ax = b \Longleftrightarrow A^TAx = A^Tb \Longleftrightarrow x=(A^TA)^{-1}A^Tb\]</span></p><p>위 식은 의사역행렬을 적용하는 과정을 보여준다. 하나씩 천천히 살펴보면서 원리를 이해해보자.</p><p><span class="math display">\[Ax = b, \quad  A \in R^{3 \times 2}\]</span></p><p>평범한 선형방정식이 있다. 하지만 행렬 <span class="math inline">\(A\)</span>는 정방행렬이 아니다. 즉, 위 식은 미지수 <span class="math inline">\(x\)</span>가 2개인데, 선형방정식은 3개인 경우이다. 이 상태에서는 행렬 <span class="math inline">\(A\)</span>의 역행렬을 구할 수 없다. 역행렬이 존재하기 위해서는 정방행렬이어야 하기 때문이다. 따라서 각 항에 전치행렬을 곱해서 정방행렬의 형태로 만들어준다.</p><p><span class="math display">\[A^TAx = A^Tb, \quad A^TA \in R^{3 \times 3}\]</span></p><p>이제 <span class="math inline">\(A^TA\)</span>는 <span class="math inline">\(3 \times 3\)</span> 형태의 정방행렬이기에 역행렬을 구할 수 있다. <span class="math inline">\(A^TA\)</span>의 역행렬은 <span class="math inline">\((A^TA)^{-1}\)</span>이다. 해당 역행렬을 양쪽 항에 곱해주자.</p><p><span class="math display">\[(A^TA)^{-1}A^TAx = (A^TA)^{-1}A^Tb, \quad A^TA \in R^{3 \times 3}\]</span></p><p>특정 행렬과 그의 역행렬을 곱하면 항등 행렬이 되며, 이는 <span class="math inline">\(x\)</span>와 같다. 그 이유는 항등행렬은 각 행마다 하나의 1만을 가지고 있기 때문에 <span class="math inline">\(Ix\)</span>는 <span class="math inline">\(x\)</span>와 똑같은 결과를 도출한다. 따라서 식을 정리해보면 다음과 같다.</p><p><span class="math display">\[x = (A^TA)^{-1}A^Tb, \quad A^TA \in R^{3 \times 3}\]</span></p><p>이 방법은 근사 해를 구할 수 있게 해주기에 매우 유용하지만, 많은 행렬 계산이 들어가고 근사값을 구하는 것이기에 일반적으로 사용하기를 추천하지는 않는다. 이의 대안으로 우리는 chapter2에서 벡터 사이의 유사성을 계산할 수 있는 방법을 살펴볼 것이다.</p>]]></content>
    
    
    <categories>
      
      <category>MachineLearning</category>
      
      <category>mathematics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>머신러닝</tag>
      
      <tag>mathematics</tag>
      
      <tag>machine learning</tag>
      
      <tag>mathematics for machine learning</tag>
      
      <tag>머신러닝 수학</tag>
      
      <tag>수학</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linear Algebra (1)</title>
    <link href="/ko/Mathematic/mathematic-0/"/>
    <url>/ko/Mathematic/mathematic-0/</url>
    
    <content type="html"><![CDATA[<p>글을 시작하기에 앞서 해당 글은 Marc Peter Deisenroth, A. Aldo Faisal, Cheng Soon Ong의 저서인 mathematics for machine learning을 바탕으로 요약 및 정리한 글임을 알려드립니다. <span id="more"></span></p><hr /><h2 id="벡터vector란">벡터(vector)란</h2><p>일반적으로 동일한 종류의 두 객체를 합하거나 스칼라와 곱해서 같은 종류의 다른 객체를 생성할 수 있다면 이를 벡터라고 한다. 좀 더 추상적인 수학적 관점에서 벡터를 정의한다면, 앞의 두 조건을 만족하는 모든 객체들이 벡터로 간주된다.</p><ul><li><p>'기하학에서의 벡터(Geometric vector)'도 합과 스칼라 곱이 가능하기 때문에 벡터이다.</p></li><li><p>'다항식(Polynomials)'도 서로 더하거나 스칼라를 곱할 수 있기에 벡터 중 하나이다.</p></li><li><p>'오디오 신호(Audio signals)'도 숫자의 열거이기에 신호끼리 서로 더하거나 연산할 수 있다. 따라서 벡터 중 하나이다.</p></li><li><p><strong><span class="math inline">\(\mathbb{R}^n\)</span>(실수 집합)의 요소도 벡터이다. 이 책에서 가장 중요한 벡터 개념이기에 예시로 설명하고자 한다.</strong></p></li></ul><p><span class="math display">\[a= \begin{bmatrix}1\\2\\3\end{bmatrix}\in\mathbb{R}^3\]</span></p><p>위의 예시 <span class="math inline">\(a\)</span>는 삼항이고, 따라서 <span class="math inline">\(\mathbb{R}^3\)</span>에 속한다. 이 벡터를 다른 벡터 <span class="math inline">\(b\)</span>와 더해도 그 결과값이 <span class="math inline">\(\mathbb{R}^3\)</span>에 속하며, 스칼라 <span class="math inline">\(\lambda\)</span>와 곱해도 그 결과값이 <span class="math inline">\(\mathbb{R}^3\)</span>에 속한다. 따라서 이 또한 벡터이다. <span class="math inline">\(\mathbb{R}^n\)</span>의 요소들을 벡터로 전제하면 배열을 사용하여 벡터 연산이 가능하기에 훨씬 편리하다. 선형대수의 알고리즘 대부분이 <span class="math inline">\(\mathbb{R}^n\)</span>로 공식화되기 때문에 우리는 <span class="math inline">\(\mathbb{R}^n\)</span>안에서의 벡터에 집중할 것이다.</p><p>수학의 주요 아이디어 중 하나는 폐포(closure)이다. 폐포의 의미는 주어진 작업에서 발생할 수 있는 모든 것들을 나타내는 것이다. 즉, 어떤 연산를 통해 발생할 수 있는 모든 결과들을 보여주는 것이다. 이를 벡터 개념에서 적용한다면 의미는 다음과 같다. 작은 벡터들을 더하고 크기를 조정할 때 어떤 벡터가 만들어지는가? 이 질문에 대한 답이 '벡터 공간'이다. 벡터 공간에 대해서는 이후 자세히 다룰 것이다. 아래의 그림은 이번 장에서 보여주는 개념들을 요약한 도식이다.</p><figure><img src="/images/39.png" alt="벡터 도식" /><figcaption aria-hidden="true">벡터 도식</figcaption></figure><h2 id="연립-선형방정식-systems-of-linear-equations">연립 선형방정식 (Systems of Linear Equations)</h2><p>연립 선형방정식은 선형대수의 중요한 핵심 파트 중 하나이다. 연립 선형방정식에 대한 설명은 예시를 살펴보면서 진행하자.</p><p><span class="math display">\[4x_1 + 4x_2 = 5\]</span> <span class="math display">\[2x_1 - 4x_2 = 1\]</span></p><p>위의 두 수식은 두 개의 변수로 구성된 연립 선형방정식이다. 위의 두 식을 모두 만족하는 <span class="math inline">\(x_1\)</span>의 값과 <span class="math inline">\(x_2\)</span>의 값을 구하려고 한다. 이를 그래프로 나타내면 아래와 같다.</p><figure><img src="/images/40.png" alt="연립 선형방정식" /><figcaption aria-hidden="true">연립 선형방정식</figcaption></figure><p>두 수식을 모두 만족하는 값은 위 그래프의 '검은 점'이다. 위의 수식을 정리해보면 검은 점의 좌표는 <span class="math inline">\((1, \frac{1}{4})\)</span>인 것을 알 수 있다.</p><p>변수가 2개일 때는 위의 예시와 같이 2차원 그래프를 그린 후 겹쳐지는 점을 구하면 된다. 그렇다면 변수가 세 개인 경우에는 어떻게 해야 할까? 변수의 개수와 동일하게 차원이 증가하기 때문에 3차원 그래프로 나타낼 수 있다. 또한 변수가 세 개인 경우에는 겹쳐지는 지점으로 평면(plane)이 등장한다.</p><p>연립 선형방정식을 좀 더 일반화하면, 아래와 같은 결론을 도출할 수 있다.</p><ul><li>1단계: 변수 n개인 연립 선형방정식</li></ul><p><span class="math display">\[a_{11}x_1 + a_{12}x_2  + \cdots + a_{1n}x_n = b_1\\\vdots\\a_{m1}x_1 + a_{m2}x_2  + \cdots + a_{mn}x_n = b_m\]</span></p><ul><li>2단계: 벡터인 변수의 계수(coefficient)를 행렬(matrix)로 변경하기</li></ul><p><span class="math display">\[x_1\begin{bmatrix}a_{11}\\\vdots\\a_{m1}\end{bmatrix}+x_2\begin{bmatrix}a_{12}\\\vdots\\a_{m2}\end{bmatrix}+\cdots+x_n\begin{bmatrix}a_{1n}\\\vdots\\a_{mn}\end{bmatrix}=\begin{bmatrix}b_{1}\\\vdots\\b_{m}\end{bmatrix}\]</span></p><ul><li>3단계: 변수도 행렬(matrix)로 변경하기 (<span class="math inline">\(Ax=b\)</span>)</li></ul><p><span class="math display">\[\begin{bmatrix}a_{11} &amp; \cdots &amp; a_{1n}\\\vdots &amp; &amp; \vdots\\a_{m1} &amp; \cdots &amp; a_{mn}\end{bmatrix}\begin{bmatrix}x_1\\\vdots\\x_n\end{bmatrix}=\begin{bmatrix}b_{1}\\\vdots\\b_{m}\end{bmatrix}\]</span></p><h2 id="행렬-matrices">행렬 (Matrices)</h2><p>행렬은 선형대수에서 가장 중요한 원리이다. 연립 선형방정식을 간단하게 나타내기 위해 사용하기도 하며, 이후 자세히 다룰 '선형 변환 (linear mapping)'에서도 사용된다. 행렬에 대한 흥미로운 주제를 다루기 전에 행렬이 무엇인지 간단히 살펴보자.</p><p><span class="math inline">\(m, n \in \mathbb N\)</span>(자연수)인 행렬 A는 행이 <span class="math inline">\(m\)</span>이고 열이 <span class="math inline">\(n\)</span>인 튜플(tuple)이며, <span class="math inline">\(i=1\cdots m\)</span>이고 <span class="math inline">\(j=1 \cdots n\)</span>인 <span class="math inline">\(a_{ij}\)</span>를 요소로 가진다. 해당 정의를 수식으로 표현하면 다음과 같다.</p><p><span class="math display">\[A=\begin{bmatrix}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n}\\a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n}\\\vdots &amp; \vdots &amp; &amp; \vdots\\a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{mn}\end{bmatrix},a_{ij} \in \mathbb R\]</span></p><p>행렬의 각각 행과 열은 행벡터 또는 열벡터이며, <span class="math inline">\(\mathbb R^{m\times n}\)</span>은 모든 <span class="math inline">\(m \times n\)</span>행렬을 포함한다. 위의 예시인 <span class="math inline">\(A\)</span> 또한 <span class="math inline">\(m \times n\)</span>에 포함된다. 행렬 <span class="math inline">\(A\)</span>는 긴 벡터형태인 <span class="math inline">\(a\)</span>로 나타낼 수 있으며, <span class="math inline">\(a \in \mathbb R^{mn}\)</span>이다. 예로 행렬 <span class="math inline">\(A\)</span>가 <span class="math inline">\(\mathbb R^{4\times 2}\)</span>에 포함된다면, <span class="math inline">\(a\)</span>는 <span class="math inline">\(\mathbb R^8\)</span>에 포함된다.</p><h3 id="행렬의-덧셈과-곱셈">행렬의 덧셈과 곱셈</h3><p>행렬 <span class="math inline">\(A\)</span>와 <span class="math inline">\(B\)</span> 모두가 <span class="math inline">\(\mathbb R^{m \times n}\)</span>에 속한다면, 두 행렬은 더할 수 있다.</p><p><span class="math display">\[A+B:=\begin{bmatrix}a_{11}+b_{11} &amp; \cdots &amp; a_{1n}+b_{1n}\\\vdots &amp; &amp; \vdots\\a_{m1}+b_{m1} &amp; \cdots &amp; a_{mn}+b_{mn}\end{bmatrix}\in\mathbb R^{m \times n}\]</span></p><p>행렬 <span class="math inline">\(A\)</span>가 <span class="math inline">\(\mathbb R^{m \times n}\)</span>에 속하고, 행렬 <span class="math inline">\(B\)</span>가 <span class="math inline">\(\mathbb R^{n \times k}\)</span>에 속한다면, <span class="math inline">\(C=AB\in\mathbb R^{n \times k}\)</span>이다.</p><p><span class="math display">\[c_{ij}=\sum_{l=1}^n a_{il}b_{lj} \quad\quad  i=1 \cdots m,\quad  j= 1 \cdots k\]</span></p><p>행렬 <span class="math inline">\(A\)</span>와 <span class="math inline">\(B\)</span>의 곱인 <span class="math inline">\(C\)</span>의 요소는 <span class="math inline">\(A\)</span>의 행과 <span class="math inline">\(B\)</span>의 열의 곱과 같다. 행렬의 행과 열을 곱하는 것을 '내적(dot product)'이라고 부르며, 자세한 내용은 2장에서 다룰 것이다. 내적은 기호 " <span class="math inline">\(\cdot\)</span> "로 나타낸다.</p><p>다시 한번 강조하지만 두 행렬의 곱은 이웃하는 차원이 동일해야 가능하다. <span class="math inline">\(m \times n\)</span>인 행렬 <span class="math inline">\(A\)</span>는 <span class="math inline">\(n \times k\)</span>인 행렬 <span class="math inline">\(B\)</span>와 곱할 수 있으며, 그 결과는 <span class="math inline">\(m \times k\)</span>행렬이다. 즉, <span class="math inline">\(AB\)</span>는 가능하다. 하지만 <span class="math inline">\(BA\)</span>의 경우는 이웃하는 차원이 동일하지 않기 때문에 곱할 수 없다.</p><p>하지만 프로그래밍에서는 지금까지 봤던 곱의 원리와는 다르게 행렬의 요소끼리 곱셈을 하는 '아다마르 곱(Hadamard product)'도 가능하다. 아다마르 곱은 같은 <span class="math inline">\(m \times n\)</span>크기의 두 행렬이 같은 위치에 있는 요소끼리 곱해지는 것이며, 행렬 덧셈의 원리와 같다.</p><p>'항등 행렬(Identity Matrix)'은 <span class="math inline">\(n \times n\)</span> 행렬로 <span class="math inline">\(\mathbb R^{n \times n}\)</span>에 속한다. 항등 행렬의 요소는 행과 열의 위치가 같은 주대각선(main diagonal)만 1이고, 나머지는 0이다. 도식화하면 다음과 같다.</p><p><span class="math display">\[I_n=\begin{bmatrix}1 &amp; 0 &amp; \cdots &amp; 0 &amp; \cdots &amp; 0\\0 &amp; 1 &amp; \cdots &amp; 0 &amp; \cdots &amp; 0\\\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots\\0 &amp; 0 &amp; \cdots &amp; 1 &amp; \cdots &amp;0\\\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots\\0 &amp; 0 &amp; \cdots &amp; 0 &amp; \cdots &amp;1\end{bmatrix}\in\mathbb R^{n \times n}\]</span></p><p>지금까지 행렬의 덧셈과 곱셈에 대해 살펴보았다. 행렬은 다음과 같은 특징을 가진다.</p><ul><li>결합법칙(Associativity)</li></ul><p><span class="math inline">\(A \in \mathbb R^{m \times n},\quad B \in \mathbb R^{n \times q},\quad C \in \mathbb R^{q \times p} \ :\ (AB)C = A(BC)\)</span></p><ul><li>분배법칙(Distributivity)</li></ul><p><span class="math inline">\(A \in \mathbb R^{m \times n},\quad B, C \in \mathbb R^{n \times q} \ :\ A(B+C) = AB + AC\)</span></p><ul><li>항등행렬과의 곱</li></ul><p><span class="math inline">\(A \in \mathbb R^{m \times n} \ :\ I_mA = AI_n = A\)</span></p><h3 id="역행렬과-전치행렬">역행렬과 전치행렬</h3><p>행렬 <span class="math inline">\(A \in \mathbb R^{n \times n}\)</span>와 행렬 <span class="math inline">\(B \in \mathbb R^{n \times n}\)</span>가 있다. 만약 행렬 <span class="math inline">\(A, B\)</span>에 대해서 <span class="math inline">\(AB = I_n = BA\)</span>가 성립한다면, <span class="math inline">\(B\)</span>는 <span class="math inline">\(A\)</span>의 '역행렬(inverse matrix)'이다. <span class="math inline">\(A\)</span>에 대한 역행렬의 기호는 <span class="math inline">\(A^{-1}\)</span>이다.</p><p>모든 행렬이 역행렬을 가진 것은 아니다. 역행렬이 존재하는 경우 해당 행렬을 가역 행렬 또는 비특이 행렬이라고 하며, 존재하지 않는 경우 비가역 행렬이라고 한다.</p><p><span class="math display">\[A:=\begin{bmatrix}a_{11} &amp; a_{12}\\a_{21} &amp; a_{22}\\\end{bmatrix}\in\mathbb R^{2 \times 2}\]</span></p><p>행렬 <span class="math inline">\(A\)</span>를 <span class="math inline">\(2 \times 2\)</span>행렬로 정의한다.</p><p><span class="math display">\[B:=\begin{bmatrix}a_{22} &amp; -a_{12}\\-a_{21} &amp; a_{11}\\\end{bmatrix}\in\mathbb R^{2 \times 2}\]</span></p><p>행렬 <span class="math inline">\(A\)</span>와 곱해서 항등 행렬이 나올 수 있는 행렬 <span class="math inline">\(B\)</span>를 정의한다.</p><p><span class="math display">\[AB=\begin{bmatrix}a_{11}a_{22}-a_{12}a_{21} &amp; 0\\0 &amp; a_{11}a_{22}-a_{12}a_{21}\\\end{bmatrix}=(a_{11}a_{22}-a_{12}a_{21})I\]</span></p><p>두 행렬을 곱한 후, 항등 행렬 기준으로 식을 정리한다.</p><p><span class="math display">\[A^{-1}= \frac{1}{a_{11}a_{22}-a_{12}a_{21}}\begin{bmatrix}a_{22} &amp; -a_{12}\\-a_{21} &amp; a_{11}\\\end{bmatrix}\]</span></p><p>그 결과 행렬 <span class="math inline">\(A\)</span>의 역행렬을 구할 수 있다.</p><p>정리하면 다음과 같다. 행렬 <span class="math inline">\(A\)</span>와 곱해서 항등 행렬 <span class="math inline">\(I\)</span>가 나온다면 그 행렬은 역행렬 <span class="math inline">\(A^{-1}\)</span>이다.</p><p>일반적으로 전치행렬 <span class="math inline">\(A^T\)</span>은 행렬 <span class="math inline">\(A\)</span>의 행과 열이 바뀐다. 즉, 행렬 <span class="math inline">\(A\)</span>가 <span class="math inline">\(m \times n\)</span>이라면 전치행렬인 <span class="math inline">\(A^T\)</span>는 <span class="math inline">\(n \times m\)</span>인 것이다. 전치행렬은 주대각선(main diagonal)을 기준으로 뒤집힌 행렬을 말한다.</p><p><span class="math display">\[A=\begin{bmatrix}\mathbf{a_{11}} &amp; a_{12}\\a_{21} &amp; \mathbf{a_{22}}\\\end{bmatrix}\quadA^T=\begin{bmatrix}\mathbf{a_{11}} &amp; a_{21}\\a_{12} &amp; \mathbf{a_{22}}\\\end{bmatrix}\]</span></p><p>지금까지 역행렬과 전치행렬의 정의에 대해서 살펴보았다. 역행렬과 전치행렬은 아래와 같은 특징을 가진다.</p><ol type="1"><li>역행렬</li></ol><ul><li><span class="math inline">\(AA^{-1} = I = A^{-1}A\)</span></li><li><span class="math inline">\((AB)^{-1} = A^{-1}B^{-1}\)</span></li><li><span class="math inline">\((A+B)^{-1} \ne A^{-1} + B^{-1}\)</span></li></ul><ol start="2" type="1"><li>전치행렬</li></ol><ul><li><span class="math inline">\((A^T)^T = A\)</span></li><li><span class="math inline">\((A+B)^T = A^T + B^T\)</span></li><li><span class="math inline">\((AB)^T = B^TA^T\)</span></li></ul><p>역행렬은 <span class="math inline">\(n \times n\)</span> 형태의 가역 행렬일 때만 존재한다. 따라서 행렬 <span class="math inline">\(A\)</span>가 가역 행렬이고 역행렬 <span class="math inline">\(A^{-1}\)</span>가 존재한다면, 아래와 같은 식도 성립한다.</p><p><span class="math inline">\((A^{-1})^T = (A^{T})^-1 =: A^{-T}\)</span></p><h3 id="행렬과-스칼라의-곱">행렬과 스칼라의 곱</h3><p>행렬 <span class="math inline">\(A\)</span>에 스칼라 <span class="math inline">\(\lambda\)</span>를 곱해보자. 여기서 행렬 <span class="math inline">\(A\)</span>는 <span class="math inline">\(\mathbb R^{m \times n}\)</span>에 속하고, 스칼라 <span class="math inline">\(\lambda\)</span>는 실수 <span class="math inline">\(\mathbb R\)</span>에 속한다. 스칼라 <span class="math inline">\(\lambda\)</span>는 행렬 <span class="math inline">\(A\)</span>의 요소들에 각각 곱해진다. 이를 기호로 나타내면 <span class="math inline">\(\lambda A=K\)</span>, <span class="math inline">\(K_{ij} = \lambda a_{ij}\)</span> 이다. 스칼라 <span class="math inline">\(\lambda, \psi\)</span>을 행렬과 곱할 때, 다음과 같은 특징을 가진다.</p><ul><li>결합법칙(Associativity)</li></ul><p><span class="math inline">\((\lambda\psi)C = \lambda(\psi C),\quad C \in \mathbb R^{m \times n}\)</span></p><p><span class="math inline">\(\lambda(BC) = (\lambda B)C = B(\lambda C)= (BC)\lambda, \quad B \in \mathbb R^{m \times n}, C \in \mathbb R^{n \times k}\)</span></p><p><span class="math inline">\((\lambda C)^T = C^T\lambda^T = C^T\lambda = \lambda C^T\)</span></p><ul><li>분배법칙(Distributivity)</li></ul><p><span class="math inline">\((\lambda + \psi)C = \lambda C + \psi C,\quad C \in \mathbb R^{m \times n}\)</span></p><p><span class="math inline">\(\lambda(B + C)=\lambda B + \lambda C,\quad B,C \in \mathbb R^{m \times n}\)</span></p>]]></content>
    
    
    <categories>
      
      <category>MachineLearning</category>
      
      <category>mathematics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>머신러닝</tag>
      
      <tag>mathematics</tag>
      
      <tag>machine learning</tag>
      
      <tag>mathematics for machine learning</tag>
      
      <tag>머신러닝 수학</tag>
      
      <tag>수학</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[7/18] 인공신경망 구현: 순전파 알고리즘</title>
    <link href="/ko/DeeplearningJulia/Deeplearning-7/"/>
    <url>/ko/DeeplearningJulia/Deeplearning-7/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다. <span id="more"></span></p><hr /><p>이전 글에서 인공신경망을 학습한다는 것이 어떤 의미인지 살펴보았다. 이번에는 인공신경망을 직접 설계하고 학습하여 손글씨 숫자를 분류하는 인공신경망을 만들 것이다. 인공신경망을 설계하는 것은 앞전에 살펴봤던 도식을 만드는 것이다. 은닉층 개수를 정하여 인공신경망의 깊이를 설정하고, 사용되는 활성화 함수들을 정한다. <strong>그 후 인공신경망을 '어떻게' 학습시킬 것인가를 정해야 한다.</strong> 오늘 같이 구현할 '순전파'는 경사하강법에서 기울기를 구하는 방법 중 하나이다.</p><h2 id="순전파란">순전파란</h2><p>순전파는 기울기를 구하는 과정이 입력값에서 예측값으로 진행되는 것을 의미한다. 즉, 순서대로 이행되는 정직한 미분 알고리즘이다. 우리가 앞서 <a href="https://dev-bearabbit.github.io/2020/03/31/DeeplearningJulia/Deeplearning-4/">경사하강법</a> 파트에서 살펴봤던 미분 방법을 사용한다.</p><p>순전파 알고리즘의 편미분 원리는 다음과 같다.</p><ol type="1"><li>편미분 대상(가중치와 편향)에 아주 작은 수(1e-50)를 더해준다.</li><li>손실 함수 값인 <span class="math inline">\(f1\)</span>을 구한다.</li><li>편미분 대상(가중치와 편향)에 아주 작은 수(1e-50)를 빼준다.</li><li>손실 함수 값인 <span class="math inline">\(f2\)</span> 구한다.</li><li><span class="math inline">\(\frac{(f1 - f2)}{2h}\)</span>를 한다. -&gt; 편미분값 완성</li><li>위의 식 결과를 미분값 객체에 저장한다.</li></ol><p>하지만 순전파 알고리즘은 너무 느리다. 그 이유는 매개 변수인 가중치와 편향을 업데이트한 후 다시 처음부터 신경망을 계산하여 손실함수 값을 갱신하기 때문이다. 다음 글에서는 이를 좀 더 빨리 진행할 수 있는 역전파 알고리즘을 살펴볼 것이다.</p><p>아래의 수식은 이전 글에서 우리가 만들었던 인공신경망의 프로세스를 나타낸 것이다.</p><p><span class="math display">\[\hat{y}=\sigma(h(XW1+B1)\times W2+B2)\]</span></p><p>순전파는 위의 수식에서 합성 함수들 가장 안쪽에 위치한 입력값부터 계산이 진행된다. 즉, 안쪽에서 바깥쪽으로 계산된다고도 볼 수 있다. 도식에서는 왼쪽에서 오른쪽으로 이동하며, 수식에서는 안쪽에서 바깥쪽으로 이동한다.</p><h2 id="mnist-project">'MNIST' Project</h2><p>'MNIST'는 손글씨로 쓴 숫자를 예측하는 인공신경망을 만드는 프로젝트이다. 해당 프로젝트에 대해 더 알고싶다면 <a href="https://juliaml.github.io/MLDatasets.jl/latest/datasets/MNIST/#MLDatasets.MNIST.testtensor">이 링크</a>를 참고하면 된다. MNIST는 대부분의 교재에서 사용하는 예시 중 하나이며, 해당 데이터셋이 패키지 안에 준비되어 있다. 먼저 아래의 코드를 입력해서 데이터를 가져오자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-comment">#import Pkg           # 패키지를 처음 사용할 때 입력해야 한다.</span><br>Pkg.add(<span class="hljs-string">&quot;MNIST&quot;</span>)<br><span class="hljs-keyword">using</span> MLDatasets<br>train_x, train_y = MNIST.traindata()<br>test_x,  test_y  = MNIST.testdata()<br></code></pre></td></tr></table></figure><p>해당 데이터의 입력값 <code>train_x</code>는 <span class="math inline">\(28 \times 28\)</span> 이미지 데이터가 60000개 들어 있으며, <code>train_y</code>는 정답 숫자가 <span class="math inline">\(60000 \times 1\)</span> 형태로 들어 있다. 우리는 이를 신경망 모델에 알맞게 전처리해주어야 한다. 특히 <code>train_y</code>는 <code>7</code>이나 <code>8</code>같은 숫자로 들어가 있는데 이를 '원-핫 인코딩'형태로 변환해야 한다. 이를 위해 아래의 함수를 먼저 정의하자.</p><p><strong>Note</strong> 원-핫 인코딩이란? 원-핫 인코딩은 숫자의 형태를 분류하기 위해 사용되는 데이터 형태로 <code>7</code>을 [0,0,0,0,0,0,0,1,0,0]로 변경해준다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    원-핫 인코딩 레이블을 만드는 함수</span><br><span class="hljs-string">    예를 들어 0~9까지의 숫자 중 3을 원-핫 레이블로 만들면</span><br><span class="hljs-string">    [0  0  0  1  0  0  0  0  0  0]과 같이 출력할 것이다.</span><br><span class="hljs-string">    x : 만들려는 숫자</span><br><span class="hljs-string">    y: 메트릭스의 길이, 주의할 점은 이것은 0부터 시작한다!</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">function</span> making_one_hot_label(x, y)<br><br>    temp = x + <span class="hljs-number">1</span><br>    temp_matrix = zeros(<span class="hljs-built_in">Int8</span>, <span class="hljs-number">1</span>, y)<br>    temp_matrix[temp] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span>(temp_matrix)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> making_one_hot_labels(y_train)<br>    t = making_one_hot_label.(y_train, <span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">return</span> (reduce(vcat, t))<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 함수를 사용하면 숫자로 입력된 <code>train_y</code>가 원-핫 레이블로 변경된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-comment"># 훈련데이터 입력값 전처리</span><br>train_x = reshape(train_x,<span class="hljs-number">784</span>, <span class="hljs-number">60000</span>)<br>train_x = <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Float64</span>&#125;(train_x)<br>train_x=train_x&#x27;<br><br><span class="hljs-comment"># 실제 실험데이터 입력값 전처리</span><br>test_x = reshape(test_x,<span class="hljs-number">784</span>, <span class="hljs-number">10000</span>)<br>test_x = <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Float64</span>&#125;(test_x)<br>test_x=test_x&#x27;<br><br><span class="hljs-comment"># 훈련데이터 정답 레이블 전처리 (원-핫 인코딩)</span><br>t = making_one_hot_labels(train_y)<br>typeof(t), size(t)<br></code></pre></td></tr></table></figure><p>이제 신경망 모델을 학습하기 위해 필요한 데이터는 모두 준비되었다. 우리가 만들 신경망은 이전 글에서 정리했던 '2층 신경망(TwoLayerNet)'이다. 신경망 모델에서는 네트워크에서 가중치와 편향이 계속 업데이트되어야 하기 때문에 딕셔너리로 정의한다. 만약 딕셔너리에 대해서 모르거나 더 알고 싶다면 <a href="https://dev-bearabbit.github.io/2020/03/10/ThinkJulia/Think-Julia-Chapter-11/">해당 글</a>을 참고하자. 또한 네트워크가 정확히 무엇인지 궁금하다면 <a href="https://dev-bearabbit.github.io/2020/04/02/DeeplearningJulia/Deeplearning-6/">이전 글</a>을 참고하면 된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">params = <span class="hljs-built_in">Dict</span>()<br>grads = <span class="hljs-built_in">Dict</span>()<br></code></pre></td></tr></table></figure><p>가중치를 할당할 딕셔너리를 정의하였다. <code>params</code>는 기존 매개 변수를 저장하며, <code>grads</code>는 매개 변수의 미분값들을 저장한다. 이제 가중치와 편향의 초기값을 생성하는 함수를 정의하자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> making_network(input_size, hidden_size, output_size, weight_init_std =<span class="hljs-number">0.01</span>)<br>    params[<span class="hljs-string">&quot;W1&quot;</span>] = weight_init_std * randn(<span class="hljs-built_in">Float64</span>, input_size, hidden_size)<br>    params[<span class="hljs-string">&quot;b1&quot;</span>] = zeros(<span class="hljs-built_in">Float32</span>, <span class="hljs-number">1</span>, hidden_size)<br>    params[<span class="hljs-string">&quot;W2&quot;</span>] = weight_init_std * randn(<span class="hljs-built_in">Float64</span>, hidden_size, output_size)<br>    params[<span class="hljs-string">&quot;b2&quot;</span>] = zeros(<span class="hljs-built_in">Float32</span>, <span class="hljs-number">1</span>, output_size)<br>    <span class="hljs-keyword">return</span>(params)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 함수는 입력 데이터의 행렬 크기, 은닉층의 행렬 크기, 결과값의 행렬 크기를 받아서 그에 알맞는 가중치와 편향 행렬을 생성해준다. 가중치는 오버피팅을 막기 위해 가장 작게 셋팅하는 것이 좋기 때문에 <code>weight_init_std</code>을 곱해준다. 가중치인 <code>W1</code>, <code>W2</code>는 정규분포를 따라 랜덤 수를 생성해주는 <code>randn()</code>를 사용하였으며, 편향인 <code>b1</code>, <code>b2</code>는 초기값인 크기에 맞게 제로 행렬로 만들어준다. 제로 행렬을 만드는 방법은 <code>zeros()</code>를 사용한다.</p><p>우리가 사용하는 데이터는 입력값이 <span class="math inline">\(60000 \times 784\)</span>이며, 결과값은 <span class="math inline">\(60000 \times 10\)</span>이다. 따라서 <code>W1</code>은 <span class="math inline">\(784 \times 50\)</span>이며, <code>W2</code>는 <span class="math inline">\(50 \times 10\)</span>이다. <code>b1</code>은 <span class="math inline">\(1 \times 50\)</span>이고, <code>b2</code>는 <span class="math inline">\(1 \times 10\)</span>이다. 따라서 다음과 같이 함수를 사용하면 알맞은 가중치와 행렬 초기값을 만들 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">making_network(<span class="hljs-number">784</span>, <span class="hljs-number">50</span>, <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>초기값 설정이 끝났다면 이제 신경망을 학습할 차례이다. 학습을 진행하기 전에 필요한 변수들을 미리 세팅해준다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">train_loss_list = <span class="hljs-built_in">Float64</span>[]<br>accuracy = <span class="hljs-built_in">Float64</span>[]<br></code></pre></td></tr></table></figure><p><code>train_loss_list</code>는 학습이 진행되는 동안 제공되는 손실 함수의 값을 저장할 리스트이다. 모델의 정확도 또한 <code>accuracy</code>에 저장하여 값이 변화하는 과정을 살펴볼 예정이다.</p><p>지금부터는 순전파 기반 경사하강법에 사용되는 함수들을 정의할 것이다. 대부분의 함수들은 우리가 이전 글들에서 살펴봤던 원리와 같으며, 단지 신경망 모델에 맞게 부분적인 수정이 이루어졌다.</p><p>먼저 기본적인 활성화 함수를 정의한다. 우리는 이번 신경망 모델에 시그모이드와 소프트맥스를 사용할 예정이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> sigmoid(x)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>/(<span class="hljs-number">1</span>+exp(-x))<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> softmax_single(a)<br>    c = maximum(a)<br>    exp.(a .- c) / sum(exp.(a .- c))<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment"># 배치 데이터에 사용하는 소프트맥스</span><br><span class="hljs-keyword">function</span> softmax(a)<br>    temp = map(softmax_single, eachrow(a))<br>    <span class="hljs-keyword">return</span>(transpose(hcat(temp ...)))<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>시그모이드 함수는 그대로 사용하며, 소프트맥스의 경우는 배치 데이터에 사용하는 함수를 따로 생성해준다. 배치 데이터는 각 행이 하나의 이미지이기 때문에 행 하나의 요소 합이 1이어야 한다. 위의 <code>softmax()</code>는 각 행 별로 <code>softmax_single()</code>를 계산하여 배열로 반환한다.</p><p><strong>Note</strong> 배치(batch)란? 배치는 모델이 한번에 처리하는 데이터의 개수를 의미한다. 예를 들어 MNIST 데이터를 본다면, 입력데이터 <span class="math inline">\(1 \times 784\)</span>는 하나의 이미지이다. 만약 모델에 투입하는 입력데이터가 <span class="math inline">\(100 \times 784\)</span>라면 이미지 100개를 한번에 사용한 것이며, 이는 배치 데이터이다.</p><p>그 다음 예측값 <span class="math inline">\(\hat{y}\)</span>을 반환하는 <code>predict()</code>를 정의한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> predict(x)<br>    a1 = (x * params[<span class="hljs-string">&quot;W1&quot;</span>]) .+ params[<span class="hljs-string">&quot;b1&quot;</span>]<br>    z1 = sigmoid.(a1)<br>    a2 = (z1 * params[<span class="hljs-string">&quot;W2&quot;</span>]) .+ params[<span class="hljs-string">&quot;b2&quot;</span>]<br>    <span class="hljs-keyword">return</span> softmax(a2)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>predict()</code>는 <code>params</code>에 있는 초기값 가중치와 편향을 사용하여 계산한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> cross_entropy_error(y,t)<br>    delta = <span class="hljs-number">1e-7</span><br>    batch_size = length(y[:,<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> (-sum(log.(y.+delta).*t) / batch_size)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> loss(x, t)<br>    y = predict(x)<br>    <span class="hljs-keyword">return</span> cross_entropy_error(y, t)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>loss()</code>는 예측값을 계산하고 손실 함수의 결과까지 도출해주는 함수이며, 손실 함수로는 '교차 엔트로피 오차'를 사용하였다. <code>cross_entropy_error()</code>은 배치데이터 손실함수 값의 평균을 제공할 수 있도록 수정하였다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    f는 손실함수, x는 입력값, t는 정답, w는 대상</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">function</span> numerical_gradient(f, x, t, w)<br>    h=<span class="hljs-number">10</span>^-<span class="hljs-number">4</span><br>    vec=zeros(<span class="hljs-built_in">Float64</span>,size(w))<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>:length(w))<br>        origin=w[i]<br>        w[i]+=h<br>        fx1=f(x,t)<br>        w[i]-=<span class="hljs-number">2</span>*h<br>        fx2=f(x,t)<br>        vec[i]=(fx1-fx2)/<span class="hljs-number">2</span>h<br>        w[i]=origin<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span>  vec<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>기존의 <code>numerical_gradient()</code>는 매개 변수로 <code>f()</code>와 미분 대상인 <code>x</code>값만 받았다. 하지만 우리가 적용하려는 <code>loss()</code>는 매개 변수가 <code>x, t</code>로 2개가 들어가기 때문에 이 또한 <code>numerical_gradient()</code>의 매개 변수로 추가하였다. 그 다음 <code>loss()</code>에서 편미분되는 변수가 가중치와 편향이기 때문에 이 또한 매개 변수로 추가하였다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> TwoLayerNet_numerical_gradient(f, x, t)<br>    grads[<span class="hljs-string">&quot;W1&quot;</span>] = numerical_gradient(f, x, t,params[<span class="hljs-string">&quot;W1&quot;</span>])<br>    grads[<span class="hljs-string">&quot;W2&quot;</span>] = numerical_gradient(f, x, t,params[<span class="hljs-string">&quot;W2&quot;</span>])<br>    grads[<span class="hljs-string">&quot;b1&quot;</span>] = numerical_gradient(f, x, t,params[<span class="hljs-string">&quot;b1&quot;</span>])<br>    grads[<span class="hljs-string">&quot;b2&quot;</span>] = numerical_gradient(f, x, t,params[<span class="hljs-string">&quot;b2&quot;</span>])<br>    <span class="hljs-keyword">return</span>(grads)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 <code>TwoLayerNet_numerical_gradient()</code>는 가중치와 편향을 모두 편미분하여 <code>grads</code>에 값을 저장한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> SGD(params,grads)<br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> keys(params)<br>        params[key] -= learning_rate * grads[key]<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> params<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>SGD()</code>는 '확률적 경사하강법'으로 기존 가중치와 편향에서 '학습률 <span class="math inline">\(\times\)</span> 편미분값'을 빼서 갱신한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> evaluate(test_x,test_y)<br>    temp = (sum((argmax.(eachrow(predict(test_x))).-<span class="hljs-number">1</span>) .== test_y)/size(test_x)[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> (temp * <span class="hljs-number">100</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>마지막으로 정의할 함수 <code>evaluate()</code>는 정확도를 계산한다. 정확도란 실제 실험데이터들을 사용하여 해당 신경망 모델이 얼마나 맞추는지를 확률로 반환한다. 이후 신경망을 직접 학습시키고 정확도를 확인할 것이다.</p><p>이제 학습을 진행하기 전에 배치 사이즈와 학습률, 반복 횟수를 지정한다. 보통 학습률은 0.01이나 0.1을 사용한다. 또한 배치 사이즈는 입력 데이터의 형태에 따라 최적화된 크기가 다르지만 이번에는 임의로 배치사이즈를 100으로 지정할 것이다. 그리고 반복 횟수는 100개의 배치데이터 기준으로 1에폭(epoch)인 600을 지정하였다. 에폭이라는 기준에 대해 자세히 알고 싶다면 아래 Note를 확인해보자.</p><p><strong>Note</strong> 에폭이란? 에폭(epoch)은 훈련데이터 전체의 개수를 의미한다. MNIST 데이터를 예시로 본다면 훈련데이터는 60000개이다. 배치 사이즈가 100인 경우 한번에 100개의 훈련데이터가 사용되므로 모델에 1에폭을 훈련시키려면 600번을 반복해야 한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">train_size = size(train_x)[<span class="hljs-number">1</span>]<br>batch_size = <span class="hljs-number">100</span><br>learning_rate = <span class="hljs-number">0.1</span><br>iters_num = <span class="hljs-number">600</span><br></code></pre></td></tr></table></figure><p>이제 모든 준비가 완료되었다. 아래의 코드를 입력하여 학습을 실행해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-meta">@time</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:iters_num<br>        batch_mask = rand(<span class="hljs-number">1</span>:train_size, <span class="hljs-number">100</span>)<br>        x_batch = train_x[batch_mask, :]<br>        t_batch = t[batch_mask, :]<br><br>        <span class="hljs-comment"># 편미분값 구하기</span><br>        TwoLayerNet_numerical_gradient(loss, x_batch, t_batch)<br><br>        <span class="hljs-comment"># 확률적 경사하강법</span><br>        SGD(params, grads)<br><br>        temp_loss = loss(x_batch, t_batch)<br>        print(<span class="hljs-string">&quot;NO.<span class="hljs-variable">$i</span>: &quot;</span>)<br>        println(temp_loss)<br>        append!(train_loss_list, temp_loss)<br>        append!(accuracy, evaluate(test_x, test_y))<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 코드는 순전파 기반 경사하강법을 구현한 것이다. 프로세스는 다음과 같다.</p><ul><li><p>먼저 입력 데이터 60000개 중에 100개를 무작위로 뽑아서 배치 데이터셋을 생성한다.</p></li><li><p>그 다음 가중치와 편향을 편미분한다.(순전파) <code>grads</code>에 가중치와 편향의 편미분 값들을 저장한다.</p></li><li><p>기존 신경망인 <code>params</code>의 가중치와 편향에서 '학습률 <span class="math inline">\(\times\)</span> 편미분값'을 빼서 갱신한다. (SGD)</p></li><li><p>갱신한 가중치와 편향으로 다시 손실 함수의 값을 구한 후 <code>train_loss_list</code>에 추가한다.</p></li><li><p>해당 모델을 사용하여 실제 실험데이터를 얼마나 맞추는지 확률을 계산하고, <code>accuracy</code>에 추가한다.</p></li><li><p><code>iters_num</code>만큼 위의 프로세스를 반복한다.</p></li></ul><p>편미분을 진행하는 파트에서 순전파는 역전파보다 시간이 매우 많이 소요된다. 따라서 비교적 시간이 여유로울 때 코드를 진행하기를 추천한다.</p><p>위의 학습 결과는 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Julia">NO<span class="hljs-number">.1</span>: <span class="hljs-number">2.292942018493531</span><br>NO<span class="hljs-number">.2</span>: <span class="hljs-number">2.288184723441353</span><br>NO<span class="hljs-number">.3</span>: <span class="hljs-number">2.2987287770939293</span><br>NO<span class="hljs-number">.4</span>: <span class="hljs-number">2.3000466383158993</span><br>NO<span class="hljs-number">.5</span>: <span class="hljs-number">2.2887273179016963</span><br>NO<span class="hljs-number">.6</span>: <span class="hljs-number">2.2926579888410235</span><br>NO<span class="hljs-number">.7</span>: <span class="hljs-number">2.29624786295159</span><br>NO<span class="hljs-number">.8</span>: <span class="hljs-number">2.2953948065780376</span><br>NO<span class="hljs-number">.9</span>: <span class="hljs-number">2.2990271264453774</span><br>NO<span class="hljs-number">.10</span>: <span class="hljs-number">2.2735668193617418</span><br>.<br>.<br>.<br>NO<span class="hljs-number">.590</span>: <span class="hljs-number">0.9584272233933265</span><br>NO<span class="hljs-number">.591</span>: <span class="hljs-number">0.8445645939069023</span><br>NO<span class="hljs-number">.592</span>: <span class="hljs-number">0.9125098806007815</span><br>NO<span class="hljs-number">.593</span>: <span class="hljs-number">0.8713494631790804</span><br>NO<span class="hljs-number">.594</span>: <span class="hljs-number">0.8839853719315479</span><br>NO<span class="hljs-number">.595</span>: <span class="hljs-number">0.88424914270352</span><br>NO<span class="hljs-number">.596</span>: <span class="hljs-number">0.8817506678094389</span><br>NO<span class="hljs-number">.597</span>: <span class="hljs-number">0.9543049814512449</span><br>NO<span class="hljs-number">.598</span>: <span class="hljs-number">0.867151437734806</span><br>NO<span class="hljs-number">.599</span>: <span class="hljs-number">0.9474920771844572</span><br>NO<span class="hljs-number">.600</span>: <span class="hljs-number">0.8690392628614342</span><br><span class="hljs-number">17654.229691</span> seconds (<span class="hljs-number">20.70</span> G allocations: <span class="hljs-number">9.067</span> TiB, <span class="hljs-number">6.94</span>% gc time)<br></code></pre></td></tr></table></figure><p>100 단위의 배치 데이터를 600번 반복한 결과, 처음 2.29였던 손실 함수 값이 0.86까지 떨어졌다. 이는 오답률이 많이 감소되었다는 것을 의미한다. 시간은 대략 17600초가 걸렸으며, 환산해보면 약 5시간 정도 소요되었다.</p><p>위의 학습 과정에서 저장했던 <code>train_loss_list</code>와 <code>accuracy</code>를 그래프로 나타내보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">using</span> Plots<br>x = range(<span class="hljs-number">1</span>,length(train_loss_list),step=<span class="hljs-number">1</span>)<br>y = train_loss_list<br></code></pre></td></tr></table></figure><figure><img src="/images/41.png" alt="손실 함수 그래프" /><figcaption aria-hidden="true">손실 함수 그래프</figcaption></figure><p>저장된 손실 함수 값을 그래프로 그려본 결과, 지속적으로 감소하는 양상을 확인할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">x = range(<span class="hljs-number">1</span>,length(accuracy),step=<span class="hljs-number">1</span>)<br>y = accuracy<br><br>plot(x,y)<br></code></pre></td></tr></table></figure><figure><img src="/images/42.png" alt="정확도 그래프" /><figcaption aria-hidden="true">정확도 그래프</figcaption></figure><p>저장된 정확도 또한 계속 상승하는 것을 볼 수 있다. 가장 높은 정확도는 아래의 코드를 통해 확인하자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">argmax(accuracy)   <span class="hljs-comment"># 최대값 인덱스 반환</span><br><span class="hljs-number">598</span><br>accuracy[<span class="hljs-number">598</span>]<br><span class="hljs-number">80.15</span><br></code></pre></td></tr></table></figure><p>정확도는 80%를 웃돈다. 여기서 추가로 더 학습하면 정확도는 90%도 넘을 수 있다.</p><p>위의 코드를 돌려보면 알겠지만 순전파는 매우 느리다. 아마 1에폭을 돌리면 더이상 학습을 진행하고 싶지 않을 것이다. 하지만 학습을 더 진행하고 싶진 않지만 90%가 넘는지 확인하고 싶은 이들을 위해 순전파로 3에폭을 돌려보았다. 결과는 다음과 같다.</p><figure><img src="/images/46.png" alt="손실 함수 그래프" /><figcaption aria-hidden="true">손실 함수 그래프</figcaption></figure><p>손실 함수 그래프이다. 손실 함수의 값이 0.5 아래로 떨어진 것을 확인할 수 있다.</p><figure><img src="/images/45.png" alt="정확도 그래프" /><figcaption aria-hidden="true">정확도 그래프</figcaption></figure><p>정확도는 80%를 훨씬 넘었다. 가장 높은 정확도를 확인하기 위해 아래의 코드를 입력해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">argmax(accuracy)   <span class="hljs-comment"># 최대값 인덱스 반환</span><br><span class="hljs-number">1709</span><br>accuracy[<span class="hljs-number">1709</span>]<br><span class="hljs-number">90.16999999999999</span><br></code></pre></td></tr></table></figure><p>정확도가 90%가 넘은 것을 확인할 수 있다.</p><p>순전파는 반복되는 매 횟수마다 활성화 함수를 미분하기 때문에 시간이 오래 걸린다. 그렇기에 실상 사용되는 미분법은 아니지만, 신경망의 원리를 파악하기 위해서는 알아야 한다. 다음 글에서는 5시간을 3분으로 줄여주는 마법같은 역전파를 살펴볼 것이다.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>deep learning in julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>딥러닝</tag>
      
      <tag>Deeplearning</tag>
      
      <tag>머신러닝</tag>
      
      <tag>줄리아</tag>
      
      <tag>신경망</tag>
      
      <tag>순전파</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[6/18] 인공신경망 구현: 모델 학습</title>
    <link href="/ko/DeeplearningJulia/Deeplearning-6/"/>
    <url>/ko/DeeplearningJulia/Deeplearning-6/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다. <span id="more"></span></p><hr /><p>이전 글에서는 신경망이 작동하는 과정을 수학식을 사용하여 살펴보았다. 신경망은 입력값에 가중치를 곱하고 편향을 더한 후 활성화 함수를 거쳐 예측값을 도출한다. 즉, 가중치와 편향은 입력값에서 올바른 예측값을 제공하는데 중요한 변수라는 것이다. 그렇다면 해당 입력 데이터에 알맞는 가중치와 편향은 어떻게 찾을까? 이번 글에서는 가중치와 편향이 가지는 의미는 정확히 무엇이며, 적절한 가중치와 편향을 찾는 방법은 무엇인지를 살펴볼 것이다.</p><h2 id="적절한-가중치와-편향">적절한 가중치와 편향</h2><p>실제 신경망은 우리가 태어난 이후 경험한 데이터를 바탕으로 신경세포 안에 적절한 가중치와 편향을 셋팅한다. 그에 따라 입력값을 받으면 세포체에서 변환되어 신호를 다른 신경세포로 전달할지를 결정한다. 하지만 우리가 만든 인공신경망은 적절한 가중치와 편향이 존재하지 않는다. 그렇기에 인공신경망 모델을 구성할 때 가중치와 편향의 초기값을 랜덤으로 설정한다. 물론 그 랜덤 값은 대부분 적절한 가중치와 편향은 아니다. 결국 우리는 '인간'이 학습하는 것처럼 인공신경망도 학습해야 한다. <strong>즉, 인공신경망은 매개 변수인 가중치와 편향의 적절한 값을 찾기 위해 학습해야 한다.</strong></p><h2 id="인공신경망-학습이란">인공신경망 학습이란</h2><p>처음 만들어진 인공신경망은 매개 변수인 가중치와 편향을 랜덤으로 설정했기 때문에 엉망이다. 즉, 바보와 같아서 예측을 제대로 하지 못한다. 따라서 적절한 가중치와 편향을 찾아주어야 한다. 이 과정을 신경망 학습이라고 한다. 신경망 학습은 학습데이터를 기반으로 진행된다. 학습데이터에는 입력값과 정답이 있다. 입력값을 투입했을 때, 가중치와 편향을 계산한 후 나온 예측값을 정답과 비교하여 신경망의 오류 정도를 파악한다. 지금까지 배웠던 블럭들을 조합해보면 다음과 같다.</p><ul><li><p>활성화 함수: 가중치와 편향을 추가한 입력값을 받아 신호를 전달할지 결정한다.</p></li><li><p>손실 함수: 예측값과 정답의 오차를 나타낸다.</p></li><li><p>편미분: 가중치와 편향을 기준으로 각각의 순간변화량(기울기)을 측정한다.</p></li><li><p>경사하강법: 신경망 모델을 학습시키는 알고리즘으로서 가중치와 편향 갱신을 반복하는 과정을 거쳐 적절한 가중치와 편향을 찾는다.</p></li></ul><h2 id="인공신경망-학습-과정">인공신경망 학습 과정</h2><p>인공신경망은 네트워크 그래프의 형식을 취한다. 네트워크 그래프란 요소인 노드(node)와 노드들의 관계를 나타내는 엣지(edge)로 구성하여 만든 그래프이다. 여기서 노드는 변화하는 주체를 의미하며, 엣지는 그 변화의 정도를 나타낸다. 인공신경망을 네트워크 그래프 관점에서 설명한다면 입력데이터와 은닉층의 중간값, 출력값은 모두 노드이며 데이터에 변화를 야기하는 가중치와 편향은 엣지이다. 네트워크 그래프로 도식화한 신경망은 아래와 같다.</p><figure><img src="/images/31.png" alt="신경망 구조" /><figcaption aria-hidden="true">신경망 구조</figcaption></figure><p>결국 우리가 학습을 통해 찾아야 하는 것은 엣지(edge)인 가중치와 편향의 값인 것을 확인할 수 있다. 지금부터 진행되는 학습 과정에 대한 설명은 경사하강법을 기반으로 한다.</p><p>학습 과정을 세분화하여 설명하기 위해 위의 인공신경망 도식을 바탕으로 설명하고자 한다. 먼저 위의 인공신경망은 2층 구조이며, 입력값은 <span class="math inline">\([x_1, x_2, x_3, x_4]\)</span>로 총 4개이다. 또한 은닉층 <span class="math inline">\([h_1, h_2]\)</span>을 거쳐 예측값 <span class="math inline">\([y_1, y_2, y_3]\)</span>을 출력한다.</p><ol type="1"><li>인공신경망 매개 변수 셋팅</li></ol><p>위의 도식만 설정되면 가중치와 편향의 크기는 자동으로 결정된다. 먼저 입력층에서 은닉층으로 가는 1층 구간의 W1은 <span class="math inline">\(1 \times 4\)</span>행렬인 입력값과 곱해서 <span class="math inline">\(1 \times 2\)</span>행렬이 결과로 나와야 하기에 <span class="math inline">\(4 \times 2\)</span>의 행렬이며, 편향은 <span class="math inline">\(1 \times 2\)</span> 행렬이다. 은닉층과 출력층 사이의 2층 구간 W2 또한 이와 같은 원리로 자동 설정된다.</p><p><span class="math display">\[ X(1 \times 4) \cdot W1(4 \times 2) + B(1 \times 2) = H(1 \times 2)\]</span></p><ol start="2" type="1"><li>인공신경망 계산</li></ol><p>위 식의 결과를 활성화 값이라고 한다. 이 값을 활성화 함수의 입력값으로 투입하여 다음 층으로의 전달 여부를 결정한다. 위의 계산들을 층(layer)이라고 표현한다. 도식에 나타난 신경망 구조는 층 단위 계산이 2번 반복되기에 2층 신경망인 것이다. 이런 층 단위 계산을 반복할수록 더 깊은 신경망을 구축할 수 있다.</p><ol start="3" type="1"><li>손실 함수 값 계산</li></ol><p>위의 신겸망 계산을 가중치와 편향을 갱신하면서 반복하여 손실 함수 값을 줄인다. 손실 함수는 예측값 <span class="math inline">\(\hat{y}\)</span>와 정답 <span class="math inline">\(t\)</span>의 오차를 계산한다. 보통 평균 제곱 오차와 교차 엔트로피 오차를 이용한다.</p><ol start="4" type="1"><li>매개 변수의 편미분 구하기</li></ol><p>그렇다면 손실 함수의 값을 어떻게 줄이는가? 이때 사용되는 것이 편미분이다. 편미분은 분자의 <span class="math inline">\(f(x)\)</span>를 분모의 변수를 기준으로 미분한 것이며, 함수 <span class="math inline">\(f(x)\)</span>에서 변수가 순간적으로 얼마나 변하는가를 나타낸다. 즉, 기울기를 나타내는 것이다. 편미분 값을 통해서 가중치와 편향이 어느 방향으로 변해야 하는지를 파악할 수 있다. 이 파트에서 순전파나 역전파 알고리즘을 사용한다.</p><ol start="5" type="1"><li>편미분 값에 학습률 곱하여 매개 변수 갱신</li></ol><p>편미분 값을 저장한 후 학습률을 곱해준다. 학습률은 기존 가중치에 얼만큼 영향을 줄 것인가를 나타낸다. 학습률은 보통 0.1이나 0.01을 사용한다. 학습률이 너무 크면 학습폭이 커서 최솟값을 못찾을 수도 있다. 즉, 신경망이 도착지까지 가는데 너무 큰 걸음으로 걷는 것이다. 멀리 있을 때는 좋을 수 있지만 가까워지면 도착지에 딱 맞게 가는 것은 어려워진다. 학습률을 곱한 편미분 값을 기존 가중치와 편향에서 뺀 후, 그 결과를 다시 가중치와 편향으로 갱신한다.</p><ol start="6" type="1"><li>손실 함수 값 계산</li></ol><p>갱신된 가중치와 편향을 가지고 손실 함수를 다시 계산한 후, 나온 결과를 바탕으로 모델의 성능이 더 좋아졌는지 판단할 수 있다. 손실 함수 값이 이전의 결과보다 0에 가까워졌다면 학습이 잘 되고 있다고 평가할 수 있다.</p><ol start="7" type="1"><li>4 ~ 6 지정된 횟수만큼 반복하기</li></ol><p>위의 과정을 반복하면 손실 함수 값은 0에 가까워지고 인공신경망의 예측 정확도가 올라간다. 보통 사용하는 학습 알고리즘마다 적절한 횟수는 다르지만 '에폭(epoch)'을 기준으로 삼는다. 에폭은 학습데이터의 갯수를 나타낸다. 만약 사용하는 학습 입력데이터가 500개라면 해당 신경망의 1에폭은 500번이다. 만약 한번 학습을 시킬 때 10개 단위의 배치데이터를 사용한다면 1에폭의 수는 50번이 된다.</p><ol start="8" type="1"><li>학습된 모델의 정확도 확인하기</li></ol><p>정확도는 학습된 모델이 실제 데이터를 얼만큼 맞추는가로 평가된다. 학습된 인공신경망은 97%~98%의 정확도까지도 보인다.</p><h2 id="결론">결론</h2><p>지금까지 인공신경망이 어떻게 학습되는지 그 과정을 살펴보았다. 신경망 학습은 인공신경망 구현에 있어 매우 중요한 부분이다. 신경망이 어떤 방식으로 학습되는지에 따라서 성능이 제각각이기 때문이다. 학습에 있어 다양한 기술적인 튜닝이 있지만 핵심 원리는 이 글을 벗어나지 않는다. 다음 글에서 순전파 알고리즘 기반의 경사하강법을 구현해보고, 이후 역전파에 대해서 살펴볼 것이다.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>deep learning in julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>딥러닝</tag>
      
      <tag>Deeplearning</tag>
      
      <tag>머신러닝</tag>
      
      <tag>줄리아</tag>
      
      <tag>가중치</tag>
      
      <tag>네트워크</tag>
      
      <tag>편향</tag>
      
      <tag>딥러닝학습</tag>
      
      <tag>학습</tag>
      
      <tag>신경망모델</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[5/18] 인공신경망 구현: 수학식 풀이</title>
    <link href="/ko/DeeplearningJulia/Deeplearning-5/"/>
    <url>/ko/DeeplearningJulia/Deeplearning-5/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다. <span id="more"></span></p><hr /><h2 id="인공신경망이란">인공신경망이란</h2><p><span class="math display">\[Layer=(X*W)+B\]</span></p><p>위 수식은 각 층을 계산하는 식이며, 입력 데이터의 값들인 배열 <span class="math inline">\(X\)</span>에 가중치 <span class="math inline">\(W\)</span>를 곱한 후 편향 <span class="math inline">\(B\)</span>를 더한다. 이 식은 신경망이 작동하는 방식에서 가져온 알고리즘이다. 생물학에서의 신경망은 수많은 뉴런(신경 세포)이 연결되어 있으며, 이들은 전기 신호를 전달한다. 각각의 뉴런들은 수상돌기를 통해 들어오는 전기 신호를 받고 세포체에서 종합한 후 축삭돌기를 통해 전기 신호를 다른 뉴런으로 내보낸다. 이때 축삭돌기 끝 부분인 시냅스에서 전기 신호에 따라 신경전달물질을 분비하여 다른 뉴런의 시냅스로 전달하는데 이런 과정을 신경이라고 부르는 것이다.</p><figure><img src="/images/36.png" alt="신경 세포 구조" /><figcaption aria-hidden="true">신경 세포 구조</figcaption></figure><p>그렇다면 뉴런들은 왜 전기 신호들을 전달하는 것일까? 이유는 간단하다. 우리 몸에서 필요한 생활 기능들을 '적절'하게 조절하기 위해서이다. 뉴런은 수상돌기에서 전기 신호를 생산하라는 흥분성 신호와 전기 신호를 생산하지 말라는 억제성 신호를 받아들인다. 그후 세포체에서 이를 종합하여 다른 뉴런으로 해당 전기 신호를 보낼지 말지 결정한다. 이런 뉴런의 원리를 바탕으로 살펴봤을 때 가중치를 곱하는 것은 뉴런에서 각각의 고유한 흥분성과 억제성 신호를 받아들이는 과정을 표현했다고 볼 수 있다. 물론 실제 생물학에서의 뉴런은 세포체에서 전기 신호를 보내거나(1), 보내지 않거나(0)라는 계단 함수의 개념으로 작동한다는 차이점이 있지만, 가중치의 원리는 동일하다. 또한 편향은 뉴런이 가지고 있는 '임계값'을 표현한 것이다. 세포체는 받은 전기 신호가 어느 임계값 이상이 되어야 전기 신호를 내보내는 데, 이를 나타낸 것이다.</p><p>따라서 인공신경망의 원리를 한번에 설명한다면, 입력 신호에 가중치를 곱하면서 적절한 전기 신호로 변환하여 받은 후, 편향(임계값)이 넘으면 전기 신호를 출력한다고 정리된다. 2층으로 구성된 인공신경망 계산 과정을 도식화하면 다음과 같다.</p><figure><img src="/images/37.png" alt="인공신경망 계산 과정" /><figcaption aria-hidden="true">인공신경망 계산 과정</figcaption></figure><h2 id="인공신경망-수학식-풀이">인공신경망 수학식 풀이</h2><p>인공신경망을 코드로 구현하기에 앞서 수학식으로 풀이해보려고 한다. 이 과정이 필요한 이유는 컴퓨터가 신경망 모델을 어떻게 진행하는지 명확히 파악하고, 이해해야 하기 때문이다. 따라서 위의 인공신경망 도식을 수식으로 풀이해보자. (참고로 위의 인공신경망 도식은 2층 신경망이다.)</p><p><span class="math display">\[X:\begin{bmatrix} x_1 &amp; x_2 \\ \end{bmatrix}\quadW_1:\begin{bmatrix} w1_{11} &amp; w1_{12} \\ w1_{21} &amp; w1_{22} \\ \end{bmatrix}\quadW_2:\begin{bmatrix} w2_{11} &amp; w2_{12} &amp; w2_{13}\\ w2_{21} &amp; w2_{22} &amp; w2_{23}\\ \end{bmatrix}\]</span> <span class="math display">\[B_1:\begin{bmatrix}b1_1 &amp; b1_2 \end{bmatrix}\quad B_2:\begin{bmatrix} b2_1 &amp; b2_2 &amp; b2_3 \end{bmatrix}\]</span></p><p>먼저 입력값인 <span class="math inline">\(X\)</span>와 가중치 <span class="math inline">\(W_1, W_2\)</span>, 편향 <span class="math inline">\(b_1, b_2\)</span>를 설정한다. 예시이기 때문에 입력층, 은닉층, 출력층의 노드 개수를 임의로 설정하였다. (실제로는 훨씬 많은 노드들이 사용된다.)</p><p><span class="math display">\[Z1 = XW_1+B_1\]</span> <span class="math display">\[Z1=\begin{bmatrix} x_1 &amp; x_2 \\ \end{bmatrix}\times\begin{bmatrix} w1_{11} &amp; w1_{12} \\ w1_{21} &amp; w1_{22} \\ \end{bmatrix}+\begin{bmatrix}b1_1 &amp; b1_2 \end{bmatrix}\\\]</span></p><p><span class="math display">\[=\begin{bmatrix}x_1w1_{11}+x_2w1_{21}+b1_1 &amp; x_1w1_{12}+x_2w1_{22}+b1_2\end{bmatrix}\]</span></p><p>먼저 입력값에 첫 번째 가중치인 <span class="math inline">\(W_1\)</span>을 곱하고 첫 번째 편향인 <span class="math inline">\(B_1\)</span> 더한다. 입력값과 가중치, 편향 모두 배열이기에 이 계산은 배열 단위로 이루어진다. 즉, 행렬곱과 행렬덧셈이 사용되는 것이다. 이 과정은 입력값이 첫 번째 활성화 함수 <span class="math inline">\(h(x)\)</span>로 넘어가기 전에 이루어진다.</p><p><span class="math display">\[A1 = \cfrac{1}{1+e^{-Z1}}\]</span> <span class="math display">\[A1 =\begin{bmatrix}\cfrac{1}{1+e^{-Z1_1}} &amp; \cfrac{1}{1+e^{-Z1_2}}\end{bmatrix}\]</span></p><p>그 다음, 위의 <span class="math inline">\(Z_1\)</span>을 활성화 함수에 대입하면 된다. 여기서 <span class="math inline">\(Z_1\)</span>은 행렬인데 위의 수식을 <span class="math inline">\(Z_1\)</span>의 요소에 각각 적용한다. 참고로 위 식에서 사용된 활성화 함수는 시그모이드 함수이다. 이 과정은 입력값이 첫 번째 은닉층에 도착한 것이다.</p><p><span class="math display">\[Z2 = A1 \times W_2+b_2\]</span> <span class="math display">\[ =\begin{bmatrix}\frac{w2_{11}}{1+e^{-Z1_1}}+\frac{w2_{21}}{1+e^{-Z1_2}}+b2_1 &amp; \frac{w2_{12}}{1+e^{-Z1_1}}+\frac{w2_{22}}{1+e^{-Z1_2}}+b2_2 &amp; \frac{w2_{13}}{1+e^{-Z1_1}}+\frac{w2_{23}}{1+e^{-Z1_2}}+b2_3\end{bmatrix}\]</span></p><p><span class="math inline">\(A1\)</span>의 값은 행렬로 반환된다. <span class="math inline">\(A1\)</span>을 다시 두 번째 은닉층으로 보내기 위해 두 번째 가중치인 <span class="math inline">\(W_2\)</span>를 곱하고 두 번째 편향인 <span class="math inline">\(b_2\)</span>를 더한다. 여기서도 행렬곱과 행렬덧셈이 사용된다. 행렬 단위로 계산되는 수식은 <span class="math inline">\(Z1\)</span>과 동일하다.</p><p><span class="math display">\[\hat{y_k}=\cfrac{e^{Z2_k}}{\sum_{i=1}^n e^{Z2_i}}\]</span> <span class="math display">\[\hat{y}=\begin{bmatrix}\cfrac{e^{Z2_1}}{\sum_{i=1}^3 e^{Z2_i}} &amp; \cfrac{e^{Z2_2}}{\sum_{i=1}^3 e^{Z2_i}} &amp; \cfrac{e^{Z2_3}}{\sum_{i=1}^3 e^{Z2_i}}\end{bmatrix}\]</span></p><p>은닉층 계산 이후 마지막으로 출력층 활성화 함수인 소프트맥스 함수를 적용하여 예측값 <span class="math inline">\(\hat{y}\)</span>을 얻는다.</p><p>위의 식을 토대로 우리는 예측값을 아래와 같은 식로 정의할 수 있다.</p><p><span class="math display">\[\hat{y}=\sigma(h(XW1+B1)\times W2+B2)\]</span></p><p>위의 식을 살펴보면 <span class="math inline">\(Z1\)</span>인 <span class="math inline">\(XW_1+B_1\)</span>을 활성화 함수 <span class="math inline">\(h(x)\)</span>에 대입하고, 활성화 함수의 결과 값을 다시 <span class="math inline">\(Z2\)</span>의 입력값으로 받는다. 그렇게 <span class="math inline">\(Z2\)</span>를 계산한 후 출력층의 활성화 함수인 <span class="math inline">\(\sigma(x)\)</span>에 대입하여 나온 값이 예측값 <span class="math inline">\(\hat{y}\)</span>이다.</p><h2 id="결론">결론</h2><p>아번 글에서는 신경망을 구현하기에 앞서 신경망의 원리를 수학식으로 풀이하였다. 이 과정은 이해를 위함이며, 다음 글에서는 손글씨 인식하는 신경망을 구현하면서 코드로 작동하는 과정을 살펴볼 것이다.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>deep learning in julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>딥러닝</tag>
      
      <tag>Deeplearning</tag>
      
      <tag>머신러닝</tag>
      
      <tag>줄리아</tag>
      
      <tag>신경망</tag>
      
      <tag>순전파</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[4/18] 경사하강법</title>
    <link href="/ko/DeeplearningJulia/Deeplearning-4/"/>
    <url>/ko/DeeplearningJulia/Deeplearning-4/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다. <span id="more"></span></p><hr /><p>이전 글에서 우리는 손실 함수에 대해서 살펴보았다. 손실 함수는 신경망을 평가하는 판단지표로서 사용되며, 손실 함수의 값을 줄이는 방향으로 신경망을 학습시킨다고 하였다. 다른 말로, 좋은 신경망 모델은 손실 함수 값이 작아야 한다. 그렇다면 이쯤에서 "어떻게 손실 함수의 값을 줄일 수 있을까?"라는 의문이 들 것이다. 이것이 바로 최적화의 문제이다. 이번 글에서는 손실 함수를 최소화하는 경사하강법에 대해서 살펴볼 것이다.</p><h2 id="경사하강법이란">경사하강법이란</h2><p>경사하강법은 신경망 학습에서 손실함수의 값을 최소화하는 가중치와 편향을 찾는 최적화 알고리즘이다. 신경망 모델의 학습 과정을 순서대로 나열하면 다음과 같다.</p><ol type="1"><li>임의의 값을 가진 가중치와 편향을 생성한다.</li><li>신경망 계산을 한다.</li><li>손실 함수로 출력층의 결과인 예측값과 정답을 비교한다.</li><li>예측값과 정답의 격차를 줄이기 위해 가중치와 편향을 조정한다.</li><li>2~4의 과정을 반복하여 손실 함수의 값을 줄인다.</li></ol><p>위의 순서 중에서 경사하강법은 4, 5번 과정을 진행하는 알고리즘이다. 그렇다면 경사하강법의 작동 원리는 무엇인가? 바로 미분이다. 경사하강법은 손실 함수의 미분값(기울기)을 도출하여 가중치와 편향에서 빼주는 방식으로 적절한 가중치와 편향을 찾는다.</p><h2 id="미분">미분</h2><p>최적화된 가중치와 편향을 찾는 방법은 바로 손실 함수 수식의 "기울기"이다. 손실 함수 그래프에서 가장 아래에 있는 점(최솟점)을 찾기 위해서는 임의의 점에서 기울기를 구해 이동할 방향을 잡아야 한다. 그렇다면 기울기를 구하는 방법은 무엇인가? 바로 미분이다.</p><p>미분은 순간변화량을 나타내며, 수식은 다음과 같다.</p><p><span class="math display">\[f&#39;(x)=\frac{df(x)}{dx}=\lim_{h\to0} \frac{f(x+h)-f(x)}{h}\]</span></p><p>위 수식은 <span class="math inline">\(f(x)\)</span>에서 <span class="math inline">\(x\)</span>가 아주 작은 값인 <span class="math inline">\(h\)</span>만큼 이동했을 때의 변화량을 구하는 식이며, 이는 <span class="math inline">\(x\)</span>의 이동이 <span class="math inline">\(f(x)\)</span>를 얼마나 변화시키는지를 나타낸다.</p><p>하지만 위의 식을 컴퓨터에서 구현하는 것은 반올림오차 문제때문에 기술적으로 어렵다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; h = <span class="hljs-number">1e-50</span><br>Julia&gt; x = <span class="hljs-number">3</span><br>Julia&gt; f(x) = x^<span class="hljs-number">2</span><br>Julia&gt; (f(x+h) - f(x)) / h<br><span class="hljs-number">0.0</span><br></code></pre></td></tr></table></figure><p>수학적 원리로는 아주 미세한 값의 차이가 나지만, 컴퓨터는 이를 0으로 처리해버린다. 이런 문제로 보통 <span class="math inline">\(h\)</span>의 값을 <span class="math inline">\(10^{-4}\)</span>로 사용한다. 또한 위의 코드는 <span class="math inline">\((x+h)\)</span>와 <span class="math inline">\(x\)</span>사이의 기울기이기에 약간의 오차가 발생한다. 이런 오차를 줄이기 위해서 사용하는 방식이 <strong>중앙 차분</strong>이다.</p><p><span class="math display">\[f&#39;(x)=\frac{dy}{dx}=\lim_{h\to0} \frac{f(x+h)-f(x-h)}{2h}\]</span></p><p>중앙 차분이란 <span class="math inline">\(f(x+h)\)</span>에서 <span class="math inline">\(f(x-h)\)</span>의 값을 뺀 후 <span class="math inline">\(2h\)</span>로 나누는데, 이는 <span class="math inline">\((x+h)\)</span>와 <span class="math inline">\((x-h)\)</span> 사이의 기울기를 구함으로써 보다 정확한 값을 얻을 수 있다. 아래의 코드는 기존의 미분 공식과 중앙차분을 적용한 값의 비교이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; (f(x+h) - f(x))/ h<br><span class="hljs-number">6.000100000012053</span><br>Julia&gt; (f(x+h) - f(x-h))/ <span class="hljs-number">2</span>h<br><span class="hljs-number">6.000000000012661</span><br></code></pre></td></tr></table></figure><p><span class="math inline">\(f(x)=x^2\)</span>이기 때문에 이를 미분하면 <span class="math inline">\(f&#39;(x)=2x\)</span>이다. 즉, <span class="math inline">\(x\)</span>가 3일 때 <span class="math inline">\(f&#39;(x)\)</span>는 6인 것이다. 이를 바탕으로 위의 코드를 보면 약간의 차이로 중앙 차분이 적용된 미분 공식이 6에 가까운 것을 확인할 수 있다.</p><p>위의 미분 공식으로 코드로 구현하면 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> derivative(f,x)<br>    h = <span class="hljs-number">10</span>^-<span class="hljs-number">4</span><br>    <span class="hljs-keyword">return</span> (f(x+h)-f(x-h)) / <span class="hljs-number">2</span>h<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="편미분">편미분</h2><p>미분 파트에서는 <span class="math inline">\(f(x)=x^2\)</span>과 같은 변수가 1개인 경우만을 살펴보았다. 하지만 대부분의 손실 함수들은 신경망 디자인에 따라서 변수의 개수가 변동하는 다변수 함수이다. 따라서 실제 사용되는 손실 함수들을 미분해야 하며, 그 방법을 편미분이라고 한다.</p><p>편미분이란 변수가 2개 이상인 수식에서 각각의 변수들을 기준으로 미분하는 것을 말한다. 다음 식을 편미분해보자.</p><p><span class="math display">\[f(x,y)=x^2+2xy+y^2\]</span></p><p>위 식에서 편미분 <span class="math inline">\(\frac{\partial f}{\partial x}\)</span> 와 <span class="math inline">\(\frac{\partial f}{\partial y}\)</span>를 수식으로 나타내면 아래와 같다.</p><p><span class="math inline">\(\frac{\partial f}{\partial x} = 2x+2y\)</span></p><p><span class="math inline">\(\frac{\partial f}{\partial y} = 2y+2x\)</span></p><p>편미분은 각각의 변수를 기준으로 하여 나머지 변수는 상수화하여 미분을 진행하면 된다. 위에서 편미분 <span class="math inline">\(\frac{\partial f}{\partial x}\)</span>은 <span class="math inline">\(x\)</span>만을 변수로 하고 <span class="math inline">\(y\)</span>를 상수화 하였으며, 편미분 <span class="math inline">\(\frac{\partial f}{\partial y}\)</span>은 <span class="math inline">\(y\)</span>만을 변수로 하여 <span class="math inline">\(x\)</span>을 상수화하였다.</p><p>위의 수식들을 코드로 구현해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; x = <span class="hljs-number">5</span><br>Julia&gt; y = <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>먼저 필요한 변수들을 임의로 정의한다. 편미분 <span class="math inline">\(\frac{\partial f}{\partial x}\)</span>부터 비교하면 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; f(x) = x^<span class="hljs-number">2</span>+<span class="hljs-number">2</span>*x*y+y^<span class="hljs-number">2</span><br>Julia&gt; derivative(f,x)       <span class="hljs-comment"># 미분 함수 사용</span><br><span class="hljs-number">25.999999999868347</span><br>Julia&gt; <span class="hljs-number">2</span>*x + <span class="hljs-number">2</span>*y               <span class="hljs-comment"># 편미분 수식 직접 입력</span><br><span class="hljs-number">26</span><br></code></pre></td></tr></table></figure><p>코드 결과에서 두 개의 미분 값이 거의 유사함을 확인할 수 있다. 다음으로 편향을 기준으로 하는 편미분 <span class="math inline">\(\frac{\partial f}{\partial y}\)</span>도 확인해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; f(y) = x^<span class="hljs-number">2</span>+<span class="hljs-number">2</span>*x*y+y^<span class="hljs-number">2</span><br>Julia&gt; derivative(f,y)      <span class="hljs-comment"># 미분 함수 사용</span><br><span class="hljs-number">25.999999999868347</span><br>Julia&gt; <span class="hljs-number">2</span>*y + <span class="hljs-number">2</span>*x        <span class="hljs-comment"># 편미분 수식 직접 입력</span><br><span class="hljs-number">26</span><br></code></pre></td></tr></table></figure><h2 id="기울기">기울기</h2><p>지금까지 우리는 경사하강법에서 사용되는 미분에 대해 알아보았다. 손실 함수는 보통 변수가 2개 이상이기 때문에 편미분을 통해 각각의 변수 값들을 구하며, 이전 파트에서 변수 하나씩의 값을 구하였다. 하지만 실제 신경망에서 작동하는 기울기(미분값)은 한번에 도출되어야 한다. 따라서 다변수 함수를 한번에 미분해주는 코드를 구현하고자 한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> numerical_gradient(f, x)<br>    h = <span class="hljs-number">10</span>^-<span class="hljs-number">4</span><br>    grad = zeros(<span class="hljs-number">1</span>,length(x))<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>:length(x))<br>        origin=x[i]<br>        x[i] += h<br>        fx1 = f(x)<br>        x[i] -= <span class="hljs-number">2</span>*h<br>        fx2 = f(x)<br>        grad[i] = (fx1-fx2)/<span class="hljs-number">2</span>h<br>        x[i] = origin<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span>  grad<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>이제 위의 예시를 다시 사용하여 값이 잘 도출되는지 확인해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; g = [<span class="hljs-number">5.0</span> <span class="hljs-number">8.0</span>]   <span class="hljs-comment"># 다변수</span><br>Julia&gt; f(g) = g[<span class="hljs-number">1</span>]^<span class="hljs-number">2</span>+<span class="hljs-number">2</span>*g[<span class="hljs-number">1</span>]*g[<span class="hljs-number">2</span>]+g[<span class="hljs-number">2</span>]^<span class="hljs-number">2</span> <span class="hljs-comment"># 함수 수식</span><br></code></pre></td></tr></table></figure><p>편미분 파트의 예시와는 다르게 두 개의 변수를 한번에 계산하기 위해 배열화하였다. 또한 함수 수식에서 각 변수들의 기호를 배열 <code>g</code>의 인덱스로 변경하였다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; numerical_gradient(f, g)<br><span class="hljs-number">1</span>×<span class="hljs-number">2</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Int64</span>,<span class="hljs-number">2</span>&#125;:<br><span class="hljs-number">26.0</span>  <span class="hljs-number">26.0</span><br></code></pre></td></tr></table></figure><p>각자 편미분한 값과 같은 결과가 출력된다.</p><h3 id="경사하강법">경사하강법</h3><p>이제 기울기를 통해 변수들을 최적화하는 알고리즘인 경사하강법을 살펴볼 것이다. '경사하강법(gradient_descent)'은 함수의 미분을 통해 얻은 기울기를 사용해 기존 변수 값을 갱신하여 오차를 점점 줄여나가는 알고리즘이다. 먼저 경사하강법의 수식을 살펴보자.</p><p><span class="math display">\[W:=W-\eta \frac{\partial f}{\partial W}\]</span> <span class="math display">\[B:=B-\eta \frac{\partial f}{\partial B}\]</span></p><p>위 식에서 기호 <span class="math inline">\(\eta\)</span>는 학습률을 나타낸다. <strong>학습률(learning rate)</strong>이란 기울기를 어느 정도 반영할 것인가를 나타낸다. 보통 학습률은 미리 정하며, <span class="math inline">\(0.01\)</span>이나 <span class="math inline">\(0.001\)</span> 등을 사용한다. 위의 수식을 한 문장으로 정리한다면 다음과 같다.</p><p>"이전 변수에서 학습률을 곱한 기울기(편미분)를 뺀 결과가 새로운 변수이며, 이를 여러 번 반복하여 오차를 0으로 만드는 적절한 변수를 반한한다."</p><p>경사하강법의 코드는 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> gradient_descent(f,x,lr,step_num)<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:step_num<br>        grad = numerical_gradient(f, x)<br>        x -= grad.*lr<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> x<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위 코드는 매개 변수로 함수 공식인 <code>f</code>, 변수의 초기 값인 <code>x</code>, 학습률인 <code>lr</code>,반복 횟수인 <code>step_num</code>을 받는다. 이제 위에서 사용했던 예시를 가지고 경사하강법을 실행해보자. 신경망 학습에서 경사하강법 결과에 대한 이해는 필수적이기에 이번 예시는 신경망에서의 경사하강법이라고 전제하고 설명할 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; g = [<span class="hljs-number">5.0</span> <span class="hljs-number">8.0</span>]   <span class="hljs-comment"># 다변수 (가중치 또는 편향)</span><br>Julia&gt; f(g) = g[<span class="hljs-number">1</span>]^<span class="hljs-number">2</span>+<span class="hljs-number">2</span>*g[<span class="hljs-number">1</span>]*g[<span class="hljs-number">2</span>]+g[<span class="hljs-number">2</span>]^<span class="hljs-number">2</span> <span class="hljs-comment"># 함수 수식 (손실 함수)</span><br></code></pre></td></tr></table></figure><p>위의 식을 바탕으로 오차를 계산하면 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; f(g)<br><span class="hljs-number">169.0</span><br></code></pre></td></tr></table></figure><p>오차가 <code>169</code>로 도출되었다. 손실 함수의 값이 매우 큰 상태이다. 즉, 아주 좋지 못한 신경망이다. 이제 경사하강법으로 최적화된 가중치와 편향을 찾아보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; gradient_descent(f, g, <span class="hljs-number">0.01</span>, <span class="hljs-number">100</span>)<br><span class="hljs-number">1</span>×<span class="hljs-number">2</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-number">2</span>&#125;:<br>-<span class="hljs-number">1.39034</span>  <span class="hljs-number">1.60966</span><br></code></pre></td></tr></table></figure><p>경사하강법의 결과가 나왔다. 확실히 <span class="math inline">\(5\)</span>과 <span class="math inline">\(8\)</span>보다는 매우 작은 값이 출력되었다. 손실 함수 수식에 해당 결과를 대입함으로써 정말 최적화된 값인지 확인해보고자 한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; g = [-<span class="hljs-number">1.39034</span>  <span class="hljs-number">1.60966</span>]<br><span class="hljs-number">1</span>×<span class="hljs-number">2</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-number">2</span>&#125;:<br> -<span class="hljs-number">1.39034</span>  <span class="hljs-number">1.60966</span><br><br>Julia&gt; f(g)<br><span class="hljs-number">0.0481012623999999</span><br></code></pre></td></tr></table></figure><p>오차값이 거의 0에 도달하였다. 최적화에 성공한 것이다. 신경망은 이런 경사하강법을 통해서 적절한 가중치와 편향을 찾는다. 이제는 신경망을 구현하기 위한 모든 재료들을 살펴보았다. 다음 포스트에서는 지금까지 만들었던 함수들을 바탕으로 신경망을 직접 구현해보자.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>deep learning in julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>딥러닝</tag>
      
      <tag>Deeplearning</tag>
      
      <tag>머신러닝</tag>
      
      <tag>경사하강법</tag>
      
      <tag>미분</tag>
      
      <tag>편미분</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[3/18] 손실 함수</title>
    <link href="/ko/DeeplearningJulia/Deeplearning-3/"/>
    <url>/ko/DeeplearningJulia/Deeplearning-3/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다. <span id="more"></span></p><hr /><h2 id="손실-함수란">손실 함수란</h2><p>신경망을 사용하기 위해서는 그 전에 학습을 통해 올바른 기준을 생성해주어야 한다. 이런 과정을 '신경망 학습'이라고 한다. 신경망 학습에서는 훈련 데이터를 사용하며, 이를 통해 신경망이 실전 문제에서도 적절하게 접근할 수 있도록 하는 가중치를 찾는다. 그렇다면 신경망 학습이 잘 이루어지고 있는지 어떻게 알 수 있을까? 여기서 '손실 함수'가 사용된다. 손실 함수(loss function)는 신경망을 평가하는 평가지표로서 사용되며, 오답률을 나타낸다. 즉, 손실 함수의 값이 0에 가까울수록 좋은 신경망이라는 것이다. 보통 손실 함수는 정답과 신경망이 도출한 출력 값을 비교하여 나타낸다.</p><p>일반적으로 사용하는 손실 함수로는 평균 제곱 오차와 교차 엔트로피 오차가 있다.</p><h3 id="평균-제곱-오차">평균 제곱 오차</h3><p>'평균 제곱 오차(Mean Squared Error, MSE)'는 출력 값에서 정답을 뺀 결과를 제곱하여 더한 값들을 비교한다. 수식은 아래와 같다.</p><p><span class="math display">\[E=\frac{1}{n}\sum_{i=1}^n (y_i-t_i)^2\]</span></p><p>위의 수식에서 <span class="math inline">\(y_i\)</span>는 출력 값, <span class="math inline">\(t_i\)</span>는 정답이며 <span class="math inline">\(n\)</span>은 원소의 개수이다. 출력 값에서 정답을 뺀 오차를 제곱하여 <span class="math inline">\(n\)</span>으로 나눠줌으로써 평균을 손실 함수의 값으로 제공한다.</p><p>위의 수식을 코드로 구현하면 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> mean_squared_error(y,t)<br>    error = (y-t).^<span class="hljs-number">2</span><br>    <span class="hljs-keyword">return</span> sum(error) / length(y)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>좀 더 정확한 이해를 위해 예시를 확인해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; t = [<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>] <span class="hljs-comment"># 정답 레이블</span><br>Julia&gt; y1 = [<span class="hljs-number">0.1</span> <span class="hljs-number">0.05</span> <span class="hljs-number">0.6</span> <span class="hljs-number">0.0</span> <span class="hljs-number">0.05</span> <span class="hljs-number">0.1</span> <span class="hljs-number">0.0</span> <span class="hljs-number">0.1</span> <span class="hljs-number">0.0</span> <span class="hljs-number">0.0</span>] <span class="hljs-comment"># 출력 값 with 정답</span><br>Julia&gt; y2 = [<span class="hljs-number">0.1</span> <span class="hljs-number">0.05</span> <span class="hljs-number">0.1</span> <span class="hljs-number">0.0</span> <span class="hljs-number">0.05</span> <span class="hljs-number">0.1</span> <span class="hljs-number">0.0</span> <span class="hljs-number">0.6</span> <span class="hljs-number">0.0</span> <span class="hljs-number">0.0</span>] <span class="hljs-comment"># 출력 값 with 오답</span><br></code></pre></td></tr></table></figure><p>먼저 정답 배열인 <code>t</code>와 출력 배열인 <code>y1</code>, <code>y2</code>를 세팅해준다. 해당 예시는 예측값이며 <code>y1</code>, <code>y2</code>는 소프트맥스 함수의 결과이다. <code>y1</code>은 정답을 맞춘 출력 값이고, <code>y2</code>는 오답인 출력 값이다. 그렇다면 출력 값 <code>y1</code>, <code>y2</code>을 사용하여 오차 값을 구해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; mean_squared_error(y1,t)<br><span class="hljs-number">0.019500000000000007</span><br><br>Julia&gt; mean_squared_error(y2,t)<br><span class="hljs-number">0.11949999999999998</span><br></code></pre></td></tr></table></figure><p>정답에 높은 확률을 할당한 결과 값 <code>y1</code>은 오차로 <span class="math inline">\(0.0195\)</span>이며, 오답에 높은 확률을 할당한 결과 값 <code>y2</code>는 오차로 <span class="math inline">\(0.1194\)</span>가 나왔다. 즉, <code>y1</code>이 <code>y2</code>보다 더 잘 예측했음을 알 수 있다.</p><h3 id="교차-엔트로피-오차">교차 엔트로피 오차</h3><p>'교차 엔트로피 오차(Cross Entropy Error, CEE)'는 자연로그를 이용한 함수이다. 수식은 아래와 같다.</p><p><span class="math display">\[E=-\sum_{i=1}^n (t_i\times\ln y_i)\]</span></p><p>위의 식은 정답 레이블 <code>t</code>와 출력 값을 곱한다. 여기서 정답 레이블은 오답과 정답을 <code>0</code>과 <code>1</code>로 표현한 것이기 때문에 오답인 경우는 출력 값과 <code>0</code>이 곱해진다. 즉, 정답 위치와 같은 출력 값만 자연로그 값이 제공되며 나머지는 <span class="math inline">\(0\)</span>으로 반환된다. 위의 수식에서는 2가지의 의문이 제기될 수 있다.</p><p>첫 번째 의문은 "하나의 값을 제외한 나머지가 0임에도 불구하고 왜 <span class="math inline">\(\sum\)</span>(시그마)를 사용하는가?"이다. 그 이유는 배열을 하나의 값으로 반환하기 위해서이다. <span class="math inline">\(t_i*\ln y_i\)</span>식을 계산하면 아래와 같은 결과가 도출된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; delta = <span class="hljs-number">1e-7</span><br>Julia&gt; -log.(y1.+ delta).* t<br><span class="hljs-number">1</span>×<span class="hljs-number">10</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-number">2</span>&#125;:<br> <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.510825</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span><br></code></pre></td></tr></table></figure><p>이 결과에서 0이 아닌 값만 도출하는 것은 쉬워보이지만, 정답 레이블에서 1의 위치가 계속 변하기 때문에 기술적으로 복잡하다. 그렇기 때문에 하나의 값을 도출하기 위해서 모두 더한 것이다. 한 값을 제외하고 전부 0이기 때문에 이는 배열에서 스칼라로 변한 것뿐 수학적인 문제는 없다.</p><p>두 번째 의문은 "왜 자연로그를 이용하는가?"이다. 먼저 자연로그 그래프를 살펴보자.</p><figure><img src="/images/35.png" alt="자연로그" /><figcaption aria-hidden="true">자연로그</figcaption></figure><p>위의 그래프에서는 <span class="math inline">\(x\)</span>축이 1일 때 <span class="math inline">\(y\)</span>축이 0이며, <span class="math inline">\(x\)</span>축이 1 미만일 때에는 <span class="math inline">\(-e\)</span>에 가까운 값으로 향한다. 즉, 0부터 1 사이의 수들은 전부 음수로 반환되는 것이다. 이런 원리를 이용하여 정답레이블 1에 위치한 소프트맥스 함수의 확률 값이 1에 가까울수록 작은 수로 변환되며, 이를 통해서 판단지표의 역할을 하는 것이다. 음수로 나오는 결과를 양수로 변환하기 위해서 <span class="math inline">\(log\)</span> 앞에 <span class="math inline">\(-\)</span> 를 곱한다.</p><p>해당 수식을 코드로 구현하면 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> cross_entropy_error(y, t)<br>    delta = <span class="hljs-number">1e-7</span><br>    <span class="hljs-keyword">return</span> -sum(log.(y.+ delta).* t)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 정의에서 <code>delta</code> 또한 기술적인 이유로 포함되었다. 그래프에서도 확인할 수 있듯이 자연로그는 <span class="math inline">\(x\)</span>축이 0인 경우의 <span class="math inline">\(y\)</span>값이 마이너스 무한대이다. 따라서 <span class="math inline">\(log_e 0\)</span>은 <code>-inf</code>이기 때문에 계산 오류가 바로 발생한다. 이를 막기 위해 아주 작은 값인 <span class="math inline">\(1e-7\)</span>을 더해주는 것이다. <span class="math inline">\(1e-7\)</span>은 지수 표기법으로 <span class="math inline">\(0.0000001\)</span>을 의미한다.</p><p>지금부터 예시에 교차 엔트로피 오차를 적용해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; t = [<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>] <span class="hljs-comment"># 정답 레이블</span><br>Julia&gt; y1 = [<span class="hljs-number">0.1</span> <span class="hljs-number">0.05</span> <span class="hljs-number">0.6</span> <span class="hljs-number">0.0</span> <span class="hljs-number">0.05</span> <span class="hljs-number">0.1</span> <span class="hljs-number">0.0</span> <span class="hljs-number">0.1</span> <span class="hljs-number">0.0</span> <span class="hljs-number">0.0</span>] <span class="hljs-comment"># 출력 값 with 정답</span><br>Julia&gt; y2 = [<span class="hljs-number">0.1</span> <span class="hljs-number">0.05</span> <span class="hljs-number">0.1</span> <span class="hljs-number">0.0</span> <span class="hljs-number">0.05</span> <span class="hljs-number">0.1</span> <span class="hljs-number">0.0</span> <span class="hljs-number">0.6</span> <span class="hljs-number">0.0</span> <span class="hljs-number">0.0</span>] <span class="hljs-comment"># 출력 값 with 오답</span><br></code></pre></td></tr></table></figure><p>예시 데이터셋은 평균 제곱 오차에서 사용했던 것을 그대로 사용할 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; cross_entropy_error(y1,t)<br><span class="hljs-number">0.510825457099338</span><br><br>Julia&gt; cross_entropy_error(y2,t)<br><span class="hljs-number">2.302584092994546</span><br></code></pre></td></tr></table></figure><p>위의 결과를 보면 잘 예측한 <code>y1</code>이 잘못 예측한 <code>y2</code>보다 더 작은 것을 확인할 수 있다. 이처럼 손실 함수는 오차를 계산하여 오차율을 나타내며, 값이 0에 가까울수록 오차가 없다고 판단한다. 즉, 손실 함수의 값이 0에 가까울수록 해당 신경망은 잘 학습되었다고 평가되는 것이다.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>deep learning in julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>딥러닝</tag>
      
      <tag>Deeplearning</tag>
      
      <tag>머신러닝</tag>
      
      <tag>줄리아</tag>
      
      <tag>loss</tag>
      
      <tag>손실함수</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[2/18] 활성화 함수</title>
    <link href="/ko/DeeplearningJulia/Deeplearning-2/"/>
    <url>/ko/DeeplearningJulia/Deeplearning-2/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다. <span id="more"></span></p><hr /><h2 id="활성화-함수">활성화 함수</h2><p>활성화 함수란 신경망 노드에 위치해 있는 함수로서 입력값들을 출력 신호의 여부로 변환해주는 함수이다. 보통 은닉층에서 사용하는 활성화 함수와 출력층에서 사용하는 활성화 함수로 나눠져 있으며, <span class="math inline">\(h(x)\)</span>로 표기한다.</p><h3 id="은닉층에서-사용하는-활성화-함수">은닉층에서 사용하는 활성화 함수</h3><p>은닉층에서 사용되는 기본적인 활성화 함수로는 3가지 정도가 있다.</p><h4 id="계단-함수">계단 함수</h4><p>계단 함수는 입력값이 <span class="math inline">\(0\)</span>이하이면 <span class="math inline">\(0\)</span>, <span class="math inline">\(0\)</span>을 초과하면 <span class="math inline">\(1\)</span>로 변환해주는 함수이다. 수식으로는 다음과 같다.</p><p><span class="math display">\[h(x) = \begin{cases}0 &amp; \text{(x≤0) \]</span>}\ 1 &amp; \ \end{cases} $$</p><p>아래는 위 수식의 코드 구현이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> step_function(x)<br>    <span class="hljs-keyword">if</span> x&lt;=<span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>이를 그래프로 나타내보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; <span class="hljs-keyword">using</span> Plots<br>Julia&gt; x = range(-<span class="hljs-number">5.0</span>, <span class="hljs-number">5.0</span>, step = <span class="hljs-number">0.1</span>)<br>Julia&gt; y = step_function.(x)<br>Julia&gt; plot(x,y)<br></code></pre></td></tr></table></figure><figure><img src="/images/33.png" alt="계단 함수" /><figcaption aria-hidden="true">계단 함수</figcaption></figure><p>그래프에서 보면 <span class="math inline">\(0\)</span>을 기준으로 <span class="math inline">\(0\)</span> 또는 <span class="math inline">\(1\)</span>을 반환하는 것을 확인할 수 있다. 위의 함수는 연속적인 값이 아닌 이진수를 결과로 반환한다.</p><p><strong>Tip</strong> 위의 코드를 보면 <code>step_function.(x)</code>에 도트 연산자를 확인할 수 있다. 도트 연산자는 배열 단위의 입력 값에 함수나 연산자를 각 요소별로 적용해준다.</p><h4 id="시그모이드-함수">시그모이드 함수</h4><p>시그모이드 함수는 입력값들을 <span class="math inline">\(0\)</span>과 <span class="math inline">\(1\)</span>사이의 수로 변환해주는 함수이다. 수식은 아래와 같다.</p><p><span class="math display">\[h(x)=\frac{1}{1+e^{-x}}\]</span></p><p>위의 식을 코드로 구현해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> sigmoid(x)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / (<span class="hljs-number">1</span>+exp(-x))<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>그래프를 그려보면 <span class="math inline">\(0\)</span>과 <span class="math inline">\(1\)</span> 사이의 소수들로 구성된 것을 볼 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; <span class="hljs-keyword">using</span> Plots<br>Julia&gt; x = range(-<span class="hljs-number">5.0</span>, <span class="hljs-number">5.0</span>, step = <span class="hljs-number">0.1</span>)<br>Julia&gt; y = sigmoid.(x)<br>Julia&gt; plot(x,y)<br></code></pre></td></tr></table></figure><figure><img src="/images/32.png" alt="시그모이드 함수" /><figcaption aria-hidden="true">시그모이드 함수</figcaption></figure><p>시그모이드 함수는 <span class="math inline">\(0\)</span>과 <span class="math inline">\(1\)</span>의 사이에서 연속적인 값을 반환하며, <span class="math inline">\(0\)</span>을 중간값인 <span class="math inline">\(0.5\)</span>로 설정한다. 따라서 계단 함수와 달리 각 신호의 강도를 표현할 수 있다.</p><h4 id="relu-함수">ReLU 함수</h4><p>ReLU 함수는 음수를 모두 <span class="math inline">\(0\)</span>으로 바꾸고 양수는 그대로 출력하는 함수이다. 수식은 다음과 같다.</p><p><span class="math display">\[h(x) = \begin{cases}0 &amp; \text{(x≤0)\]</span>}\ x &amp; \ \end{cases} $$</p><p>위 수식을 코드로 구현해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> relu(x)<br>    <span class="hljs-keyword">return</span> max(<span class="hljs-number">0</span>,x)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><figure><img src="/images/34.png" alt="ReLU 함수" /><figcaption aria-hidden="true">ReLU 함수</figcaption></figure><p>위의 그래프를 통해 음수는 모두 <span class="math inline">\(0\)</span>으로 처리되며, 양수는 값이 그대로 출력되는 것을 확인할 수 있다.</p><h4 id="세-가지-함수-비교">세 가지 함수 비교</h4><p>지금까지 은닉층에서 사용하는 활성화 함수들을 살펴보았다. 이제는 배열에 직접 적용해봄으로서 각 함수들을 비교해보고자 한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; x = [-<span class="hljs-number">1</span> -<span class="hljs-number">2</span> -<span class="hljs-number">3</span>;<span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><p>위의 코드는 예시로 적용해 볼 <span class="math inline">\(2\times3\)</span> 배열이다. 계단 함수와 시그모이드 함수, ReLU 함수 순서로 적용해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; step_function.(x)<br><span class="hljs-number">2</span>×<span class="hljs-number">3</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Int64</span>,<span class="hljs-number">2</span>&#125;:<br> <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span><br> <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>계단 함수는 음수와 <span class="math inline">\(0\)</span>은 모두 '<span class="math inline">\(0\)</span>'으로 바꾸고 양수들을 '<span class="math inline">\(1\)</span>'로 출력하였다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; sigmoid.(x)<br><span class="hljs-number">2</span>×<span class="hljs-number">3</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-number">2</span>&#125;:<br> <span class="hljs-number">0.268941</span>  <span class="hljs-number">0.119203</span>  <span class="hljs-number">0.0474259</span><br> <span class="hljs-number">0.5</span>       <span class="hljs-number">0.952574</span>  <span class="hljs-number">0.999089</span><br></code></pre></td></tr></table></figure><p>시그모이드 함수는 각 배열 요소들을 <span class="math inline">\(0\)</span>부터 <span class="math inline">\(1\)</span>까지의 수로 변환하여 출력하였다. 요소 중 하나인 <span class="math inline">\(0\)</span>은 중간값 0.5로 설정된 것을 볼 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; relu.(x)<br><span class="hljs-number">2</span>×<span class="hljs-number">3</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Int64</span>,<span class="hljs-number">2</span>&#125;:<br> <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span><br> <span class="hljs-number">0</span>  <span class="hljs-number">3</span>  <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>ReLU 함수의 경우 음수는 모두 <span class="math inline">\(0\)</span>으로 바꾸고 양수는 그대로 출력한 것을 확인할 수 있다.</p><h3 id="출력층에서-사용하는-활성화-함수">출력층에서 사용하는 활성화 함수</h3><p>출력층에서 사용되는 활성화 함수는 목적에 따라 달라진다. 일반적으로 회귀에는 항등 함수, 분류에는 소프트맥스 함수가 쓰인다.</p><h4 id="항등-함수">항등 함수</h4><p>항등 함수는 입력값을 그대로 출력한다. 수식과 코드는 아래와 같다.</p><p><span class="math display">\[σ(x)=x\]</span></p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> identity_function(x)<br>    <span class="hljs-keyword">return</span> x<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="소프트맥스-함수">소프트맥스 함수</h4><p>소프트맥스 함수는 0과 1사이의 값을 비율로 출력하기 때문에 "확률"로 해석할 수 있다. 이런 이유로 분류 신경망에서 소프트맥스 함수를 사용한다. 예를 들어, 꽃 사진 하나를 분석하여 어떤 꽃인지 분류하는 신경망을 구현 중이라면 소프트맥스 함수는 (장미 70%, 진달래 21%, 붓꽃 9%) 이런 식으로 결과를 제공한다. 수식은 다음와 같다.</p><p><span class="math display">\[y_k=\frac{e^{a_k}}{\sum_{i=1}^n e^{a_i}}\]</span></p><p>이 수식에서 <span class="math inline">\(y_k\)</span>는 출력층의 <span class="math inline">\(k\)</span>번째 노드이며, 분자의 <span class="math inline">\(a_k\)</span>는 <span class="math inline">\(k\)</span>번째 입력 값이다. 또한 분모에서 <span class="math inline">\(n\)</span>은 총 출력층의 개수이며, 분모 전체는 출력된 값의 전체 합을 의미한다. 이를 코드로 구현하면 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> softmax(x)<br>    c = maximum(x)<br>    exp.(x.-c)/sum(exp.(x.-c))<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위 코드에서 입력 신호의 최대값을 빼는 이유는 오버플로(overflow) 문제를 막기 위함이다. 오버플로(overflow)란 결과값이 컴퓨터가 표현할 수 있는 값을 넘어갔을 때 발생하는 문제이며, 최대값을 빼주면 에러를 막을 수 있다.</p><h4 id="두-가지-함수-비교">두 가지 함수 비교</h4><p>지금까지 출력층에서 사용하는 항등 함수와 소프트맥스 함수를 살펴보았다. 이제는 예시에 직접 적용해보면서 각 함수들의 결과들을 비교해보고자 한다. 예시로 사용할 배열은 은닉층 활성화 함수들 비교했던 <code>x</code>를 그대로 사용하기로 한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; x = [-<span class="hljs-number">1</span> -<span class="hljs-number">2</span> -<span class="hljs-number">3</span>;<span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><p>먼저 항등 함수부터 확인해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; identity_function(x)<br><span class="hljs-number">2</span>×<span class="hljs-number">3</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Int64</span>,<span class="hljs-number">2</span>&#125;:<br> -<span class="hljs-number">1</span>  -<span class="hljs-number">2</span>  -<span class="hljs-number">3</span><br>  <span class="hljs-number">0</span>   <span class="hljs-number">3</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>입력값을 그대로 반환하는 것을 알 수 있다. 그 다음으로는 소프트맥스 함수를 적용해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; softmax(x)<br><span class="hljs-number">2</span>×<span class="hljs-number">3</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-number">2</span>&#125;:<br> <span class="hljs-number">0.000328971</span>  <span class="hljs-number">0.000121022</span>  <span class="hljs-number">4.45214e-5</span><br> <span class="hljs-number">0.000894237</span>  <span class="hljs-number">0.0179612</span>    <span class="hljs-number">0.98065</span><br></code></pre></td></tr></table></figure><p><span class="math inline">\(0\)</span>과 <span class="math inline">\(1\)</span> 사이의 값들로 변환되어 출력하는 것을 확인할 수 있다. 여기서 소프트맥스가 제대로 구현되었는지 확인하려면 모든 요소들을 더해서 <span class="math inline">\(1\)</span>이 나오면 된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; sum(softmax(x))<br><span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure><p>요소들의 합이 <span class="math inline">\(1\)</span>임을 확인할 수 있다.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>deep learning in julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>딥러닝</tag>
      
      <tag>Deeplearning</tag>
      
      <tag>머신러닝</tag>
      
      <tag>줄리아</tag>
      
      <tag>ReLU</tag>
      
      <tag>렐루</tag>
      
      <tag>시그모이드</tag>
      
      <tag>sigmoid</tag>
      
      <tag>softmax</tag>
      
      <tag>소프트맥스</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[1/18] 행렬과 벡터의 곱</title>
    <link href="/ko/DeeplearningJulia/Deeplearning-1/"/>
    <url>/ko/DeeplearningJulia/Deeplearning-1/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다. <span id="more"></span></p><hr /><h2 id="벡터란">벡터란</h2><p>벡터(Vector)는 '크기'와 '방향'을 모두 나타낸다. 예를 들어, 자동차가 시속 5마일로 달린다고 해보자. 여기서 5마일은 단순히 크기일뿐 방향을 나타내고 있지 않으므로 벡터라고 할 수 없다. 벡터로 나타내기 위해서는 5마일에 동쪽으로 향하는 '크기'와 '방향'까지 포함된 개념이어야 한다.</p><p>벡터의 기호는 <span class="math inline">\(\overrightarrow{a}\)</span>이며, 아래와 같은 '열벡터'가 기본 형태이다.</p><p><span class="math display">\[\overrightarrow{a}=\begin{bmatrix}X \\Y \\\end{bmatrix}\]</span></p><p>벡터의 성분 개수와 차원은 동일하기 때문에 위의 열벡터는 성분 <code>x</code>와 <code>y</code> 를 가진 2차원 벡터이다.</p><p>행벡터는 기본형인 열벡터를 '전치'한 형태이다. 여기서 전치란 주대각선(Main diagonal)을 대칭한 것이며, 보통 행렬에서 많이 사용된다.</p><p><span class="math display">\[\overrightarrow{a}^T=\begin{bmatrix}X&amp;Y\end{bmatrix}\]</span></p><p>행렬의 경우 아래의 행렬과 벡터의 곱에서 더 자세하게 설명할 것이다.</p><h2 id="벡터의-내적">벡터의 내적</h2><p>벡터의 곱셈은 크게 '외적(Cross product)'과 '내적(Dot product)' 2가지의 방법이 사용되며, 우리는 그 중 딥러닝에서 사용하는 내적에 대해 살펴볼 것이다.</p><p>내적을 수학식으로 표현하면 아래와 같다.</p><p><span class="math display">\[\overrightarrow{a}\cdot\overrightarrow{b}=\sum_{i=1}^n a_ib_i=a_1b_1+a_2b_2+a_3b_3+\cdots+a_nb_n\]</span></p><p>열벡터 a와 b를 내적하면 같은 위치에 있는 성분끼리 곱한 수들을 더한다. 즉, 열벡터 당 하나의 스칼라가 값으로 나오는 것이다.</p><p><span class="math display">\[\overrightarrow{a}=\begin{bmatrix}a_1\\a_2\\a_3\\\vdots\\a_n\end{bmatrix}\quad\overrightarrow{b}=\begin{bmatrix}b_1\\b_2\\b_3\\\vdots\\b_n\end{bmatrix}\quad\overrightarrow{a}\cdot\overrightarrow{b}=a_1b_1+a_2b_2+a_3b_3\cdots a_nb_n\]</span></p><p>이와 같은 과정을 벡터의 내적이라고 한다.</p><h2 id="행렬과-벡터의-곱">행렬과 벡터의 곱</h2><p>행렬이란 <span class="math inline">\(m \times n\)</span>의 2차원 배열이다. 여기서 <span class="math inline">\(m\)</span>은 행의 개수이고 <span class="math inline">\(n\)</span>은 열의 개수이다. 아래는 <span class="math inline">\(m \times n\)</span>의 행렬을 시각화한 것이다.</p><p><span class="math display">\[A=\begin{bmatrix}a_{11} &amp; \cdots &amp; a_{1n} \\\vdots &amp; \ddots &amp; \vdots \\a_{m1} &amp; \cdots &amp; a_{mn}\end{bmatrix}\]</span></p><p>그렇다면 위와 같은 행렬을 벡터와 곱하는 것이 가능할까?</p><p><strong>NOTE</strong> 앞의 질문에 대답하기 전에 행렬과 벡터의 관계를 명확히 하려고 한다. 앞서 백터를 설명하는 섹션에서 봤던 열벡터 <span class="math inline">\(\overrightarrow{a}\)</span>는 <span class="math inline">\(2 \times 1\)</span> 행렬이라고 할 수 있으며, <span class="math inline">\(\overrightarrow{a}^T\)</span>는 <span class="math inline">\(1 \times 2\)</span> 행렬이라고 할 수 있다. 즉, 열벡터와 행벡터 모두 행렬로서 바라볼 수 있으며 그 반대도 가능하다.</p><p>행렬과 벡터를 곱하는 방법은 2가지가 있다.</p><h3 id="행-단위를-행벡터로-가정하여-내적한다">행 단위를 행벡터로 가정하여 내적한다</h3><p><span class="math display">\[A\overrightarrow{x}= \begin{bmatrix} a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\ a_{21} &amp; a_{22} &amp; \cdots &amp; \vdots \\ \vdots &amp; \cdots &amp; \ddots &amp; \vdots \\ a_{m1} &amp; \cdots &amp; \cdots &amp; a_{mn} \end{bmatrix} \cdot \begin{bmatrix} x_1\\ x_2\\ \vdots\\ x_n\\ \end{bmatrix} = \begin{bmatrix} a_{11}x_1 + a_{12}x_2 + \cdots + a_{1n}x_n \\ a_{12}x_1 + a_{22}x_2 + \cdots\cdots\cdot\ \vdots\ \\ \ \vdots\ \\ a_{m1}x_1 + \cdots\cdots\cdots\cdot + a_{mn}x_n \end{bmatrix} =\overrightarrow{b}\]</span></p><p>위의 공식은 행렬 A의 각 행을 행벡터로 인식하여 <span class="math inline">\(A\)</span>와 <span class="math inline">\(\overrightarrow{x}\)</span>가 내적한다. 즉, 전치행렬 <span class="math inline">\(A^T\)</span>의 열들을 벡터로 내적하는 것과 같다. 그렇기에 <span class="math inline">\(\overrightarrow{x}\)</span>의 길이는 행렬 A의 열 개수인 <span class="math inline">\(n\)</span>이어야 하며, 결과값인 <span class="math inline">\(\overrightarrow{b}\)</span>는 길이가 <span class="math inline">\(m\)</span>이다.</p><p><span class="math display">\[A\overrightarrow{x}= A(m \times n) \cdot \overrightarrow{x}(n \times 1) = \overrightarrow{b}(m \times 1)\]</span></p><p>직접 숫자를 넣어 예시를 풀어보자.</p><p><span class="math display">\[A\overrightarrow{x}= \begin{bmatrix} 3 &amp; 1 &amp; 0 &amp; 3 \\ 2 &amp; 4 &amp; 7 &amp; 0 \\ -1 &amp; 2 &amp; 3 &amp; 4 \\ \end{bmatrix} \cdot \begin{bmatrix} 1\\ 2\\ 3\\ 4\\ \end{bmatrix} = \begin{bmatrix} 3\times1+1\times2+0\times3+3\times4 \\ 2\times1+4\times2+7\times3+0\times4 \\ -1\times1+2\times2+3\times3+4\times4\quad \end{bmatrix} = \begin{bmatrix} 17\\ 31\\ 28\\ \end{bmatrix}\]</span></p><p>위의 예시를 살펴보면 행렬 A의 각각의 행벡터와 <span class="math inline">\(\overrightarrow{x}\)</span>를 내적하여 나온 스칼라 값이 결과값인 것을 확인할 수 있다. 결국 위의 식을 정리한다면 다음와 같다.</p><p><span class="math display">\[A\overrightarrow{x}= \begin{bmatrix} \ \overrightarrow{a_1^T}\ \\ \ \overrightarrow{a_2^T}\ \\ \ \vdots\ \\ \ \overrightarrow{a_n^T}\ \\ \end{bmatrix} \cdot \overrightarrow{x} \ = \begin{bmatrix} \ \overrightarrow{a_1} \cdot\overrightarrow{x}\\ \ \overrightarrow{a_2} \cdot\overrightarrow{x}\\ \ \vdots\\ \ \overrightarrow{a_n} \cdot\overrightarrow{x}\\ \end{bmatrix}\]</span></p><h3 id="행렬을-열벡터의-모음으로-가정하여-내적한-후-각-행들을-더해준다">행렬을 열벡터의 모음으로 가정하여 내적한 후, 각 행들을 더해준다</h3><p>다음으로는 '열벡터' 개념만으로 행렬 벡터 곱을 이해하는 방법이다. 어떤 방법을 사용하든 결과는 동일하지만 진행되는 논리구조는 다르다. 둘 중 어느 방법을 사용해도 상관없지만 개인적으로는 이 방법이 더 편하다고 생각한다. 먼저 아래의 행렬을 각각의 열벡터의 모음이라고 생각해보자.</p><p><span class="math display">\[\begin{matrix} \overrightarrow{v_1}\ &amp; \overrightarrow{v_2}\ &amp; \cdots &amp; \overrightarrow{v_n} \end{matrix}\]</span> <span class="math display">\[\begin{bmatrix} a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\ a_{21} &amp; a_{22} &amp; \cdots &amp; \vdots \\ \vdots &amp; \cdots &amp; \ddots &amp; \vdots \\ a_{m1} &amp; \cdots &amp; \cdots &amp; a_{mn} \end{bmatrix}\]</span></p><p>위의 도식처럼 행렬 A의 각 열들은 <span class="math inline">\(v_1\)</span>, <span class="math inline">\(v_2\)</span>, <span class="math inline">\(\cdots\)</span> <span class="math inline">\(v_n\)</span>인 열벡터로 분리되었다. <span class="math inline">\(v\)</span>의 개수는 행렬 A의 열 개수와 동일하며, 여기서는 n을 4라고 가정하자. 그 다음 <span class="math inline">\(\overrightarrow{v}\)</span> 백터들을 각각 <span class="math inline">\(\overrightarrow{x}\)</span>와 내적한 후, 결과로 나온 값들을 행 단위로 더해주면 된다.</p><p><span class="math display">\[A\overrightarrow{x}=\begin{bmatrix} \overrightarrow{v_1}\\ \overrightarrow{v_2}\\ \overrightarrow{v_3}\\ \overrightarrow{v_4}\\ \end{bmatrix} \begin{bmatrix} x_1\\ x_2\\ x_3\\ x_4\\ \end{bmatrix} = \begin{matrix}[x_1\overrightarrow{v_1}+x_2\overrightarrow{v_2}+x_3\overrightarrow{v_3}+x_4\overrightarrow{v_4}]\end{matrix}\]</span></p><p>따라서 <span class="math inline">\(A\overrightarrow{x}\)</span>는 <span class="math inline">\(\overrightarrow{v}\)</span> 벡터들에 <span class="math inline">\(\overrightarrow{x}\)</span>의 스칼라(상수)를 곱해준 것이다. 이는 <span class="math inline">\(\overrightarrow{v}\)</span> 벡터들의 값들을 <strong>가중</strong>해준다는 의미와 같다. 마지막으로 <span class="math inline">\(\overrightarrow{x}\)</span>의 스칼라(상수)를 곱해진 <span class="math inline">\(\overrightarrow{v}\)</span> 백터들을 행 단위로 더해주면 된다.</p><p>이제는 원리는 파악했으니 아래의 문제를 풀어보도록 하자.</p><p><span class="math display">\[A\overrightarrow{x}= \begin{bmatrix} 3 &amp; 1 &amp; 0 &amp; 3 \\ 2 &amp; 4 &amp; 7 &amp; 0 \\ -1 &amp; 2 &amp; 3 &amp; 4 \\ \end{bmatrix} \cdot \begin{bmatrix} 1\\ 2\\ 3\\ 4\\ \end{bmatrix}\]</span></p><p>보다시피 위의 문제와 동일하다. 다만 답이 어떻게 도출되는지 과정의 차이를 집중적으로 살펴볼 것이다.</p><p><span class="math display">\[\begin{matrix} \overrightarrow{v_1}\ &amp;\overrightarrow{v_2}\ &amp; \overrightarrow{v_3}\ &amp; \overrightarrow{v_4} \end{matrix}\]</span> <span class="math display">\[ \begin{bmatrix} 3\\ 2\\ -1\\ \end{bmatrix}  \begin{bmatrix} 1\\ 4\\ 2\\ \end{bmatrix}  \begin{bmatrix} 0\\ 7\\ 3\\ \end{bmatrix}  \begin{bmatrix} 3\\ 0\\ 4\\ \end{bmatrix}\]</span></p><p><span class="math display">\[\begin{matrix}[x_1\overrightarrow{v_1}+x_2\overrightarrow{v_2}+x_3\overrightarrow{v_3}+x_4\overrightarrow{v_4}]\end{matrix}\]</span></p><p>위의 도식처럼 열벡터 단위로 분리한 후, 아래의 공식에 대입한다.</p><p><span class="math display">\[\begin{bmatrix}3\times1+1\times2+0\times3+3\times4 \\ 2\times1+4\times2+7\times3+0\times4 \\ -1\times1+2\times2+3\times3+4\times4\quad \end{bmatrix} = \begin{bmatrix} 3 &amp; 2 &amp; 0 &amp; 12 \\ 2 &amp; 8 &amp; 21 &amp; 0 \\ -1 &amp; 4 &amp; 9 &amp; 16 \\ \end{bmatrix}\]</span></p><p>위의 결과를 행 단위로 더해준다.</p><p><span class="math display">\[\begin{bmatrix} 3 + 2 + 0 + 12 \\ 2 + 8 + 21 + 0 \\ -1 + 4 + 9 + 16 \\ \end{bmatrix} = \begin{bmatrix} 17 \\ 31 \\ 28 \\ \end{bmatrix}\]</span></p><p>보다시피 첫 번째 방법과 결과는 같다. 위의 예시들은 모두 행렬과 열벡터 한 개를 내적하였다. 만약 행렬과 열벡터 여러 개를 한 번에 내적하고 싶다면 어떻게 해야 하는가? 벡터를 하나씩 행렬과 내적한 결과를 순서대로 나열하면 될 것이다. 이를 한번에 진행해주는 연산방법을 '행렬곱'이라고 한다.</p><h2 id="행렬곱">행렬곱</h2><p>행렬곱은 여러 개의 벡터를 한번에 행렬과 곱하는 것과 동일한 결과를 제공한다. 즉, 위에서 봤던 행렬과 벡터의 곱을 여러 번 진행한 것이라고 볼 수 있다. 만약 행렬 A와 행렬 B를 곱하여 행렬 C를 도출한다고 가정해보자.</p><p><span class="math display">\[ C = A*B \rightarrow c_{mn}=a_m^T \cdot b_n \]</span></p><p>행렬 C의 요소 <span class="math inline">\(c_{mn}\)</span>는 행렬 A의 <span class="math inline">\(m\)</span>번째 행과 행렬 B의 <span class="math inline">\(n\)</span>번째 열을 내적한 값이다. 이를 도식으로 나타내면 다음과 같다.</p><p><span class="math display">\[\begin{bmatrix} a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\ a_{21} &amp; a_{22} &amp; \cdots &amp; \vdots \\ \vdots &amp; \cdots &amp; \ddots &amp; \vdots \\ a_{m1} &amp; \cdots &amp; \cdots &amp; a_{mn} \end{bmatrix} \begin{bmatrix} b_{11} &amp; b_{12} &amp; \cdots &amp; b_{1n} \\ b_{21} &amp; b_{22} &amp; \cdots &amp; \vdots \\ \vdots &amp; \cdots &amp; \ddots &amp; \vdots \\ b_{m1} &amp; \cdots &amp; \cdots &amp; b_{mn} \end{bmatrix}\]</span> <span class="math display">\[= \begin{bmatrix} (a_{11}b_{11}+a_{12}b_{21}\cdots+a_{1n}b_{m1}) &amp;  \cdots &amp; (a_{11}b_{m1}+a_{12}b_{m2}\cdots+a_{1n}b_{mn}) \\ (a_{21}b_{11}+a_{22}b_{21}\cdots+a_{2n}b_{m1}) &amp;  \cdots &amp; (a_{21}b_{m1}+a_{22}b_{m2}\cdots+a_{2n}b_{mn}) \\ \vdots &amp;  &amp; \vdots \\ (a_{m1}b_{11}+a_{m2}b_{21}\cdots+a_{mn}b_{m1}) &amp; \cdots &amp; (a_{m1}b_{m1}+a_{m2}b_{m2}\cdots+a_{mn}b_{mn}) \end{bmatrix}\]</span></p><p>행렬곱에서는 행렬 두 개가 계산되는 것이므로 결과 또한 행렬의 형태를 가진다.</p><p><span class="math display">\[A*B= A(m \times n)*(n \times o) = C(m \times o)\]</span></p><p>이제 예시를 풀어보자.</p><p><span class="math display">\[\begin{bmatrix} 1 &amp; 4 \\ 2 &amp; 5 \\ 3 &amp; 6 \\ \end{bmatrix}* \begin{bmatrix} 1 &amp; 2 &amp; 3\\ 4 &amp; 5 &amp; 6\\ \end{bmatrix}\]</span></p><p>위의 행렬들은 <span class="math inline">\(3\times2\)</span>와 <span class="math inline">\(2\times3\)</span>이므로 결과값 행렬은 <span class="math inline">\(3\times3\)</span>행렬이어야 한다.</p><p><span class="math display">\[\begin{bmatrix} (1\times1+4\times4) &amp; (1\times2+4\times5) &amp; (1\times3+4\times6) \\ (2\times1+5\times4) &amp; (2\times2+5\times5) &amp; (2\times3+5\times6) \\ (3\times1+6\times4) &amp; (3\times2+6\times5) &amp; (3\times3+6\times6) \\ \end{bmatrix}\]</span> <span class="math display">\[=\]</span> <span class="math display">\[\begin{bmatrix} 17 &amp; 22 &amp; 27 \\ 22 &amp; 29 &amp; 36 \\ 27 &amp; 36 &amp; 45 \\ \end{bmatrix}\]</span></p><p>문제의 답으로 <span class="math inline">\(3\times3\)</span> 행렬이 나온 것을 확인할 수 있다. 이런 행렬곱은 신경망 계산에서 벡터의 단위로 내적 계산을 한번에 하기 위해 사용된다.</p><h2 id="줄리아에서의-곱셈">줄리아에서의 곱셈</h2><p>줄리아에서 내적을 사용하기 위해서는 아래의 코드를 입력하여 해당 패키지를 다운로드해야 한다. <code>LinearAlgebra</code> 사용법에 대해 자세히 알고 싶다면 <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/">이 링크</a>에서 확인할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; <span class="hljs-keyword">import</span> Pkg<br>Julia&gt; Pkg.add(<span class="hljs-string">&quot;LinearAlgebra&quot;</span>)<br>Julia&gt; <span class="hljs-keyword">using</span> LinearAlgebra<br></code></pre></td></tr></table></figure><p>준비가 끝났다면 줄리아에서 내적을 어떻게 계산하는지 살펴보자. 줄리아에서 함수 <code>dot()</code>은 두 개의 백터를 내적한다. 아래의 예시를 통해 확인해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; a = ones(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)<br>Julia&gt; a<br><br><span class="hljs-number">1</span>×<span class="hljs-number">3</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-number">2</span>&#125;:<br> <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span><br><br>Julia&gt; b = a&#x27;<br>Julia&gt; b<br><br><span class="hljs-number">3</span>×<span class="hljs-number">1</span> Adjoint&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-number">2</span>&#125;&#125;:<br> <span class="hljs-number">1.0</span><br> <span class="hljs-number">1.0</span><br> <span class="hljs-number">1.0</span><br><br>Julia&gt; dot(a,b)<br><span class="hljs-number">3.0</span><br></code></pre></td></tr></table></figure><p>위의 코드는 <span class="math inline">\(1\times3\)</span> 행렬인 a와, a의 전치행렬인 b를 생성하고 두 벡터를 내적한다. 그 결과로는 3이 도출되었다. 그렇다면 모든 신경망 계산에 <code>dot()</code>만을 사용하면 되는 것일까? 그렇지 않다. <code>dot()</code>은 모든 배열들을 하나의 벡터로 벡터화하는 문제가 있다. 아래의 예시를 통해서 알아보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; a = ones(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>Julia&gt; a<br><span class="hljs-number">2</span>×<span class="hljs-number">3</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-number">2</span>&#125;:<br> <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span><br> <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span><br><br>Julia&gt; b = a&#x27;<br>Julia&gt; b<br><span class="hljs-number">3</span>×<span class="hljs-number">2</span> Adjoint&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-number">2</span>&#125;&#125;:<br> <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span><br> <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span><br> <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span><br><br>Julia&gt; dot(a,b)<br><span class="hljs-number">6.0</span><br></code></pre></td></tr></table></figure><p>위의 예시는 <span class="math inline">\(2\times3\)</span> 행렬인 a와 a의 전치행렬을 생성한다는 점에서 같지만, 각 변수들이 2차원 배열인 매트릭스(Matrix)라는 점에서 다르다. 즉, 첫 번째 예시는 1차 배열을 다루기 때문에 벡터화되어도 상관없는 반면 두 번째 예시는 2차원 배열이기 때문에 행과 열을 보존하여 내적을 해야 하는 것이다. 따라서 이는 행렬곱을 사용하여 처리해주어야 한다. 행렬곱 연산자는 <code>*(a,b)</code>이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; a = ones(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>Julia&gt; b = a&#x27;<br>Julia&gt; *(a,b)<br><span class="hljs-number">2</span>×<span class="hljs-number">2</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-number">2</span>&#125;:<br> <span class="hljs-number">3.0</span>  <span class="hljs-number">3.0</span><br> <span class="hljs-number">3.0</span>  <span class="hljs-number">3.0</span><br></code></pre></td></tr></table></figure><h2 id="신경망-계산">신경망 계산</h2><p>신경망은 입력층, 은닉층, 출력층으로 구분되며 가중치와 편향을 사용하여 계산한다. 이제 신경망에서 사용되는 계산법을 모두 배웠으므로 위의 지식을 바탕으로 신경망이 어떻게 작동하는지 알아보자. 아래의 그림은 신경망 구조의 예시이다. 참고로 아래의 그림은 하나의 예시일 뿐이며, 각 층 변수의 개수는 가변적으로 설정할 수 있다.</p><figure><img src="/images/31.png" alt="신경망 구조" /><figcaption aria-hidden="true">신경망 구조</figcaption></figure><p>위의 그림은 2층 신경망 구조이다. 위 그림에서 동그라미는 각 층의 성분으로 <strong>노드</strong>라고 하며, 노드끼리 연결된 화살표는 가중치인 <strong>엣지</strong>라고 한다. 지금부터는 위 신경망 구조를 코드로 구현하여 '행렬과 벡터 곱', '행렬곱'을 사용해볼 것이다.</p><p>먼저 위 구조를 분해해보도록 하자.</p><p>입력층(<span class="math inline">\(1\times4\)</span> 행렬), 은닉층(<span class="math inline">\(1\times2\)</span> 행렬), 출력층(<span class="math inline">\(1\times3\)</span> 행렬)은 다음과 같다.</p><p>입력층: <span class="math inline">\(X=[x_1,x_2,x_3,x_4]\quad\)</span> 은닉층: <span class="math inline">\(H=[h_1,h_2]\quad\)</span> 출력층: <span class="math inline">\(Y=[y_1,y_2,y_3]\quad\)</span></p><p>신경망을 계산하기 위해서는 가중치와 편향이 필요하다. 가중치는 각 층 사이에서 곱해지는 행렬이며, 편향은 각 층의 계산마다 더해지는 상수이다. 가중치와 편향에 대한 정의는 4장인 경사하강법에서 자세히 다룰 것이다.</p><p>각 층은 가중치인 <span class="math inline">\(W\)</span>를 곱하고 편향 <span class="math inline">\(B\)</span>를 더하여 다음 층으로 넘어간다. 이를 수학식으로 표현하면 아래와 같다.</p><p><span class="math inline">\(H=(X*W)+B\)</span></p><p>위의 신경망 구조에서 가중치와 편향은 총 2개가 필요하다. 먼저 가중치부터 살펴본다면, 첫 번째 가중치는 입력층과 은닉층 사이에 있으므로 <span class="math inline">\(4\times2\)</span> 행렬이어야 한다. 또한 두 번째는 은닉층과 출력층 사이에 있으므로 <span class="math inline">\(2\times3\)</span> 행렬이다.</p><p><span class="math display">\[가중치 행렬 1:\begin{bmatrix} w_{11} &amp; w_{12} \\ w_{21} &amp; w_{22} \\ w_{31} &amp; w_{32} \\ w_{41} &amp; w_{42} \end{bmatrix}\quad가중치 행렬 2:\begin{bmatrix} w_{51} &amp; w_{52} &amp; w_{53}\\ w_{61} &amp; w_{62} &amp; w_{63}\\ \end{bmatrix}\]</span></p><p>다음은 편향이다. 편향은 각 층과 가중치가 곱해진 결과에 더하므로 입력층에서 은닉층 사이의 첫 번째 편향은 <span class="math inline">\(1\times2\)</span> 행렬이며, 두 번째 편향은 <span class="math inline">\(1\times3\)</span> 행렬이다.</p><p><span class="math display">\[ 편향1:\begin{bmatrix}b_1 &amp; b_2 \end{bmatrix}\quad편향 2:\begin{bmatrix} b_3 &amp; b_4 &amp; b_5 \end{bmatrix}\]</span></p><p>입력층에서 은닉층까지의 계산을 순서대로 나타내면 아래의 수학식과 같다.</p><p><span class="math display">\[h_1=w_{11}x_1+w_{21}x_2+w_{31}x_3+w_{41}x_4+b_1\\h_2=w_{12}x_1+w_{22}x_2+w_{32}x_3+w_{42}x_4+b_2\]</span></p><p>다음은 은닉층에서 출력층의 계산을 수학식으로 작성한 것이다.</p><p><span class="math display">\[y_1=w_{51}h_1+w_{61}h_2+b_3\\y_2=w_{52}h_1+w_{62}h_2+b_4\\y_3=w_{53}h_1+w_{63}h_2+b_5\]</span></p><p>이제 준비가 완료되었다. 위의 수학식들을 코드로 구현해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs julia">Julia&gt; X = [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>]<br>Julia&gt; W1 = [<span class="hljs-number">1</span> <span class="hljs-number">2</span>; <span class="hljs-number">3</span> <span class="hljs-number">4</span>;<span class="hljs-number">5</span> <span class="hljs-number">6</span>;<span class="hljs-number">7</span> <span class="hljs-number">8</span>]<br>Julia&gt; W2 = [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>; <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>]<br>Julia&gt; B1 = [<span class="hljs-number">1</span> <span class="hljs-number">2</span>]<br>Julia&gt; B2 = [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p>먼저 입력층 행렬과 가중치 행렬, 편향을 할당해준다. 그 후 위의 수학공식을 구현하여 은닉층을 구현해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; H = *(X,W1)+B1<br><span class="hljs-number">51</span>  <span class="hljs-number">62</span><br></code></pre></td></tr></table></figure><p>은닉층은 입력층의 값에 가중치 W1을 곱한 후, 편향 B1을 더하였다. 마지막으로 출력층을 구현하면 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; Y = *(H,W2)+B2<br><span class="hljs-number">300</span>  <span class="hljs-number">414</span>  <span class="hljs-number">528</span><br></code></pre></td></tr></table></figure><p>사실 신경망을 구현하는 것은 위의 설명보다 더 복잡하다. 하지만 위의 원리를 이해하지 못한다면 신경망 자체를 파악할 수 없다. 다음 글에서는 신경망에 쓰이는 활성화 함수들을 살펴보고 줄리아로 구현할 것이다.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>deep learning in julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>딥러닝</tag>
      
      <tag>Deeplearning</tag>
      
      <tag>머신러닝</tag>
      
      <tag>벡터</tag>
      
      <tag>내적</tag>
      
      <tag>줄리아</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[0/18] 줄리아로 딥러닝 구현하기</title>
    <link href="/ko/DeeplearningJulia/Deeplearning-0/"/>
    <url>/ko/DeeplearningJulia/Deeplearning-0/</url>
    
    <content type="html"><![CDATA[<p>해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다. <span id="more"></span></p><hr /><h2 id="introduction">Introduction</h2><p>이 시리즈는 줄리아를 사용하여 딥러닝의 알고리즘을 이해하고 구현하는 것을 목표로 한다. 특히 신경망에서 사용되는 수학적 지식이나 수식들에 대한 설명을 덧붙이면서 딥러닝을 잘 모르는 초보자들도 이해할 수 있도록 하였다.</p><p>목차는 아래와 같다.</p><ol type="1"><li><p>행렬과 벡터의 곱</p></li><li><p>활성화 함수</p></li><li><p>손실 함수</p></li><li><p>경사하강법</p></li><li><p>인공신경망 구현 - 수학식 풀이</p></li><li><p>인공신경망 구현 - 모델 학습</p></li><li><p>인공신경망 구현 - 순전파 알고리즘</p></li><li><p>인공신경망 구현 - 역전파 설명</p></li><li><p>인공신경망 구현 - 역전파 알고리즘</p></li><li><p>ReLU vs. Sigmoid 성능 비교</p></li><li><p>인공신경망 최적화 - Optimizer</p></li><li><p>인공신경망 최적화 - 가중치 초기값</p></li><li><p>인공신경망 최적화 - 드랍아웃(Dropout)</p></li></ol><h2 id="줄리아-사용법">줄리아 사용법</h2><p>위 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)를 사용한다. 그렇다면 왜 파이썬이 아니라 줄리아로 구현하는가? 그 이유는 간단하다. 머신러닝을 구현하는 데 있어 줄리아는 오로지 내장 함수만을 사용하여 모든 구현이 가능하다. 만약 줄리아 언어 자체를 배우고 싶다면 블로그 내에 <a href="https://dev-bearabbit.github.io/categories/language/julia/">"Think Julia"</a>을 정리한 시리즈가 있다.</p><h3 id="배열-생성하기">배열 생성하기</h3><p>신경망의 데이터들은 모두 배열로 구성되어 있기 때문에 배열을 필수적으로 생성해야 한다. 따라서 본격적으로 딥러닝을 구현하기 전에 줄리아에서는 어떻게 배열을 생성하는지에 대해 다뤄볼 것이다.</p><p>줄리아의 큰 장점 중 하나는 파이썬이나 R과는 다르게 1차원부터 n차원까지의 배열을 한 가지의 자료형으로 표현한다는 것이다. 그렇기에 우리는 차원의 구분없이 간단한 코드로 여러 차원의 배열을 생성할 수 있다. 줄리아에서 2차원 배열을 구현하는 방법은 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>]<br><span class="hljs-number">1</span>×<span class="hljs-number">6</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Int64</span>,<span class="hljs-number">2</span>&#125;:<br> <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span><br><br>Julia&gt; [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>; <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>]<br><span class="hljs-number">2</span>×<span class="hljs-number">3</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Int64</span>,<span class="hljs-number">2</span>&#125;:<br> <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span><br> <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>줄리아는 배열에 <code>;</code>를 추가하면 2차원 배열을 반환한다. 위의 예시는 직접 데이터를 입력하는 경우이다. 만약 데이터가 랜덤 값인 배열을 생성하고 싶다면 어떻게 해야 하는가? 지금부터는 다양한 배열들을 구현하는 함수들을 살펴볼 것이다.</p><h4 id="모든-요소가-1인-배열">모든 요소가 1인 배열</h4><p>아래의 코드는 모든 요소가 1인 2차원 배열을 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; ones(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)<br><span class="hljs-number">3</span>×<span class="hljs-number">5</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-number">2</span>&#125;:<br> <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span><br> <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span><br> <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure><p>결과에서 알 수 있듯이 요소는 모두 소수형태인 1로 반환되며, 2차원 배열을 생성하는 방법은 <code>ones(row,column)</code>순서이다. 3차원 배열을 만드는 코드는 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; ones(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>)<br><span class="hljs-number">3</span>×<span class="hljs-number">5</span>×<span class="hljs-number">2</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-number">3</span>&#125;:<br>[:, :, <span class="hljs-number">1</span>] =<br> <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span><br> <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span><br> <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span><br><br>[:, :, <span class="hljs-number">2</span>] =<br> <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span><br> <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span><br> <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure><p>위의 배열은 3차원 배열이며, 이를 생성하는 방법은 <code>ones(row,column,third dimension)</code> 순서이다. 예시를 보면서 파악했을 수도 있지만 매개 변수의 개수가 차원의 크기와 동일하다. 즉, <code>ones(3,5,2,3)</code>은 4차원 배열을 반환한다.</p><h4 id="모든-요소가-0인-배열">모든 요소가 0인 배열</h4><p>아래의 코드는 모든 요소가 0인 2차원 배열을 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; zeros(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><span class="hljs-number">2</span>×<span class="hljs-number">3</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-number">2</span>&#125;:<br> <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span><br> <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span><br></code></pre></td></tr></table></figure><p><code>zeros()</code>와 <code>ones()</code>는 요소의 값만 다를 뿐 문법은 같다. 즉, <code>zeros(2,3,2)</code>는 3차원 배열을 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; zeros(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)<br><span class="hljs-number">2</span>×<span class="hljs-number">3</span>×<span class="hljs-number">2</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-number">3</span>&#125;:<br>[:, :, <span class="hljs-number">1</span>] =<br> <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span><br> <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span><br><br>[:, :, <span class="hljs-number">2</span>] =<br> <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span><br> <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span><br></code></pre></td></tr></table></figure><h4 id="모든-요소가-정수-n인-배열">모든 요소가 정수 n인 배열</h4><p>0과 1이 아닌 정수 n을 값으로 하는 배열을 만들고 싶다면 <code>fill()</code>을 사용하면 된다. 예시는 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; fill(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br><span class="hljs-number">3</span>×<span class="hljs-number">4</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Int64</span>,<span class="hljs-number">2</span>&#125;:<br> <span class="hljs-number">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">2</span><br> <span class="hljs-number">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">2</span><br> <span class="hljs-number">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>위 배열은 요소가 2인 2차원 배열이다. 즉, 첫 번째 매개 변수가 요소의 값이고 뒤의 매개 변수들이 행과 열인 것이다. 3차원 배열을 만드는 법은 다른 함수들과 같이 매개 변수를 추가하면 된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; fill(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>)<br><span class="hljs-number">3</span>×<span class="hljs-number">4</span>×<span class="hljs-number">2</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Int64</span>,<span class="hljs-number">3</span>&#125;:<br>[:, :, <span class="hljs-number">1</span>] =<br> <span class="hljs-number">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">2</span><br> <span class="hljs-number">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">2</span><br> <span class="hljs-number">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">2</span><br><br>[:, :, <span class="hljs-number">2</span>] =<br> <span class="hljs-number">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">2</span><br> <span class="hljs-number">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">2</span><br> <span class="hljs-number">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="랜덤-배열-만들기">랜덤 배열 만들기</h3><p>앞에서는 하나의 값을 요소로 하는 배열들을 생성하였다. 지금부터는 하나의 값이 아니라 다양한 값을 랜덤으로 가지는 배열들을 만들어 볼 것이다.</p><h4 id="부동소수점-랜덤-배열">부동소수점 랜덤 배열</h4><p>부동소수점을 요소로 가지는 랜덤 배열은 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-number">2</span>&#125;(<span class="hljs-literal">undef</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><span class="hljs-number">2</span>×<span class="hljs-number">3</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-number">2</span>&#125;:<br> <span class="hljs-number">2.53205e-314</span>  <span class="hljs-number">2.53205e-314</span>  <span class="hljs-number">2.37106e-314</span><br> <span class="hljs-number">2.53203e-314</span>  <span class="hljs-number">2.37106e-314</span>  <span class="hljs-number">2.3099e-314</span><br></code></pre></td></tr></table></figure><p><code>&#123;Float64,2&#125;</code> 코드는 배열의 데이터 타입과 차원을 입력하고, <code>(undef, 2, 3)</code> 코드는 랜덤데이터와 행, 열을 입력한다. 그렇다면 3차원 배열을 만들기 위해서는 어떻게 해야 할까? 3차원 배열을 생성해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-number">3</span>&#125;(<span class="hljs-literal">undef</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)<br><span class="hljs-number">2</span>×<span class="hljs-number">3</span>×<span class="hljs-number">2</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-number">3</span>&#125;:<br>[:, :, <span class="hljs-number">1</span>] =<br> <span class="hljs-number">2.52381e-314</span>  <span class="hljs-number">2.52381e-314</span>  <span class="hljs-number">5.0e-324</span><br> <span class="hljs-number">2.55284e-314</span>  <span class="hljs-number">2.52381e-314</span>  <span class="hljs-number">2.52381e-314</span><br><br>[:, :, <span class="hljs-number">2</span>] =<br> <span class="hljs-number">2.52381e-314</span>  <span class="hljs-number">4.0e-323</span>  <span class="hljs-number">1.0e-323</span><br> <span class="hljs-number">2.52381e-314</span>  <span class="hljs-number">5.0e-323</span>  <span class="hljs-number">2.29607e-314</span><br></code></pre></td></tr></table></figure><h4 id="정수-랜덤-배열">정수 랜덤 배열</h4><p>정수로 구성된 랜덤 배열은 간단하다. 부동소수점 랜덤 배열을 생성하는 위의 코드에서 데이터 타입만 변경해주면 된다. 2차원 배열은 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Int64</span>,<span class="hljs-number">2</span>&#125;(<span class="hljs-literal">undef</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><span class="hljs-number">2</span>×<span class="hljs-number">3</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Int64</span>,<span class="hljs-number">2</span>&#125;:<br> <span class="hljs-number">5333990960</span>  <span class="hljs-number">5124673872</span>  <span class="hljs-number">4770</span><br> <span class="hljs-number">5333975168</span>  <span class="hljs-number">4799098432</span>    -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>3차원 배열 또한 차원 수를 변경하고, 매개 변수를 추가하면 된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Int64</span>,<span class="hljs-number">3</span>&#125;(<span class="hljs-literal">undef</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)<br><span class="hljs-number">2</span>×<span class="hljs-number">3</span>×<span class="hljs-number">2</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Int64</span>,<span class="hljs-number">3</span>&#125;:<br>[:, :, <span class="hljs-number">1</span>] =<br> <span class="hljs-number">5108433792</span>  <span class="hljs-number">5108433872</span>           <span class="hljs-number">1</span><br> <span class="hljs-number">5343445008</span>  <span class="hljs-number">5108433632</span>  <span class="hljs-number">5108433952</span><br><br>[:, :, <span class="hljs-number">2</span>] =<br> <span class="hljs-number">5108434032</span>  <span class="hljs-number">12</span>           <span class="hljs-number">2</span><br> <span class="hljs-number">5108434112</span>  <span class="hljs-number">12</span>  <span class="hljs-number">4798283777</span><br></code></pre></td></tr></table></figure><h4 id="범위를-설정한-정수-랜덤-배열">범위를 설정한 정수 랜덤 배열</h4><p>위의 예시들을 보면 1부터 5343445008까지 정말 큰 숫자들이 랜덤으로 선정되는 걸 확인할 수 있다. 5343445008와 같은 큰 숫자가 필요없거나 최대값을 설정해야 한다면, 아래의 함수를 사용하자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; rand(<span class="hljs-number">1</span>:<span class="hljs-number">10</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)<br><span class="hljs-number">2</span>×<span class="hljs-number">4</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Int64</span>,<span class="hljs-number">2</span>&#125;:<br> <span class="hljs-number">8</span>  <span class="hljs-number">7</span>  <span class="hljs-number">10</span>  <span class="hljs-number">10</span><br> <span class="hljs-number">8</span>  <span class="hljs-number">9</span>   <span class="hljs-number">1</span>  <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p><code>rand()</code>는 첫 번째 매개 변수로 범위를 받고, 이후 행과 열을 받는다. 범위 안에서 요소의 값들이 결정되며 3차원 배열 또한 생성 가능하다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; rand(<span class="hljs-number">1</span>:<span class="hljs-number">10</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>)<br><span class="hljs-number">2</span>×<span class="hljs-number">4</span>×<span class="hljs-number">2</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Int64</span>,<span class="hljs-number">3</span>&#125;:<br>[:, :, <span class="hljs-number">1</span>] =<br> <span class="hljs-number">9</span>  <span class="hljs-number">7</span>  <span class="hljs-number">9</span>  <span class="hljs-number">8</span><br> <span class="hljs-number">5</span>  <span class="hljs-number">7</span>  <span class="hljs-number">7</span>  <span class="hljs-number">7</span><br><br>[:, :, <span class="hljs-number">2</span>] =<br> <span class="hljs-number">9</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>  <span class="hljs-number">5</span><br> <span class="hljs-number">9</span>  <span class="hljs-number">3</span>  <span class="hljs-number">3</span>  <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="배열-차원-변경하기">배열 차원 변경하기</h3><p>어떤 배열을 다른 형태의 배열로 변경하고 싶다면 <code>reshape()</code>를 사용할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; a = collect(<span class="hljs-number">1</span>:<span class="hljs-number">16</span>)<br><span class="hljs-number">16</span>-element <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Int64</span>,<span class="hljs-number">1</span>&#125;:<br>  <span class="hljs-number">1</span><br>  <span class="hljs-number">2</span><br>  <span class="hljs-number">3</span><br>  <span class="hljs-number">4</span><br>  ⋮<br> <span class="hljs-number">13</span><br> <span class="hljs-number">14</span><br> <span class="hljs-number">15</span><br> <span class="hljs-number">16</span><br><br></code></pre></td></tr></table></figure><p>위의 객체 <code>a</code>는 <span class="math inline">\(16\times1\)</span> 배열이다. 이 배열을 <span class="math inline">\(4\times4\)</span> 배열로 바꾸고 싶다면 아래와 같이 입력하면 된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; reshape(a,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>)<br><span class="hljs-number">4</span>×<span class="hljs-number">4</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Int64</span>,<span class="hljs-number">2</span>&#125;:<br> <span class="hljs-number">1</span>  <span class="hljs-number">5</span>   <span class="hljs-number">9</span>  <span class="hljs-number">13</span><br> <span class="hljs-number">2</span>  <span class="hljs-number">6</span>  <span class="hljs-number">10</span>  <span class="hljs-number">14</span><br> <span class="hljs-number">3</span>  <span class="hljs-number">7</span>  <span class="hljs-number">11</span>  <span class="hljs-number">15</span><br> <span class="hljs-number">4</span>  <span class="hljs-number">8</span>  <span class="hljs-number">12</span>  <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><p><code>reshape(a,4,4)</code>은 앞에 첫 번째 매개 변수로 기존 배열을 받으며, 이후는 행과 열을 받는다. 데이터의 개수만 맞추면 모든 차원의 배열로 변경할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; reshape(a,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)<br><span class="hljs-number">2</span>×<span class="hljs-number">2</span>×<span class="hljs-number">4</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Int64</span>,<span class="hljs-number">3</span>&#125;:<br>[:, :, <span class="hljs-number">1</span>] =<br> <span class="hljs-number">1</span>  <span class="hljs-number">3</span><br> <span class="hljs-number">2</span>  <span class="hljs-number">4</span><br><br>[:, :, <span class="hljs-number">2</span>] =<br> <span class="hljs-number">5</span>  <span class="hljs-number">7</span><br> <span class="hljs-number">6</span>  <span class="hljs-number">8</span><br><br>[:, :, <span class="hljs-number">3</span>] =<br>  <span class="hljs-number">9</span>  <span class="hljs-number">11</span><br> <span class="hljs-number">10</span>  <span class="hljs-number">12</span><br><br>[:, :, <span class="hljs-number">4</span>] =<br> <span class="hljs-number">13</span>  <span class="hljs-number">15</span><br> <span class="hljs-number">14</span>  <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><p>지금까지 신경망을 배우기 위한 기본적인 배열 처리 방법에 대해서 알아보았다. 이제는 본격적으로 신경망에 대해 알아보자.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>deep learning in julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>딥러닝</tag>
      
      <tag>Deeplearning</tag>
      
      <tag>머신러닝</tag>
      
      <tag>줄리아</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[20/20] 디버깅</title>
    <link href="/ko/ThinkJulia/Think-Julia-Chapter-20/"/>
    <url>/ko/ThinkJulia/Think-Julia-Chapter-20/</url>
    
    <content type="html"><![CDATA[<blockquote><p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p></blockquote><p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap21">Debugging</a>를 한글로 요약 정리한 글입니다. <span id="more"></span></p><h2 id="디버깅-debugging">디버깅 (Debugging)</h2><p>디버깅을 할 때, 보다 신속하게 오류를 추적하려면 여러 종류의 오류를 구분할 수 있어야 한다.</p><ul><li><p>소스 코드가 바이트 코드로 변환할 때 인터프리터가 '문법 오류(Syntax errors )'을 발견하여 프로그램 구조에 문제가 있음을 나타낸다. 예시로 함수 블록 끝에 <code>end</code> 키워드를 생햑하면 아래과 같은 메시지가 생성된다. <code>ERROR: LoadError: syntax: incomplete: function requires end.</code></p></li><li><p>프로그램이 실행되는 동안 문제가 발생하면 인터프리터가 '런타임 오류 (Runtime errors)'를 생성한다. 대부분의 런타임 오류 메시지에는 오류가 발생한 위치 및 실행중인 함수에 대한 정보가 초함된다. 예시로 무한재귀로 인해 결국 런타임 오류가 발생하는 경우를 볼 수 있다. <code>ERROR: StackOverflowError.</code></p></li><li><p>의미 오류(Semantic errors)는 오류 메시지를 생성하지 않고 실행되지만 프로그램이 올바르게 작동하지 않는 문제이다. 예로는 표현식이 예상한 순서대로 평가되지 않아서 잘못된 결과가 발생하는 등이 있다.</p></li></ul><p>디버깅의 첫 번째 단계는 처리중인 오류의 종류를 파악하는 것이다. 아래의 글은 오류 타입 별로 구성되어 있지만, 사실 몇몇 기술들은 둘 이상의 오류를 가진 경우도 있다.</p><h3 id="문법-오류-syntax-errors">문법 오류 (Syntax Errors)</h3><p>문법 오류는 대부분 쉽게 찾아서 수정할 수 있다. 하지만 가끔씩 오류 메시지는 도움을 주지 않는다. 대부분의 일반적인 메시지는 <code>ERROR: LoadError: syntax: incomplete: premature end of input</code> 이나 <code>ERROR: LoadError: syntax: unexpected "=", neither of which</code>으로 어느 것도 유익한 정보를 주지 않는다.</p><p>반면, 메시지는 프로그램에서 문제가 발생한 위치를 알려준다. 줄리아는 문제를 발견한 위치를 전달하는데, 때때로 그 위치는 명확하지 않다. 이런 상황에서 실제 오류 위치는 대부분 오류 메시지가 알려준 위치보다 앞서 있는 경우가 많다.</p><p>프로그램을 점진적으로 개발하는 경우 오류의 위치를 잘 알고 있어야 한다. 이를 위해 추가되는 코드는 아래로 붙이는 것이 좋다.</p><p>책에서 코드를 복사하는 경우 본인의 코드를 책의 코드와 매우 신중하게 비교해야 한다. 되도록이면 모든 글자들을 전부 확인하는 것이 좋다. 동시에 책이 잘못되었을 수 있으므로 문법 오류처럼 보이는 것이 있다면 한번 더 확인해야 한다.</p><p>가장 일반적인 문법 오류들을 피하는 방법은 다음과 같다.</p><ul><li><p>변수 이름에 줄리아 키워드를 사용하지 않기</p></li><li><p>for문, while문, if문, 함수 블록을 포함하여 모든 복합 명령문 끝에 <code>end</code> 키워드가 있는지 확인하기</p></li><li><p>코드에 일치하는 인용 부호가 있는지 확인하기</p></li><li><p>삼중 따옴표(triple quotes)가 있는 문자열인 경우 문자열을 올바르게 종료했는지 확인해야 한다. 종료되지 않은 문자열은 프로그램 끝에서 유효하지 않은 토큰 오류를 발생시키거나 다음 문자열이 나올 때까지 이후 프로그램을 문자열로 인식한다. 두 번째의 경우에는 오류 메시지도 생성되지 않는다.</p></li><li><p>닫히지 않은 (,{,[ 등의 연산자들은 줄리아가 현재 명령문의 일부로 다음 행을 진행하도록 한다. 일반적으로 다음 행에서 오류가 발생한다.</p></li><li><p>조건부 내부에서 <code>==</code>대신에 <code>=</code>를 사용했는지 확인하기</p></li><li><p>코드에 ASCII 외의 다른 문자가 있는 경우 줄리아가 일반적으로 비 ASCII로 처리하지만 문제가 발생할 수 있다. 웹 페이지나 다른 소스에서 텍스트를 붙여 넣을 때는 주의해야 한다.</p></li></ul><p>아무것도 작동하지 않는다면, 아래로 넘어가자.</p><h4 id="코드를-계속-변경하지만-변하는-것이-없습니다">코드를 계속 변경하지만 변하는 것이 없습니다</h4><p>REPL에 오류가 있다고 표시되지만 오류가 보이지 않는다면, REPL과 해당 개발자가 다른 코드를 보고 있을 가능성이 있다. 이럴 때는 프로그래밍 환경을 확인하여 편집중인 프로그램이 줄리아가 실행하려는 프로그램이 맞는지 확인해야 한다.</p><p>확실하지 않은 경우 프로그램을 시작할 때 명확하고 의도적인 구문 오류를 시도하고 다시 실행해보자. REPL에서 새 오류를 찾지 못하면 새 코드를 실행하지 않은 것이다.</p><p>몇 가지 주요 원인은 아래와 같다.</p><ul><li><p>파일을 편집하고 다시 실행하기 전에 변경 사항을 저장하는 것을 잊었다. 일부 프로그래밍 환경에서는 이 작업을 수행하지만 그렇지 않은 환경도 있다.</p></li><li><p>파일 이름을 변경했지만 여전히 이전 이름을 사용하여 실행중이다.</p></li><li><p>개발 환경의 무언가가 잘못 구성되었다.</p></li><li><p>모듈을 작성하고 사용하는 경우, 표준 줄리아 모듈 중 하나와 이름을 동일하게 지정하면 안된다.</p></li><li><p><code>using</code>을 사용하여 모듈을 가져오는 경우, 모듈에서 코드를 수정할 때 REPL을 다시 시작해야 한다. 모듈을 다시 가져오면 아무 작업도 수행되지 않는다.</p></li></ul><p>문제가 발생하여 진행 상황을 파악할 수 없는 경우 한 가지 방법은 "Hello, world"와 같은 새로운 프로그램으로 다시 시작하는 것이다. 이후 원래 프로그램의 조각을 새 프로그램에 점차적으로 추가하면 된다.</p><h3 id="런타임-오류-runtime-errors">런타임 오류 (Runtime Errors)</h3><p>프로그램이 문법상 올바른 경우 줄리아는 적어도 프로그램을 읽고 실행할 수 있다. 그렇다면 무엇이 더 잘못될 수 있을까?</p><h4 id="내-프로그램은-아무것도-하지-않습니다">내 프로그램은 아무것도 하지 않습니다</h4><p>이 문제는 함수와 클래스로 구성된 파일이 실행을 시작하기 위해 함수를 호출하지 않는 경우가 가장 일반적이다. 만약 클래스와 함수를 제공하기 위한 모듈만 계획한다면 이것은 아마 의도적일 수 있다.</p><p>의도하지 않은 경우, 프로그램에 함수 호출이 있는지 확인하고 실행 흐름에 도달했는지 확인하라</p><h4 id="내-프로그램이-멈췄습니다">내 프로그램이 멈췄습니다</h4><p>프로그램이 멈추고 아무 것도 하지 않는 것 같다면 "매달려(hang)" 있는 것이다. 그것은 무한 루프 또는 무한 재귀에 걸리는 것을 의미한다.</p><ul><li><p>문제가 있다고 생각되는 특정 루프가 있는 경우 루프 바로 시작점에 "루프 입력", 종료점에 "루프 종료"라고 인쇄문을 추가하고 프로그램을 실행하라. 첫 번째 메시지만 받으면 무한 루프이며, 아래의 무한 루프 파트를 참고하라</p></li><li><p>대부분의 경우 무한 재귀로 인해 프로그램이 잠시 실행된 다음 <code>ERROR: LoadError: StackOverflowError</code> 오류가 발생한다. 이런 경우 아래의 무한 재귀를 참고하라.</p></li><li><p>이들 단계 중 어느 것도 작동하지 않는다면 다른 루프, 기타 재귀 함수 및 메서드 테스트를 시작하라.</p></li><li><p>그래도 문제가 해결되지 않는다면 프로그램의 실행 흐름을 이해 못한 것일 가능성이 높다. 아래의 실행 흐름 파트를 확인하라.</p></li></ul><h4 id="무한-루프">무한 루프</h4><p>무한 루프를 가지고 있다고 생각하고 어떤 루프가 문제인건지 안다면 해당 루프 끝에 조건의 변수 값과 조건 값을 인쇄하는 출력문을 추가해보자.</p><p>예를 들면 아래의 코드와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">while</span> x &gt; <span class="hljs-number">0</span> &amp;&amp; y &lt; <span class="hljs-number">0</span><br>    <span class="hljs-comment"># do something to x</span><br>    <span class="hljs-comment"># do something to y</span><br>    <span class="hljs-meta">@debug</span> <span class="hljs-string">&quot;variables&quot;</span> x y<br>    <span class="hljs-meta">@debug</span> <span class="hljs-string">&quot;condition&quot;</span> x &gt; <span class="hljs-number">0</span> &amp;&amp; y &lt; <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>이제 프로그램을 디버그 모드로 작동하면, 루프가 작동할 때마다 변수 값과 상태를 볼 수 있다. 루프의 마지막 작동에서 상태는 <code>false</code>가 나와야 한다. 만약 루프가 계속 작동된다면 <code>x</code>와 <code>y</code>의 값을 볼 수 있으며, 왜 그 값들이 제대로 업데이트되지 않는지 찾을 수 있을 것이다.</p><h4 id="무한-재귀">무한 재귀</h4><p>대부분의 경우, 무한 재귀는 프로그램이 잠시 실행되었다가 <code>ERROR: LoadError: StackOverflowError</code>와 같은 오류가 바로 발생한다.</p><p>만약 함수가 무한 재귀를 일으킨다고 의심되면 조건 코드를 확인해봐야 한다. 재귀 호출을 하지 않고 함수가 반환되도록 하는 조건이 있어야 한다. 그렇지 않은 경우 알고리즘을 다시 생각하고 조건 코드를 작성해야 한다.</p><p>조건이 명확함에도 프로그램이 멈추지 않는 경우에는 함수의 시작 부분에 매개 변수를 출력하는 출력문을 추가하자. 이후 프로그램을 실행하면 함수가 호출될 때마다 매개 변수 값이 출력된다. 조건문으로 이동하지 않는 이유에 대한 아이디어를 얻을 수도 있다.</p><h4 id="실행-흐름">실행 흐름</h4><p>프로그램에서 실행 흐름이 어떻게 움직이는지 확실하지 않다면, "함수 시작 (함수 이름)" 이런 문구를 함수 시작 부분에 출력문으로 추가하자.</p><p>그러면 프로그램이 작동할 때, 각 함수들의 이름이 출력될 것이다.</p><h4 id="프로그램을-실행할-때-예외가-발생합니다">프로그램을 실행할 때 예외가 발생합니다</h4><p>런타임동안 무언가 잘못되었다면 줄리아는 예외의 이름과 위치를 포함한 메시지를 출력한다.</p><p>stacktrace는 현재 실행중인 함수부터 호출되었던 함수들을 계속 식별한다. 즉, 각 호출이 발생한 파일의 줄 번호를 포함하여 현재 위치로 오는 과정의 함수 호출 순서를 추적하는 것이다.</p><p>첫 번째 단계는 오류가 발생한 프로그램의 위치를 확인하고 발생한 문제를 파악할 수 있는지 확인하는 것이다. 다음은 가장 일반적인 런타임 오류 중 일부이다.</p><ul><li><p>ArgumentError 함수 호출에 대한 인수 중 하나가 잘못된 경우</p></li><li><p>BoundsError 배열 인덱싱 작업이 범위를 벗어난 요소에 엑세스하려는 경우</p></li><li><p>DomainError 함수 또는 생성자에 대한 인수가 유효한 도메인 외부에 있는 경우</p></li><li><p>DivideError 분모 값이 0인 정수 나누기를 시도한 경우</p></li><li><p>EOFError 파일이나 스트림에서 더 이상 읽을 데이터가 없는 경우</p></li><li><p>InexactError 정확하게 데이터 타입으로 변환할 수 없는 경우</p></li><li><p>KeyError AbstractDict(Dict) 또는 Set 등 인덱싱 작업이 불가능한 객체에 인덱스를 통해 요소에 접근하거나 삭제하려는 경우</p></li><li><p>MethodError 주어진 함수에 필요한 메서드가 존재하지 않은 경우</p></li><li><p>OutOfMemoryError 시스템이 올바르게 처리하기에는 너무 많은 메모리를 할당한 조작인 경우</p></li><li><p>OverflowError 표현식의 결과가 지정된 데이터 타입에 비해 너무 커서 랩어라운드(wraparound)를 발생시키는 경우</p></li><li><p>StackOverflowError 함수 호출이 호툴 스택의 크기를 넘어선 경우 (일반적으로 호출이 무한번 반복될 때 발생한다.)</p></li><li><p>StringIndexError 유효하지 않은 인덱스로 문자열에 접근하는 경우</p></li><li><p>SystemError 오류 코드와 함께 시스템 호툴에 실패한 경우</p></li><li><p>TypeError 데이터 타입이 이상하거나 또는 잘못된 데이터 타입을 인수로 가진 함수를 호출한 경우</p></li><li><p>UndefVarError 현재 범위에서의 심볼(symbol)이 정의되어 있지 않은 경우</p></li></ul><h4 id="프린트문을-너무-많이-추가해서-결과가-넘칩니다">프린트문을 너무 많이 추가해서 결과가 넘칩니다</h4><p>디버깅에 프린트문을 사용할 때 발생하는 문제 중 하나는 출력에 묻힐 수도 있다는 점이다. 해결 방안으로는 출력을 단순화하거나 프로그램을 단순화하는 두 가지의 방법이 있다.</p><p>출력을 단순화하기 위해 도움이 되지 않는 인쇄 설명을 제거하거나 주석 처리하거나 이해하기 쉽도록 출력을 형식화 할 수 있다.</p><p>프로그램을 단순화하기 위해 할 수 있는 몇 가지가 있다. 먼저 프로그램이 진행중인 문제를 축소하라. 예를 들어 목록을 검색하는 경우에는 작은 목록을 검색하는 것이다. 프로그램이 사용자로부터 입력을 받는 경우 문제를 일으키는 가장 간단한 입력을 제공하면 된다.</p><p>둘째, 프로그램을 정리하라. 데드 코드를 제거하고 가능한 쉽게 읽을 수 있도록 프로그램을 재구성하라. 예를 들어 프로그램의 중첩된 부분에 문제가 있다고 생각된다면 간단한 구조로 해당 부분을 다시 작성하면 된다. 큰 함수가 의심되는 경우에는 작은 함수로 분할하여 별도로 테스트하면 된다.</p><p>작은 크기의 테스트 과정에서 종종 버그를 발견한다. 어떤 상황에서는 프로그램이 작동하지만 다른 상황에서는 작동하지 않는다는 것을 알게 되면 무슨 일이 일어나고 있는지에 대한 실마리를 얻을 수 있다.</p><p>마찬가지로 코드를 다시 작성하면 미묘한 버그를 찾는 데 도움이 될 수 있다. 프로그램에 영향을 미치지 않아야 한다고 생각되는 변화를 만들고 작동하면 버그를 찾을 수도 있다.</p><h3 id="의미-오류-semantic-errors">의미 오류 (Semantic Errors)</h3><p>어떤 면에서 의미 오류는 인터프리터가 오류에 대한 정보를 제공하지 않기 때문에 디버그하기 가장 어렵다. 오직 개발자만이 어떻게 프로그램이 진행되어야 하는지 알고 있다.</p><p>첫 번째 단계는 프로그램 텍스트와 현재 보고 있는 동작을 연결하는 것이다. 이를 위해서는 프로그램이 실제로 작동하고 있는 것에 대한 가설이 필요하다. 하지만 가설을 확인하기에는 프로그램 작동이 너무 빠르게 진행된다.</p><p>그래서 개발자들은 종종 프로그램을 인간과 같은 속도로 늦출 수 있기를 바란다. 잘 배치된 프린트문을 삽입하는 것이 디버거(debugger)를 셋팅하거나 중단 포인트를 삽입하는 것보다 더 빠르다.</p><h4 id="내-프로그램이-작동하지-않습니다">내 프로그램이 작동하지 않습니다</h4><p>아래와 같은 질문을 스스로에게 해야한다.</p><ul><li><p>프로그램이 제대로 작동하지 않는 것 같은가? 해당 기능을 수행하는 코드 섹션을 찾아 필요할 때 실행되는지 확인하라.</p></li><li><p>일어나면 안되는 것들이 발생했는가? 프로그램에서 해당 기능을 수행한느 코드를 찾고 실행하지 않아야 할 때 실행 중인지 확인하라.</p></li><li><p>코드 섹션이 예상과 다른 결과를 도출하는가? 특히 줄리아 모듈의 함수 및 메서드와 관련된 코드인 경우 문제의 코드를 이해해야 한다. 호출한 함수에 대한 설명서를 읽은 후 간단한 테스트 사례를 작성하고 결과를 확인하여 시험해보라.</p></li></ul><p>프로그래밍을 하려면 프로그램 작동 방식에 대한 추상적 모델이 필요하다. 프로그램이 예상대로 되지 않는 이유 중에 종종 추상적 모델 자체가 잘못된 경우가 있다.</p><p>추상적 모델을 수저어하는 가장 좋은 방법은 프로그램을 구성요소로 나누고 각 구성요소를 독립적으로 테스트하는 것이다. 현실과 추상적 모델의 차이가 발견되면 문제를 해결할 수 있다.</p><p>물론 프로그램을 개발할 때 구성요소를 작성하고 테스트해야 한다. 문제가 발생하면 정확하지 않은 소량의 새 코드가 문제여야 한다.</p><h4 id="크고-거친-표현식을-사용해서-기대한-대로-작동하지-않습니다">크고 거친 표현식을 사용해서 기대한 대로 작동하지 않습니다</h4><p>복잡한 표현식을 작성하는 것은 읽기 쉬우면 괜찮지만 디버깅하기 어려울 수 있다. 복잡한 표현을 임시 변수에 대한 할당으로 나누는 것이 더 좋을 수 있다.</p><p>예시는 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">addcard(game.hands[i], popcard(game.hands[findneighbor(game, i)]))<br></code></pre></td></tr></table></figure><p>위의 코드를 아래와 같이 다시 작성할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia">neighbor = findneighbor(game, i)<br>pickedcard = popcard(game.hands[neighbor])<br>addcard(game.hands[i], pickedcard)<br></code></pre></td></tr></table></figure><p>변수 이름은 추가적인 설명으로 제공되기 때문에 보다 쉽게 읽을 수 있으며, 중간 변수의 데이터 타입을 확인하고 해당 값을 표시할 수 있으므로 디버그하기가 더 쉽다.</p><p>큰 표현식으로 인해 발생할 수 있는 또 다른 문제는 평가 순서가 예상과 다를 수 있다는 점이다. 예를 들어 <span class="math inline">\(\frac{x}{2π}\)</span>을 줄리아에서 작성하는 경우는 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">y = x / <span class="hljs-number">2</span> * <span class="hljs-literal">π</span><br></code></pre></td></tr></table></figure><p>곱셈과 나눗셈은 같은 순서라서 왼쪽에서 오른쪽으로 평가되기 때문에 위의 코드는 정확하지 않다. 이 표현식은 <span class="math inline">\(\frac{xπ}{2}\)</span>로 계산된다.</p><p>디버그하기 위한 좋은 표현식은 괄호를 추가해서 평가 순서를 정확하게 정해주는 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">y = x / (<span class="hljs-number">2</span> * <span class="hljs-literal">π</span>)<br></code></pre></td></tr></table></figure><p>만약에 평가 순서를 확신할 수 없다면, 괄호를 사용하라. 프로그램 작동이 정확할뿐만 아니라 작업 순서를 외우지 않은 다른 사람들도 더 읽기 쉽다.</p><h4 id="함수는-있는데-기대했던-결과를-반환하지-않습니다">함수는 있는데 기대했던 결과를 반환하지 않습니다</h4><p>복잡한 식의 반환문이 있는 경우 반환하기 전에 결과를 볼 기회가 없다. 다시 말하면, 임시 변수를 사용할수 있다는 것이다. 예를 들면 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">return</span> removematches(game.hands[i])<br></code></pre></td></tr></table></figure><p>위의 코드를 아래와 같이 바꿀 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">count = removematches(game.hands[i])<br><span class="hljs-keyword">return</span> count<br></code></pre></td></tr></table></figure><p>이제는 반환하기 전에 변수 <code>count</code>를 확인해볼 수 있다.</p><h4 id="디버깅하다가-막혀서-도움이-필요합니다">디버깅하다가 막혀서 도움이 필요합니다</h4><p>먼저 몇 분정도 컴퓨터에서 벗어나라. 컴퓨터를 사용하다보면 아래와 같은 증상이 나타날 수 있다.</p><ul><li>좌절과 분노</li><li>미신적 신념과 마법적 사고</li><li>랜덤 워크 프로그래밍</li></ul><p>이런 증상으로 고통받고 있다면 일어나서 산책을 하는 것도 좋다. 침착할 때 프로그램에 대해 생각하라. 어떻게 작동하는가? 오류 발생하기 직전의 수정은 무엇이었나? 등등</p><p>때로는 버그를 찾는 데 시간이 걸린다. 컴퓨터에서 멀리 떨어져 있을 때 종종 버그를 찾게 된다. 버그를 찾는 가장 좋은 장소는 기차, 샤워시설, 잠들기 직전 등이 있다.</p><h4 id="진지하게-정말-도움이-필요합니다">진지하게 정말 도움이 필요합니다</h4><p>최고의 프로그래머조차도 때때로 막힌다. 또한 프로그램에서 작업하면서 오류를 보지 못하는 경우도 종종 있다. 그래서 신선한 눈이 필요하다.</p><p>다른 사람을 데려 오기 전에 미리 준비하라. 프로그램은 가능한 단순해야 하며 오류를 발생시키는 가장 작은 입력에 대해 작업해야 한다. 적절한 장소에 프린트문이 있어야 하며, 간결하게 설명할 수 있을 정도로 문제를 잘 이해해야 한다.</p><p>도움을 받기 위해 누군가를 데려올 때 필요한 정보를 제공하라.</p><ul><li><p>오류 메시지가 있는 경우 오류 메시지는 무엇이며 어떤 부분을 나타내는가?</p></li><li><p>이 오류가 발생하기 전에 마지막으로 수행한 작업은 무엇이며, 마지막 코드 줄은 무엇인가? 테스트한 결과는 어떠한가?</p></li><li><p>지금까지 무엇을 시도했으며, 어떤 결과를 얻었나?</p></li></ul><p>버그를 발견하면 잠시 시간을 내어 버그를 더 빨리 찾을 수 있는 방법에 대해 생각하라. 다음에 비슷한 버그를 발견하면 더 빨리 해결할 수 있다.</p><p>목표는 단지 프로그램을 작동시키는 것이 아니라는 점을 기억하라. 목표는 프로그램 작동 방법을 배우는 것이다.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>think julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>줄리아</tag>
      
      <tag>Julia</tag>
      
      <tag>Think Julia</tag>
      
      <tag>기초 강의</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[19/20] 베이스 및 표준 라이브러리</title>
    <link href="/ko/ThinkJulia/Think-Julia-Chapter-19/"/>
    <url>/ko/ThinkJulia/Think-Julia-Chapter-19/</url>
    
    <content type="html"><![CDATA[<blockquote><p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p></blockquote><p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap20">The Goodies: Base and Standard Library</a>를 한글로 요약 정리한 글입니다. <span id="more"></span></p><h2 id="베이스-및-표준-라이브러리-base-and-standard-library">베이스 및 표준 라이브러리 (Base and Standard Library)</h2><p>줄리아는 기본 배터리가 포함되어 있다. 즉, 베이스(base) 모듈에는 가장 유용한 함수들, 데이터 타입 및 매크로가 포함된다. 이들은 모두 줄리아에서 바로 사용할 수 있다.</p><p>또한 줄리아는 표준 라이브러리에 많은 특수 모듈을 제공한다. 이를 사용하기 위해서는 먼저 라이브러리를 가져와야 한다.</p><ul><li><p><code>import Module</code>은 모듈을 가져오며, <code>Module.fn(x)</code>은 함수 <code>fn</code>을 호출한다.</p></li><li><p><code>using Module</code>은 모든 모듈 함수, 데이터 타입, 매크로를 가져온다.</p></li></ul><p>이 장은 공식적인 줄리아 문서를 대신하지는 않으며, 완벽한 것이 아니라 가능한 것에 대한 예시들을 제시할 것이다. 해당 예시에는 다른 곳에서 이미 소개된 함수들은 포함되지 않는다. 완벽한 전체 개요는 <a href="https://docs.julialang.org">이 링크</a>에서 찾을 수 있다.</p><h3 id="성능-측정-measuring-performance">성능 측정 (Measuring Performance)</h3><p>우리는 몇몇 알고리즘이 다른 알고리즘보다 성능이 우수하다는 것을 알았다. 실제로 <a href="https://dev-bearabbit.github.io/2020/03/10/ThinkJulia/Think-Julia-Chapter-11/">메모 파트</a>에 나온 <code>fibonnaci</code>는 <a href="https://dev-bearabbit.github.io/2020/03/03/ThinkJulia/Think-Julia-Chapter-6/">연습해보기</a>의 <code>fib</code>보다 훨씬 빠르다. <code>@time</code>을 사용하면 성능 차이를 숫자로 표현할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; fib(<span class="hljs-number">1</span>)<br><span class="hljs-number">1</span><br>julia&gt; fibonacci(<span class="hljs-number">1</span>)<br><span class="hljs-number">1</span><br>julia&gt; <span class="hljs-meta">@time</span> fib(<span class="hljs-number">40</span>)<br>  <span class="hljs-number">0.567546</span> seconds (<span class="hljs-number">5</span> allocations: <span class="hljs-number">176</span> bytes)<br><span class="hljs-number">102334155</span><br>julia&gt; <span class="hljs-meta">@time</span> fibonacci(<span class="hljs-number">40</span>)<br>  <span class="hljs-number">0.000012</span> seconds (<span class="hljs-number">8</span> allocations: <span class="hljs-number">1.547</span> KiB)<br><span class="hljs-number">102334155</span><br></code></pre></td></tr></table></figure><p><code>@time</code>은 함수를 실행하는 데 걸린 시간, 할당 횟수 및 결과를 반환하기 전에 할당된 메모리를 출력한다. 메모 파트에서의 <code>fibonacci</code>는 훨씬 빠르지만 더 많은 메모리를 차지한다.</p><blockquote><p>세상에 공짜는 없다!</p></blockquote><p><strong>TIP</strong> 줄리아의 함수는 처음 실행될 때 컴파일된다. 따라서 두 알고리즘을 비교하려면 컴파일할 함수로 구현해야 하며, 처음 호출할 때는 성능 측정을 하면 안된다. 그렇지 않다면 컴파일 시간도 측정된다. 패키지 <a href="https://github.com/JuliaCI/BenchmarkTools.jl"><code>BenchmarkTools</code></a>은 올바른 방법으로 벤치마킹하는 매크로 <code>@btime</code>을 제공한다.</p><h3 id="모음-및-데이터-구조-collections-and-data-structures">모음 및 데이터 구조 (Collections and Data Structures)</h3><p><a href="https://dev-bearabbit.github.io/2020/03/12/ThinkJulia/Think-Julia-Chapter-13/">딕셔너리 뺌셈 파트</a>에서 우리는 딕셔너리를 사용하여 문서에는 있지만 단어 배열에는 없는 단어를 찾았다. 해당 함수는 문서의 단어를 키로 포함한 <code>d1</code>과 단어 배열을 포함한 <code>d2</code>를 가져간다. 그후 <code>d2</code>에 없는 <code>d1</code>의 키를 포함한 딕셔너리를 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> subtract(d1, d2)<br>    res = <span class="hljs-built_in">Dict</span>()<br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> keys(d1)<br>        <span class="hljs-keyword">if</span> key ∉ keys(d2)<br>            res[key] = <span class="hljs-literal">nothing</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    res<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 딕셔너리에서 값은 사용하지 않기 때문에 <code>nothing</code>이먀, 결과적으로 저장 공간이 낭비된 것이다.</p><p>줄리아는 마치 딕셔너리에서 키만 수집한 모음과 같은 <code>셋(set)</code>이라고 불리는 다른 내장 데이터 타입을 제공한다. 셋에 요소를 추가하는 것은 빠르다. 그리고 셋은 일반적인 작동을 계산하는 함수와 연산자를 제공한다.</p><p>예를 들어 셋 뺄셈은 <code>setdiff()</code>라는 함수를 사용하면 가능하다. 그래서 아래의 코드처럼 <code>subtract()</code>을 재작성한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> subtract(d1, d2)<br>    setdiff(d1, d2)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>결과는 딕셔너리를 대신한 셋 형태이다.</p><p>이 책의 몇 가지 예제는 셋을 사용하여 간결하고 효율적으로 실행할 수 있다. 다음은 딕셔너리를 사용하여 중복을 해결하는 솔루션이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> hasduplicates(t)<br>    d = <span class="hljs-built_in">Dict</span>()<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> t<br>        <span class="hljs-keyword">if</span> x ∈ d<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        <span class="hljs-keyword">end</span><br>        d[x] = <span class="hljs-literal">nothing</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-literal">false</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>요소가 처음에 나타날 때는 딕셔너리에 추가된다. 만약 동일한 요소가 다시 나타나면 이 함수는 <code>true</code>을 반환한다.</p><p>셋을 사용하면 우리는 같은 함수를 아래와 같이 작성할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> hasduplicates(t)<br>    length(<span class="hljs-built_in">Set</span>(t)) &lt; length(t)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>요소는 오직 셋에서 한번만 나타날 수 있기 때문에 <code>t</code>의 요소가 한번 이상으로 나타나면 셋은 <code>t</code>보다 더 작아질 것이다. 만약 중복이 없다면 셋은 <code>t</code>와 똑같은 사이즈일 것이다.</p><p>또한 <a href="https://dev-bearabbit.github.io/2020/03/06/ThinkJulia/Think-Julia-Chapter-9/">워드 플레이 예제</a>에서도 셋을 사용할 수 있다. 예를 들어 루프가 포함된 <code>useonly</code>의 버전을 확인해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> usesonly(word, available)<br>    <span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> word<br>        <span class="hljs-keyword">if</span> letter ∉ available<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>useonly</code>는 <code>word</code>에 있는 모든 알파벳들이 <code>available</code>에 속해 있는지를 확인한다. 위의 함수를 아래와 같이 재작성할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> usesonly(word, available)<br>    <span class="hljs-built_in">Set</span>(word) ⊆ <span class="hljs-built_in">Set</span>(available)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>⊆ (\subseteq TAB)</code> 연산자는 두 개의 <code>word</code>의 단어가 <code>available</code>와 같은지의 가능성을 포함하여 한 셋이 서브셋인지를 확인한다.</p><h3 id="수학-mathematics">수학 (Mathematics)</h3><p>복소수(Complex numbers)는 줄리아에서 제공된다. 글로벌 상수 <code>im</code>은 복소수 <span class="math inline">\(i\)</span>이며, <span class="math inline">\(-1\)</span>의 제곱근을 나타낸 것이다.</p><p>이제는 오일러의 등식(Euler’s identity)을 확인할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-literal">ℯ</span>^(<span class="hljs-literal">im</span>*<span class="hljs-literal">π</span>)+<span class="hljs-number">1</span><br><span class="hljs-number">0.0</span> + <span class="hljs-number">1.2246467991473532e-16</span><span class="hljs-literal">im</span><br></code></pre></td></tr></table></figure><p>기호 <code>ℯ (\euler TAB)</code>는 자연로그의 기초이다.</p><p>이제는 삼각함수의 식을 작성해보자.</p><p><span class="math display">\[\begin{equation}cos(x)=\frac{e^{ix}+e^{-1x}}{2}\end{equation}\]</span></p><p>우리는 x에 다른 값을 넣어서 위의 방정식을 테스트할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; x = <span class="hljs-number">0</span>:<span class="hljs-number">0.1</span>:<span class="hljs-number">2</span><span class="hljs-literal">π</span><br><span class="hljs-number">0.0</span>:<span class="hljs-number">0.1</span>:<span class="hljs-number">6.2</span><br>julia&gt; cos.(x) == <span class="hljs-number">0.5</span>*(<span class="hljs-literal">ℯ</span>.^(<span class="hljs-literal">im</span>*x)+<span class="hljs-literal">ℯ</span>.^(-<span class="hljs-literal">im</span>*x))<br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>위의 코드는 점 연산자의 다른 예시이다. 줄리아는 또한 숫자가 <code>2π</code>와 같은 계수로서 병치되는 것을 허용한다.</p><h3 id="문자열">문자열</h3><p><a href="https://dev-bearabbit.github.io/2020/03/05/ThinkJulia/Think-Julia-Chapter-8/">문자열 파트</a>와 <a href="https://dev-bearabbit.github.io/2020/03/06/ThinkJulia/Think-Julia-Chapter-9/">워드 플레이 파트</a>에서는 우리는 문자열 객체에서 몇 가지 기본 검색을 진행하였다. 그러나 줄리아는 'Perl 호환 정규식(PCRE)'을 처리할 수 있으므로 문자열 객체에서 복잡한 채턴을 쉽게 찾을 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> usesonly(word, available)<br>  r = <span class="hljs-built_in">Regex</span>(<span class="hljs-string">&quot;[^<span class="hljs-subst">$(available)</span>]&quot;</span>)<br>  !occursin(r, word)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>정규식(regex)은 <code>available</code> 문자열에 없는 문자를 찾고, <code>occursin</code>은 패턴이 <code>word</code>에 있는 경우 <code>true</code>를 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; usesonly(<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;abn&quot;</span>)<br><span class="hljs-literal">true</span><br>julia&gt; usesonly(<span class="hljs-string">&quot;bananas&quot;</span>, <span class="hljs-string">&quot;abn&quot;</span>)<br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>정규식들은 <code>r</code>을 붙이면 일반적이지 않은 문자열로도 구성될 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; match(<span class="hljs-string">r&quot;[^abn]&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>)<br><br>julia&gt; m = match(<span class="hljs-string">r&quot;[^abn]&quot;</span>, <span class="hljs-string">&quot;bananas&quot;</span>)<br><span class="hljs-built_in">RegexMatch</span>(<span class="hljs-string">&quot;s&quot;</span>)<br></code></pre></td></tr></table></figure><p>위의 경우에는 문자열 보간이 허용되지 않는다. <code>match()</code>는 패턴을 찾지 못하면 아무것도 반환하지 않으며, 패턴을 찾으면 'regexmatch' 객체를 반환한다.</p><p>정규식 객체에서 다음 정보를 추출할 수 있다.</p><ul><li>매치된 전체 서브문자열: <code>m.match</code></li><li>캡처된 서브문자열을 문자 배열화: <code>m.captures</code></li><li>전체 매치가 시작되는 오프셋: <code>m.offset</code></li><li>캡쳐된 서브문자열 오프셋의 배열: <code>m.offsets</code></li></ul><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; m.match<br><span class="hljs-string">&quot;s&quot;</span><br>julia&gt; m.offset<br><span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>정규식들은 매우 강력하며, <a href="http://perldoc.perl.org/perlre.html">PERL 페이지</a>에서 다양한 세부 정보들을 제공한다.</p><h3 id="배열">배열</h3><p><a href="https://dev-bearabbit.github.io/2020/03/08/ThinkJulia/Think-Julia-Chapter-10/">배열 파트</a>에서는 배열 객체를 인덱스를 가진 1차원 컨테이너를 사용하여 해당 요소를 처리하였다. 하지만 줄리아에서 배열은 다차원 컬렉션이다.</p><p>2 x 3 제로 행렬을 만들어보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; z = zeros(<span class="hljs-built_in">Float64</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-number">2</span>×<span class="hljs-number">3</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-number">2</span>&#125;:<br> <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span><br> <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span><br>julia&gt; typeof(z)<br><span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure><p>이 매트릭스의 데이터 타입은 부동소수점으로 구성된 2차원 배열이다. <code>size()</code>는 각 차원을 나타내는 숫자를 요소로 가진 튜플을 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; size(z)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p><code>ones()</code>는 인수로 데이터 타입과 숫자를 받아 매트릭스를 생성한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; s = ones(<span class="hljs-built_in">String</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br><span class="hljs-number">1</span>×<span class="hljs-number">3</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">String</span>,<span class="hljs-number">2</span>&#125;:<br> <span class="hljs-string">&quot;&quot;</span>  <span class="hljs-string">&quot;&quot;</span>  <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>문자열 유닛 요소는 빈 문자열을 나타낸다.</p><p><strong>WARNING</strong> <code>s</code>는 1차원 배열이 아니다.</p><p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; s ==  [<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>]<br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure></p><p><code>s</code>는 행(row) 매트릭스이며, ["", "", ""]는 열(column) 매트릭스이다.</p><p>매트릭스는 요소를 행으로 분리하기 위해 <code>;</code>을 구분자로 사용한다. 행을 직접 분리하는 코드는 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; a = [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>; <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>]<br><span class="hljs-number">2</span>×<span class="hljs-number">3</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Int64</span>,<span class="hljs-number">2</span>&#125;:<br><span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span><br><span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>매트릭스 이름 뒤 대괄호를 사용하여 개별 요소들을 직접 입력할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; z[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] = <span class="hljs-number">1</span><br><span class="hljs-number">1</span><br>julia&gt; z[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] = <span class="hljs-number">1</span><br><span class="hljs-number">1</span><br>julia&gt; z<br><span class="hljs-number">2</span>×<span class="hljs-number">3</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-number">2</span>&#125;:<br> <span class="hljs-number">0.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">0.0</span><br> <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure><p>또한 각 차원의 슬라이스를 사용하여 요소의 하위 그룹을 선택할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; u = z[:,<span class="hljs-number">2</span>:<span class="hljs-keyword">end</span>]<br><span class="hljs-number">2</span>×<span class="hljs-number">2</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-number">2</span>&#125;:<br> <span class="hljs-number">1.0</span>  <span class="hljs-number">0.0</span><br> <span class="hljs-number">0.0</span>  <span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure><p><code>.</code> 연산자는 모든 차원에 적용된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-literal">ℯ</span>.^(<span class="hljs-literal">im</span>*u)<br><span class="hljs-number">2</span>×<span class="hljs-number">2</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Complex</span>&#123;<span class="hljs-built_in">Float64</span>&#125;,<span class="hljs-number">2</span>&#125;:<br> <span class="hljs-number">0.540302</span>+<span class="hljs-number">0.841471</span><span class="hljs-literal">im</span>       <span class="hljs-number">1.0</span>+<span class="hljs-number">0.0</span><span class="hljs-literal">im</span><br>      <span class="hljs-number">1.0</span>+<span class="hljs-number">0.0</span><span class="hljs-literal">im</span>       <span class="hljs-number">0.540302</span>+<span class="hljs-number">0.841471</span><span class="hljs-literal">im</span><br></code></pre></td></tr></table></figure><h3 id="인터페이스">인터페이스</h3><p>줄리아는 비공식 인터페이스를 지정하여 동작, 즉 특정 목표를 가진 메서드를 정의한다. 데이터 타입에 이런 메서드를 확장하면 해당 데이터 타입의 객체를 사용하여 동작을 빌드할 수 있다.</p><blockquote><p>오리처럼 보이고 오리처럼 수영하고 오리처럼 울면 아마 그것은 오리일 것이다.</p></blockquote><p><a href="https://dev-bearabbit.github.io/2020/03/03/ThinkJulia/Think-Julia-Chapter-6/">연습해보기 파트</a>에서 우리는 피보나치 수열의 <span class="math inline">\(n\)</span>번째 요소를 반환하는 <code>fib()</code>를 구현하였다.</p><p>위의 함수는 컬렉션의 값을 반복하는 것이 인터페이스이다. 그러므로 피보나치 수열을 느리게 반환하는 이터레이터를 만들어보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">struct</span> Fibonacci&#123;T&lt;:<span class="hljs-built_in">Real</span>&#125; <span class="hljs-keyword">end</span><br>Fibonacci(d::<span class="hljs-built_in">DataType</span>) = d&lt;:<span class="hljs-built_in">Real</span> ? Fibonacci&#123;d&#125;() : error(<span class="hljs-string">&quot;No Real type!&quot;</span>)<br><br>Base.iterate(::Fibonacci&#123;T&#125;) <span class="hljs-keyword">where</span> &#123;T&lt;:<span class="hljs-built_in">Real</span>&#125; = (zero(T), (one(T), one(T)))<br>Base.iterate(::Fibonacci&#123;T&#125;, state::<span class="hljs-built_in">Tuple</span>&#123;T, T&#125;) <span class="hljs-keyword">where</span> &#123;T&lt;:<span class="hljs-built_in">Real</span>&#125; = (state[<span class="hljs-number">1</span>], (state[<span class="hljs-number">2</span>], state[<span class="hljs-number">1</span>] + state[<span class="hljs-number">2</span>]))<br></code></pre></td></tr></table></figure><p>위의 코드는 외부 생성자와 <code>iterate</code> 메서드를 사용하여 <code>Fibonnaci</code> 필드 없이 파라메트릭 데이터 타입을 구현하였다. 첫 번째는 이터레이터를 초기화하기 위해 호출되며, 첫 번째 값 0과 상태(state)를 반환한다. 위 사례에서 상태는 두 번째 값인 1과 세 번째 값 1을 포함한 튜플이다.</p><p>두 번째는 피보나치 수열의 다음 값을 얻기 위해 호출되고 첫 번째 요소는 다음 값, 두 번째 요소는 두 개의 다음 값을 가진 튜플을 반환한다.</p><p>이제는 <code>Fibonnaci</code>를 <code>for</code>루프로 나타낼 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> Fibonacci(<span class="hljs-built_in">Int64</span>)<br>           e &gt; <span class="hljs-number">100</span> &amp;&amp; <span class="hljs-keyword">break</span><br>           print(e, <span class="hljs-string">&quot; &quot;</span>)<br>       <span class="hljs-keyword">end</span><br><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">13</span> <span class="hljs-number">21</span> <span class="hljs-number">34</span> <span class="hljs-number">55</span> <span class="hljs-number">89</span><br></code></pre></td></tr></table></figure><p>이것은 마술처럼 보일 수 있지만, 원리는 간단하다. 줄리아에서 <code>for</code>루프는 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> iter<br>    <span class="hljs-comment"># body</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 루프의 프로세스를 풀어서 설명한다면 아래 코드와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">next = iterate(iter)<br><span class="hljs-keyword">while</span> next !== <span class="hljs-literal">nothing</span><br>    (i, state) = next<br>    <span class="hljs-comment"># body</span><br>    next = iterate(iter, state)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>이것은 잘 정의된 인터페이스가 어떻게 그에 맞는 함수들을 구현할 수 있게 허용하는지 보여주는 좋은 예시이다.</p><h3 id="대화식-유틸리티-interactive-utilities">대화식 유틸리티 (Interactive Utilities)</h3><p>우리는 이미 <code>InteractiveUtils</code> 모듈을 <a href="https://dev-bearabbit.github.io/2020/03/18/ThinkJulia/Think-Julia-Chapter-18/#more">디버깅 파트</a>에서 보았다. <code>@which</code> 매크로는 빙산의 일각에 불과하다.</p><p>줄리아 코드는 <code>LLVM</code> 라이브러리에 의해 여러 단계로 기계코드화 된다. 각 단계의 결과들을 직접 시각화할 수 있다.</p><p>아래의 간단한 예제를 살펴보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> squaresum(a::<span class="hljs-built_in">Float64</span>, b::<span class="hljs-built_in">Float64</span>)<br>    a^<span class="hljs-number">2</span> + b^<span class="hljs-number">2</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>첫 번째 단계는 '낮은 수준의 코드(lowered code)'를 보는 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-keyword">using</span> InteractiveUtils<br><br>julia&gt; <span class="hljs-meta">@code_lowered</span> squaresum(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>)<br>CodeInfo(<br><span class="hljs-number">1</span> ─ %<span class="hljs-number">1</span> = (Core.apply_type)(Base.<span class="hljs-built_in">Val</span>, <span class="hljs-number">2</span>)<br>│   %<span class="hljs-number">2</span> = (%<span class="hljs-number">1</span>)()<br>│   %<span class="hljs-number">3</span> = (Base.literal_pow)(:^, a, %<span class="hljs-number">2</span>)<br>│   %<span class="hljs-number">4</span> = (Core.apply_type)(Base.<span class="hljs-built_in">Val</span>, <span class="hljs-number">2</span>)<br>│   %<span class="hljs-number">5</span> = (%<span class="hljs-number">4</span>)()<br>│   %<span class="hljs-number">6</span> = (Base.literal_pow)(:^, b, %<span class="hljs-number">5</span>)<br>│   %<span class="hljs-number">7</span> = %<span class="hljs-number">3</span> + %<span class="hljs-number">6</span><br>└──      <span class="hljs-keyword">return</span> %<span class="hljs-number">7</span><br>)<br></code></pre></td></tr></table></figure><p><code>@code_lowered</code> 매크로는 컴파일러가 일반화한 최적화 코드의 중간 단계를 배열로 반환한다.</p><p>다음 단계는 데이터 타입 정보를 추가하는 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-meta">@code_typed</span> squaresum(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>)<br>CodeInfo(<br><span class="hljs-number">1</span> ─ %<span class="hljs-number">1</span> = (Base.mul_float)(a, a)::<span class="hljs-built_in">Float64</span><br>│   %<span class="hljs-number">2</span> = (Base.mul_float)(b, b)::<span class="hljs-built_in">Float64</span><br>│   %<span class="hljs-number">3</span> = (Base.add_float)(%<span class="hljs-number">1</span>, %<span class="hljs-number">2</span>)::<span class="hljs-built_in">Float64</span><br>└──      <span class="hljs-keyword">return</span> %<span class="hljs-number">3</span><br>) =&gt; <span class="hljs-built_in">Float64</span><br></code></pre></td></tr></table></figure><p>위의 결과에서 중간 결과의 데이터 타입과 정확하게 유추된 반환 값을 확인할 수 있다.</p><p>이 코드의 표현들을 <code>LLVM</code>코드로 변환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-meta">@code_llvm</span> squaresum(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>)<br>;  @ none:<span class="hljs-number">2</span> within <span class="hljs-string">`squaresum&#x27;</span><br><span class="hljs-string">define double @julia_squaresum_14821(double, double) &#123;</span><br><span class="hljs-string">top:</span><br><span class="hljs-string">; ┌ @ intfuncs.jl:243 within `</span>literal_pow&#x27;<br>; │┌ @ float.jl:<span class="hljs-number">399</span> within <span class="hljs-string">`*&#x27;</span><br><span class="hljs-string">    %2 = fmul double %0, %0</span><br><span class="hljs-string">    %3 = fmul double %1, %1</span><br><span class="hljs-string">; └└</span><br><span class="hljs-string">; ┌ @ float.jl:395 within `</span>+&#x27;<br>   %<span class="hljs-number">4</span> = fadd double %<span class="hljs-number">2</span>, %<span class="hljs-number">3</span><br>; └<br>  ret double %<span class="hljs-number">4</span><br>&#125;<br></code></pre></td></tr></table></figure><p>그러면 마지막으로 기계 코드가 생성된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs julia">julia&gt; <span class="hljs-meta">@code_native</span> squaresum(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>)<br>.section__TEXT,__text,regular,pure_instructions<br>; ┌ @ none:<span class="hljs-number">2</span> within <span class="hljs-string">`squaresum&#x27;</span><br><span class="hljs-string">; │┌ @ intfuncs.jl:243 within `</span>literal_pow&#x27;<br>; ││┌ @ none:<span class="hljs-number">2</span> within <span class="hljs-string">`*&#x27;</span><br><span class="hljs-string">vmulsd%xmm0, %xmm0, %xmm0</span><br><span class="hljs-string">vmulsd%xmm1, %xmm1, %xmm1</span><br><span class="hljs-string">; │└└</span><br><span class="hljs-string">; │┌ @ float.jl:395 within `</span>+&#x27;<br>vaddsd%xmm1, %xmm0, %xmm0<br>; │└<br>retl<br>nopl(%eax)<br>; └<br></code></pre></td></tr></table></figure><h3 id="디버깅">디버깅</h3><p><code>Logging</code> 매크로는 프린트 구문의 스캐폴딩을 대체할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-meta">@warn</span> <span class="hljs-string">&quot;Abandon printf debugging, all ye who enter here!&quot;</span><br>┌ Warning: Abandon printf debugging, all ye who enter here!<br>└ @ Main REPL[<span class="hljs-number">1</span>]:<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>소스(source)에서 디버그 구문을 제거할 필요는 없다. 예를 들어 위의 <code>@warn</code>과 달리 아래의 코드는 기본적으로 출력이 생성되지 않는다. 이 경우 '디버그 로깅( debug logging)'을 사용하지 않으면 <code>sum(rand(100))</code>은 평가되지 않는다.</p><p>로깅 레벨은 환경 변수인 <code>JULIA_DEBUG:</code>로 선택할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia">$ JULIA_DEBUG=all julia -e &#x27;<span class="hljs-meta">@debug</span> <span class="hljs-string">&quot;The sum of some values <span class="hljs-subst">$(sum(rand(<span class="hljs-number">100</span>)</span>))&quot;</span>&#x27;<br>┌ Debug: The sum of some values <span class="hljs-number">47.116520814555024</span><br>└ @ Main none:<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>여기서는 모든 디버그 정보를 얻기 위해서 모두 사용햇지만 특정 파일 또는 모듈에 대한 출력만 생성하도록 선택할 수도 있다.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>think julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>줄리아</tag>
      
      <tag>Julia</tag>
      
      <tag>Think Julia</tag>
      
      <tag>기초 강의</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[18/20] 기타 문법들</title>
    <link href="/ko/ThinkJulia/Think-Julia-Chapter-18/"/>
    <url>/ko/ThinkJulia/Think-Julia-Chapter-18/</url>
    
    <content type="html"><![CDATA[<blockquote><p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p></blockquote><p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap19">The Goodies: Syntax</a>를 한글로 요약 정리한 글입니다. <span id="more"></span></p><h2 id="기타-문법들-syntax">기타 문법들 (Syntax)</h2><p>이 책의 목적 중 하나는 가능한 적게 줄리아를 사용하는 법을 알려주는 것이었다. 만약 동일한 어떤 일을 하는 두 가지의 방법이 있다면, 그 중 하나만 이 책에 적었으며 나머지는 언급하지 않았다. 때로는 나머지 방법을 연습문제에 포함시켰다.</p><p>지금부터는 언급하지 않았던 것들 중에 알아두면 좋은 것들을 소개할 것이다. 줄리아는 실제로 필수적이지는 않은 여러 가지 기능들을 제공한다. 이런 기능 없이도 좋은 코드를 작성할 수 있지만, 기능을 포함하면 더 간결하고 읽기 쉽고 효율적인 코드를 작성할 수 있다.</p><p>이 장과 다음 장에서는 이전 장에서 생략한 아래의 사항들에 대해 설명할 것이다.</p><ul><li>문법 보충</li><li><code>Base</code>에서 직접 사용 가능한 함수, 데이터 타입 및 매크로</li><li>표준 라이브러리에 있는 함수, 데이터 타입 및 매크로</li></ul><h3 id="네임드-튜플-named-tuples">네임드 튜플 (Named Tuples)</h3><p>네임드 튜플을 만들어 튜플의 구성요소 이름을 지정할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; x = (a=<span class="hljs-number">1</span>, b=<span class="hljs-number">1</span>+<span class="hljs-number">1</span>)<br>(a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>)<br>julia&gt; x.a<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>네임드 튜플에서는 점 문법인 <code>(x.a)</code>을 사용하여 필드에 접근할 수 있다.</p><h3 id="함수">함수</h3><p>줄리아에서 함수는 간결한 문법으로 정의할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; f(x,y) = x + y<br>f (generic <span class="hljs-keyword">function</span> with <span class="hljs-number">1</span> method)<br></code></pre></td></tr></table></figure><h4 id="익명-함수-anonymous-functions">익명 함수 (Anonymous Functions)</h4><p>이름 설정 없이 함수를 정의할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; x -&gt; x^<span class="hljs-number">2</span> + <span class="hljs-number">2</span>x - <span class="hljs-number">1</span><br><span class="hljs-comment">#1 (generic function with 1 method)</span><br>julia&gt; <span class="hljs-keyword">function</span> (x)<br>           x^<span class="hljs-number">2</span> + <span class="hljs-number">2</span>x - <span class="hljs-number">1</span><br>       <span class="hljs-keyword">end</span><br><span class="hljs-comment">#3 (generic function with 1 method)</span><br></code></pre></td></tr></table></figure><p>위의 코드는 익명 함수의 예시이다. 익명 함수는 종종 다른 함수의 인수로 사용된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-keyword">using</span> Plots<br><br>julia&gt; plot(x -&gt; x^<span class="hljs-number">2</span> + <span class="hljs-number">2</span>x - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, xlabel=<span class="hljs-string">&quot;x&quot;</span>, ylabel=<span class="hljs-string">&quot;y&quot;</span>)<br></code></pre></td></tr></table></figure><figure><img src="/images/25.png" alt="Plot" /><figcaption aria-hidden="true">Plot</figcaption></figure><p>위의 그래프는 <code>Plot</code> 명령어의 결과이다.</p><h4 id="키워드-인수-keyword-arguments">키워드 인수 (Keyword Arguments)</h4><p>함수 인수 또한 아래와 같이 명명될 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">ulia&gt; <span class="hljs-keyword">function</span> myplot(x, y; style=<span class="hljs-string">&quot;solid&quot;</span>, width=<span class="hljs-number">1</span>, color=<span class="hljs-string">&quot;black&quot;</span>)<br>           <span class="hljs-comment">###</span><br>       <span class="hljs-keyword">end</span><br>myplot (generic <span class="hljs-keyword">function</span> with <span class="hljs-number">1</span> method)<br>julia&gt; myplot(<span class="hljs-number">0</span>:<span class="hljs-number">10</span>, <span class="hljs-number">0</span>:<span class="hljs-number">10</span>, style=<span class="hljs-string">&quot;dotted&quot;</span>, color=<span class="hljs-string">&quot;blue&quot;</span>)<br></code></pre></td></tr></table></figure><p>함수에서 키워드 인수는 세미콜론(;) 뒤에 지정되며, 쉼표로 호출된다.</p><h4 id="클로저-closures">클로저 (Closures)</h4><p>클로저는 함수가 함수의 호출 범위 밖에 정의된 변수를 캡쳐할 수 있게 하는 기술이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; foo(x) = ()-&gt;x<br>foo (generic <span class="hljs-keyword">function</span> with <span class="hljs-number">1</span> method)<br><br>julia&gt; bar = foo(<span class="hljs-number">1</span>)<br><span class="hljs-comment">#1 (generic function with 1 method)</span><br><br>julia&gt; bar()<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>이 예시에서 함수 <code>foo()</code>는 <code>foo()</code>의 인수<code>x</code>에 접근하는 익명 함수를 반환한다. <code>bar</code>는 해당 익명함수를 지정하고 <code>foo()</code>의 인수인 값을 반환한다.</p><h3 id="블럭-blocks">블럭 (Blocks)</h3><p>블럭은 여러 명령문들을 그룹화하는 방법이다. 블럭은 키워드 <code>begin</code>로 시작하고 <code>end</code>로 끝난다.</p><p><a href="https://dev-bearabbit.github.io/2020/03/02/ThinkJulia/Think-Julia-Chapter-4/">인터페이스 디자인</a>에서 <code>@svg</code>를 소개했다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">🐢 = Turtle()<br><span class="hljs-meta">@svg</span> <span class="hljs-keyword">begin</span><br>    forward(🐢, <span class="hljs-number">100</span>)<br>    turn(🐢, -<span class="hljs-number">90</span>)<br>    forward(🐢, <span class="hljs-number">100</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>이 예시에서 <code>@svg</code>는 3개의 함수 호출을 그룹화한 블록인 단일 인수가 있다.</p><h4 id="let-블럭"><code>let</code> 블럭</h4><p><code>let</code> 블럭은 값을 참조할 수 있는 위치와 같은 새로운 바인딩(binding)을 생성하는 데 유용하다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; x, y, z = -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>;<br><br>julia&gt; <span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>, z<br>           <span class="hljs-meta">@show</span> x y z;<br>       <span class="hljs-keyword">end</span><br>x = <span class="hljs-number">1</span><br>y = -<span class="hljs-number">1</span><br>ERROR: <span class="hljs-built_in">UndefVarError</span>: z not defined<br>julia&gt; <span class="hljs-meta">@show</span> x y z;<br>x = -<span class="hljs-number">1</span><br>y = -<span class="hljs-number">1</span><br>z = -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>위 예시에서 첫 번째 <code>@show</code>매크로는 로컬 변수 <code>x</code>와 글로벌 변수 <code>y</code>와 정의되지 않은 <code>z</code>를 보여준다. 글로벌 변수는 그대로 유지된다.</p><h4 id="do-블럭"><code>do</code> 블럭</h4><p><a href="https://dev-bearabbit.github.io/2020/03/13/ThinkJulia/Think-Julia-Chapter-14/">14장의 읽고 쓰기 파트</a>에서 우리는 작성이 끝난 파일을 닫아야 했다. 이것은 <code>do</code> 블럭을 사용하여 자동화할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; data = <span class="hljs-string">&quot;This here&#x27;s the wattle,\nthe emblem of our land.\n&quot;</span><br><span class="hljs-string">&quot;This here&#x27;s the wattle,\nthe emblem of our land.\n&quot;</span><br>julia&gt; open(<span class="hljs-string">&quot;output.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">do</span> fout<br>           write(fout, data)<br>       <span class="hljs-keyword">end</span><br><span class="hljs-number">48</span><br></code></pre></td></tr></table></figure><p>위 예시에서 <code>fout</code>는 결과를 위해 사용된 파일 스트림이다.</p><p>이것은 기능적으로 아래의 코드와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; f = fout -&gt; <span class="hljs-keyword">begin</span><br>           write(fout, data)<br>       <span class="hljs-keyword">end</span><br><span class="hljs-comment">#3 (generic function with 1 method)</span><br>julia&gt; open(f, <span class="hljs-string">&quot;output.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>)<br><span class="hljs-number">48</span><br></code></pre></td></tr></table></figure><p>익명 함수는 <code>open()</code>의 첫 번째 인수로서 사용된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> open(f::<span class="hljs-built_in">Function</span>, args...)<br>    io = open(args...)<br>    <span class="hljs-keyword">try</span><br>        f(io)<br>    <span class="hljs-keyword">finally</span><br>        close(io)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>do</code> 블럭은 둘러싸는 범위에서 변수를 캡처할 수 있다. 예를 들어 위의 예시였던 <code>open...do</code>에 있는 변수 데이터는 외부 범위에서 캡처된다.</p><h3 id="제어-흐름-control-flow">제어 흐름 (Control Flow)</h3><h4 id="삼항-연산자-ternary-operator">삼항 연산자 (Ternary Operator)</h4><p>삼항 연산자 <code>?:</code>는 단일 표현식 값들 중에서 선택해야 할 때 사용되는 <code>if-elseif</code>문의 대안이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; a = <span class="hljs-number">150</span><br><span class="hljs-number">150</span><br>julia&gt; a % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? println(<span class="hljs-string">&quot;even&quot;</span>) : println(<span class="hljs-string">&quot;odd&quot;</span>)<br>even<br></code></pre></td></tr></table></figure><p><code>?</code>앞의 표현식은 조건을 나타낸 것이다. 만약 조건이 <code>true</code>면 <code>:</code> 이전의 표현식을 실행하며, <code>false</code>면 <code>:</code>뒤의 표현식을 실행한다.</p><h4 id="단락-평가-short-circuit-evaluation">단락 평가 (Short-Circuit Evaluation)</h4><p>연산자 <code>&amp;&amp;</code>와 <code>||</code>는 단락 평가를 수행한다. 즉, 다음 인수는 오직 최종값을 결정할 때만 평가된다.</p><p>예를 들어 재귀적인 팩토리얼 함수 정의는 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> fact(n::<span class="hljs-built_in">Integer</span>)<br>    n &gt;= <span class="hljs-number">0</span> || error(<span class="hljs-string">&quot;n must be non-negative&quot;</span>)<br>    n == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    n * fact(n-<span class="hljs-number">1</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="테스크-일명-coroutines">테스크 (일명 Coroutines)</h4><p>테스크(task)는 반환 없이 협력적으로 제어할 수 있는 제어 구조이다. 줄리아에서, 테스크는 첫 번째 인수로 <code>channel</code> 객체를 가지는 함수로 구현될 수 있다. <code>channel</code>은 함수에서 수신자에게 값을 전달하는 데 사용된다.</p><p>피보나치 수열은 테스크를 사용하여 생성할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> fib(c::<span class="hljs-built_in">Channel</span>)<br>    a = <span class="hljs-number">0</span><br>    b = <span class="hljs-number">1</span><br>    put!(c, a)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span><br>        put!(c, b)<br>        (a, b) = (b, a+b)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>put!</code>은 <code>channel</code>객체에 값을 저장하며, <code>take!</code>은 객체로부터 값을 읽는다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; fib_gen = <span class="hljs-built_in">Channel</span>(fib);<br><br>julia&gt; take!(fib_gen)<br><span class="hljs-number">0</span><br>julia&gt; take!(fib_gen)<br><span class="hljs-number">1</span><br>julia&gt; take!(fib_gen)<br><span class="hljs-number">1</span><br>julia&gt; take!(fib_gen)<br><span class="hljs-number">2</span><br>julia&gt; take!(fib_gen)<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>생성자 <code>Channel</code>은 테스크를 만든다. <code>fib()</code>는 <code>put!</code>을 호출할 때마다 일시 중지되고 <code>take!</code>이후에 다시 시작된다. 성능상의 이유로 시퀀스의 여러 값은 재개와 일시정지 동안에 <code>Channel</code> 객체에 저장된다.</p><p>또한 <code>Channel</code> 객체는 이터레이터(iterator)로써도 사용된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> <span class="hljs-built_in">Channel</span>(fib)<br>           print(val, <span class="hljs-string">&quot; &quot;</span>)<br>           val &gt; <span class="hljs-number">20</span> &amp;&amp; <span class="hljs-keyword">break</span><br>       <span class="hljs-keyword">end</span><br><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">13</span> <span class="hljs-number">21</span><br></code></pre></td></tr></table></figure><h3 id="데이터-타입">데이터 타입</h3><h4 id="기본-데이터-타입-primitive-types">기본 데이터 타입 (Primitive Types)</h4><p>기본적으로 사용되는 구체적 데이터 타입들을 기본 데이터 타입이라고 한다. 다른 언어들과 달리 줄리아에서는 고유한 기본 데이터 타입을 선언할 수 있다. 표준 기본 데이터 타입도 같은 방식으로 정의된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">primitive type</span> <span class="hljs-built_in">Float64</span> &lt;: <span class="hljs-built_in">AbstractFloat</span> <span class="hljs-number">64</span> <span class="hljs-keyword">end</span><br><span class="hljs-keyword">primitive type</span> <span class="hljs-built_in">Bool</span> &lt;: <span class="hljs-built_in">Integer</span> <span class="hljs-number">8</span> <span class="hljs-keyword">end</span><br><span class="hljs-keyword">primitive type</span> <span class="hljs-built_in">Char</span> &lt;: <span class="hljs-built_in">AbstractChar</span> <span class="hljs-number">32</span> <span class="hljs-keyword">end</span><br><span class="hljs-keyword">primitive type</span> <span class="hljs-built_in">Int64</span> &lt;: <span class="hljs-built_in">Signed</span> <span class="hljs-number">64</span> <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 명령문에 있는 숫자들은 얼마나 많은 비트가 요구되는지 나타낸다.</p><p>아래의 예시는 기본 데이터 타입인 <code>Byte</code>와 생성자를 만든다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-keyword">primitive type</span> Byte <span class="hljs-number">8</span> <span class="hljs-keyword">end</span><br><br>julia&gt; Byte(val::<span class="hljs-built_in">UInt8</span>) = reinterpret(Byte, val)<br>Byte<br>julia&gt; b = Byte(<span class="hljs-number">0x01</span>)<br>Byte(<span class="hljs-number">0x01</span>)<br></code></pre></td></tr></table></figure><p><code>reinterpret()</code>은 8비트의 부호없는 정수 비트를 바이트에 저장하는 데 사용된다.</p><h4 id="파라메트릭-데이터-타입-parametric-types">파라메트릭 데이터 타입 (Parametric Types)</h4><p>줄리아의 데이터 타입 시스템은 파라메트릭, 즉 데이터 타입이 매개 변수를 가질 수 있다.</p><p>데이터 타입 매개 변수는 데이터 타입 이름 뒤에 중괄호로 묶여 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">struct</span> Point&#123;T&lt;:<span class="hljs-built_in">Real</span>&#125;<br>    x::T<br>    y::T<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 코드는 <code>Real</code>을 supertype으로 갖는 모든 데이터 타입인 <code>T</code>의 좌표를 가진 새로운 파라메트릭 타입 <code>Point&#123;T&lt;:Real&#125;</code> 정의한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; Point(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>)<br>Point&#123;<span class="hljs-built_in">Float64</span>&#125;(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>)<br></code></pre></td></tr></table></figure><p>복합 데이터 타입 외에도 추상 데이터 타입이나 기본 데이터 타입에도 매개 변수가 있을 수 있다.</p><p><strong>Tip</strong> 성능상의 이유로 구조체 필드에 구체적 데이터 타입을 사용하는 것이 절대적으로 권장되며, 그것이 <code>Point</code>를 빠르고 유연하게 만드는 좋은 방법이다.</p><h4 id="데이터-타입-유니언-type-unions">데이터 타입 유니언 (Type Unions)</h4><p>데이터 타입 유니언은 임의의 인수 타입으로 작용할 수 있는 추상적인 파라메트릭 데이터 타입이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; IntOrString = <span class="hljs-built_in">Union</span>&#123;<span class="hljs-built_in">Int64</span>, <span class="hljs-built_in">String</span>&#125;<br><span class="hljs-built_in">Union</span>&#123;<span class="hljs-built_in">Int64</span>, <span class="hljs-built_in">String</span>&#125;<br>julia&gt; <span class="hljs-number">150</span> :: IntOrString<br><span class="hljs-number">150</span><br>julia&gt; <span class="hljs-string">&quot;Julia&quot;</span> :: IntOrString<br><span class="hljs-string">&quot;Julia&quot;</span><br></code></pre></td></tr></table></figure><p>대부분의 컴퓨터 언어에서 데이터 타입 유니언은 데이터 타입을 추론하기 위한 내부 구조이다. 하지만 줄리아에서는 데이터 타입 유니언이 적을 때 효율적인 코드를 작성할 수 있기 때문에 이 기능을 사용자에게 노출한다. 이 기능은 줄리아를 사용하는 개발자에게 디스패치를 제어할 수 있는 유연성을 제공한다.</p><h3 id="메서드-methods">메서드 (Methods)</h3><h4 id="파라메트릭-메서드-parametric-methods">파라메트릭 메서드 (Parametric Methods)</h4><p>메서드 정의 또한 데이터 타입 매개 변수를 가질 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; isintpoint(p::Point&#123;T&#125;) <span class="hljs-keyword">where</span> &#123;T&#125; = (T === <span class="hljs-built_in">Int64</span>)<br>isintpoint (generic <span class="hljs-keyword">function</span> with <span class="hljs-number">1</span> method)<br>julia&gt; p = Point(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>Point&#123;<span class="hljs-built_in">Int64</span>&#125;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>julia&gt; isintpoint(p)<br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h4 id="함수형-객체-function-like-objects">함수형 객체 (Function-like Objects)</h4><p>줄리아에서는 어떤 임의의 객체도 "호출 가능"하게 만들 수 있다. 이런 "호출 가능"한 객체를 펑터(functor)라고도 부른다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">struct</span> Polynomial&#123;R&#125;<br>    coeff::<span class="hljs-built_in">Vector</span>&#123;R&#125;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> (p::Polynomial)(x)<br>    val = p.coeff[<span class="hljs-keyword">end</span>]<br>    <span class="hljs-keyword">for</span> coeff <span class="hljs-keyword">in</span> p.coeff[<span class="hljs-keyword">end</span>-<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>:<span class="hljs-number">1</span>]<br>        val = val * x + coeff<br>    <span class="hljs-keyword">end</span><br>    val<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 <code>Polynomial</code>을 평가하기 위해서는 간단하게 호출하면 된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; p = Polynomial([<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">100</span>])<br>Polynomial&#123;<span class="hljs-built_in">Int64</span>&#125;([<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>])<br>julia&gt; p(<span class="hljs-number">3</span>)<br><span class="hljs-number">931</span><br></code></pre></td></tr></table></figure><h3 id="생성자-constructors">생성자 (Constructors)</h3><p>파라메트릭 데이터 타입은 명시적 또는 암시적으로 생성될 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; Point(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)         <span class="hljs-comment"># implicit T</span><br>Point&#123;<span class="hljs-built_in">Int64</span>&#125;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>julia&gt; Point&#123;<span class="hljs-built_in">Int64</span>&#125;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment"># explicit T</span><br>Point&#123;<span class="hljs-built_in">Int64</span>&#125;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>julia&gt; Point(<span class="hljs-number">1</span>,<span class="hljs-number">2.5</span>)       <span class="hljs-comment"># implicit T</span><br>ERROR: <span class="hljs-built_in">MethodError</span>: no method matching Point(::<span class="hljs-built_in">Int64</span>, ::<span class="hljs-built_in">Float64</span>)<br></code></pre></td></tr></table></figure><p>기본 내부 생성자 및 외부 생성자는 각 <code>T</code>에서 생성된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">struct</span> Point&#123;T&lt;:<span class="hljs-built_in">Real</span>&#125;<br>    x::T<br>    y::T<br>    Point&#123;T&#125;(x,y) <span class="hljs-keyword">where</span> &#123;T&lt;:<span class="hljs-built_in">Real</span>&#125; = new(x,y)<br><span class="hljs-keyword">end</span><br><br>Point(x::T, y::T) <span class="hljs-keyword">where</span> &#123;T&lt;:<span class="hljs-built_in">Real</span>&#125; = Point&#123;T&#125;(x,y);<br></code></pre></td></tr></table></figure><p>그리고 <code>x</code>와 <code>y</code>는 같은 데이터 타입이어야 한다.</p><p><code>x</code>와 <code>y</code>가 다른 데이터 타입을 가지면, 외부 생성자를 아래와 같이 정의될 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Point(x::<span class="hljs-built_in">Real</span>, y::<span class="hljs-built_in">Real</span>) = Point(promote(x,y)...);<br></code></pre></td></tr></table></figure><p><code>promote()</code>의 세부사항은 아래에서 다룰 것이다.</p><h3 id="전환-및-프로모션-conversion-and-promotion">전환 및 프로모션 (Conversion and Promotion)</h3><p>줄리아는 인수를 공동 데이터 타입으로 승격시키는 시스탬을 가지고 잇다. 이 작업은 자동으로 수행되지는 않지만 쉽게 확장할 수 있다.</p><h4 id="전환-conversion">전환 (Conversion)</h4><p>값은 다른 데이터 타입으로 변환될 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; x = <span class="hljs-number">12</span><br><span class="hljs-number">12</span><br>julia&gt; typeof(x)<br><span class="hljs-built_in">Int64</span><br>julia&gt; convert(<span class="hljs-built_in">UInt8</span>, x)<br><span class="hljs-number">0x0c</span><br>julia&gt; typeof(ans)<br><span class="hljs-built_in">UInt8</span><br></code></pre></td></tr></table></figure><p>또한 고유한 <code>convert</code>메서드도 추가할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; Base.convert(::<span class="hljs-built_in">Type</span>&#123;Point&#123;T&#125;&#125;, x::<span class="hljs-built_in">Array</span>&#123;T, <span class="hljs-number">1</span>&#125;) <span class="hljs-keyword">where</span> &#123;T&lt;:<span class="hljs-built_in">Real</span>&#125; = Point(x...)<br><br>julia&gt; convert(Point&#123;<span class="hljs-built_in">Int64</span>&#125;, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br>Point&#123;<span class="hljs-built_in">Int64</span>&#125;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h4 id="프로모션-promotion">프로모션 (Promotion)</h4><p>프로모션은 혼합 데이터 타입의 값을 단일 공통 데이터 타입으로 변환하는 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; promote(<span class="hljs-number">1</span>, <span class="hljs-number">2.5</span>, <span class="hljs-number">3</span>)<br>(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.5</span>, <span class="hljs-number">3.0</span>)<br></code></pre></td></tr></table></figure><p><code>promote()</code>의 메서드 일반적으로 직접 정의되지는 않지만, 보조 함수인 <code>promote_rule()</code>은 프로모션의 규칙을 나타내는 데 사용된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">promote_rule(::<span class="hljs-built_in">Type</span>&#123;<span class="hljs-built_in">Float64</span>&#125;, ::<span class="hljs-built_in">Type</span>&#123;<span class="hljs-built_in">Int32</span>&#125;) = <span class="hljs-built_in">Float64</span><br></code></pre></td></tr></table></figure><h3 id="메타프로그래밍-metaprogramming">메타프로그래밍 (Metaprogramming)</h3><p>줄리아 코드는 언어 자체의 데이터 구조로서 표현할 수 있다. 이는 프로그램이 자체적으로 코드를 변환하고 생성할 수 있도록 허락한다.</p><h4 id="표현식">표현식</h4><p>모든 줄리아 프로그램은 문자열로서 시작한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; prog = <span class="hljs-string">&quot;1 + 2&quot;</span><br><span class="hljs-string">&quot;1 + 2&quot;</span><br></code></pre></td></tr></table></figure><p>다음 단계는 줄리아 문자열의 문자 각각을 분석하여 <code>Expr</code>라는 줄리아 데이터 타입의 표현식 객체로 나타내는 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; ex = Meta.parse(prog)<br>:(<span class="hljs-number">1</span> + <span class="hljs-number">2</span>)<br>julia&gt; typeof(ex)<br><span class="hljs-built_in">Expr</span><br>julia&gt; dump(ex)<br><span class="hljs-built_in">Expr</span><br>  head: <span class="hljs-built_in">Symbol</span> call<br>  args: <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Any</span>&#125;((<span class="hljs-number">3</span>,))<br>    <span class="hljs-number">1</span>: <span class="hljs-built_in">Symbol</span> +<br>    <span class="hljs-number">2</span>: <span class="hljs-built_in">Int64</span> <span class="hljs-number">1</span><br>    <span class="hljs-number">3</span>: <span class="hljs-built_in">Int64</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><code>dump()</code>은 expr 객체의 주석을 보여준다.</p><p>괄호 안에 <code>:</code>을 쓰거나 또는 <code>quote</code> 블록을 사용하여 표현식을 직접 구성할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; ex = <span class="hljs-keyword">quote</span><br>           <span class="hljs-number">1</span> + <span class="hljs-number">2</span><br>       <span class="hljs-keyword">end</span>;<br></code></pre></td></tr></table></figure><h4 id="eval"><code>eval</code></h4><p>줄리아는 <code>eval</code>을 사용하여 표현식 객체를 평가할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; eval(ex)<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>모든 모듈은 범위 내에서 표현식을 평가하는 고유한 <code>eval()</code>을 가진다.</p><p><strong>WARNING</strong> <code>eval()</code>을 과도하게 사용하는 것은 사실 무언가가 잘못되었다는 것을 의미한다.</p><h4 id="매크로-macros">매크로 (Macros)</h4><p>매크로는 프로그램에서 생성된 코드를 포함할 수 있다. 매크로는 <code>Expr</code>객체의 튜플을 컴파일된 표현식에 직접 매핑한다.</p><p>아래의 코드는 간단한 매크로이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">macro</span> containervariable(container, element)<br>    <span class="hljs-keyword">return</span> esc(:($(<span class="hljs-built_in">Symbol</span>(container,element)) = $container[$element]))<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>매크로는 이름 앞에 <code>@(at-sign)</code>을 붙인다. <code>@containervariable letters 1</code> 매크로 호출은 아래의 코드로 대체된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">:(letters1 = letters[<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p><code>@macroexpand @containervariable letters 1</code>은 디버깅에 매우 유용한 표현식을 반환한다.</p><p>이 예제는 매크로가 어떻게 인수 이름에 접근하는지 보여준다. 반환 표현식은 매크로 호출 환경에서 분석되어야 하므로 <code>esc</code>를 사용하여 "escaped" 처리를 해야한다.</p><p><strong>NOTE</strong> 왜 매크로인가? 전체 프로그램이 실행되기 전에 매크로는 분석 시간 동안 맟춤형 코드의 조각들을 생성하고 포함한다.</p><h4 id="생성-함수-generated-functions">생성 함수 (Generated Functions)</h4><p>매크로 <code>@generated</code>는 인수의 타입에 따라 메서드에 대한 특수 코드를 생성한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-meta">@generated</span> <span class="hljs-keyword">function</span> square(x)<br>    println(x)<br>    :(x * x)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>함수를 호출할 경우, 생성 함수는 일반 함수처럼 작동한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; x = square(<span class="hljs-number">2</span>); <span class="hljs-comment"># note: output is from println() statement in the body</span><br><span class="hljs-built_in">Int64</span><br>julia&gt; x              <span class="hljs-comment"># now we print x</span><br><span class="hljs-number">4</span><br>julia&gt; y = square(<span class="hljs-string">&quot;spam&quot;</span>);<br><span class="hljs-built_in">String</span><br>julia&gt; y<br><span class="hljs-string">&quot;spamspam&quot;</span><br></code></pre></td></tr></table></figure><h3 id="결측값-missing-values">결측값 (Missing Values)</h3><p>결측값은 <code>Missing</code>유형의 싱글톤(singleton) 인스턴스인 <code>missing</code>객체를 통해 표현될 수 있다.</p><p>배열은 결측값을 포함할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; a = [<span class="hljs-number">1</span>, <span class="hljs-literal">missing</span>]<br><span class="hljs-number">2</span>-element <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Union</span>&#123;<span class="hljs-built_in">Missing</span>, <span class="hljs-built_in">Int64</span>&#125;,<span class="hljs-number">1</span>&#125;:<br> <span class="hljs-number">1</span><br>  <span class="hljs-literal">missing</span><br></code></pre></td></tr></table></figure><p>이런 배열 요소의 데이터 타입은 <code>Union&#123;Missing, T&#125;</code> 이며, 결측값이 아닌 <code>T</code> 데이터 타입이다.</p><p>결측값이 포함된 배열을 호출하면 리듀스 함수가 결측값을 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; sum(a)<br><span class="hljs-literal">missing</span><br></code></pre></td></tr></table></figure><p>이 상황에서는 결측값을 넘겨주는 <code>skipmissing()</code>을 사용하면 된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; sum(skipmissing([<span class="hljs-number">1</span>, <span class="hljs-literal">missing</span>]))<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="c와-포트란-코드-호출-calling-c-and-fortran-code">C와 포트란 코드 호출 (Calling C and Fortran Code)</h3><p>많은 코드들이 C 또는 포트란으로 작성된다. 테스트된 코드를 다시 사용하는 것이 직접 만든 알고리즘 버전을 코드로 작성하는 것보다 더 낫다. 줄리아는 <code>ccall</code> 문법을 사용하여 기존 C 또는 포트란 라이브러리를 직접 호출할 수 있다.</p><p>우리는 <a href="https://dev-bearabbit.github.io/2020/03/13/ThinkJulia/Think-Julia-Chapter-14/">데이터베이스</a> 파트에서 데이터베이스 함수의 GDBM 라이브러리에 줄리아 인터페이스를 도입하였다. 라이브러리는 C로 작성되며, 데이터베이스를 닫으려면 close (db)에 대한 함수를 호출해야 한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Base.close(dbm::DBM) = gdbm_close(dbm.handle)<br><br><span class="hljs-keyword">function</span> gdbm_close(handle::<span class="hljs-built_in">Ptr</span>&#123;<span class="hljs-built_in">Cvoid</span>&#125;)<br>    <span class="hljs-keyword">ccall</span>((:gdbm_close, <span class="hljs-string">&quot;libgdbm&quot;</span>), <span class="hljs-built_in">Cvoid</span>, (<span class="hljs-built_in">Ptr</span>&#123;<span class="hljs-built_in">Cvoid</span>&#125;,), handle)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>dbm 객체는 <code>Ptr&#123;Cvoid&#125;</code>데이터 타입의 필드 <code>handle</code>을 가지고 있다. 이 필드에는 데이터베이스를 참조하는 C 포인터가 있다. 데이터베이스를 닫으려면 C 함수인 <code>gdbm_close()</code>는 데이터베이스를 가리키는 C 포인터만 반환 값 없이 호출해야 한다. 줄리아는 인수를 가진 <code>ccall()</code>을 사용하여 직접 수행한다.</p><ul><li>우리가 호출하고자하는 함수의 이름을 요소로 가지는 튜플: <code>gdbm_close</code> 및 문자열로 지정된 공유 라이브러리 <code>"libgdm"</code></li><li>반환 데이터 타입: <code>Cvoid</code></li><li>인수 데이터 타입의 튜플: <code>(Ptr&#123;Cvoid&#125;)</code></li><li>인수 값: <code>handle</code></li></ul><p>GDBM 라이브러리의 완전한 맵핑은 ThinkJulia 소스에서 예제로 찾을 수 있다.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>think julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>줄리아</tag>
      
      <tag>Julia</tag>
      
      <tag>Think Julia</tag>
      
      <tag>기초 강의</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Big-O 표기법</title>
    <link href="/ko/Algorithms/Algorithms-0/"/>
    <url>/ko/Algorithms/Algorithms-0/</url>
    
    <content type="html"><![CDATA[<p>글을 시작하기에 앞서 해당 글은 Sanjoy Dasgupta, Christos Papadimitriou, Umesh 의 저서인 Algorithms를 참고하여 정리한 글임을 알려드립니다. <span id="more"></span></p><h2 id="피보나치-입문">피보나치 입문</h2><p>피보나치는 유명한 수열로 가장 많이 알려져있다. 수열 내에서 각 숫자들은 이전 두 숫자의 합이라는 것이 피보나치 수열의 원리이다. 피보나치수 <span class="math inline">\(F_n\)</span>은 다음과 같다.</p><p><span class="math display">\[fib(n) = \begin{cases}0 &amp; \text{if n=0 \]</span>}\ 1 &amp; \ fib(n-1)+fib(n-2) &amp; \ \end{cases} $$</p><h3 id="지수적-알고리즘">지수적 알고리즘</h3><p>피보나치 수열은 <span class="math inline">\(2^n\)</span>과 거의 같은 속도로 증가한다. 일반적으로 <span class="math inline">\(F_n\)</span>≈<span class="math inline">\(2^{0.694n}\)</span> 이다. 따라서 피보나치 함수 fib(n)의 수행속도는 <span class="math inline">\(2^{0.694n}\)</span>인 <span class="math inline">\((1.6)^n\)</span>에 비례한다. 즉, <span class="math inline">\(F_n+1\)</span>을 계산하는 것은 <span class="math inline">\(F_n\)</span>을 계산하는 시간의 1.6배가 더 걸린다는 것이다.</p><p>지수함수를 기반으로 한 피보나치 수열을 구하는 공식은 <span class="math inline">\(n\)</span>에서 <span class="math inline">\(0\)</span>이 될 때까지 스스로를 반복해야 하기 때문에 <span class="math inline">\(n\)</span>이 크면 클수록 엄청나게 많은 시간이 소요된다. 그렇다면 좀 더 빠르게 만들 수는 없을까? 피보나치에서 나온 값들을 배열에 저장한다면, 더 빠르게 작동할 것이다.</p><h3 id="다항-시간-알고리즘">다항 시간 알고리즘</h3><p>다항함수는 지수함수보다 훨씬 빠르게 작동한다. 따라서 다항함수를 기반으로 작성된 코드가 훨씬 효율적이다. 코드는 먼저 <span class="math inline">\(0\)</span>부터 <span class="math inline">\(n\)</span>까지의 배열을 만든 후, 해당 배열의 인수를 다항식인 <span class="math inline">\(f(X)=f(x-2)+f(x-1)\)</span> 넣는 프로세스로 진행된다. 물론 <span class="math inline">\(f(0)\)</span>과 <span class="math inline">\(f(1)\)</span>은 <span class="math inline">\(0\)</span>과 <span class="math inline">\(1\)</span>로 값을 따로 지정한다. 이 방식은 지수함수를 기반으로 작성했을 때보다 훨씬 빠르고 효율적으로 작동한다.</p><h3 id="좀-더-정확한-분석">좀 더 정확한 분석</h3><p>위의 지수적 알고리즘과 다항 시간 알고리즘을 좀 더 정확하게 알아보고자 한다. 뒤의 1장에서 배우겠지만, <span class="math inline">\(n\)</span>비트의 두 숫자를 더하는데 걸리는 시간은 <span class="math inline">\(n\)</span>에 비례한다. 따라서 지수적 알고리즘은 <span class="math inline">\(F_n\)</span>을 <span class="math inline">\(n\)</span>의 수만큼 반복하여 더했기 때문에 연산 개수는 <span class="math inline">\(n*F_n\)</span>이라고 할 수 있다. 또한 다항 시간 알고리즘의 연산 개수는 <span class="math inline">\(n\)</span>의 개수에 따른 결과값들을 더하기 때문에 <span class="math inline">\(n^2\)</span>에 비례한다. 정확하게 분석해도 다항시간 알고리즘이 훨씬 빠르다.</p><h2 id="빅오-표기법-big-o-notation">빅오 표기법 (big-O notation)</h2><p>알고리즘의 효율성은 데이터 개수인 <span class="math inline">\(n\)</span>에 따라 연산되는 횟수를 의미하며, 크게 '시간 복잡도(시간 효율성)'와 '공간 복잡도(공간 효율성)'로 나뉜다. 이런 알고리즘의 효율성을 나타내는 방법으로는 빅오(Big-O), 빅오메가(big-Ω), 빅세타(big-Θ) 표기법이 있다.</p><ul><li>빅오(Big-O)표기법: 상한선 기준 (≤)</li><li>빅오메가(big-Ω): 하한선 기준 (≥)</li><li>빅세타(big-Θ): 상한선과 하한선 사이를 기준 (≤ ≤)</li></ul><p>알고리즘 효율성은 그래프가 위로 향할수록(값이 클수록) 비효율적이라는 뜻이다. 빅오 표기법은 상한선을 기준으로 표기하기 때문에 알고리즘의 최악의 효율정도를 제시할 수 있어 주로 사용된다.</p><p>하지만 상한선이 꼭 해당 알고리즘의 최악의 효율성과 동일한 것은 아니다. 만약 최악의 효율성은 <span class="math inline">\(n\)</span>값이 <span class="math inline">\(1000\)</span>일 때 나타난다고 가정하자. 하지만 알고리즘은 찾고자 하는 값을 5번만에도 찿을 수 있다. 따라서 최악의 효율성이 항상 그 알고리즘의 효율성을 대변하지는 않는다.</p><h3 id="빅오-표기법의-수학적-정의">빅오 표기법의 수학적 정의</h3><p>빅오 표기법의 수학적 정의는 다음과 같다.</p><p>"모든 <span class="math inline">\(n≥n_0≥0\)</span> 에 대하여 <span class="math inline">\(0≤f(n)≤c*g(n)\)</span> 인 양수 <span class="math inline">\(c\)</span>와 <span class="math inline">\(n_0\)</span>가 존재하면 <span class="math inline">\(f(n)=O(g(n))\)</span>이다."</p><p>예를 통해 개념을 정리하자. 내가 만든 알고리즘의 시간 효율성을 나타내는 함수 <span class="math inline">\(f(n)\)</span>이고 <span class="math inline">\(n\)</span>과 상수 <span class="math inline">\(c\)</span>을 아래의 방정식과 같다고 가정한다.</p><p><span class="math inline">\(f(n)=n^2+5n+8\)</span> <span class="math inline">\(g(n)=n^2+4\)</span></p><p>위의 방정식은 <span class="math inline">\(0≤f(n)≤c*g(n)\)</span>을 만족하는 상수 <span class="math inline">\(c\)</span>가 존재한다. 또한 <span class="math inline">\(n_0\)</span>은 <span class="math inline">\(f(n)\)</span>와 <span class="math inline">\(g(n)\)</span>가 같은 값일 때를 찾으면 되는데, 예시에서는 존재한다. 여기서 같은 값이란 그래프의 비교가 시작되는 지점이다. 상수 <span class="math inline">\(c\)</span>와 <span class="math inline">\(n_0\)</span>를 찾았다면 빅오 표기법으로 작성할 수 있다.</p><h3 id="빅오-표기법의-특징">빅오 표기법의 특징</h3><p>빅오 표기법은 몇 가지의 특징을 가지고 있다.</p><ul><li>상수항을 무시한다. 빅오 표기법에서는 데이터 입력값인 <span class="math inline">\(n\)</span>이 충분히 크다고 가정하며, 알고리즘의 효율성 또한 <span class="math inline">\(n\)</span>값에 좌우되기 때문에 상수항처럼 사소한 부분은 무시한다.</li></ul><p><span class="math inline">\(O(3n^2)\)</span> -&gt; <span class="math inline">\(O(n^2)\)</span></p><ul><li>영향력이 크지 않은 항도 무시한다. 빅오 표기법에서는 가장 영향력이 큰 항을 제외한 나머지는 큰 영향력이 없다. 따라서 제외하여 판단한다.</li></ul><p><span class="math inline">\(O(3n^2+5n+15)\)</span> -&gt; <span class="math inline">\(O(n^2)\)</span></p><p>아래의 그래프는 각 함수마다의 성능을 보여준다.</p><figure><img src="/images/23.png" alt="big-O notation" /><figcaption aria-hidden="true">big-O notation</figcaption></figure><p>그래프에 나와있는 시간 효율성을 정리하면 다음과 같다.</p><p><span class="math inline">\(O(1) &lt; O(log n) &lt; O(n) &lt; O(nlog n) &lt; O(n^2) &lt; O(2^n)\)</span></p><p>상수함수 &lt; 로그함수 &lt; 선형함수 &lt; 다항함수 &lt; 지수함수</p><p>위의 순서를 보면, 상수함수가 가장 작고 지수함수가 가장 크다. 즉 상수함수는 데이터 수가 많아도 빠르게 작동하는 알고리즘이며, 지수함수는 데이터 수가 많아질수록 급격하게 느려지는 알고리즘이라는 뜻이다. 시간 효율성 관점에서는 상수함수가 더욱 우월하다.</p>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
      <category>algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithms</tag>
      
      <tag>알고리즘</tag>
      
      <tag>빅오 표기법</tag>
      
      <tag>피보나치</tag>
      
      <tag>기초</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[17/20] 서브타이핑</title>
    <link href="/ko/ThinkJulia/Think-Julia-Chapter-17/"/>
    <url>/ko/ThinkJulia/Think-Julia-Chapter-17/</url>
    
    <content type="html"><![CDATA[<blockquote><p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p></blockquote><p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap18">Subtyping</a>를 한글로 요약 정리한 글입니다. <span id="more"></span></p><h2 id="서브타이핑-subtyping">서브타이핑 (Subtyping)</h2><p>이전 장에서는 다중 디스패치 매커니즘과 폴리모픽 메서드에 대해서 알아보았다. 인수 데이터 타입을 지정하지 않으면 모든 데이터 타입이 인수로 사용가능한 메서드가 생성된다. 메서드에서 허용된 데이터 타입의 서브셋(subset)을 지정하는 것은 다음 단계이다.</p><p>이번 장에서는 카드 놀이에서의 카드 덱 및 포커 패를 나타내는 데이터 타입을 사용한 서브타이핑을 볼 것이다. 만약 포커를 해본 적이 없다면, <a href="https://en.wikipedia.org/wiki/Poker">해당 링크</a>에서 관련 정보를 읽을 수 있다.</p><h3 id="카드">카드</h3><p>덱에 4개의 모양과 13개의 순위로 조합된 52개의 카드가 있다. 모양은 하트(<code>♥</code>), 스페이드(<code>♠</code>), 다이아몬드(<code>♦</code>), 클로버(<code>♣</code>)으로 구성되어 있다. 순위는 에이스(A), 2, 3, 4, 5, 6, 7, 8, 9, 10, 잭(J), 퀸(Q), 킹(K)으로 나눠져있다. 게임을 진행할 때는 에이스가 킹보다 높으며 2보다는 낮다.</p><p>카드를 표현하기 위해 새로운 객체를 정의한다면, 객체는 무슨 속성을 가져야 하는지가 명확하다. 바로 모양과 순위이다. 하지만 이 사실이 어떤 데이터 타입의 속성이어야 하는지와 연결되지는 않는다. 한 가지 방안은 <code>"Spade"</code>와 <code>"Queen"</code>처럼 문자열을 사용하는 것이다. 이런 구현의 문제점은 카드들의 순위와 모양을 비교하는 것이 어렵다는 점이다.</p><p>대안으로는 모양과 순위를 인코드(encode)하기 위해 정수를 사용하는 것이다. 인코드(encode)란 숫자와 모양 또는 숫자와 순위 사이에 매핑을 정의하는 것을 의미한다. 이런 종류의 인코딩은 암호화(encryption)이다.</p><p>예를 들어 아래의 정보는 각 모양과 이에 연결되는 정수 코드를 보여준다.</p><ul><li><code>♠</code> -&gt; 4</li><li><code>♥</code> -&gt; 3</li><li><code>♦</code> -&gt; 2</li><li><code>♣</code> -&gt; 1</li></ul><p>이 코드는 높은 값의 모양은 높은 숫자에 매핑했기 때문에 카드들을 비교하기가 더 쉽다. 우리는 카드들의 정수 코드를 사용하여 비교할 수 있다.</p><p>위에서 사용한 <code>-&gt;</code> 기호는 줄리아 프로그램에서 사용하는 것은 아니지만 매핑을 명확히 보여주기 위해서 사용한 것이다. 이와 같은 기호들은 프로그램 디자인의 일부이며, 코드에는 나타나지 않는다.</p><p><code>Card</code> 구조체의 정의는 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">struct</span> Card<br>    suit :: <span class="hljs-built_in">Int64</span><br>    rank :: <span class="hljs-built_in">Int64</span><br>    <span class="hljs-keyword">function</span> Card(suit::<span class="hljs-built_in">Int64</span>, rank::<span class="hljs-built_in">Int64</span>)<br>        <span class="hljs-meta">@assert</span>(<span class="hljs-number">1</span> ≤ suit ≤ <span class="hljs-number">4</span>, <span class="hljs-string">&quot;suit is not between 1 and 4&quot;</span>)<br>        <span class="hljs-meta">@assert</span>(<span class="hljs-number">1</span> ≤ rank ≤ <span class="hljs-number">13</span>, <span class="hljs-string">&quot;rank is not between 1 and 13&quot;</span>)<br>        new(suit, rank)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>Card</code>를 만들기 위해서는 <code>Card()</code>에 원하는 모양과 순위를 넣어 호출해야 한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; queen_of_diamonds = Card(<span class="hljs-number">2</span>, <span class="hljs-number">12</span>)<br>Card(<span class="hljs-number">2</span>, <span class="hljs-number">12</span>)<br></code></pre></td></tr></table></figure><h3 id="글로벌-변수-global-variables">글로벌 변수 (Global Variables)</h3><p>사람들이 쉽게 읽을 수 있도록 하는 <code>Card</code> 객체를 출력하기 위해서는 정수 코드로 매핑된 모양과 순위가 필요하다. 보편적인 방법은 문자열 배열로 만드는 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">const</span> suit_names = [<span class="hljs-string">&quot;♣&quot;</span>, <span class="hljs-string">&quot;♦&quot;</span>, <span class="hljs-string">&quot;♥&quot;</span>, <span class="hljs-string">&quot;♠&quot;</span>]<br><span class="hljs-keyword">const</span> rank_names = [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>, <span class="hljs-string">&quot;7&quot;</span>, <span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-string">&quot;9&quot;</span>, <span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;J&quot;</span>, <span class="hljs-string">&quot;Q&quot;</span>, <span class="hljs-string">&quot;K&quot;</span>]<br></code></pre></td></tr></table></figure><p><code>suit_names</code>과 <code>rank_names</code>은 글로벌 변수이다. <code>const</code> 선언은 변수가 오직 하나에만 할당되도록 한다. 이것은 글로벌 변수들의 실행 문제들을 해결해준다.</p><p>이제 우리는 적절한 <code>show</code> 메서드를 구현할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> Base.show(io::<span class="hljs-built_in">IO</span>, card::Card)<br>    print(io, rank_names[card.rank], suit_names[card.suit])<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>rank_names[card.rank]</code> 표현식은 "<code>rank_names</code> 배열의 인덱스로 <code>Card</code> 객체의 <code>rank</code>필드를 사용하라 그리고 알맞은 인수를 선택하라" 를 표현한 것이다.</p><p>지금까지 완성한 메서드를 사용하면, 우리는 출력된 카드를 얻을 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; Card(<span class="hljs-number">3</span>, <span class="hljs-number">11</span>)<br>J♥<br></code></pre></td></tr></table></figure><h3 id="카드-비교하기-comparing-cards">카드 비교하기 (Comparing Cards)</h3><p>내장 데이터 타입에서는 관계 연산자(<code>&lt;</code>, <code>&gt;</code>, <code>==</code>, etc.)가 값들을 비교하여 큰지, 작은지 또는 같은지를 결정한다. 하지만 개발자가 정의한 고유 데이터 타입에서는 <code>&lt;</code> 메서드를 제공하여 내장 연산자들의 실행을 가져올 수 있다.</p><p>카드를 정확하게 순서대로 나열하는 것은 명확하지 않다. 예를 들어 3 클로버와 2 다이아몬드 중에 무엇이 더 나은가? 하나는 보다 높은 순위지만 낮은 모양이고, 다른 것은 낮은 순위지만 높은 모양이다. 카드들을 비교하기 위해서는 순위와 모양 중 무엇이 더 중요한지를 결정해야 한다.</p><p>답은 아마 게임을 어떤 게임을 하고 있는지에 따라서 나뉘겠지만, 간단하게 하기 위해서 우리는 모양이 더 중요하다고 임의로 선택할 것이다. 따라서 모든 스페이드는 모든 다이아몬드보다 더 중요하다.</p><p>해당 사항을 <code>&lt;</code>로 작성할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">import</span> Base.&lt;<br><br><span class="hljs-keyword">function</span> &lt;(c1::Card, c2::Card)<br>    (c1.suit, c1.rank) &lt; (c2.suit, c2.rank)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="유닛-테스팅-unit-testing">유닛 테스팅 (Unit Testing)</h3><p>유닛 테스팅은 코드가 예상했던 대로 정확하게 작동하는지 확인해준다. 이 방법은 코드 수정 후에도 제대로 작동하는지 확인하기 위해서 사용하며, 또한 개발 중에도 코드 실행이 잘 작동하는지 미리 정의해볼 수 있다.</p><p>간단한 유닛 테스팅은 <code>@test</code>메크로로 실행된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-keyword">using</span> Test<br><br>julia&gt; <span class="hljs-meta">@test</span> Card(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>) &lt; Card(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)<br>Test Passed<br>julia&gt; <span class="hljs-meta">@test</span> Card(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) &lt; Card(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)<br>Test Passed<br></code></pre></td></tr></table></figure><p>만약 따라오는 표현식이 <code>true</code>라면 <code>@test</code>는 <code>"Test Passed"</code>를 반환하고 <code>false</code>라면 <code>"Test Failed"</code>를 반환한다 그리고 표현식이 아예 평가될 수 없다면 <code>"error result"</code>를 반환한다.</p><h3 id="덱-decks">덱 (Decks)</h3><p>지금까지는 카드를 만들었으며, 다음 단계로는 덱을 정의하는 것이다. 덱은 카드로 만들어졌기 때문에 각각의 덱은 카드 배열을 속성으로서 포함하는 것이 당연하다.</p><p>아래는 <code>Deck</code> 구조체 정의이다. 생성자는 필드로 <code>cards</code>를 가지며, 52개 카드의 기본 세트를 일반화한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">struct</span> Deck<br>    cards :: <span class="hljs-built_in">Array</span>&#123;Card, <span class="hljs-number">1</span>&#125;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> Deck()<br>    deck = Deck(Card[])<br>    <span class="hljs-keyword">for</span> suit <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:<span class="hljs-number">4</span><br>        <span class="hljs-keyword">for</span> rank <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:<span class="hljs-number">13</span><br>            push!(deck.cards, Card(suit, rank))<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    deck<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>덱을 채우는 가장 쉬운 방법은 '중첩 루프(nested loop)'를 사용하는 것이다. 바깥의 루프는 1부터 4까지의 모양을 열거하며, 내부의 루프는 1부터 13의 순위를 열거한다. 각 반복은 최신의 모양과 순위를 포함한 새로운 <code>Card</code>를 생성하여 <code>deck.cards</code>에 밀어넣는다.</p><p>아래는 <code>Deck</code>을 보여주는 <code>show</code>메서드이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> Base.show(io::<span class="hljs-built_in">IO</span>, deck::Deck)<br>    <span class="hljs-keyword">for</span> card <span class="hljs-keyword">in</span> deck.cards<br>        print(io, card, <span class="hljs-string">&quot; &quot;</span>)<br>    <span class="hljs-keyword">end</span><br>    println()<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>결과는 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; Deck()<br>A♣ <span class="hljs-number">2</span>♣ <span class="hljs-number">3</span>♣ <span class="hljs-number">4</span>♣ <span class="hljs-number">5</span>♣ <span class="hljs-number">6</span>♣ <span class="hljs-number">7</span>♣ <span class="hljs-number">8</span>♣ <span class="hljs-number">9</span>♣ <span class="hljs-number">10</span>♣ J♣ Q♣ K♣ A♦ <span class="hljs-number">2</span>♦ <span class="hljs-number">3</span>♦ <span class="hljs-number">4</span>♦ <span class="hljs-number">5</span>♦ <span class="hljs-number">6</span>♦ <span class="hljs-number">7</span>♦ <span class="hljs-number">8</span>♦ <span class="hljs-number">9</span>♦ <span class="hljs-number">10</span>♦ J♦ Q♦ K♦ A♥ <span class="hljs-number">2</span>♥ <span class="hljs-number">3</span>♥ <span class="hljs-number">4</span>♥ <span class="hljs-number">5</span>♥ <span class="hljs-number">6</span>♥ <span class="hljs-number">7</span>♥ <span class="hljs-number">8</span>♥ <span class="hljs-number">9</span>♥ <span class="hljs-number">10</span>♥ J♥ Q♥ K♥ A♠ <span class="hljs-number">2</span>♠ <span class="hljs-number">3</span>♠ <span class="hljs-number">4</span>♠ <span class="hljs-number">5</span>♠ <span class="hljs-number">6</span>♠ <span class="hljs-number">7</span>♠ <span class="hljs-number">8</span>♠ <span class="hljs-number">9</span>♠ <span class="hljs-number">10</span>♠ J♠ Q♠ K♠<br></code></pre></td></tr></table></figure><h3 id="추가-제거-셔플-그리고-정렬">추가, 제거, 셔플 그리고 정렬</h3><p>카드를 다루려면 덱으로부터 카드를 제거하고 반환하는 함수가 필요하다. <code>pop!()</code>은 편리하게 이를 수행할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> Base.pop!(deck::Deck)<br>    pop!(deck.cards)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>pop!()</code>은 배열에서 마지막 카드를 제거하기 때문에</p><p>카드를 추가하기 위해서는 <code>push!()</code>를 사용하면 된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> Base.push!(deck::Deck, card::Card)<br>    push!(deck.cards, card)<br>    deck<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>한번에 많은 작업들을 수행하지 않고 다른 메서드를 사용하는 방식을 '비니어(veneer)'라고도 부른다. 비니어는 원래 목공에서 사용되는 단어이며, 고급스럽게 보이기 위해 싼 목재 표면에 비싼 목재를 붙일 때 사용되는 고품질의 얇은 층을 의미한다. 이 예시에서 <code>push!</code>는 덱에 알맞는 배열 작동을 표현하는 얇은 메서드이며, 이 방식은 구현의 인터페이스나 외관을 향상시킨다.</p><p>또 다른 예시로서, <code>Random</code>을 사용하여 <code>suffle!()</code>이라는 함수를 작성해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">using</span> Random<br><br><span class="hljs-keyword">function</span> Random.shuffle!(deck::Deck)<br>    shuffle!(deck.cards)<br>    deck<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="추상-데이터-타입과-서브타이핑">추상 데이터 타입과 서브타이핑</h3><p>우리는 카드를 들고 있는 '손'을 표현하는 데이터 타입을 원한다. 손과 덱은 카드 모음을 만들고 추가 및 제거 작동이 필요하다는 점에서 비슷하다. 하지만 손과 덱은 다른 점도 분명히 있다. 예를 들어 포커에서는 두 손을 비교하여 누가 이길지를 비교해야 하고, 각 손의 점수를 계산해야 한다.</p><p>그래서 구체적인 데이터 타입을 그룹화하는 방법이 필요하다. 줄리아에서는 덱과 손의 부모처럼 제공하는 '추상 데이터 타입(abstract type)'을 정의하여 제공한다. 이를 '서브타이핑(subtyping)'이라고 한다.</p><p>추상 데이터 타입인 <code>CardSet</code>을 불러오자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">abstract type</span> CardSet <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>새로운 추상 데이터 타입은 <code>abstract type</code>으로 생성된다. 선택적인 "부모" 데이터 타입도 존재하는 추상 데이터 타입을 <code>&lt;:</code> 뒤에 작성함으로써 구체회될 수 있다.</p><p><code>supretype</code>이 주어지지 않으면, 기본 <code>supretype</code>은 <code>Any</code>로 지정된다. <code>Any</code>는 모든 객체가 인스턴스이고 모든 데이터 타입이 서브타입인 추상 데이터 타입이다.</p><p>지금부터는 <code>CardSet</code>의 자식인 <code>Deck</code>읖 나타낼 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">struct</span> Deck &lt;: CardSet<br>    cards :: <span class="hljs-built_in">Array</span>&#123;Card, <span class="hljs-number">1</span>&#125;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> Deck()<br>    deck = Deck(Card[])<br>    <span class="hljs-keyword">for</span> suit <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:<span class="hljs-number">4</span><br>        <span class="hljs-keyword">for</span> rank <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:<span class="hljs-number">13</span><br>            push!(deck.cards, Card(suit, rank))<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    deck<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>isa</code>연산자는 해당 객체가 주어진 데이터 타입이 맞는지 확인해준다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; deck = Deck();<br><br>julia&gt; deck <span class="hljs-keyword">isa</span> CardSet<br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>또한 손도 <code>CardSet</code>의 종류 중 하나이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">struct</span> Hand &lt;: CardSet<br>    cards :: <span class="hljs-built_in">Array</span>&#123;Card, <span class="hljs-number">1</span>&#125;<br>    label :: <span class="hljs-built_in">String</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> Hand(label::<span class="hljs-built_in">String</span>=<span class="hljs-string">&quot;&quot;</span>)<br>    Hand(Card[], label)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>52개의 새로운 카드를 손에 채우는 대신, <code>Hand</code> 생성자는 <code>cards</code>를 빈 배열과 함께 초기화한다. 선택적 인수는 생성자에 전달되어 <code>Hand</code>에 라벨을 제공한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; hand = Hand(<span class="hljs-string">&quot;new hand&quot;</span>)<br>Hand(Card[], <span class="hljs-string">&quot;new hand&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="추상-데이터-타입과-함수">추상 데이터 타입과 함수</h3><p>이제부터는 <code>CardSet</code>을 인수로 가진 함수를 통해 <code>Deck</code>과 <code>Hand</code> 사이의 공통 작업을 표현할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> Base.show(io::<span class="hljs-built_in">IO</span>, cs::CardSet)<br>    <span class="hljs-keyword">for</span> card <span class="hljs-keyword">in</span> cs.cards<br>        print(io, card, <span class="hljs-string">&quot; &quot;</span>)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> Base.pop!(cs::CardSet)<br>    pop!(cs.cards)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> Base.push!(cs::CardSet, card::Card)<br>    push!(cs.cards, card)<br>    <span class="hljs-literal">nothing</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>카드를 다루기 위해 <code>pop!()</code>과 <code>push!()</code>를 사용할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; deck = Deck()<br>A♣ <span class="hljs-number">2</span>♣ <span class="hljs-number">3</span>♣ <span class="hljs-number">4</span>♣ <span class="hljs-number">5</span>♣ <span class="hljs-number">6</span>♣ <span class="hljs-number">7</span>♣ <span class="hljs-number">8</span>♣ <span class="hljs-number">9</span>♣ <span class="hljs-number">10</span>♣ J♣ Q♣ K♣ A♦ <span class="hljs-number">2</span>♦ <span class="hljs-number">3</span>♦ <span class="hljs-number">4</span>♦ <span class="hljs-number">5</span>♦ <span class="hljs-number">6</span>♦ <span class="hljs-number">7</span>♦ <span class="hljs-number">8</span>♦ <span class="hljs-number">9</span>♦ <span class="hljs-number">10</span>♦ J♦ Q♦ K♦ A♥ <span class="hljs-number">2</span>♥ <span class="hljs-number">3</span>♥ <span class="hljs-number">4</span>♥ <span class="hljs-number">5</span>♥ <span class="hljs-number">6</span>♥ <span class="hljs-number">7</span>♥ <span class="hljs-number">8</span>♥ <span class="hljs-number">9</span>♥ <span class="hljs-number">10</span>♥ J♥ Q♥ K♥ A♠ <span class="hljs-number">2</span>♠ <span class="hljs-number">3</span>♠ <span class="hljs-number">4</span>♠ <span class="hljs-number">5</span>♠ <span class="hljs-number">6</span>♠ <span class="hljs-number">7</span>♠ <span class="hljs-number">8</span>♠ <span class="hljs-number">9</span>♠ <span class="hljs-number">10</span>♠ J♠ Q♠ K♠<br>julia&gt; shuffle!(deck)<br>J♦ <span class="hljs-number">10</span>♣ <span class="hljs-number">8</span>♠ <span class="hljs-number">9</span>♥ <span class="hljs-number">5</span>♠ <span class="hljs-number">7</span>♣ <span class="hljs-number">6</span>♦ A♠ J♣ <span class="hljs-number">7</span>♠ <span class="hljs-number">5</span>♦ <span class="hljs-number">10</span>♥ <span class="hljs-number">3</span>♦ <span class="hljs-number">9</span>♦ <span class="hljs-number">9</span>♣ <span class="hljs-number">4</span>♣ <span class="hljs-number">8</span>♦ <span class="hljs-number">8</span>♥ <span class="hljs-number">5</span>♣ A♥ K♥ K♦ K♠ <span class="hljs-number">4</span>♦ A♦ Q♥ <span class="hljs-number">6</span>♠ <span class="hljs-number">2</span>♦ <span class="hljs-number">6</span>♥ <span class="hljs-number">2</span>♣ <span class="hljs-number">10</span>♠ <span class="hljs-number">3</span>♥ <span class="hljs-number">2</span>♥ J♥ Q♣ <span class="hljs-number">5</span>♥ <span class="hljs-number">2</span>♠ <span class="hljs-number">9</span>♠ <span class="hljs-number">10</span>♦ Q♠ <span class="hljs-number">3</span>♠ <span class="hljs-number">8</span>♣ K♣ <span class="hljs-number">7</span>♥ <span class="hljs-number">3</span>♣ J♠ <span class="hljs-number">4</span>♥ <span class="hljs-number">6</span>♣ <span class="hljs-number">7</span>♦ <span class="hljs-number">4</span>♠ A♣ Q♦<br>julia&gt; card = pop!(deck)<br>Q♦<br>julia&gt; push!(hand, card)<br></code></pre></td></tr></table></figure><p>자연스러운 다음 단계는 <code>move!()</code>에서 해당 코드를 캡슐화하는 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> move!(cs1::CardSet, cs2::CardSet, n::<span class="hljs-built_in">Int</span>)<br>    <span class="hljs-meta">@assert</span> <span class="hljs-number">1</span> ≤ n ≤ length(cs1.cards)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:n<br>        card = pop!(cs1)<br>        push!(cs2, card)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-literal">nothing</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>move!()</code>는 두 개의 <code>CardSet</code> 객체와 카드를 처리할 수까지 총 세 개의 인수를 가져간다. 두 개의 <code>CardSet</code> 객체는 변경가능하며, <code>nothing</code>을 반환한다.</p><p>게임에서 카드들은 한 손에서 다른 손으로 가거나 손에서 덱으로 이동한다. 이런 작동들은 모두 <code>move!()</code>를 사용하면 된다. 즉, <code>cs1</code>과 <code>cs2</code>는 <code>Deck</code>이나 <code>hand</code>일 수 있다.</p><h3 id="데이터-타입-다이어그램">데이터 타입 다이어그램</h3><p>지금까지는 프로그램의 상태를 보여주는 스택 다이어그램과 객체와 값의 속성을 보여주는 객체 다이어그램을 살펴보았다. 이런 다이어그램들은 프로그램 실행에서 스냅샷을 나타내므로 프로그램이 실행되면 이들도 변한다.</p><p>또한 다이어그램은 가끔 과도하게 상세하다. '데이터 타입 다이어그램(type diagram)'은 프로그램 구조를 더 추상적으로 표현한다. 개별적인 객체를 모두 보여주는 것 대신에 데이터 타입의 관계만을 보여준다.</p><p>데이터 타입 사이의 관계의 종류는 여러 가지이다.</p><ul><li><p>구체적인 데이터 타입의 객체는 다른 데이터 타입의 객체로부터 참조를 포함할 수 있다. 에를 들어, 각 직사각형은 Point의 참조를 포함하고, 덱은 카드 배열의 참조를 포함한다. 이런 관계의 종류는 "HAS-A"라고 한다. 즉, “직사각형은 포인트를 참조한다 (a Rectangle has a Point)” 인 것이다.</p></li><li><p>구체적인 데이터 타입은 서브데이터 타입으로서 추상 데이터 타입을 가진다. 이런 관계의 종류를 "IS-A"이다. 즉, "손은 Cardset의 종류이다.(a Hand is a kind of a CardSet)" 이다.</p></li><li><p>한 데이터 타입의 객체는 다른 데이터 타입의 객체를 매개 변수로 사용하거나 계산의 일부로 사용한다는 점에서 다른 데이터 타입에 따라 달라질 수 있다. 이런 관계를 "종속성(dependency)"이라고 한다.</p></li></ul><figure><img src="/images/24.png" alt="type diagram" /><figcaption aria-hidden="true">type diagram</figcaption></figure><p>위의 다이어그램에서 속인 빈 화살표는 IS-A 관계를 보여준다. Hand는 CardSet의 서브데이터 타입을 가지고 있다.</p><p>일반적인 화살표는 HAS-A 관계를 보여준다. Deck은 Card객체를 참조한다.</p><p>옆에 *를 가진 화살표는 다수(multiplicity)이다. 이것은 Deck이 얼마나 많은 카드를 가지고 있는지를 표시한다. 다수(multiplicity)는 <code>52</code>와 같은 간단한 숫자나 <code>like 5:7</code>같은 범위, Deck이 여러 개의 Cards를 가진다는 별 표시 등으로 표현된다.</p><p>종속성은 위의 다이어그램에 없다. 일반적으로 종속성은 점선 화살표로 표시되며, 종속성이 많을 때에는 생략되기도 한다.</p><p>다이어그램의 세부사항들은 Deck이 카드들의 배열을 포함한다는 것을 보여주지만, 배열이나 딕셔너리같은 내장 데이터 타입들은 보통 타입 다이어그램에 포함되지 않는다.</p><h3 id="디버깅">디버깅</h3><p>서브타이핑은 객체를 인수로 가진 함수를 호출할 때 어떤 메서드가 호출되는지 파악하기 힘드므로 디버깅하기 어렵게 만든다.</p><p><code>Hand</code>객체에서 작동하는 함수를 작성한다고 가정해보자. 그러면 <code>+PokerHand+s</code>, <code>+BridgeHand+s</code>와 같은 <code>hand+s</code>의 모든 종류들에 작동할 수 있도록 만들고 싶을 것이다. <code>+sort!</code>와 같은 메서드를 호출하면 추상 데이터 타입인 <code>Hand</code>에 대해 정의된 메서드를 얻을 수 있다. 하지만 서브데이터 타입 중 하나를 인수로 사용하는 <code>sort!</code>메서드가 존재한다면, 아레의 버전을 얻게 될 것이다. 이런 방식은 보통 좋지만, 때로는 헷갈릴 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> Base.sort!(hand::Hand)<br>    sort!(hand.cards)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>프로그램을 통한 실행 흐름에 대해 확실할 수 없는 경우 가장 간단한 해결책은 관련 메서드 시작부분에 <code>print</code>문을 추가하는 것이다. <code>shuffle!</code>이 <code>Running shuffle! Deck</code>과 같은 메시지를 출력하면, 프로그램이 작동할 때 실행 흐름을 추적한다.</p><p>더 나은 대안으로는 <code>@which</code> 매크로를 사용하는 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-meta">@which</span> sort!(hand)<br>sort!(hand::Hand) <span class="hljs-keyword">in</span> Main at REPL[<span class="hljs-number">5</span>]:<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>그러면 <code>Hand</code>의 <code>sort!</code> 메서드는 인수로서 <code>Hand</code> 데이터 타입의 객체 하나를 가진다.</p><p>설계 제안은 다음과 같다. 메서드를 재정의(override)할 때, 새로운 메서드의 인터페이스는 이전 메서드와 동일해야 한다. 동일한 매개 변수를 가져가고 동일한 데이터 타입을 반환하며 동이란 전제 조건 및 사후 조건을 준수해야 한다. 이 조건을 따른다면, <code>CardSet</code>과 같은 supertype의 인스턴스와 같이 작동하도록 설계된 함수가 서브데이터 타입인 <code>Deck</code>과 <code>Hand</code>의 인스턴스에도 작동한다는 것을 알 수 있다.</p><p>이와 같은 '리스코프 치환 규칙(Liskov substitution principle)'을 어긴다면, 해당 코드는 아마 붕괴할 것이다.</p><p><code>supertype()</code>은 데이터 타입의 supertype을 찾아준다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; supertype(Deck)<br>CardSet<br></code></pre></td></tr></table></figure><h3 id="데이터-캡슐화">데이터 캡슐화</h3><p>이전 섹션에서는 '데이터 타입 지향 디자인 (type-oriented design)'이라는 개발 계획을 보여줬다. 우리는 <code>Point</code>,<code>Rectangle</code>,<code>MyTime</code>과 같이 필요한 객체들을 확인하고, 그들을 표현하기 위해 구조체를 정의하였다. 각각의 경우에는 객체와 현실세계의 실체 사이에 명백한 대응 관계가 있다.</p><p>그러나 때로는 어떤 객체가 필요한지, 어떻게 상호작용해야 하는지 명확하지 않다. 이 경우에는 다른 개발 계획이 필요하다. 캡슐화와 일반화를 통해 함수 인터페이스로 발견한 것과 같은 방식으로 우리는 데이터 캡슐화를 통해 데이터 타입 인터페이스를 발견할 수 있다.</p><p><a href="https://dev-bearabbit.github.io/2020/03/12/ThinkJulia/Think-Julia-Chapter-13/">12장</a>에서 본 마르코프 분석이 좋은 예시이다. 아래의 코드는 글로벌 변수인 <code>prefix</code>와 <code>suffixes</code>를 정의한 것이다. 이 변수들은 여러 함수에서 사용될 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">suffixes = <span class="hljs-built_in">Dict</span>()<br>prefix = []<br></code></pre></td></tr></table></figure><p>위의 변수들은 글로벌 변수이기 때문에 한 번에 하나의 분석만 실행할 수 있다. 두 개의 텍스트를 읽으면 접두사와 접미사가 동일한 데이터 구조에 추가되어 흥미로운 생성 텍스트가 만들어진다.</p><p>여러 분석을 실행하고, 별도로 유지하기 위해서는 각 분석의 상태를 객체에 캡슐화할 수 있다. 아래의 코드를 통해 확인하자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">struct</span> Markov<br>    order :: <span class="hljs-built_in">Int64</span><br>    suffixes :: <span class="hljs-built_in">Dict</span>&#123;<span class="hljs-built_in">Tuple</span>&#123;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">Vararg</span>&#123;<span class="hljs-built_in">String</span>&#125;&#125;, <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">String</span>, <span class="hljs-number">1</span>&#125;&#125;<br>    prefix :: <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">String</span>, <span class="hljs-number">1</span>&#125;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> Markov(order::<span class="hljs-built_in">Int64</span>=<span class="hljs-number">2</span>)<br>    new(order, <span class="hljs-built_in">Dict</span>&#123;<span class="hljs-built_in">Tuple</span>&#123;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">Vararg</span>&#123;<span class="hljs-built_in">String</span>&#125;&#125;, <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">String</span>, <span class="hljs-number">1</span>&#125;&#125;(), <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">String</span>, <span class="hljs-number">1</span>&#125;())<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>그 다음, 함수를 메서드를 변환한다. 예를 들어 아래의 <code>processword</code>를 보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> processword(markov::Markov, word::<span class="hljs-built_in">String</span>)<br>    <span class="hljs-keyword">if</span> length(markov.prefix) &lt; markov.order<br>        push!(markov.prefix, word)<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">end</span><br>    get!(markov.suffixes, (markov.prefix...,), <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">String</span>, <span class="hljs-number">1</span>&#125;())<br>    push!(markov.suffixes[(markov.prefix...,)], word)<br>    popfirst!(markov.prefix)<br>    push!(markov.prefix, word)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>작동을 변경하지 않고 디자인만 변경하는 프로그램 변환은 <a href="https://dev-bearabbit.github.io/2020/03/02/ThinkJulia/Think-Julia-Chapter-4/">리팩토링</a>의 또 다른 예시이다.</p><p>이 예시는 데이터 타입 설계를 위한 개발 계획을 제시한다.</p><ul><li><p>글로벌 변수를 읽고 쓰는 함수를 시작하시오.</p></li><li><p>프로그램이 작동하면 전역 변수들과 그들을 사용하는 함수 사이의 연관성을 찾으시오.</p></li><li><p>관련 변수를 구조체의 필드로서 캡슐화하시오.</p></li><li><p>연관된 함수들을 새로운 데이터 타입의 객체가 인수인 메서드로 변환하시오.</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>think julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>줄리아</tag>
      
      <tag>Julia</tag>
      
      <tag>Think Julia</tag>
      
      <tag>기초 강의</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[16/20] 다중 디스패치</title>
    <link href="/ko/ThinkJulia/Think-Julia-Chapter-16/"/>
    <url>/ko/ThinkJulia/Think-Julia-Chapter-16/</url>
    
    <content type="html"><![CDATA[<blockquote><p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p></blockquote><p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap17">Multiple Dispatch</a>를 한글로 요약 정리한 글입니다. <span id="more"></span></p><h2 id="다중-디스패치-multiple-dispatch">다중 디스패치 (Multiple Dispatch)</h2><p>줄리아에서는 다른 데이터 타입들에서도 작동하는 코드를 작성할 수 있으며, 해당 코드를 '제네릭 프로그래밍(generic programming)'이라고 한다.</p><p>이번 장에서는 줄리아에서 데이터 타입 선언 사용하는 방법에 설명하고 인수의 데이터 타입에 따라 다른 작동을 구현하는 함수인 다중 디스패치(Multiple Dispatch)에 대해 알아볼 것이다.</p><h3 id="데이터-타입-선언-type-declarations">데이터 타입 선언 (Type Declarations)</h3><p><code>::</code> 연산자는 변수나 표현식에 '데이터 타입 주석(type annotations)'을 붙인다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; (<span class="hljs-number">1</span> + <span class="hljs-number">2</span>) :: <span class="hljs-built_in">Float64</span><br>ERROR: <span class="hljs-built_in">TypeError</span>: <span class="hljs-keyword">in</span> typeassert, expected <span class="hljs-built_in">Float64</span>, got <span class="hljs-built_in">Int64</span><br>julia&gt; (<span class="hljs-number">1</span> + <span class="hljs-number">2</span>) :: <span class="hljs-built_in">Int64</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>이런 방식은 개발자가 예측한 대로 프로그램이 작동하는지 확인하는데 도움을 준다.</p><p>또한 <code>::</code> 연산자는 변수 옆인 할당문 왼쪽 측면에도 붙을 수도 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-keyword">function</span> returnfloat()<br>           x::<span class="hljs-built_in">Float64</span> = <span class="hljs-number">100</span><br>           x<br>       <span class="hljs-keyword">end</span><br>returnfloat (generic <span class="hljs-keyword">function</span> with <span class="hljs-number">1</span> method)<br>julia&gt; x = returnfloat()<br><span class="hljs-number">100.0</span><br>julia&gt; typeof(x)<br><span class="hljs-built_in">Float64</span><br></code></pre></td></tr></table></figure><p>변수 <code>x</code>는 데이터 타입이 항상 <code>Float64</code>이며, 값은 부동 소수점으로 변환된다.</p><p>또한 데이터 타입 주석은 함수의 정의 헤더 부분에도 불일 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> sinc(x)::<span class="hljs-built_in">Float64</span><br>    <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">end</span><br>    sin(x)/(x)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>sinc()</code>의 반환 값은 항상 <code>Float64</code>로 변환된다.</p><p>데이터 타입이 생략될 때, 줄리아에서는 항상 데이터 타입 <code>Any</code>을 값으로 사용할 수 있다.</p><h3 id="메서드-methods">메서드 (Methods)</h3><p><a href="https://dev-bearabbit.github.io/2020/03/16/ThinkJulia/Think-Julia-Chapter-16/">구조체와 함수</a>에서 <code>MyTime</code>이라는 구조체를 정의하였다. <code>printtime()</code>이라는 함수를 사용하여 작성해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">using</span> Printf<br><br><span class="hljs-keyword">struct</span> MyTime<br>    hour :: <span class="hljs-built_in">Int64</span><br>    minute :: <span class="hljs-built_in">Int64</span><br>    second :: <span class="hljs-built_in">Int64</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> printtime(time)<br>    <span class="hljs-meta">@printf</span>(<span class="hljs-string">&quot;%02d:%02d:%02d&quot;</span>, time.hour, time.minute, time.second)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>보다시피, 데이터 타입 선언은 성능상의 이유로 구조체 정의의 필드에 추가될 수 있다.</p><p>위 함수를 호출하려면, <code>MyTime</code> 객체를 인수로 전달해야 한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; start = MyTime(<span class="hljs-number">9</span>, <span class="hljs-number">45</span>, <span class="hljs-number">0</span>)<br>MyTime(<span class="hljs-number">9</span>, <span class="hljs-number">45</span>, <span class="hljs-number">0</span>)<br>julia&gt; printtime(start)<br><span class="hljs-number">09</span>:<span class="hljs-number">45</span>:<span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p><code>MyTime</code> 객체만을 인수로 받는다는 메서드를 <code>printtime()</code>에 추가하기 위해서는 함수 정의에 <code>::MyTime</code>을 인수로 작성하면 된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> printtime(time::MyTime)<br>    <span class="hljs-meta">@printf</span>(<span class="hljs-string">&quot;%02d:%02d:%02d&quot;</span>, time.hour, time.minute, time.second)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>메서드는 특정 기호가 포함된 함수 정의이다. <code>printtime()</code>은 <code>MyTime</code> 객체만을 인수로 받는다.</p><p><code>printtime()</code>를 <code>MyTime</code> 객체로 호출하는 것은 아래와 같은 결과를 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; printtime(start)<br><span class="hljs-number">09</span>:<span class="hljs-number">45</span>:<span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p>아래는 <code>::</code>을 사용하지 않고 함수를 재정의하여 모든 데이터 타입을 인수로 허용한 함수이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> printtime(time)<br>    println(<span class="hljs-string">&quot;I don&#x27;t know how to print the argument time.&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>만약 <code>MyTime</code> 객체가 아닌 다른 데이터 타입을 인수로 하여 <code>printtime()</code>을 호출한다면 아래와 같은 결과를 얻는다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; printtime(<span class="hljs-number">150</span>)<br>I don&#x27;t know how to print the argument time.<br></code></pre></td></tr></table></figure><h3 id="추가적-예시들-additional-examples">추가적 예시들 (Additional Examples)</h3><p>앞서 <a href="https://dev-bearabbit.github.io/2020/03/16/ThinkJulia/Think-Julia-Chapter-16/">15장</a>에서 사용했던 <code>increment()</code>에 인수를 세부적으로 설정하여 재정의할 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> increment(time::MyTime, seconds::<span class="hljs-built_in">Int64</span>)<br>    seconds += timetoint(time)<br>    inttotime(seconds)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>한번 더 짚고 넘어가자면, 위의 함수는 '순수 함수(pure function)'이며 '변경자(modifier)'는 아니다.</p><p>아래의 코드는 <code>increment()</code>를 불러오는 방법이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; start = MyTime(<span class="hljs-number">9</span>, <span class="hljs-number">45</span>, <span class="hljs-number">0</span>)<br>MyTime(<span class="hljs-number">9</span>, <span class="hljs-number">45</span>, <span class="hljs-number">0</span>)<br>julia&gt; increment(start, <span class="hljs-number">1337</span>)<br>MyTime(<span class="hljs-number">10</span>, <span class="hljs-number">7</span>, <span class="hljs-number">17</span>)<br></code></pre></td></tr></table></figure><p>인수 순서를 바꿔서 넣는다면, 오류 메시지를 얻는다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; increment(<span class="hljs-number">1337</span>, start)<br>ERROR: <span class="hljs-built_in">MethodError</span>: no method matching increment(::<span class="hljs-built_in">Int64</span>, ::MyTime)<br></code></pre></td></tr></table></figure><p>그 이유는 메서드에 정의된 순서가 <code>increment(time::MyTime, seconds::Int64)</code>이지 <code>increment(seconds::Int64, time::MyTime)</code>가 아니기 때문이다.</p><p>다음으로는 두 인수를 비교하는 <code>isafter()</code>를 <code>MyTime</code> 객체만 인수로 받을 수 있도록 설정해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> isafter(t1::MyTime, t2::MyTime)<br>    (t1.hour, t1.minute, t1.second) &gt; (t2.hour, t2.minute, t2.second)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>또한 선택적 인수를 사용하면 '다중 메서드 정의(multiple method definitions)'가 구현된 셈이다. 예시는 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> f(a=<span class="hljs-number">1</span>, b=<span class="hljs-number">2</span>)<br>    a + <span class="hljs-number">2</span>b<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위 함수는 아래의 세 가지 메서드로 변환된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia">f(a, b) = a + <span class="hljs-number">2</span>b<br>f(a) = f(a, <span class="hljs-number">2</span>)<br>f() = f(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>이 표현식들은 유효한 줄리아 메서드 정의이며, 함수 또는 메서드를 정의하는 단축 표기 방법이다.</p><h3 id="생성자-constructors">생성자 (Constructors)</h3><p>생성자(Constructors)는 객체를 만들기 위해서 호출되는 특별한 함수이다. <code>MyTime</code>의 기본 생성자 메서드는 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">MyTime(hour, minute, second)<br>MyTime(hour::<span class="hljs-built_in">Int64</span>, minute::<span class="hljs-built_in">Int64</span>, second::<span class="hljs-built_in">Int64</span>)<br></code></pre></td></tr></table></figure><p>또한 자체 '외부 생성자(outer constructor)' 메서드를 추가할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> MyTime(time::MyTime)<br>    MyTime(time.hour, time.minute, time.second)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>이 메서드는 새로운 <code>MyTime</code> 객체가 인수의 복사본이기 때문에 '복사 생성자(copy constructor)'라고도 부른다.</p><p>인수를 변경하지 못하게 하려면, '내부 생성자(inner constructor)' 메서드가 필요하다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">struct</span> MyTime<br>    hour :: <span class="hljs-built_in">Int64</span><br>    minute :: <span class="hljs-built_in">Int64</span><br>    second :: <span class="hljs-built_in">Int64</span><br>    <span class="hljs-keyword">function</span> MyTime(hour::<span class="hljs-built_in">Int64</span>=<span class="hljs-number">0</span>, minute::<span class="hljs-built_in">Int64</span>=<span class="hljs-number">0</span>, second::<span class="hljs-built_in">Int64</span>=<span class="hljs-number">0</span>)<br>        <span class="hljs-meta">@assert</span>(<span class="hljs-number">0</span> ≤ minute &lt; <span class="hljs-number">60</span>, <span class="hljs-string">&quot;Minute is not between 0 and 60.&quot;</span>)<br>        <span class="hljs-meta">@assert</span>(<span class="hljs-number">0</span> ≤ second &lt; <span class="hljs-number">60</span>, <span class="hljs-string">&quot;Second is not between 0 and 60.&quot;</span>)<br>        new(hour, minute, second)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>이제 구조체인 <code>MyTime</code>은 4개의 내부 생성자 메서드를 가지고 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">MyTime()<br>MyTime(hour::<span class="hljs-built_in">Int64</span>)<br>MyTime(hour::<span class="hljs-built_in">Int64</span>, minute::<span class="hljs-built_in">Int64</span>)<br>MyTime(hour::<span class="hljs-built_in">Int64</span>, minute::<span class="hljs-built_in">Int64</span>, second::<span class="hljs-built_in">Int64</span>)<br></code></pre></td></tr></table></figure><p>내부 생성자 메서드는 항상 데이터 타입 선언 블럭 내에 정의되며, 새로 선언된 데이터 타입의 객체를 만드는 <code>new()</code>라는 특수 함수에 접근할 수 있다.</p><p><strong>WARNING</strong> 내부 생성자가 정의되었다면 기본 생성자는 사용할 수 없다. 따라서 필요한 내부 생성자는 명확하게 작성해야 한다.</p><p>로컬 함수인 <code>new()</code>의 인수 없이 사용하는 두 번째 메서드는 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">mutable struct</span> MyTime<br>    hour :: <span class="hljs-built_in">Int</span><br>    minute :: <span class="hljs-built_in">Int</span><br>    second :: <span class="hljs-built_in">Int</span><br>    <span class="hljs-keyword">function</span> MyTime(hour::<span class="hljs-built_in">Int64</span>=<span class="hljs-number">0</span>, minute::<span class="hljs-built_in">Int64</span>=<span class="hljs-number">0</span>, second::<span class="hljs-built_in">Int64</span>=<span class="hljs-number">0</span>)<br>        <span class="hljs-meta">@assert</span>(<span class="hljs-number">0</span> ≤ minute &lt; <span class="hljs-number">60</span>, <span class="hljs-string">&quot;Minute is between 0 and 60.&quot;</span>)<br>        <span class="hljs-meta">@assert</span>(<span class="hljs-number">0</span> ≤ second &lt; <span class="hljs-number">60</span>, <span class="hljs-string">&quot;Second is between 0 and 60.&quot;</span>)<br>        time = new()<br>        time.hour = hour<br>        time.minute = minute<br>        time.second = second<br>        time<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위 코드는 필드 하나가 자체 구조체가 되는 '재귀 데이터 구조(recursive data structures)'를 가능하게 한다. 해당 예시의 구조체는 인스턴스화 이후에 필드가 수정되기 때문에 변경 가능해야 한다.</p><h3 id="show"><code>show</code></h3><p><code>show()</code>는 객체를 문자열로 표현하여 반환하는 특별한 함수이다. 아래의 코드는 <code>MyTime</code> 객체에 <code>show</code> 메서드를 사용한 예시이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">using</span> Printf<br><br><span class="hljs-keyword">function</span> Base.show(io::<span class="hljs-built_in">IO</span>, time::MyTime)<br>    <span class="hljs-meta">@printf</span>(io, <span class="hljs-string">&quot;%02d:%02d:%02d&quot;</span>, time.hour, time.minute, time.second)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>Base.show</code> 함수에 새로운 메서드를 추가하고 싶기 때문에 <code>show</code>앞에 <code>Base</code>를 작성하였다.</p><p>객체를 출력하면 줄리아는 <code>show()</code>를 실행한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; time = MyTime(<span class="hljs-number">9</span>, <span class="hljs-number">45</span>)<br><span class="hljs-number">09</span>:<span class="hljs-number">45</span>:<span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p>새로운 복합 데이터 타입을 작성할 때는 항상 외부 생성자를 사용한다. 이렇게 하면 객체와 <code>show</code>를 인스턴스하기 더 쉬워져서 디버깅에 유용하다.</p><h3 id="연산자-오버로딩-operator-overloading">연산자 오버로딩 (operator overloading)</h3><p>연산자 메서드를 정의함으로써, 개발자가 정의한 고유 데이터 타입 안에서 연산자들이 어떻게 작동하는지를 지정할 수 있다. 예를 들어 만약 두 개의 <code>MyTime</code> 인수와 <code>+</code>메서드를 정의하였다면, <code>MyTime</code> 객체에서 <code>+</code> 연산자를 사용할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">import</span> Base.+<br><br><span class="hljs-keyword">function</span> +(t1::MyTime, t2::MyTime)<br>    seconds = timetoint(t1) + timetoint(t2)<br>    inttotime(seconds)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>import</code>문은 메서드를 추가할 수 있도록 <code>+</code> 연산자를 로컬 범위에서 가져온다.</p><p>아래의 코드는 정의한 <code>+</code> 연산자를 어떻게 사용하는지를 보여준다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; start = MyTime(<span class="hljs-number">9</span>, <span class="hljs-number">45</span>)<br><span class="hljs-number">09</span>:<span class="hljs-number">45</span>:<span class="hljs-number">00</span><br>julia&gt; duration = MyTime(<span class="hljs-number">1</span>, <span class="hljs-number">35</span>, <span class="hljs-number">0</span>)<br><span class="hljs-number">01</span>:<span class="hljs-number">35</span>:<span class="hljs-number">00</span><br>julia&gt; start + duration<br><span class="hljs-number">11</span>:<span class="hljs-number">20</span>:<span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p>이제부터는 <code>+</code> 연산자를 <code>MyTime</code>객체와 사용하면 줄리아는 위에서 만든 메서드를 가져오며, REPL이 결과를 보여줄 때는 줄리아가 앞에서 작성한 <code>show</code>를 사용하여 보여준다.</p><p>개발자가 정의한 데이터 타입에서 작동하도록 연산자들의 작동을 추가하는 것을 '연산자 오버로딩(operator overloading)'이라고 한다.</p><h3 id="다중-디스패치-multiple-dispatch-1">다중 디스패치 (Multiple dispatch)</h3><p>이전 섹션에서는 <code>MyTime</code>객체끼리 더하는 과정을 보았다. 하지만 만약 <code>MyTime</code>객체에 정수를 더하고 싶다면 어떻게 해야할까?</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> +(time::MyTime, seconds::<span class="hljs-built_in">Int64</span>)<br>    increment(time, seconds)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 함수는 <code>+</code> 연산자가 <code>MyTime</code>객체와 정수가 더해지는 방법을 메서드로 정의하였다.</p><p>두 개를 더한 결과는 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; start = MyTime(<span class="hljs-number">9</span>, <span class="hljs-number">45</span>)<br><span class="hljs-number">09</span>:<span class="hljs-number">45</span>:<span class="hljs-number">00</span><br>julia&gt; start + <span class="hljs-number">1337</span><br><span class="hljs-number">10</span>:<span class="hljs-number">07</span>:<span class="hljs-number">17</span><br></code></pre></td></tr></table></figure><p>덧셈은 교환법칙이 성립하기 때문에 인수 순서가 변경된 메서드도 추가한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> +(seconds::<span class="hljs-built_in">Int64</span>, time::MyTime)<br>  time + seconds<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>인수 순서를 바꿔도 똑같은 결과를 얻을 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-number">1337</span> + start<br><span class="hljs-number">10</span>:<span class="hljs-number">07</span>:<span class="hljs-number">17</span><br></code></pre></td></tr></table></figure><p>함수를 적용할 때 어떤 메서드가 적합한지 선택하는 것을 '디스패치(dispatch)'라고 한다. 줄리아는 디스패치 프로세스가 주어진 인수의 수와 데이터 타입에 따라 호출할 함수의 메서드를 선택할 수 있도록 한다. 함수의 인수를 모두 사용하여 호출할 메서드를 선택하는 것을 '다중 디스패치(multiple dispatch)'라고 한다.</p><h3 id="제네릭-프로그래밍-generic-programming">제네릭 프로그래밍 (Generic Programming)</h3><p>다중 디스패치는 유용하지만 항상 필요한 것은 아니다. 다른 데이터 타입을 인수로 하여 함수를 작성하면 다중 디스패치를 사용하지 않아도 된다.</p><p>지금까지 문자열에 대해 작성한 많은 함수들은 다른 데이터 타입의 시퀀스에도 작동한다. 예를 들어, <a href="https://dev-bearabbit.github.io/2020/03/10/ThinkJulia/Think-Julia-Chapter-11/">딕셔너리로 카운팅하기</a>에서 사용한 단어의 개수를 세어주는 <code>histogram()</code> 을 보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> histogram(s)<br>    d = <span class="hljs-built_in">Dict</span>()<br>    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s<br>        <span class="hljs-keyword">if</span> c ∉ keys(d)<br>            d[c] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span><br>            d[c] += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    d<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>이 함수에서 <code>s</code>의 요소는 해시(hashable)할 수 있기에 딕셔너리의 키(key)로 사용될 수 있고, 따라서 리스트, 튜플, 심지어 딕셔너리에서도 작동한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t = (<span class="hljs-string">&quot;spam&quot;</span>, <span class="hljs-string">&quot;egg&quot;</span>, <span class="hljs-string">&quot;spam&quot;</span>, <span class="hljs-string">&quot;spam&quot;</span>, <span class="hljs-string">&quot;bacon&quot;</span>, <span class="hljs-string">&quot;spam&quot;</span>)<br>(<span class="hljs-string">&quot;spam&quot;</span>, <span class="hljs-string">&quot;egg&quot;</span>, <span class="hljs-string">&quot;spam&quot;</span>, <span class="hljs-string">&quot;spam&quot;</span>, <span class="hljs-string">&quot;bacon&quot;</span>, <span class="hljs-string">&quot;spam&quot;</span>)<br>julia&gt; histogram(t)<br><span class="hljs-built_in">Dict</span>&#123;<span class="hljs-built_in">Any</span>,<span class="hljs-built_in">Any</span>&#125; with <span class="hljs-number">3</span> entries:<br>  <span class="hljs-string">&quot;bacon&quot;</span> =&gt; <span class="hljs-number">1</span><br>  <span class="hljs-string">&quot;spam&quot;</span>  =&gt; <span class="hljs-number">4</span><br>  <span class="hljs-string">&quot;egg&quot;</span>   =&gt; <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>여러 데이터 타입에서도 작동하는 함수들을 폴리모픽(polymorphic)이라고 한다. 폴리모픽은 코드를 재사용할 수 있도록 도와준다.</p><p>예를 들어, 시퀀스의 요소들의 합을 제공하는 내장함수인 <code>sum()</code>은 덧셈을 가지고 있는 모든 데이터 타입의 시퀀스에 작동한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t1 = MyTime(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>)<br><span class="hljs-number">01</span>:<span class="hljs-number">07</span>:<span class="hljs-number">02</span><br>julia&gt; t2 = MyTime(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>)<br><span class="hljs-number">01</span>:<span class="hljs-number">05</span>:<span class="hljs-number">08</span><br>julia&gt; t3 = MyTime(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>)<br><span class="hljs-number">01</span>:<span class="hljs-number">05</span>:<span class="hljs-number">00</span><br>julia&gt; sum((t1, t2, t3))<br><span class="hljs-number">03</span>:<span class="hljs-number">17</span>:<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>일반적으로 함수 내부의 모든 연산들이 지정된 데이터 타입으로 작동하면, 함수는 그 유형에도 작동된다.</p><p>폴리모픽의 가장 좋은 종류는 의도하지 않았는데 이미 작성된 함수가 해당 데이터 타입에 적용가능하다는 것을 알게되는 것이다.</p><h3 id="인터페이스와-구현-interface-and-implementation">인터페이스와 구현 (Interface and Implementation)</h3><p>다중 디스패치의 목적 중 하나는 소프트웨어의 유지 및 보수를 쉽게 만드는 것이다. 즉, 시스템의 다른 부분이 변경될 때 프로그램을 계속 작동시키고 새로운 요구 사항을 충족하도록 프로그램을 수정하는 것이다.</p><p>이러한 목표를 달성하는 데 도움이 되는 디자인 원칙은 인터페이스(interface)를 구현(implementation)과 분리하는 것이다. 즉 데이터 타입이 지정된 인수를 가진 메서드는 해당 데이터 타입의 필드가 어떻게 표현되는지에 의존해서는 안된다는 것을 의미한다.</p><p>예를 들어, 이 장에서 우리는 시간을 나타내는 구조체를 개발했다. 이 데이터 타입으로 지정된 인수가 있는 메서드는 <code>timetoint</code>, <code>isafter</code> 그리고 <code>+</code>가 있다. 우리는 이 메서드들을 여러 방법으로 구현할 수 있다. 구현의 세부 사항들은 <code>MyTime</code>을 어떻게 표현하는지에 의존한다. 이 장에서 <code>MyTime</code>의 필드는 <code>hour</code>, <code>minute</code>, <code>second</code> 이다.</p><p>다른 방법으로는 자정 이후로 <code>second</code>의 수를 단일 정수로 나타낸 필드로 대체할 수 있다. 이 구현은 <code>isafter</code>와 같은 함수를 더 쉽게 작성할 수 있도록 하지만 다른 함수들을 더 어렵게 만든다.</p><p>새로운 데이터 타입을 배포한 후 더 좋은 구현을 발견할 수 있다. 만약 프로그램의 다른 부분이 해당 데이터 타입을 사용중이라면, 인터페이스를 변경하는데 시간이 많이 걸리고 오류가 발생할 수 있다.</p><p>그러나 인터페이스를 신중하게 디자인한 경우 인터페이스를 변경하지 않고 구현을 변경할 수 있다. 즉, 프로그램의 다른 부분은 변경할 필요가 없게 된다.</p><h3 id="디버깅">디버깅</h3><p>만약 함수에 대해 둘 이상의 메서드를 지정한다면, 적절한 인수를 사용하여 함수를 호출하기가 어려울 수 있다. 줄리아는 함수 메서드를 조사할 수 있다.</p><p>메서드가 주어진 함수에서 사용할 수 있는지 알기 위해서는 <code>methods()</code>를 사용하면 된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; methods(printtime)<br><span class="hljs-comment"># 2 methods for generic function &quot;printtime&quot;:</span><br>[<span class="hljs-number">1</span>] printtime(time::MyTime) <span class="hljs-keyword">in</span> Main at REPL[<span class="hljs-number">3</span>]:<span class="hljs-number">2</span><br>[<span class="hljs-number">2</span>] printtime(time) <span class="hljs-keyword">in</span> Main at REPL[<span class="hljs-number">4</span>]:<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>이 예시에서는 <code>printtime()</code>가 2개의 메서드를 가지고 있으며, 하나는 <code>MyTime</code> 인수이고 다른 하나는 <code>Any</code> 인수이다.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>think julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>줄리아</tag>
      
      <tag>Julia</tag>
      
      <tag>Think Julia</tag>
      
      <tag>기초 강의</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[15/20] 구조체와 함수</title>
    <link href="/ko/ThinkJulia/Think-Julia-Chapter-15/"/>
    <url>/ko/ThinkJulia/Think-Julia-Chapter-15/</url>
    
    <content type="html"><![CDATA[<blockquote><p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p></blockquote><p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap16">Structs and Functions</a>를 한글로 요약 정리한 글입니다. <span id="more"></span></p><h2 id="구조체와-함수-structs-and-functions">구조체와 함수 (Structs and Functions)</h2><p>저번 장에서 새로운 복합 데이터 타입을 생성하는 방법에 대해서 알아보았다면, 지금부터는 개발자가 정의한 고유 객체들을 매개 변수로 사용하여 결과로 반환하는 함수를 작성해볼 것이다. 따라서 이번 장에서는 "함수적 프로그래밍 스타일(unctional programming style)"과 새로운 두 가지 프로그램 개발 계획을 볼 것이다.</p><h3 id="시간-time">시간 (Time)</h3><p>복합 데이터 타입의 또 다른 에시로서, 시간을 기록하는 <code>MyTime</code>을 <code>struct</code>로 정의할 것이다. 코드는 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Represents the time of day.</span><br><span class="hljs-string"></span><br><span class="hljs-string">fields: hour, minute, second</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">struct</span> MyTime<br>    hour<br>    minute<br>    second<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>Time</code>이라는 이름은 이미 줄리아에서 사용 중이기 때문에, 충돌을 방지하기 위해 <code>MyTime</code>로 결정하였다. 이제 새로운 <code>MyTime</code> 객체를 생성할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; time = MyTime(<span class="hljs-number">11</span>, <span class="hljs-number">59</span>, <span class="hljs-number">30</span>)<br>MyTime(<span class="hljs-number">11</span>, <span class="hljs-number">59</span>, <span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure><figure><img src="/images/22.png" alt="object diagram" /><figcaption aria-hidden="true">object diagram</figcaption></figure><p><code>MyTime</code> 객체 다이어그램은 위와 같다.</p><h3 id="순수-함수-pure-functions">순수 함수 (Pure Functions)</h3><p>지금부터 시간 값을 추가하는 두 개의 함수를 작성할 것이다. 두 개의 함수 중 하나는 '순수 함수(pure functions)'이며 다른 하나는 '변경자(modifiers)'이다. 또한 이 함수들은 간단한 프로토타입으로 시작하여 복잡한 문제를 점진적으로 해결하는 방법인 '프로토타입 및 패치(prototype and patch)'를 호출하여 개발 계획도 시연할 것이다.</p><p>아래의 코드는 <code>addtime</code>의 간단한 프로토타입이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> addtime(t1, t2)<br>    MyTime(t1.hour + t2.hour, t1.minute + t2.minute, t1.second + t2.second)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>이 함수는 <code>MyTime</code> 객체를 새로 생성한 후, 필드를 초기화하고 새로운 객체에 대한 참조를 반환한다. 이렇게 인수로 전달된 객체를 수정하지 않고 반환하는 함수를 '순수 함수'라고 한다. 즉, 인수로 전달된 객체들은 값을 제공하거나 보여지는 정도만 실행되고 어떤 영향도 받지 않는다.</p><p>위 함수를 테스트하기 위해서 두 개의 <code>MyTime</code> 객체를 만든다. <code>start</code>에는 'Monty Python and the Holy Grail' 영화의 시작시간이 포함되고, <code>duration</code>에는 영화의 상영 시간인 1시간 35분이 포함된다.</p><p><code>addtime</code>은 영화가 끝난 시간을 보여준다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; start = MyTime(<span class="hljs-number">9</span>, <span class="hljs-number">45</span>, <span class="hljs-number">0</span>);<br><br>julia&gt; duration = MyTime(<span class="hljs-number">1</span>, <span class="hljs-number">35</span>, <span class="hljs-number">0</span>);<br><br>julia&gt; done = addtime(start, duration);<br><br>julia&gt; printtime(done)<br><span class="hljs-number">10</span>:<span class="hljs-number">80</span>:<span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p>결과는 <code>10:80:00</code>으로 우리가 원하던 시간은 아니다. 문제는 해당 함수가 분단위와 초단위가 60을 초과하는 경우를 처리하지 못한다는 것이다. 그렇게 되면 60분을 1시간으로, 60초를 1분으로 헤당 열에 반입해야 한다. 이를 해결한 코드는 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> addtime(t1, t2)<br>    second = t1.second + t2.second<br>    minute = t1.minute + t2.minute<br>    hour = t1.hour + t2.hour<br>    <span class="hljs-keyword">if</span> second &gt;= <span class="hljs-number">60</span><br>        second -= <span class="hljs-number">60</span><br>        minute += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> minute &gt;= <span class="hljs-number">60</span><br>        minute -= <span class="hljs-number">60</span><br>        hour += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">end</span><br>    MyTime(hour, minute, second)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 함수는 정확하게 작동하지만 코드가 복잡해졌다. 이후 더 짧은 대안들을 배울 것이다.</p><h3 id="변경자-modifiers">변경자 (Modifiers)</h3><p>때로는 함수가 매개 변수로 얻는 객체를 수정하는 것이 더 유용하다. 이 경우에는 변경 사항이 호출자에게 보여진다. 이런 방식으로 작동하는 함수를 '변경자(Modifiers)'라고 한다.</p><p>인수인 'second'의 숫자를 <code>MyTime</code> 객체에 추가하는 <code>increment!()</code>는 변경자를 사용하여 자연스럽게 작성할 수 있다. 초안은 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> increment!(time, seconds)<br>    time.second += seconds<br>    <span class="hljs-keyword">if</span> time.second &gt;= <span class="hljs-number">60</span><br>        time.second -= <span class="hljs-number">60</span><br>        time.minute += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> time.minute &gt;= <span class="hljs-number">60</span><br>        time.minute -= <span class="hljs-number">60</span><br>        time.hour += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>첫 번째 줄은 기본적인 작동을 수행하며, 나머지 줄은 우리가 봤던 특별한 경우들을 처리한다.</p><p>이 함수는 정확한가? 만약 <code>second</code>가 60보다 크면 어떻게 작동하는가?</p><p>함수가 제대로 작동하는지 확인하기 위해서는 <code>time.second</code> 가 60이 넘을 때까지 여러 번 실행해야 한다. 이를 위한 방법으로는 <code>if</code>문을 <code>while</code>문으로 바꾸는 것이다. 이것은 정확하게 작동하지만, 효과적이지는 않다.</p><h3 id="프로토타이핑-vs.-계획-prototyping-versus-planning">프로토타이핑 vs. 계획 (Prototyping Versus Planning)</h3><p>개발자가 시연하고 있는 개발 계획을 '프로토타입 및 패치(prototype and patch)'라고 한다. 각 함수에서 기본 계산을 실행하는 프로토타입을 만들어 테스트 한 후, 발생한 오류들을 패치한다.</p><p>이 방법은 문제가 무엇인지 깊게 이해하지 못한 경우에 특히 효과적이다. 그러나 점진적인 수정방법은 모든 오류를 한번에 볼 수 없기에, 가끔 불필요하게 복잡한 코드로 수정하도록 한다.</p><p>위 문제의 대안은 문제에 대한 높은 수준의 통찰력을 통해 프로그래밍이 훨씬 쉬워질 수 있도록 설계하는 개발방식이다. 이전 '초단위 문제'의 경우, 필요한 통찰력은 <code>Time</code> 객체가 <a href="https://en.wikipedia.org/wiki/Sexagesimal">육십진법</a>의 3개의 숫자라는 것이다. 초단위 <code>second</code>속성이 1열, 분단위 <code>minute</code>속성이 60열, 시단위 <code>hour</code>속성이 3600열이다.</p><p><code>addtime()</code>와 <code>increment!()</code>를 작성할 때, 육십진법에서는 한 열에서 다음 열로 이동해야 하기 때문에 이를 효과적으로 추가하는 방식을 고려하고 싶다.</p><p>이런 생각은 전체적인 문제의 다른 접근법을 제안한다. <code>MyTime</code> 객체를 정수로 변환하고 컴퓨터의 계산을 활용하는 것이다.</p><p>아래의 함수는 <code>MyTime</code> 객체를 정수로 변환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> timetoint(time)<br>    minutes = time.hour * <span class="hljs-number">60</span> + time.minute<br>    seconds = minutes * <span class="hljs-number">60</span> + time.second<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>그리고 아래의 함수는 정수를 <code>MyTime</code>으로 변환한다. (<code>divrem</code>은 첫 번째 인수를 두 번째 인수로 나누고 몫과 나머지를 튜플로 반환한다)</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> inttotime(seconds)<br>    (minutes, second) = divrem(seconds, <span class="hljs-number">60</span>)<br>    hour, minute = divrem(minutes, <span class="hljs-number">60</span>)<br>    MyTime(hour, minute, second)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 함수가 올바른지 확인하기 위해서는 약간의 생각과 테스트를 진행하면 된다. 테스트하는 방법은 <code>timetoint(inttotime(x)) == x</code>가 많은 <code>x</code>값에도 작동하는지 확인하는 것이다. 일관성 검사(consistency check)의 예이다.</p><p>위의 함수가 정확하다고 확신한다면, <code>addtime</code>을 다시 작성하는데 사용할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> addtime(t1, t2)<br>    seconds = timetoint(t1) + timetoint(t2)<br>    inttotime(seconds)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>해당 버전은 처음보다 훨씬 쉽고 명확하다.</p><p>어떤면에서 육십진법에서 십진법 또는 그 반대로 변환하는 것은 시간을 처리하는 것보다 어렵다. 기본 변환이 더 추상적이기 때문이다.</p><p>하지만 시간을 육십진법으로 취급하고 <code>timetoint()</code> 및 <code>inttotime()</code>와 같은 변환 함수를 작성하는데 투자할 수 있는 통찰력만 있다면 더 짧고 읽기 쉬운 안정적인 프로그램을 만들 수 있다.</p><p>또한 나중에 함수를 추가하는 것이 더 쉽다. 예를 들어, 두 개의 <code>MyTime</code>을 빼서 둘 사이의 지속 시간을 찾는다고 가정해보자. 가장 편한 방법은 두 개를 빼주는 것이다. 변환 함수를 사용하면 더 쉽고 정확하게 뺄 수 있다.</p><p>아이러니하게도, 때로는 문제를 더 일반화하여 만드는 것이 더 쉽다. 그 이유는 특별한 경우도 적고 오류 가능성도 적어지기 때문이다.</p><h3 id="디버깅">디버깅</h3><p><code>MyTime</code> 객체는 <code>minute</code>과 <code>second</code>의 값이 0부터 60사이(0은 포함, 60은 불포함)이고, <code>hour</code>이 양수이면 올바르게 생성된다. <code>minute</code>와 <code>hour</code>는 값이 정수여야 하지만, <code>second</code>은 소수도 가능하다.</p><p>이와 같은 요구사항들은 항상 참이여야 하기 때문에 고정 변수(invariants)라 불린다. 다른 방식으로 말하면, 만약 요구사항들이 참이 아니라면 무언가가 잘못되었다는 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> isvalidtime(time)<br>    <span class="hljs-keyword">if</span> time.hour &lt; <span class="hljs-number">0</span> || time.minute &lt; <span class="hljs-number">0</span> || time.second &lt; <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> time.minute &gt;= <span class="hljs-number">60</span> || time.second &gt;= <span class="hljs-number">60</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>고정 변수를 확인하는 코드를 작성하면 오류를 감지하고 원인을 찾을 수 있다. 예를 들어 <code>isvalidtime()</code>가 <code>MyTime</code> 객체를 가져와서 고정 변수를 위반하면 <code>false</code>를 반환한다.</p><p>각 함수의 시작 부분에 <code>isvalidtime()</code>를 추가하여 인수가 유효한지 확인할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> addtime(t1, t2)<br>    <span class="hljs-keyword">if</span> !isvalidtime(t1) || !isvalidtime(t2)<br>        error(<span class="hljs-string">&quot;invalid MyTime object in add_time&quot;</span>)<br>    <span class="hljs-keyword">end</span><br>    seconds = timetoint(t1) + timetoint(t2)<br>    inttotime(seconds)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>또는 주어진 고정 변수를 확인하고 실패하면 예외를 제공하는 <code>@assert</code> 매크로를 사용할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> addtime(t1, t2)<br>    <span class="hljs-meta">@assert</span>(isvalidtime(t1) &amp;&amp; isvalidtime(t2), <span class="hljs-string">&quot;invalid MyTime object in add_time&quot;</span>)<br>    seconds = timetoint(t1) + timetoint(t2)<br>    inttotime(seconds)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>@assert</code> 매크로는 정상적인 조건을 처리하는 코드와 오류를 확인하는 코드를 구분하기 때문에 유용하다.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>think julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>줄리아</tag>
      
      <tag>Julia</tag>
      
      <tag>Think Julia</tag>
      
      <tag>기초 강의</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[14/20] 구조체와 객체</title>
    <link href="/ko/ThinkJulia/Think-Julia-Chapter-14/"/>
    <url>/ko/ThinkJulia/Think-Julia-Chapter-14/</url>
    
    <content type="html"><![CDATA[<blockquote><p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p></blockquote><p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap15">Structs and Objects</a>를 한글로 요약 정리한 글입니다. <span id="more"></span></p><h2 id="구조체와-객체-structs-and-objects">구조체와 객체 (Structs and Objects)</h2><p>지금까지 우리는 내장된 데이터 타입들과 함수를 어떻게 사용하는지 배웠다. 다음 단계는 고유한 데이터 타입을 생성하는 방법을 배우는 것이다. 이 주제는 양이 방대하기 때문에 여러 장에 걸쳐 공부할 것이다.</p><h3 id="복합-데이터-타입-composite-types">복합 데이터 타입 (Composite Types)</h3><p>우리는 그동안 줄리아에 내장된 데이터 타입을 많이 사용했다. 이제부터는 2차원 공간에서 점을 나타내는 새로운 데이터 타입인 <code>Point</code>를 정의할 것이다.</p><p>수학에서 점은 보통 좌표를 구분하는 쉼표와 함께 괄호 안에 표시된다. 예를 들어, (0,0)은 원점을 나타낸 것이고, (x,y)는 원점으로부터 x는 가로축, y는 세로축의 거리를 표시한 것이다.</p><ul><li>좌표를 x와 y라는 두 변수에 별도로 저장할 수 있다.</li><li>좌표를 배열이나 튜플의 요소로 저장할 수 있다.</li><li>점을 객체로 나타내는 새로운 데이터 타입을 만들 수 있다.</li></ul><p>새로운 타입을 만드는 것은 다른 방법에 비해서 더욱 복잡하지만, 확실한 장점이 있다. (장점은 나중에 볼 것이다)</p><p>복합 데이터 타입을 정의하는 것을 구조체(struct)라고 한다. 점의 <code>struct</code> 정의는 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">struct</span> Point<br>    x<br>    y<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>헤더는 새로운 구조체를 부를 이름으로 <code>Point</code>라고 정의하며, 본문은 구조체의 속성(attributes) 또는 필드(fields)를 정의한다. <code>Point</code>구조체는 <code>x</code>와 <code>y</code>라는 두 개의 필드를 가진다.</p><p>구조체는 객체를 만드는 공장과 같다. 점을 만들기 위해서는 필드의 값을 인수로 갖는 <code>Point()</code>를 호출한다. <code>Point()</code>를 함수로 쓸 때, 이를 생성자(constructor)라고 한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; p = Point(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>)<br>Point(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>)<br></code></pre></td></tr></table></figure><p>반환 값은 <code>p</code>에 할당한 <code>Point</code>객체로 표시된다.</p><p>새 객체를 만드는 것을 인스턴스화(instantiation)라고 하며, 객체는 데이터 타입의 인스턴스이다.</p><p>만약 인스턴스를 출력한다면, 줄리아는 해당 인스턴스가 어떤 데이터 타입 및 속성을 가지고 있는지 일려준다.</p><p>모든 객체는 어떤 데이터 타입의 인스턴스이다. 그렇기 때문에 객체(object)와 인스턴스(instance)라는 단어는 바꿔서 사용할 수 있다. 하지만 이 장에서는 개발자가 정의한 고유 데이터 타입을 설명할 때만 인스턴스를 사용할 것이다.</p><p>객체와 그 필드를 보여주는 상태 다이아그램을 '객체 다이어그램(object diagram)'이라고 한다.</p><figure><img src="/images/20.png" alt="object diagram" /><figcaption aria-hidden="true">object diagram</figcaption></figure><h3 id="구조체는-불변이다-structs-are-immutable">구조체는 불변이다 (Structs are Immutable)</h3><p><code>.</code>표기법을 사용하면 필드의 값을 가져올 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; x = p.x<br><span class="hljs-number">3.0</span><br>julia&gt; p.y<br><span class="hljs-number">4.0</span><br></code></pre></td></tr></table></figure><p>표현식 <code>p.x</code>는 '객체 <code>p</code>를 참고(reference)하여 <code>x</code>의 값을 가져와라'라는 의미이다. 예를 들어, <code>x</code>라는 이름으로 변수에 값을 할당해보자. 그래도 변수<code>x</code>와 필드<code>x</code>는 충돌하지 않는다.</p><p>또한 어떤 표현식에서는 점 표기법을 사용할 수 있다. 예시는 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; distance = sqrt(p.x^<span class="hljs-number">2</span> + p.y^<span class="hljs-number">2</span>)<br><span class="hljs-number">5.0</span><br></code></pre></td></tr></table></figure><p>그러나 구조체는 기본적으로 변경할 수 없으며, 생성(construction) 후에는 필드는 값이 변경될 수 없다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; p.y = <span class="hljs-number">1.0</span><br>ERROR: setfield! immutable <span class="hljs-keyword">struct</span> of type Point cannot be changed<br></code></pre></td></tr></table></figure><p>이런 구조체의 불변성은 몇 가지의 장점을 가지고 있다.</p><ul><li>더 효율적일 수 있다.</li><li>데이터 타입 생성자가 제공하는 불변값을 위반하는 것은 불가능하다.</li><li>불변 객체를 사용하는 코드는 추론하기가 더 쉽다.</li></ul><h3 id="변경가능한-구조체-mutable-structs">변경가능한 구조체 (Mutable Structs)</h3><p>필요한 경우, '변경가능한 복합 데이터 타입(mutable composite types)'은 키워드 <code>mutable struct</code>로 정의할 수 있다. 변경가능한 점(point) 정의는 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">mutable struct</span> MPoint<br>    x<br>    y<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>또한 점 표기법을 사용하여 변경가능한 구조체의 인스턴스에 값을 할당할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; blank = MPoint(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>)<br>MPoint(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>)<br>julia&gt; blank.x = <span class="hljs-number">3.0</span><br><span class="hljs-number">3.0</span><br>julia&gt; blank.y = <span class="hljs-number">4.0</span><br><span class="hljs-number">4.0</span><br></code></pre></td></tr></table></figure><h3 id="직사각형-rectangles">직사각형 (Rectangles)</h3><p>대부분은 객체의 필드를 어떻게 설정해야 할지 명확하지만, 어떤 경우에는 개발자가 결정을 내려야 한다. 예를 들어 직사각형을 나타내는 데이터 타입을 디자인한다고 가정해보자. 직사각형의 사이즈와 위치를 구체화하기 위해서 어떤 필드를 사용해야 하는가? 간단하게 생각하기 위해서 각도는 무시하고 수직이나 수평 단위로 생각하자.</p><p>그러면 적어도 두 가지의 가능성이 있다.</p><ul><li>직사각형의 한 모서리 또는 가운데 좌표, 너비와 높이를 지정할 수 있다.</li><li>두 개의 반대쪽 모서리 좌표를 지정할 수 있다.</li></ul><p>위 두 개의 방안 중에 무엇이 더 나은지 판단하기는 어렵기 때문에 첫 번째 방법을 예로 하여 설명할 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Represents a rectangle.</span><br><span class="hljs-string"></span><br><span class="hljs-string">fields: width, height, corner.</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">struct</span> Rectangle<br>    width<br>    height<br>    corner<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>독스트링(docstring)은 필드 목록을 알려준다. 높이와 넓이는 숫자로 작성하고, 모서리의 경우는 왼쪽 아래 모서리를 지정하는 <code>Point</code>객체이다.</p><p>직사각형을 나타내기 위해서는 <code>Rectangle</code>객체를 인스턴스화해야 한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; origin = MPoint(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>)<br>MPoint(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>)<br>julia&gt; box = Rectangle(<span class="hljs-number">100.0</span>, <span class="hljs-number">200.0</span>, origin)<br>Rectangle(<span class="hljs-number">100.0</span>, <span class="hljs-number">200.0</span>, MPoint(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>))<br></code></pre></td></tr></table></figure><p>객체 다이어그램은 이 객체의 상태를 그림으로 보여준다. 그림을 보면 다른 객체의 필드인 객체가 포함되었다. 그 이유는 <code>corner</code>의 속성이 변경가능한 객체라서 <code>Rectangle</code> 외부에서 작성할 수 있기 때문이다.</p><figure><img src="/images/21.png" alt="object diagram" /><figcaption aria-hidden="true">object diagram</figcaption></figure><h3 id="인수로서-인스턴스-instances-as-arguments">인수로서 인스턴스 (Instances as Arguments)</h3><p>일반적인 방법으로 인스턴스를 인수로 전달할 수 있다. 예를 들면 아래의 코드와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> printpoint(p)<br>    println(<span class="hljs-string">&quot;(<span class="hljs-subst">$(p.x)</span>, <span class="hljs-subst">$(p.y)</span>)&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>printpoint()</code>는 <code>Point</code>를 인수로 사용하여 수학 표기법으로 반환한다. 이를 호출하기 위해 <code>p</code>를 인수로 전달하였다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; printpoint(blank)<br>(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>)<br></code></pre></td></tr></table></figure><p>만약 변경가능한 구조체 객체가 함수에 인수로 전달되면, 함수는 객체의 필드를 수정할 수 있다. 예를 들어 <code>movepoint!()</code>는 변경가능한 <code>Point</code>와 두 개의 숫자인 <code>dx</code>, <code>dy</code>을 인수로 가져가서 <code>Point</code>의 <code>x</code>와 <code>y</code>의 속성에 각각 숫자를 추가한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> movepoint!(p, dx, dy)<br>    p.x += dx<br>    p.y += dy<br>    <span class="hljs-literal">nothing</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>아래의 결과는 필드가 수정되는 것을 보여준다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; origin = MPoint(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>)<br>MPoint(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>)<br>julia&gt; movepoint!(origin, <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>)<br><br>julia&gt; origin<br>MPoint(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>)<br></code></pre></td></tr></table></figure><p>함수 내부에서는 <code>p</code>가 <code>origin</code>의 에일리언스이므로, 함수가 <code>p</code>를 수정하면 <code>origin</code>이 변경된다.</p><p>만약 변경불가능한 <code>Point</code>객체를 <code>movepoint!()</code>에 입력하면 오류가 발생한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; movepoint!(p, <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>)<br>ERROR: setfield! immutable <span class="hljs-keyword">struct</span> of type Point cannot be changed<br></code></pre></td></tr></table></figure><p>그러나 변경불가능한 객체의 변경가능한 속성 값은 수정할 수 있다. 예를 들어 <code>moverectangle!()</code>은 인수로 <code>Rectangle</code> 객체와 두 개의 숫자인 <code>dx</code>와 <code>dy</code>를 가져간 후 <code>movepoint!()</code>를 사용하여 직사각형의 모서리를 움직인다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> moverectangle!(rect, dx, dy)<br>  movepoint!(rect.corner, dx, dy)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>이제는 <code>movepoint!</code>안의 <code>p</code>가 <code>rect.corner</code>의 에일리언스이므로, <code>p</code>를 수정하면 <code>rect.corner</code>도 변경된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; box<br>Rectangle(<span class="hljs-number">100.0</span>, <span class="hljs-number">200.0</span>, MPoint(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>))<br>julia&gt; moverectangle!(box, <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>)<br><br>julia&gt; box<br>Rectangle(<span class="hljs-number">100.0</span>, <span class="hljs-number">200.0</span>, MPoint(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>))<br></code></pre></td></tr></table></figure><p><strong>WARNING</strong> 변경불가능한 객체의 변경가능한 속성도 재할당할 수는 없다.</p><p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; box.corner = MPoint(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>)<br>ERROR: setfield! immutable <span class="hljs-keyword">struct</span> of type Rectangle cannot be changed<br></code></pre></td></tr></table></figure></p><h3 id="반환-값으로서-인스턴스-instances-as-return-values">반환 값으로서 인스턴스 (Instances as Return Values)</h3><p>함수는 인스턴스를 반환할 수 있다. 예를 들어, <code>findcenter()</code>은 <code>Rectangle</code>을 인수로 받아서 직사각형 중심의 좌표를 포함하는 <code>Point</code>를 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> findcenter(rect)<br>    Point(rect.corner.x + rect.width / <span class="hljs-number">2</span>, rect.corner.y + rect.height / <span class="hljs-number">2</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>표현식 <code>rect.corner.x</code>은 "객체 <code>rect</code>을 참고하여 필드 <code>corner</code>를 선택한 후, 해당 객체의 <code>x</code> 필드를 가져오라"는 의미이다.</p><p>다음은 <code>box</code>을 인수로 전달하고 <code>Point</code>를 <code>center</code>로 할당하는 예이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; center = findcenter(box)<br>Point(<span class="hljs-number">51.0</span>, <span class="hljs-number">102.0</span>)<br></code></pre></td></tr></table></figure><h3 id="복사-copying">복사 (Copying)</h3><p>에일리어싱은 한 곳에서 변경하면 다른 곳에 예기치 못한 영향을 주기 때문에 프로그램을 읽기 어렵게 만든다. 주어진 객체를 참조하는 모든 변수를 추적하기는 어렵다.</p><p>객체를 복사하는 것은 에일리어싱을 대신한다. 줄리아는 객체를 복제할 수 있는 <code>deepcopy()</code>를 제공한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; p1 = MPoint(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>)<br>MPoint(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>)<br>julia&gt; p2 = deepcopy(p1)<br>MPoint(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>)<br>julia&gt; p1 ≡ p2<br><span class="hljs-literal">false</span><br>julia&gt; p1 == p2<br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><code>≡</code> 연산자는 우리가 예상했던 대로 <code>p1</code>과 <code>p2</code>가 같은 객체가 아니라는 것을 보여준다. 하지만 왜 <code>==</code> 연산자는 두 객체가 같은 값임에도 불구하고 <code>false</code>를 반환하는가? 그 이유는 변경가능한 객체에서 <code>==</code>연산자는 <code>===</code>연산자와 동일하게 작동하기 때문이다. 즉, 객체의 동등성(equivalence)이 아닌 동일성(identity)을 비교한다. 이것은 줄리아가 변경가능한 복합 데이터 타입에서 무엇을 동등성으로 고려해야 하는지 모른다는 것을 의미한다.</p><h3 id="디버깅">디버깅</h3><p>객체 작업을 시작하면 몇 가지 새로운 예외가 발생할 수 있다. 존재하지 않는 필드에 접근하려고 하면 다음과 같은 결과를 얻는다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; p = Point(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>)<br>Point(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>)<br>julia&gt; p.z = <span class="hljs-number">1.0</span><br>ERROR: type Point has no field z<br>Stacktrace:<br> [<span class="hljs-number">1</span>] setproperty!(::Point, ::<span class="hljs-built_in">Symbol</span>, ::<span class="hljs-built_in">Float64</span>) at ./sysimg.jl:<span class="hljs-number">19</span><br> [<span class="hljs-number">2</span>] top-level scope at none:<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>만약 객체의 데이터 타입이 무엇인지 확실하지 않다면, 물어볼 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; typeof(p)<br>Point<br></code></pre></td></tr></table></figure><p>또한 <code>isa</code>를 사용하여 객체가 데이터 타입의 인스턴스인지 확인할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; p <span class="hljs-keyword">isa</span> Point<br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>만약 객체가 특정 속성을 가지고 있는지 확신할 수 없다면, 내장 함수인 <code>fieldnames()</code>를 사용할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; fieldnames(Point)<br>(:x, :y)<br></code></pre></td></tr></table></figure><p>또는 <code>isdefined()</code>도 사용가능하다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; isdefined(p, :x)<br><span class="hljs-literal">true</span><br>julia&gt; isdefined(p, :z)<br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>첫 번째 인수는 어떤 객체든 들어갈 수 있다. 두 번째 인수에는 <code>:</code>기호를 넣고 뒤에 필드의 이름을 작성하면 된다.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>think julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>줄리아</tag>
      
      <tag>Julia</tag>
      
      <tag>Think Julia</tag>
      
      <tag>기초 강의</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[13/20] 파일</title>
    <link href="/ko/ThinkJulia/Think-Julia-Chapter-13/"/>
    <url>/ko/ThinkJulia/Think-Julia-Chapter-13/</url>
    
    <content type="html"><![CDATA[<blockquote><p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p></blockquote><p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap14">Files</a>를 한글로 요약 정리한 글입니다. <span id="more"></span></p><h2 id="파일-files">파일 (Files)</h2><p>이번 장에서는 데이터를 영구 저장소에 보관하는 '지속되는(persistent)' 프로그램에 대해 소개하고, 파일 및 데이터베이스와 같은 다양한 종류의 영구 저장소를 사용하는 법을 알아볼 것이다.</p><h3 id="지속성-persistence">지속성 (Persistence)</h3><p>지금까지 본 대부분의 프로그램들은 일시적으로 실행되었다. 즉, 프로그램이 종료되는 순간 데이터는 사라지며 프로그램을 다시 실행하면 깨끗한 슬레이트에서 시작한다는 것을 의미한다.</p><p>하지만 영구적인 프로그램도 존재한다. 프로그램이 장시간 또는 항상 실행되며, 데이터의 일부를 하드 드라이브와 같은 영구 저장소에 보관하여 재부팅해도 프로그램이 멈춘 그 상태를 반환한다.</p><p>영구적인 프로그램의 예시로 운영체제(OS)와 웹서버를 볼 수 있다. 운영체제는 컴퓨터가 켜질 때마다 실행되며, 웹서버는 네트워크에서 들어오는 요청을 받기 위해 항상 켜져 있다.</p><p>프로그램이 데이터를 유지하는 가장 간단한 방법 중 하나는 텍스트 파일을 읽고 쓰는 것이다. 우리는 이미 앞에서 텍스트 파일을 읽는 프로그램을 보았다. 이 장에서는 텍스트 파일을 작성하는 프로그램을 보게 될 것이다.</p><p>다른 대안은 프로그램 상태를 데이터베이스에 저장하는 것이다. 이 장에서는 간단한 데이터베이스를 사용하는 방법도 살펴볼 것이다.</p><h3 id="읽고-쓰기-reading-and-writing">읽고 쓰기 (Reading and Writing)</h3><p>텍스트 파일은 하드 드라이브나 플래시 메모리(flash memory)와 같은 영구 매체에 저장된 문자들의 시퀀스이다. 우리는 <a href="https://dev-bearabbit.github.io/2020/03/06/ThinkJulia/Think-Julia-Chapter-9/">8. 워드 플레이</a>에서 파일을 열고 읽는 방법을 배웠다.</p><p>파일을 쓰기 위해서는, 두 번째 매개 변수에 "w"을 입력하여 '쓰기 모드'로 파일을 열어야 한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; fout = open(<span class="hljs-string">&quot;output.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>)<br><span class="hljs-built_in">IOStream</span>(&lt;file output.txt&gt;)<br></code></pre></td></tr></table></figure><p><strong>파일이 이미 존재하는 경우 파일을 쓰기 모드로 열면 이전 데이터가 전부 지워지니 주의해야 한다.</strong> 파일이 없다면 새 파일이 만들어진다. <code>open()</code>은 파일 객체를 반환하고 <code>write()</code>는 데이터를 파일에 넣는다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; line1 = <span class="hljs-string">&quot;This here&#x27;s the wattle,\n&quot;</span>;<br><br>julia&gt; write(fout, line1)<br><span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><p>반환 값은 작성된 문자의 개수이다. 파일 객체는 현재 위치를 추적하므로 다시 <code>write()</code>를 호출하면 새 데이터가 파일 끝에 추가된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; line2 = <span class="hljs-string">&quot;the emblem of our land.\n&quot;</span>;<br><br>julia&gt; write(fout, line2)<br><span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><p>쓰기가 끝났다면, 파일을 닫아야 한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; close(fout)<br></code></pre></td></tr></table></figure><p>만약 파일을 닫지 않으면, 프로그램이 종료될 때 자동으로 닫힌다.</p><h3 id="서식-formatting">서식 (Formatting)</h3><p><code>write()</code>의 인수는 문자열이어야 하기 때문에 만약 파일에 값을 넣고 싶다면 문자열로 변환해야 한다. 가장 쉬운 방법은 <code>string()</code>이나 보간법을 사용하는 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; fout = open(<span class="hljs-string">&quot;output.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>)<br><span class="hljs-built_in">IOStream</span>(&lt;file output.txt&gt;)<br>julia&gt; write(fout, string(<span class="hljs-number">150</span>))<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><code>write()</code> 대신에 <code>print(ln)</code>을 사용할수도 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; camels = <span class="hljs-number">42</span><br><span class="hljs-number">42</span><br>julia&gt; println(fout, <span class="hljs-string">&quot;I have spotted <span class="hljs-variable">$camels</span> camels.&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>Tip</strong> 가장 강력한 방식은 <code>@printf</code>을 사용하는 것이다. 이에 대한 세부적인 사항은 <a href="https://docs.julialang.org/en/v1/stdlib/Printf/">이 링크</a>에서 확인할 수 있다.</p><h3 id="파일이름과-경로">파일이름과 경로</h3><p>파일은 폴더라고 불리는 디렉토리(directory)에 저장된다. 실행중인 모든 프로그램은 기본값으로 '현재 작동중인 디렉토리'을 가진다. 예를 들어, 만약 파일을 열어 읽어보고 싶다면, 줄리아는 현재 디렉토리에서 파일을 찾는다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; cwd = pwd()<br><span class="hljs-string">&quot;/home/ben&quot;</span><br></code></pre></td></tr></table></figure><p><code>cwd</code>는 현재 작동중인 디렉토리를 보여준다. 위 예시는 결과로 사용자인 ben의 홈 디렉토리를 보여주었다.</p><p>파일이나 디렉토리를 식별하는 <code>"/home/ben"</code>와 같은 문자열을 경로(path)라고 한다.</p><p><code>memo.txt</code>와 같은 간단한 파일 이름도 경로가 될 수 있지만, 해당 파일은 현재 디렉토리에 저장되어 있기 때문에 파일 이름만 사용하는 것은 상대 경로이다. 현재 디렉토리가 <code>"/home/ben"</code>인 경우, 상대 경로인 <code>memo.txt</code>는 <code>"/home/ben/memo.txt"</code>를 참조한다.</p><p><code>/</code>로 시작하는 경로는 현재 디렉토리에 의존하지 않는다. 파일의 절대 경로를 찾고 싶다면 <code>abspath()</code>를 사용하면 된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; abspath(<span class="hljs-string">&quot;memo.txt&quot;</span>)<br><span class="hljs-string">&quot;/home/ben/memo.txt&quot;</span><br></code></pre></td></tr></table></figure><p>줄리아에서는 파일 이름과 경로와 관련된 여러 함수들을 제공한다. 예를 들어 <code>ispath()</code>는 파일이나 디렉토리가 존재하는지 확인한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; ispath(<span class="hljs-string">&quot;memo.txt&quot;</span>)<br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>만약 존재한다면, <code>isdir()</code>은 디렉토리인지를 확인한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; isdir(<span class="hljs-string">&quot;memo.txt&quot;</span>) <span class="hljs-comment"># 상대 경로 -&gt; 파일 이름일 뿐 디렉토리는 아니다.</span><br><span class="hljs-literal">false</span><br>julia&gt; isdir(<span class="hljs-string">&quot;/home/ben&quot;</span>) <span class="hljs-comment"># 절대 경로 -&gt; 디렉토리</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>비슷하게 <code>isfile()</code>은 파일인지를 확인한다.</p><p><code>readdir()</code>은 인수로 제공한 디렉토리에 들어있는 파일과 다른 디렉토리의 이름들을 베열로 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; readdir(cwd)<br><span class="hljs-number">3</span>-element <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">String</span>,<span class="hljs-number">1</span>&#125;:<br> <span class="hljs-string">&quot;memo.txt&quot;</span><br> <span class="hljs-string">&quot;music&quot;</span><br> <span class="hljs-string">&quot;photos&quot;</span><br></code></pre></td></tr></table></figure><p>이런 함수들을 설명하기 위해 다음 예시를 확인해보자. 아래의 함수는 디렉토리 경로를 받으면 그 안에 있는 파일들과 디렉토리의 이름을 반환한다. 재밌는 점은 디렉토리 내부에 있는 다른 디렉토리도 통과하여 그 안의 파일 이름을 전부 가져오는 재귀로 구성되있다는 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> walk(dirname)<br>    <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> readdir(dirname)<br>        path = joinpath(dirname, name)<br>        <span class="hljs-keyword">if</span> isfile(path)<br>            println(path)<br>        <span class="hljs-keyword">else</span><br>            walk(path)<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>joinpath()</code>는 디렉토리와 파일 이름을 가져와 완전한 경로로 결합한다.</p><p><strong>Tip</strong> 줄리아는 <a href="https://docs.julialang.org/en/v1/base/file/#Base.Filesystem.walkdir"><code>walkdir()</code></a>이라는 함수를 제공한다. 이 함수는 우리가 작성한 함수와 비슷하지만 더 다양한 기능을 제공한다. 연습문제로 위 링크의 설명서를 읽고 함수를 사용하여 디렉토리 내부의 파일 이름을 출력해보라.</p><h3 id="예외-포착-catching-exceptions">예외 포착 (Catching Exceptions)</h3><p>파일을 읽고 쓸 때, 많은 오류들이 발생할 수 있다. 만약 존재하지 않는 파일을 열려고 한다면 <code>SystemError</code>가 일어난다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; fin = open(<span class="hljs-string">&quot;bad_file&quot;</span>)<br>ERROR: <span class="hljs-built_in">SystemError</span>: opening file <span class="hljs-string">&quot;bad_file&quot;</span>: No such file or directory<br></code></pre></td></tr></table></figure><p>또한 파일에 접근할 권한이 없는 경우에도 위와 같은 오류가 발생한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; fout = open(<span class="hljs-string">&quot;/etc/passwd&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>)<br>ERROR: <span class="hljs-built_in">SystemError</span>: opening file <span class="hljs-string">&quot;/etc/passwd&quot;</span>: Permission denied<br></code></pre></td></tr></table></figure><p>이런 오류들을 피하기 위해서는 <code>ispath()</code>와 <code>isfile()</code>같은 함수를 이용해야 하지만, 모든 가능성을 확인하려면 많은 시간이 걸린다.</p><p><code>try</code>문을 사용하면 더 쉽게 문제를 해결할 수 있다. <code>try</code>문은 문법적으로 <code>if</code>문과 유사하다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">try</span><br>    fin = open(<span class="hljs-string">&quot;bad_file.txt&quot;</span>)<br><span class="hljs-keyword">catch</span> exc<br>    println(<span class="hljs-string">&quot;Something went wrong: <span class="hljs-variable">$exc</span>&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>줄리아는 <code>try</code>절을 실행하며 시작한다. 모두 잘 진행되면 <code>catch</code>절을 건너 뛰고 진행하지만, 예외가 발생하면 <code>catch</code>절을 실행한다. <code>try</code>문으로 예외를 처리하는 것을 '예외 포착(Catching Exceptions)'이라고 한다. 이 예시에서 예외 절은 별로 도움이 되지 않는 오류 메시지를 출력한다. 일반적으로 예외를 발견하면 우리는 문제점을 수정하거나 다시 시도하거나 적어도 프로그램이 어떤 상황인지 알고 종료할 수 있는 기회를 얻는다.</p><p>일반적으로 상태 변경을 수행하거나 파일과 같은 리소스를 사용하는 코드에는 코드가 완료될 때 수행해야하는 정리 작업이 있다.(예시: 파일 닫기) 예외로 인해서 정상적인 종료에 도달하기도 전에 코드가 종료될 수 있기 때문에 작업이 복잡해진다. <code>finally</code> 키워드는 이전의 코드들이 종료되는 이유와 관계없이 특정 코드를 작동한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia">f = open(<span class="hljs-string">&quot;output.txt&quot;</span>)<br><span class="hljs-keyword">try</span><br>    line = readline(f)<br>    println(line)<br><span class="hljs-keyword">finally</span><br>    close(f)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위 예시에서 <code>close()</code>는 무조건 실행된다.</p><h3 id="데이터베이스-databases">데이터베이스 (Databases)</h3><p>데이터베이스(database)는 데이터를 저장하기 위해 조직된 파일이다. 많은 데이터베이스는 키에서 값으로 매핑된다는 점에서 딕셔너리처럼 구성되어 있다. 하지만 데이터베이스는 디스크와 같은 다른 영구저장소에 있으므로 프로그램이 종료된 후에도 유지된다는 점이 딕셔너리와는 다르다.</p><p><code>ThinkJulia</code>는 데이터베이스 작성 및 업데이트를 위해 <code>GDBM</code>(GNU dbm)에 대한 인터페이스를 제공한다. 예를 들어 이미지 파일의 설명(captions)이 포함된 데이터베이스를 만들 수 있다.</p><p>데이터베이스를 여는 것은 다른 파일을 여는 것과 비슷하다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-keyword">using</span> ThinkJulia<br><br>julia&gt; db = DBM(<span class="hljs-string">&quot;captions&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>)<br>DBM(&lt;captions&gt;)<br></code></pre></td></tr></table></figure><p>"c모드"는 데이터베이스가 존재하지 않는 경우 데이터베이스를 작성해야 함을 의미한다. 결과는 딕셔너리처럼 사용할 수 있는 데이터베이스 객체이다.</p><p>새 아이템을 만들 때는 <code>GDBM</code>이 데이터베이스 파일을 업데이트해야 한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; db[<span class="hljs-string">&quot;cleese.png&quot;</span>] = <span class="hljs-string">&quot;Photo of John Cleese.&quot;</span><br><span class="hljs-string">&quot;Photo of John Cleese.&quot;</span><br></code></pre></td></tr></table></figure><p>만약 아이템 중 하나에 접근하고 싶다면, <code>GDBM</code>은 파일을 읽어온다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; db[<span class="hljs-string">&quot;cleese.png&quot;</span>]<br><span class="hljs-string">&quot;Photo of John Cleese.&quot;</span><br></code></pre></td></tr></table></figure><p>원래 존재하던 키에 다른 값을 재할당한다면, <code>GDBM</code>은 새로운 값으로 변경한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; db[<span class="hljs-string">&quot;cleese.png&quot;</span>] = <span class="hljs-string">&quot;Photo of John Cleese doing a silly walk.&quot;</span><br><span class="hljs-string">&quot;Photo of John Cleese doing a silly walk.&quot;</span><br>julia&gt; db[<span class="hljs-string">&quot;cleese.png&quot;</span>]<br><span class="hljs-string">&quot;Photo of John Cleese doing a silly walk.&quot;</span><br></code></pre></td></tr></table></figure><p><code>keys()</code>와 <code>values()</code>와 같이 딕셔너리에 적용되는 몇몇의 함수는 데이터베이스에서 작동하지 않는다. 하지만 <code>for</code>루프와 같은 반복에서는 작동한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">for</span> (key, value) <span class="hljs-keyword">in</span> db<br>    println(key, <span class="hljs-string">&quot;: &quot;</span>, value)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>파일과 마찬가지로 데이터베이스도 작성이 끝나면 닫아야 한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; close(db)<br></code></pre></td></tr></table></figure><h3 id="직렬화-serialization">직렬화 (Serialization)</h3><p><code>GDBM</code>의 한계는 키와 값이 문자열 또는 바이트 배열이어야 한다는 것이다. 다른 유형을 사용하려고 하면 오류가 발생한다.</p><p>위의 상황에서는 직렬화해주는 <code>serialize()</code>와 역직렬화해주는 <code>deserialize()</code>가 도움이 될 수 있다. 이 함수들은 거의 모든 유형의 객체를 데이터베이스에 저장하기에 적합한 바이트 배열(an iobuffer)로 변환한 다음 바이트 배열을 다시 객체로 변환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-keyword">using</span> Serialization<br><br>julia&gt; io = <span class="hljs-built_in">IOBuffer</span>();<br><br>julia&gt; t = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br>julia&gt; serialize(io, t)<br><span class="hljs-number">24</span><br>julia&gt; print(take!(io))<br><span class="hljs-built_in">UInt8</span>[<span class="hljs-number">0x37</span>, <span class="hljs-number">0x4a</span>, <span class="hljs-number">0x4c</span>, <span class="hljs-number">0x07</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x15</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0xe2</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>]<br></code></pre></td></tr></table></figure><p>위의 형식은 사람을 위한 것이 아닌 줄리아가 해석하기 쉽게 변환한 것이다. <code>deserialize()</code>는 객체를 재구성한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; io = <span class="hljs-built_in">IOBuffer</span>();<br><br>julia&gt; t1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br>julia&gt; serialize(io, t1)<br><span class="hljs-number">24</span><br>julia&gt; s = take!(io);<br><br>julia&gt; t2 = deserialize(<span class="hljs-built_in">IOBuffer</span>(s));<br><br>julia&gt; print(t2)<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p><code>serialize()</code>와 <code>deserialize()</code>는 메모리에 입출력하는 흐름을 나타하는 'iobuffer' 객체로부터 쓰고 읽는다. <code>take!()</code>는 'iobuffer'의 내용을 바이트 배열로 가져오고 'iobuffer'을 초기상태로 재설정한다.</p><p>새 객체가 이전 객체와 동일한 값을 갖지만, 동일한 객체는 아니다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t1 == t2<br><span class="hljs-literal">true</span><br>julia&gt; t1 ≡ t2<br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>즉, 직렬화와 역직렬화는 객체를 복사하는 것과 같다. 이 방식을 사용하여 문자열이 아닌 요소들도 데이터베이스에 저장할 수 있다.</p><p><strong>Tip</strong> 실제로 문자열이 아닌 요소들이 저장된 데이터베이스는 <a href="https://github.com/JuliaIO/JLD2.jl"><code>JLD2</code></a>라는 패키지에 캡슐화하여 사용하는게 일반적이다.</p><h3 id="명령-객체-command-objects">명령 객체 (Command Objects)</h3><p>대부분의 운영체제는 셀(shell)이라고 하는 명령 줄 인터페이스를 제공한다. 셀은 일반적으로 파일 시스템을 탐색하고 응용프로그램을 시작하는 명령을 제공한다. 예를 들어, Unix에서는 <code>cd</code>를 사용하여 디렉토리를 변경하고 <code>ls</code>를 사용하여 디렉토리의 내용을 표시하며 <code>firefox</code>를 입력하여 웹브라우저를 시작할 수 있다.</p><p>셀에서 실행할 수 있는 모든 프로그램은 명령 객체를 사용하여 줄리아에서도 시작할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; cmd = <span class="hljs-string">`echo hello`</span><br><span class="hljs-string">`echo hello`</span><br></code></pre></td></tr></table></figure><p>백틱(Backticks,`)은 명령을 구분하는데 사용된다.</p><p><code>run()</code>은 명령을 실행한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; run(cmd);<br>hello<br></code></pre></td></tr></table></figure><p><code>hello</code>는 echo 명령문의 출력이며, <code>STDOUT</code>으로 전송된다. <code>run()</code>은 명령을 실행하며 문제가 생기면 <code>ErrorException</code>을 보여준다.</p><p>만약</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; a = read(cmd, <span class="hljs-built_in">String</span>)<br><span class="hljs-string">&quot;hello\n&quot;</span><br></code></pre></td></tr></table></figure><p>예를 들어, 대부분의 Unix시스템은 파일의 내용을 읽고 "체크썸(checksum)"계산하는 <code>md5sum</code> 또는 <code>md5</code>를 제공한다. <code>md5</code>에 대한 정보는 <a href="https://en.wikipedia.org/wiki/Md5">해당 링크</a>에 있다. 이 명령은 두 파일의 내용이 같은지 여부를 확인하는 효율적인 방법을 제공한다. 서로 다른 내용이 동일한 체크썸을 생성할 확률은 매우 적다.</p><p>아래의 코드는 줄리아에서 <code>md5</code>를 실행하기 위한 명령을 사용하고, 결과를 얻는다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; filename = <span class="hljs-string">&quot;output.txt&quot;</span><br><span class="hljs-string">&quot;output.txt&quot;</span><br>julia&gt; cmd = <span class="hljs-string">`md5 <span class="hljs-variable">$filename</span>`</span><br><span class="hljs-string">`md5 output.txt`</span><br>julia&gt; res = read(cmd, <span class="hljs-built_in">String</span>)<br><span class="hljs-string">&quot;MD5 (output.txt) = d41d8cd98f00b204e9800998ecf8427e\n&quot;</span><br></code></pre></td></tr></table></figure><h3 id="모듈-modules">모듈 (Modules)</h3><p>이름이 <code>"wc.ji"</code>인 파일이 있다고 가정하자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> linecount(filename)<br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> eachline(filename)<br>        count += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">end</span><br>    count<br><span class="hljs-keyword">end</span><br><br>print(linecount(<span class="hljs-string">&quot;wc.jl&quot;</span>))<br></code></pre></td></tr></table></figure><p>위의 프로그램을 실행한다면, 파일 자체를 읽고 파일의 라인 수를 출력한다. 출력을 실행해보면 <code>"wc.ji"</code>는 9개의 라인으로 이루어져 있다. 또한 아래와 같이 REPL에 포함시길 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; include(<span class="hljs-string">&quot;wc.jl&quot;</span>)<br><span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p>줄리아는 분리된 가변적인 작업공간을 생성하는 모듈을 소개한다. (마치 새로운 글로벌 설정 공간과도 같다)</p><p>모듈은 키워드 <code>module</code>로 시작해서 <code>end</code>로 끝난다. 모듈로 작성하면 도메인에 설정한 함수나 변수와 충돌하지 않는다. <code>import</code>는 다른 모듈을 가져와서 제어할 수 있도록 허락하며, <code>export</code>는 특정한 모듈 안에 있는 함수들을 공개한다. 즉, 모듈을 설정하지 않고도 외부에서 쓸 수 있는 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">module</span> LineCount<br>    <span class="hljs-keyword">export</span> linecount<br><br>    <span class="hljs-keyword">function</span> linecount(filename)<br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> eachline(filename)<br>            count += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">end</span><br>        count<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>LineCount</code> 모듈 객체은 <code>linecount</code>를 제공한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-keyword">using</span> LineCount<br><br>julia&gt; linecount(<span class="hljs-string">&quot;wc.jl&quot;</span>)<br><span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><p><strong>WARNING</strong> 이미 가져온 모듈을 다시 <code>import</code>하는 경우 줄리아는 아무 작업을 수행하지 않는다. 파일이 변경된 후에도 파일을 다시 읽지 않는다. 모듈을 다시 로드하려면 REPL을 다시 시작해야 한다. 세션을 더 오래 유지할 수 있는 <a href="https://github.com/timholy/Revise.jl"><code>Revise</code></a> 패키지가 있다.</p><h3 id="디버깅">디버깅</h3><p>파일을 읽고 쓸 때, 공백과 관련된 문제가 생길 수 있다. 공백, 탭, 줄바꿈과 같은 문제들은 일반적으로 코드에서 보이지 않기 때문에 디버깅하기 어렵다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; s = <span class="hljs-string">&quot;1 2\t 3\n 4&quot;</span>;<br><br>julia&gt; println(s)<br><span class="hljs-number">1</span> <span class="hljs-number">2</span>     <span class="hljs-number">3</span><br> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>내장 함수인 <code>repr()</code>와 <code>dump()</code>는 어떤 객체든지 인수로 받아서 객체의 값을 문자열로 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; repr(s)<br><span class="hljs-string">&quot;\&quot;1 2\\t 3\\n 4\&quot;&quot;</span><br>julia&gt; dump(s)<br><span class="hljs-built_in">String</span> <span class="hljs-string">&quot;1 2\t 3\n 4&quot;</span><br></code></pre></td></tr></table></figure><p>이런 함수들은 디버깅하기에 유용하다.</p><p>실행중에 발생할 수 있는 또 다른 문제는 시스템들이 라인의 끝을 구분하기 위해 각각의 다른 문자를 사용하는 것이다. 어떤 시스템은 줄바꿈을 <code>\n</code>으로 표시하며, 다른 시스템은 <code>\r</code>로 표시한다. 시스템들간에 파일을 이동하면 이런 불일치의 문제가 발생할 수 있다.</p><p>대부분의 시스템에는 한 형식에서 다른 형식으로 변환하는 응용 프로그램이 있다. 관련 정보는 <a href="https://en.wikipedia.org/wiki/Newline">해당 링크</a>에서 확인할 수 있다.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>think julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>줄리아</tag>
      
      <tag>Julia</tag>
      
      <tag>Think Julia</tag>
      
      <tag>기초 강의</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[12/20] 사례 연구: 데이터 구조 선택</title>
    <link href="/ko/ThinkJulia/Think-Julia-Chapter-12/"/>
    <url>/ko/ThinkJulia/Think-Julia-Chapter-12/</url>
    
    <content type="html"><![CDATA[<blockquote><p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p></blockquote><p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap13">Case Study: Data Structure Selection</a>를 한글로 요약 정리한 글입니다. <span id="more"></span></p><h2 id="사례-연구-데이터-구조-선택">사례 연구: 데이터 구조 선택</h2><p>지금까지 줄리아의 핵심 데이터 구조에 대해서 배우고 이를 사용하는 일부 알고리즘 살펴보았다. 이번 장에서는 사례 연구를 통해서 데이터 구조를 선택하고 사용하는 방법을 연습할 것이다.</p><h3 id="단어-빈도-분석-word-frequency-analysis">단어 빈도 분석 (Word Frequency Analysis)</h3><p>가능하다면, 해결책을 살펴보기 전에 아래의 연습문제를 풀어보자.</p><p><strong>연습문제 1</strong> 파일을 읽고, 각 줄을 단어로 나누고, 단어에서 공백과 문장부호를 제거한 후 소문자로 변환하는 프로그램을 작성해라.</p><p><strong>Tip</strong> <code>isletter()</code>은 문자를 알파벳인지 테스트한다.</p><p><strong>연습문제 2</strong> <a href="https://gutenberg.org">Project Gutenberg</a>로 가서 저작권이 없는 책을 일반 텍스트 형식으로 다운로드해라. 이전에 사용했던 프로그램을 수정하여 다운로드한 책을 읽어온 후, 파일 시작 부분의 헤더 정보를 건너 뛰고 위의 프로그램을 실행하라. 그 다음 책의 총 단어 수와 각 단어가 사용된 횟수를 계산하도록 프로그램을 수정해라.</p><p><strong>연습문제 3</strong> 책에서 가장 자주 사용되는 20개의 단어를 인쇄하도록 이전 연습문제의 프로그램을 수정해라.</p><p><strong>연습문제 4</strong> 이전 프로그램을 수정하여 단어 목록을 읽은 후, 단어 목록에 없는 단어를 인쇄해라. 오타는 몇 개인가? 단어 목록에 있어야 하는 일반적인 단어는 몇 개이며, 실제로 모호한 단어는 몇 개인가?</p><h3 id="랜덤-숫자">랜덤 숫자</h3><p>대부분의 컴퓨터 프로그램은 같은 입력이 주어지면 똑같은 결과를 출력한다. 그래서 이런 실행 흐름을 결정론적이라고 말할 수 있다. 결정론은 동일한 계산이 동일한 결과를 산출한다고 가정하기 때문에 일반적으로 좋은 이론이다. 하지만 일부 응용 프로그램의 경우 컴퓨터가 예측할 수 없는 형태이기를 원한다. 게임은 확실한 예이며, 다른 예들도 있다.</p><p>프로그램을 비결정론적으로 만드는 것은 어렵지만, 적어도 비결정론적으로 보이게 하는 방법은 있다. 그 중 하나는 '의사 난수 (pseudorandom numbers)' 생성하는 알고리즘을 사용하는 것이다. 의사 난수는 결정론적 계산에 의해 생성되기 때문에 실제로 완벽한 무작위는 아니지만, 마치 랜덤 숫자와 같은 결과를 제공한다.</p><p><code>rand()</code>는 <code>0.0</code>과 <code>1.0</code>사이의 랜덤 소수를 반환한다. (0.0은 포함하지만 1.0은 포함하지 않는다) <code>rand()</code>를 호출할 때마다, 긴 배열 중에 다음 소수가 반환된다. 아래의 코드를 통해 결과를 확인해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:<span class="hljs-number">10</span><br>    x = rand()<br>    println(x)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>또한 <code>rand()</code>는 이터레이터나 배열을 인수로서 가져올 수 있으며 결과로 랜덤 요소를 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:<span class="hljs-number">10</span><br>    x = rand(<span class="hljs-number">1</span>:<span class="hljs-number">6</span>)<br>    print(x, <span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="단어-히스토그램">단어 히스토그램</h3><p>이 장을 진행하기 전에 앞에서 제시했던 연습문제를 풀어봐야 한다. 그 다음 <a href="https://github.com/BenLauwens/ThinkJulia.jl/blob/master/data/emma.txt">해당 링크</a>에 가서 텍스트를 다운로드해라.</p><p>아래의 코드는 파일을 읽고 파일에 있는 단어의 히스토그램을 작성하는 프로그램이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> processfile(filename)<br>    hist = <span class="hljs-built_in">Dict</span>()<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> eachline(filename)<br>        processline(line, hist)<br>    <span class="hljs-keyword">end</span><br>    hist<br><span class="hljs-keyword">end</span>;<br><br><span class="hljs-keyword">function</span> processline(line, hist)<br>    line = replace(line, <span class="hljs-string">&#x27;-&#x27;</span> =&gt; <span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> split(line)<br>        word = string(filter(isletter, [word...])...)<br>        word = lowercase(word)<br>        hist[word] = get!(hist, word, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span>;<br></code></pre></td></tr></table></figure><p>위의 프로그램은 위의 링크에서 다운받은 'emma.txt'을 읽어온다.</p><p><code>processfile()</code>은 파일의 줄을 읽어오고 <code>processline()</code>으로 한 줄씩 보낸다. 히스토그램인 <code>hist</code>는 누적기(accumulator)로 사용된다.</p><p><code>processline()</code>은 줄을 단어로 분리하고 문자 배열로 변경하는 <code>split()</code>을 사용하기 전에 <code>-</code>을 공백으로 바꾸기 위해서 <code>replace()</code>를 사용한다. 그리고 단어 배열은 <code>filter()</code>와 <code>isletter</code>로 마침표와 기타 문장기호들을 제거하고 <code>lowercase()</code>로 소문자로 변경한다.(정확히 말하면, 문자열은 변경된 것이 아니라 소문자로 구성된 새 문자열을 반환한 것이다)</p><p>마지막으로, <code>processline()</code>은 새로운 항목을 만들거나 기존 항목을 증가시켜 히스토그램을 업데이트한다.</p><p>파일의 단어가 총 몇 개인지 세어보려면 히스토그램에서 빈도가 합쳐져야 한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> totalwords(hist)<br>    sum(values(hist))<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>다른 단어들의 수는 딕셔너리에서 아이템의 수이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> differentwords(hist)<br>    length(hist)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>결과는 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; println(<span class="hljs-string">&quot;Total number of words: &quot;</span>, totalwords(hist))<br>Total number of words: <span class="hljs-number">162742</span><br><br>julia&gt; println(<span class="hljs-string">&quot;Number of different words: &quot;</span>, differentwords(hist))<br><span class="hljs-built_in">Number</span> of different words: <span class="hljs-number">7380</span><br></code></pre></td></tr></table></figure><h3 id="가장-일반적인-단어">가장 일반적인 단어</h3><p>가장 일반적인 단어들을 찾기 위해서는 각각의 튜플이 단어와 빈도를 포함한 튜플 배열을 만들고 그 배열을 정리하면 된다. 아래의 함수는 히스토스램을 가져와 단어-빈도 튜플 배열로 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> mostcommon(hist)<br>    t = []<br>    <span class="hljs-keyword">for</span> (key, value) <span class="hljs-keyword">in</span> hist<br>        push!(t, (value, key))<br>    <span class="hljs-keyword">end</span><br>    reverse!(sort(t))<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 튜플은 빈도가 첫 번째 값이기 때문에 정렬도 빈도를 기준으로 배치된다. 아래의 코드는 10개의 가장 일반적인 단어를 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">t = mostcommon(hist)<br>println(<span class="hljs-string">&quot;The most common words are:&quot;</span>)<br><span class="hljs-keyword">for</span> (freq, word) <span class="hljs-keyword">in</span> t[<span class="hljs-number">1</span>:<span class="hljs-number">10</span>]<br>    println(word, <span class="hljs-string">&quot;\t&quot;</span>, freq)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 코드에서는 <code>\t</code>인 줄내림 분리기호를 사용하였다. 그 결과 단어들은 아래로 정렬된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Julia">The most common words are:<br>to  <span class="hljs-number">5295</span><br>the <span class="hljs-number">5266</span><br>and <span class="hljs-number">4931</span><br>of  <span class="hljs-number">4339</span><br>i   <span class="hljs-number">3191</span><br>a   <span class="hljs-number">3155</span><br>it  <span class="hljs-number">2546</span><br>her <span class="hljs-number">2483</span><br>was <span class="hljs-number">2400</span><br>she <span class="hljs-number">2364</span><br></code></pre></td></tr></table></figure><p><strong>Tip</strong> 위 코드는 <code>sort()</code>의 <code>rev</code> 키워드 인수를 사용하여 단순화할 수 있다. <code>rev</code>에 대해서는 <a href="https://docs.julialang.org/en/v1/base/sort/#Base.sort.">이 링크</a>에서 읽을 수 있다.</p><h3 id="선택적-매개-변수-optional-parameters">선택적 매개 변수 (Optional Parameters)</h3><p>지금까지는 선택적 인수를 가진 내장 함수들을 보았다. 물론 프로그래머가 직접 정의하는 함수 또한 선택적 인수를 사용하여 작성할 수 있다. 예를 들어 가장 일반적인 단어를 히스토그램으로 출력하는 함수는 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> printmostcommon(hist, num=<span class="hljs-number">10</span>)<br>    t = mostcommon(hist)<br>    println(<span class="hljs-string">&quot;The most common words are: &quot;</span>)<br>    <span class="hljs-keyword">for</span> (freq, word) <span class="hljs-keyword">in</span> t[<span class="hljs-number">1</span>:num]<br>        println(word, <span class="hljs-string">&quot;\t&quot;</span>, freq)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>첫 번째 매개 변수는 필수적으로 들어가야 하지만, 두 번째 매개 변수는 선택적이다. 위 코드에서 선택적 매개 변수의 기본값은 <code>num=10</code>이다.</p><p>만약 하나의 인수만 넣어 실행하면</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">printmostcommon(hist)<br></code></pre></td></tr></table></figure><p><code>num</code>은 자동으로 기본값이 입력된다. 만약 두 개의 인수를 모두 넣으면</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">printmostcommon(hist,<span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure><p><code>num</code>은 기본값 대신 입력한 새로운 값을 사용한다.</p><p>만약 함수에 필수적(required) 매개 변수와 선택적(optional) 매개 변수를 모두 입력하고 싶다면, 필수적 변수는 첫 번째로 입력하고 선택적 변수는 그 뒤에 써야 한다.</p><h3 id="딕셔너리-뺄셈-dictionary-subtraction">딕셔너리 뺄셈 (Dictionary Subtraction)</h3><p>책에서 words.txt 단어 리스트에 없는 단어를 찾는 것은 두 딕셔너리를 빼는 것 처럼 인식된다. 즉, 책에는 있지만 단어 리스트에는 없는 단어를 찾으려는 것이다.</p><p><code>subtract()</code>은 딕셔너리 <code>d1</code>과 <code>d2</code>를 가져와서 <code>d1</code>는 있지만 <code>d2</code>에는 없는 키들을 포함한 새로운 딕셔너리를 반환한다. 값은 필요 없기 때문에 <code>nothing</code>으로 설정했다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> subtract(d1, d2)<br>    res = <span class="hljs-built_in">Dict</span>()<br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> keys(d1)<br>        <span class="hljs-keyword">if</span> key ∉ keys(d2)<br>            res[key] = <span class="hljs-literal">nothing</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    res<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>책에는 있지만 단어 리스트에 없는 단어를 찾기 위해서는 words.txt 또한 <code>processfile()</code>를 사용해서 히스토그램으로 만들어야 한다. 그리고 <code>subtract()</code>를 사용하자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia">words = processfile(<span class="hljs-string">&quot;words.txt&quot;</span>)<br>diff = subtract(hist, words)<br><br>println(<span class="hljs-string">&quot;Words in the book that aren&#x27;t in the word list:&quot;</span>)<br><span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> keys(diff)<br>    print(word, <span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>그 결과는 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Words <span class="hljs-keyword">in</span> the book that aren&#x27;t <span class="hljs-keyword">in</span> the word list:<br>outree quicksighted outwardly adelaide rencontre jeffereys unreserved dixons betweens ...<br></code></pre></td></tr></table></figure><p>위의 단어들 중에서 일부는 사람 이름과 소유물이다. 또한 "rencontre"와 같은 단어는 더이상 사용하지 않는 용어이다. 그러나 몇 개의 단어는 일반적인 단어로서 리스트에 있어야 한다.</p><h3 id="랜덤-단어-random-words">랜덤 단어 (Random Words)</h3><p>히스토그램으로부터 랜덤 단어를 선택하기 위해서 사용되는 가장 간편한 알고리즘은 각 단어의 복사본을 빈도만큼 만든 후 배열을 생성하여 선택하게 하는 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> randomword(h)<br>    t = []<br>    <span class="hljs-keyword">for</span> (word, freq) <span class="hljs-keyword">in</span> h<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:freq<br>            push!(t, word)<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    rand(t)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 알고리즘은 작동하지만, 효율적이지는 않다. 랜덤 단어를 선택할 때마다 책만큼 큰 크기의 배열을 다시 만든다. 효율을 향상시키기 위해서 배열을 한번만 만들고 여러 번 선택하는 방법도 좋지만, 배열의 크기는 여전히 크다.</p><p>대안으로는 다음과 같다.</p><ul><li>책에 있는 단어의 배열을 가져와라.</li><li>단어 빈도의 누적 합계를 요소로 하는 배열을 만들어라. 이 배열의 마지막 요소는 책의 총 단어 수가 되어야 한다.</li><li>1부터 n사이의 난수를 선택하라. 난수가 있는 위치를 찾기 위해 이분법 검색(bisection search)를 사용하여 해당 인덱스를 얻어라.</li><li>인덱스를 사용하여 연결되어 있는 단어를 찾아라.</li></ul><p><strong>대안 해결 코드</strong> 아래의 코드는 제가 직접 작성한 코드입니다. 필요하신 분들만 참고해주세요 :)</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> cumulsum(t)<br>    cumul=[]<br>    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:length(t)<br>        temp= sum(t[<span class="hljs-number">1</span>:n])<br>        cumul=push!(cumul,temp)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> cumul<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> searching_word(t)<br>    words=collect(keys(t))<br>    addnum=cumulsum(collect(values(t)))<br>    random=rand(<span class="hljs-number">1</span>:length(t))<br>    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:(length(addnum)-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> addnum[n] &lt; random &lt; addnum[n+<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">return</span> words[n]<br>        <span class="hljs-keyword">elseif</span> n+<span class="hljs-number">1</span> == addnum[<span class="hljs-keyword">end</span>]<br>            <span class="hljs-keyword">return</span> words[<span class="hljs-keyword">end</span>]<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="마르코프-분석-markov-analysis">마르코프 분석 (Markov Analysis)</h3><p>책에서 무작위로 단어를 선택하면, 어휘는 알 수 있지만 문장은 얻지 못할 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">this the small regard harriet which knightley&#x27;s it most things<br></code></pre></td></tr></table></figure><p>위의 문장처럼 무작위로 단어를 배열하면 문법적인 문제로 어떤 의미도 갖지 못하는 경우가 많다. 예를 들어, 의미를 가진 문장이라면 "the" 다음에 명사나 형용사가 올 것으로 예상할 수 있으며 동사나 부사는 사용할 수 없다.</p><p>이런 관계를 파악하는 한 가지 방법은 특정 단어 이후에 나올 단어의 확률을 분석하는 마르코프 분석을 사용하는 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Half a bee, philosophically,<br>Must, ipso facto, half not be.<br>But half the bee has got to be<br>Vis a vis, its entity. D’you see?<br><br>But can a bee be said to be<br>Or not to be an entire bee<br>When half the bee is not a bee<br>Due to some ancient injury?<br></code></pre></td></tr></table></figure><p>위의 글에서 "half the"라는 구문 뒤에는 항상 "bee"이라는 단어가 쓰이며, "bee" 뒤에는 "has"나 "is"가 쓰이는 것을 알 수 있다.</p><p>마르코프 분석에서는 각 접두사("half the","bee")에서 가능한 모든 접미사("has","is")로 매핑한다.</p><p>이 맵이 있으면 랜덤 접두사로 시작한 후 가능한 접미사에서 임의로 선택하고 이를 반복하여 글을 생성할 수 있다.</p><p>예를 들어, 접두사 "half a"로 시작하는 경우 다음 단어는 "bee"이여야 한다. 왜냐하면 접두사 "half a"가 글에 딱 한번 나왔기 때문에 다른 확률이 없다. 다음 접두사는 "bee"이기 때문에 그 뒤에는 접미사 “philosophically”, “be” 또는 “due”가 올 수 있다.</p><p>위의 예시는 접두사 길이를 두 단어로 한정시켰다. 이처럼 마르코프 분석은 접두사 길이를 사용해서도 활용할 수 있다.</p><p><strong>마르코프 분석 연습문제</strong> 다음 장으로 가기 전에 해당 연습문제를 꼭 시도해보기를 추천한다.</p><ul><li><p>파일에서 텍스트를 읽고 마르코프 분석을 수행하는 프로그램을 작성하라. 결과는 접두사에서 가능한 접미사 모음으로 매핑되는 딕셔너리어야 한다. 모음은 배열, 튜플 또는 딕셔너리 어떤 것을 사용해도 상관없다. 접두사 길이와 상관없이 사용할 수 있는 프로그램을 작성하라.</p></li><li><p>마르코프 분석을 기반으로 임의의 텍스트를 생성하려면 이전 프로그램에 함수를 추가하라. 다음은 접두사 길이가 2인 Emma의 예이다.</p></li></ul><p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">“He was very clever, be it sweetness or be angry,<br>ashamed or only amused, at such a stroke.<br>She had never thought of Hannah till you were never meant <span class="hljs-keyword">for</span> me?<span class="hljs-string">&quot;</span><br><span class="hljs-string"> &quot;I</span> cannot make speeches, Emma:<span class="hljs-string">&quot; he soon cut it all himself.”</span><br></code></pre></td></tr></table></figure></p><p>이 예시에서는 마침표를 단어로 포함했다. 결과는 거의 문법적으로 정확하지만 완벽하지는 않으며, 의미도 어느정도 있는 것 같지만 완벽하게 이해되지는 않는다. 만약 접두사의 길이를 늘리면 어떤 결과가 나오는가? 문장이 더 의미있는가?</p><ul><li>프로그램이 작동한다면, '매쉬 업(mash-up)'을 시도할 수 있다. 두 권 이상의 책을 결합하여 생성한 랜덤 텍스트는 더 흥미로운 어휘와 문장을 보여줄 것이다.</li></ul><h3 id="데이터-구조-data-structures">데이터 구조 (Data Structures)</h3><p>마르코프 분석을 사용하여 랜덤 텍스트를 만드는 것은 재미있지만 사실 연습문제에는 '데이터 구조 선택(data structure selection)'이라는 중요한 핵심이 있다. 위의 연습문제를 풀기 위해서는 아래의 내용들을 결정해야 한다.</p><ul><li>접두사를 나타내는 방법</li><li>가능한 접미사 모음을 나타내는 방법</li><li>각 접두사에서 가능한 접미사 모음으로 매핑을 나타내는 방법</li></ul><p>마지막 문제를 해결하는 방법은 쉽다. 딕셔너리 키에서 해당 값으로 매핑해주면 끝이다. 접두사의 경우 가장 좋은 방법은 문자열, 문자열 배열, 또는 문자열 튜플이다. 접미사는 배열이나 히스토그램(딕셔너리)이 적절하다.</p><p>어떻게 선택해야 할까? 첫 번째 단계는 각 데이터 구조를 위해 구현해야 하는 작업에 대해 생각하는 것이다. 접두사의 경우 사용한 접두사를 제거하고 새로운 접두사를 추가할 수 있어야 한다. 예를 들어 현재 접두사가 "half a"이고 다음 단어가 "bee"인 경우 다음 접두사 "bee"를 생성할 수 있어야 한다.</p><p>배열은 요소를 쉽게 추가하고 제거할 수 있기 때문에 사용하기 적절하다.</p><p>접미사 모음의 경우, 새 접미사 추가 및 기존 접미사 빈도 증가, 랜덤 접미사 선택 등의 일들을 수행해야 한다.</p><p>새 접미사를 추가하는 것은 배열 구현이나 히스토그램 둘 다 쉽다. 하지만 랜덤 요소를 선택하는 것은 히스토그램보다 배열이 더 쉽다.</p><p>지금까지는 어떤 구조가 구현하기 편한지에 대해서 이야기했지만 사실 데이터 구조를 선택할 때 고려해야 할 다른 중요한 부분들이 있다. 첫 번째는 런타임이다. 각각의 데이터 구조마다 소요되는 시간은 이론적으로 차이가 있다. 예를 들어 <code>in</code> 연산자는 요소가 많을 때 배열보다 딕셔너리에서 더 빠르다.</p><p>그러나 어떤 구현이 더 빠른지 미리 알지 못하는 경우가 종종 있다. 이럴 경우 두 가지의 선택으로 나뉘는데, 그 중 하나는 모두 구현해본 다음에 어느 것이 더 나은지를 경험해보는 것이다. 이 접근법을 벤치마킹(benchmarking)이라고 한다. 또 다른 실용적인 대안은 구현하기 가장 쉬운 데이터 구조를 선택한 다음 프로그램에 적합한 속도인지를 확인하는 것이다. 만약 적합하다면, 굳이 다른 데이터 구조를 만들 필요가 없다. 적합하지 않다면, 시간이 가장 많이 걸리는 프로그램 위치를 알려주는 <code>Profile</code> 모듈과 같은 도구들을 사용하면 된다.</p><p>고려해야 할 두번째 요소는 저장 공간이다. 예를 들어, 접미사 모음에 히스토그램을 사용하면 텍스트에 여러 번 나타나는지에 관계없이 각 단어를 한 번만 저장하면 되므로 저장 공간을 덜 차지할 수 있다. 경우에 따라 저장 공간을 절약하면 프로그램 실행 속도가 빨라질 수 있으며, 메모리가 부족할 경우에는 프로그램이 실행되지 않을 수 있다. 하지만 많은 응용프로그램들에서는 런타임을 우선적으로 고려한다.</p><p>지금까지는 마르코프 분석과 텍스트 생성을 동시에 하는 데이터 구조를 생각했다. 하지만 분석과 텍스트 생성을 별도의 단계로 나눈 각각의 데이터 구조를 사용하는 것도 가능하다. 만약 통합된 데이터 구조보다 별도로 나눈 데이터 구조가 더 빠르다면 나누는 것이 바람직하다.</p><p><strong>Tip</strong> 줄리아 패키지 <a href="https://github.com/JuliaCollections/DataStructures.jl"><code>DataStructures</code></a>는 다양한 데이터 구조를 구현한다.</p><h3 id="디버깅">디버깅</h3><p>프로그램을 디버깅할 때, 특히 어려운 버그를 만났을 때 아래의 5가지를 시도해보라.</p><ul><li><p>읽기(Reading) 코드를 검사하고 스스로 다시 코드를 읽은 후 무엇을 원하는지 확인하라.</p></li><li><p>실행(Running) 변경한 다른 버전을 실행하면서 실험해보라. 코드를 올바른 위치에 잘 작성하면 문제가 명확하게 보이지만, 때로는 스캐폴딩을 만들어 문제를 확인해야 한다.</p></li><li><p>반추(Ruminating) 시간을 두고 생각해보라. 문법, 런타임, 의미 오류가 무엇인가? 오류 메시지 또는 프로그램 출력에서 무엇을 얻을 수 있나? 어떤 종류의 문제가 발생할 수 있는가? 문제가 나타나기 전에 변경한 사항은 무엇인가?</p></li><li><p>고무오리(Rubberducking) 다른 사람에게 문제를 설명하면, 말이 끝나기도 전에 답을 찾을 때가 있다. 만약 다른 사람이 없다면, 우리는 고무오리와도 대화할 수 있다. 이 전략을 고무오리 디버깅이라고 한다. 이 전략을 자세히 알고 싶다면 <a href="https://en.wikipedia.org/wiki/Rubber_duck_debugging">이 링크</a>를 참고해라.</p></li><li><p>후진(Retreating) 어떨 때는 오류가 나기 전의 프로그램으로 돌아오는 것이 가장 좋은 방법이다. 즉, 변경사항들을 취소한 후 프로그램을 다시 구현하는 것이다.</p></li></ul><p>초보 프로그래머들은 위의 5가지 방법 중 하나에 갇혀서 다른 방법들을 잊어버리곤 한다. 상황에 따라 문제에 최적화된 방법은 다르다는 것을 기억하자.</p><p>예를 들어, 문제가 인쇄상의 오류인 경우에는 코드를 읽는 것이 도움이 될 수 있지만 개념 오해로 비롯된 문제라면 읽는 방법은 도움이 되지 않는다. 프로그램이 어떻게 작동하는지 이해하지 못하면, 100번을 읽어도 오류를 찾을 수 없다.</p><p>실험 방법은 작고 간단한 테스트일 때 도움이 된다. 하지만 코드를 생각하거나 읽지 않고 실험만 진행하면 아무거나 바꿔보는 랜덤 워크 프로그래밍(random walk programming)에 빠질 수 있다. 이것은 시간이 오래 걸린다.</p><p>생각하려면 시간이 소요된다. 디버깅은 실험과학과 같다. 문제가 무엇인지에 대한 가설이 하나 이상은 있어야 한다. 둘 이상의 가능성이 있다면, 그 중 하나를 제거할 수 있는 테스트를 생각해보라.</p><p>그러나 오류가 너무 많거나 수정하려는 코드가 너무 크고 복잡하면 최고의 디버깅 기술조차 실패한다. 때로는 후진하는 것이 최선의 방법이며, 프로그램이 이해되고 작동될 때까지 단순화해야 한다.</p><p>초보 프로그래머는 종종 코드 라인을 삭제하는 후퇴를 꺼려한다. 불안하다면 프로그램 코드를 복사해둔 후 하나씩 수정해보라.</p><p>어려운 버그를 찾으려면 읽고, 실행하고, 반추하고 때로는 후진해야 한다. 한 가지 방법에서 막힌다면 다양한 방법을 시도해보라.</p><p><strong>연습문제 코드</strong> 아래의 코드는 제가 직접 작성한 코드입니다. 필요하신 분들만 참고해주세요 :)</p><ul><li>연습문제 1</li></ul><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> letterfilter(f)<br>    words=[]<br>    <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> split(f)<br>        word=lowercase(word)<br>        word=string(filter(isletter, word))<br>        push!(words,word)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> words<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> sentencetoword(t)<br>    fin = open(t)<br>    temp = []<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> eachline(t)<br>    f=readline(fin)<br>    replace(f,<span class="hljs-string">&quot;-&quot;</span> =&gt; <span class="hljs-string">&quot; &quot;</span>)<br>    replace(f,<span class="hljs-string">&quot;,&quot;</span> =&gt; <span class="hljs-string">&quot; &quot;</span>)<br>    t=letterfilter(f)<br>    temp=append!(temp,t)<br>    temp[<span class="hljs-string">&quot;&quot;</span>]=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> temp<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><ul><li>연습문제 2</li></ul><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> sentencetoword(t)<br>    fin = open(t)<br>    temp = <span class="hljs-built_in">Dict</span>()<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> eachline(t)<br>    f=readline(fin)<br>    replace(f,<span class="hljs-string">&quot;-&quot;</span> =&gt; <span class="hljs-string">&quot; &quot;</span>)<br>    replace(f,<span class="hljs-string">&quot;,&quot;</span> =&gt; <span class="hljs-string">&quot; &quot;</span>)<br>    letterfilter(f,temp)<br>    temp[<span class="hljs-string">&quot;&quot;</span>]=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> temp<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> letterfilter(f,temp)<br>    <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> split(f)<br>        word=lowercase(word)<br>        word=string(filter(isletter, word))<br>        temp[word]=get!(temp,word,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> numofword(t)<br>    ml= sentencetoword(t)<br>    wordnum=sum(values(ml))<br>    print(wordnum)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><ul><li>연습문제 3</li></ul><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> change(t)<br>    m=[]<br>    <span class="hljs-keyword">for</span> (key,value) <span class="hljs-keyword">in</span> t<br>        push!(m,(value,key))<br>    <span class="hljs-keyword">end</span><br>    reverse!(sort(m))<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> topword(t, n)<br>    words=change(t)<br>    top=words[<span class="hljs-number">1</span>:n]<br>    print(top)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><ul><li>연습문제 4</li></ul><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Julia">wordlist=sentencetoword(<span class="hljs-string">&quot;words.txt&quot;</span>)<br><br><span class="hljs-keyword">function</span> findweird(t1,t2)<br>    word1=keys(t1)<br>    word2=keys(t2)<br>    final=[]<br>    <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> word1<br>        <span class="hljs-keyword">if</span> word ∉ word2<br>        push!(final,word)<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> final<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>think julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>줄리아</tag>
      
      <tag>Julia</tag>
      
      <tag>Think Julia</tag>
      
      <tag>기초 강의</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[11/20] 튜플</title>
    <link href="/ko/ThinkJulia/Think-Julia-Chapter-11/"/>
    <url>/ko/ThinkJulia/Think-Julia-Chapter-11/</url>
    
    <content type="html"><![CDATA[<blockquote><p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p></blockquote><p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap12">Tuples</a>를 한글로 요약 정리한 글입니다. <span id="more"></span></p><h2 id="튜플-tuples">튜플 (Tuples)</h2><p>이번 장에서는 또다른 내장된 데이터 타입인 튜플(Tuples)에 대해서 알아보고 배열과 딕셔너리, 튜플이 어떻게 같이 작동하는지 공부할 것이다. 또한 유용한 기능인 '수집과 분산 연산자(gather and scatter operators.)'와 '가변 인수 배열(variable-length argument arrays)' 등을 살펴볼 것이다.</p><h3 id="튜플은-불변이다">튜플은 불변이다</h3><p>튜플은 일련의 값들이다. 값은 어떤 데이터 타입도 될 수 있으며, 또한 정수로 인덱싱되기 때문에 배열과 유사한 점이 많다. 중요한 차이점은 튜플은 요소를 변경할 수 없으며 각각의 요소들은 고유한 데이터 타입을 가진다.</p><p>문법적으로 튜플은 쉼표로 구분된 값 목록이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t = <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span><br>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>)<br></code></pre></td></tr></table></figure><p>하지만 필요하진 않더라도 괄호를 사용해서 튜플을 작성하는 것이 일반적이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t = (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>)<br>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>)<br></code></pre></td></tr></table></figure><p>하나의 요소로 튜플을 만들기 위해서는 마지막에 쉼표를 넣어주어야 한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t1 = (<span class="hljs-string">&#x27;a&#x27;</span>,)<br>(<span class="hljs-string">&#x27;a&#x27;</span>,)<br>julia&gt; typeof(t1)<br><span class="hljs-built_in">Tuple</span>&#123;<span class="hljs-built_in">Char</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>WARNING</strong> 쉼표 없는 괄호 안의 값은 튜플이 아니다.</p><p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t2 = (<span class="hljs-string">&#x27;a&#x27;</span>)<br><span class="hljs-string">&#x27;a&#x27;</span>: ASCII/Unicode U+<span class="hljs-number">0061</span> (category Ll: Letter, lowercase)<br>julia&gt; typeof(t2)<br><span class="hljs-built_in">Char</span><br></code></pre></td></tr></table></figure></p><p>튜플을 만드는 다른 방법은 내장 함수를 이용하는 것이다. 인수가 없는 상태인 <code>tuple()</code>을 입력하면 빈 튜플이 생성된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; tuple()<br>()<br></code></pre></td></tr></table></figure><p>여러 개의 인수들을 입력한다면, 인수들이 값인 튜플을 생성한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t3 = tuple(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-literal">pi</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-literal">π</span> = <span class="hljs-number">3.1415926535897</span>...)<br></code></pre></td></tr></table></figure><p><code>tuple</code>은 내장 함수의 이름이기 때문에 변수의 이름으로는 사용하지 않는 것이 좋다.</p><p>대부분의 배열 연산자들은 튜플에서 작동한다. 대괄호 연산자는 해당 인덱스의 요소를 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t = (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>);<br><br>julia&gt; t[<span class="hljs-number">1</span>]<br><span class="hljs-string">&#x27;a&#x27;</span>: ASCII/Unicode U+<span class="hljs-number">0061</span> (category Ll: Letter, lowercase)<br></code></pre></td></tr></table></figure><p>슬라이스 연산자 또한 요소들의 특정 범위를 선택한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>]<br>(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>)<br></code></pre></td></tr></table></figure><p>그러나 튜플의 한 요소를 수정하려고 시도하면, 아래의 오류 메시지가 나타난다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;A&#x27;</span><br>ERROR: <span class="hljs-built_in">MethodError</span>: no method matching setindex!(::<span class="hljs-built_in">NTuple</span>&#123;<span class="hljs-number">5</span>,<span class="hljs-built_in">Char</span>&#125;, ::<span class="hljs-built_in">Char</span>, ::<span class="hljs-built_in">Int64</span>)<br></code></pre></td></tr></table></figure><p>튜플은 변하지 않기 때문에 요소들을 수정할 수 없다.</p><p>관계 연산자들도 튜플이나 기타 시퀀스에서 작동한다. 줄리아는 각 시퀀스에서 첫 번째 요소를 비교하며 시작한다. 동일하면 다음 요소로 진행되며 다른 요소를 찾을 때까지 계속한다. 서브시퀀스는 고려되지 않는다. (실제로 큰 경우에도)</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt; (<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><span class="hljs-literal">true</span><br>julia&gt; (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2000000</span>) &lt; (<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>첫 번째 예시에서는 뒤의 튜플의 모든 요소가 앞의 튜플의 요소보다 모두 크기 때문에 <code>true</code>를 반환했다. 두 번째 예시는 세 번째 요소가 뒤의 튜플보다 앞의 튜플이 더 크지만 앞의 두 개의 요소가 모두 뒤의 튜플이 더 크기 때문에 <code>true</code>를 반환했다. 즉, 하나라도 큰 요소가 있다면 <code>true</code>이고 아니라면 <code>false</code>를 반환한다.</p><h3 id="튜플-할당">튜플 할당</h3><p>이것은 두 변수의 값을 바꿀 때 유용하다. 기존 할당에서는 임시 변수를 사용해야 한다. 예를 들어 <code>a</code>와 <code>b</code>를 바꾸려고 한다면, 아래와 같이 중간에 임시 변수가 필요하다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia">temp = a<br>a = b<br>b = temp<br></code></pre></td></tr></table></figure><p>위의 방식은 번거롭다. 튜플은 훨씬 간단한 방법으로 변경한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">a, b = b, a<br></code></pre></td></tr></table></figure><p>왼쪽은 튜플의 변수들이며, 오른쪽은 튜플의 표현식이다. 각 값들은 해당 변수에 할당되며, 오른쪽의 모든 표현식은 할당 전에 평가된다.</p><p>왼쪽에 있는 변수의 수는 오른쪽 값의 수보다 작으면 작동하지만, 초과된 값은 사라진다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; (a, b) = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>julia&gt; a, b, c = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br>ERROR: <span class="hljs-built_in">BoundsError</span>: attempt to access (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>  at index [<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p>일반적으로 오른쪽은 문자열, 배열, 튜플 등 어떤 종류의 시퀀스도 입력될 수 있다. 예를 들어 이메일 주소를 사용자 이름과 도메인으로 나누려면 다음과 같이 작성할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; addr = <span class="hljs-string">&quot;julius.caesar@rome&quot;</span><br><span class="hljs-string">&quot;julius.caesar@rome&quot;</span><br>julia&gt; uname, domain = split(addr, <span class="hljs-string">&#x27;@&#x27;</span>);<br></code></pre></td></tr></table></figure><p><code>split()</code>으로부터 반환된 두 값은 배열의 두 요소가 된다. 첫 번째 요소는 <code>uname</code>에 할당되며, 두 번째는 <code>domain</code>에 할당된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; uname<br><span class="hljs-string">&quot;julius.caesar&quot;</span><br>julia&gt; domain<br><span class="hljs-string">&quot;rome&quot;</span><br></code></pre></td></tr></table></figure><h3 id="반환-값으로서의-튜플">반환 값으로서의 튜플</h3><p>엄격하게 말하자면, 함수는 오직 한 개의 값만 반환하지만 그러나 그 한 개의 값이 튜플이라면 여러 개의 값을 반환하는 것과 같은 효과를 가진다. 예를 들어 두 정수의 나눗셈에서 몫과 나머지를 구하려 할 때, <code>x ÷ y</code>을 계산한 후 <code>x % y</code>를 계산하는 것은 비효율적이다. 두 개의 수식을 한번에 계산하는 것이 더 낫다.</p><p>내장 함수인 <code>divrem()</code>은 두 인수를 가져가 몫과 나머지인 두 개의 값을 가진 튜플로 반환한다. 이후 결과를 튜플로 저장할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t = divrem(<span class="hljs-number">7</span>, <span class="hljs-number">3</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>또는 요소들을 각각 저장하기 위해서 튜플 할당을 이용할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; q, r = divrem(<span class="hljs-number">7</span>, <span class="hljs-number">3</span>);<br><br>julia&gt; <span class="hljs-meta">@show</span> q r;<br>q = <span class="hljs-number">2</span><br>r = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>아래의 함수는 튜플을 결과로 반환하는 예시이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> minmax(t)<br>    minimum(t), maximum(t)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>minimum()</code>과 <code>maximum()</code>은 시퀀스에서 가장 작은 수와 큰 수를 찾아주는 내장된 함수이다. <code>minmax()</code>은 두 개의 값을 튜플로 반환한다. 같은 결과를 주는 내장 함수인 <code>extrema()</code>도 효과적이다.</p><h3 id="가변-인수-튜플-variable-length-argument-tuples">가변 인수 튜플 (Variable-length Argument Tuples)</h3><p>함수들은 가변적인 개수의 인수를 받아들일 수 있다. <code>...</code>로 끝나는 매개 변수 이름은 인수를 튜플로 <strong>수집(gather)</strong>한다. 예를 들어 <code>printall()</code>은 여러 인수들을 사용하여 출력한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> printall(args...)<br>    println(args)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>수집 매개 변수는 어떤 이름도 사용할 수 있지만 관례 상으로 <code>args</code>를 사용된다. 아래의 코드는 함수가 어떻게 작동하는지 보여준다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; printall(<span class="hljs-number">1</span>, <span class="hljs-number">2.0</span>, <span class="hljs-string">&#x27;3&#x27;</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2.0</span>, <span class="hljs-string">&#x27;3&#x27;</span>)<br></code></pre></td></tr></table></figure><p>위에서 본 수집을 보완해주는 것이 <strong>분산(scatter)</strong>이다. 만약 값의 시퀀스가 있고 여러 인수로 함수에 값을 전달하려는 경우 <code>...</code> 연산자를 사용하면 된다. 예를 들어 <code>divrem()</code>은 정확히 2개의 인수를 받으며, 2개의 요소를 가진 튜플을 넣어도 작동하지 않는다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t = (<span class="hljs-number">7</span>, <span class="hljs-number">3</span>);<br><br>julia&gt; divrem(t) <span class="hljs-comment"># 튜플의 값은 2개이지만 여기서 인수는 1개로 인식된다.</span><br>ERROR: <span class="hljs-built_in">MethodError</span>: no method matching divrem(::<span class="hljs-built_in">Tuple</span>&#123;<span class="hljs-built_in">Int64</span>,<span class="hljs-built_in">Int64</span>&#125;)<br></code></pre></td></tr></table></figure><p>그러나 튜플에 <code>...</code> 연산자를 사용하면 작동한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; divrem(t...) <span class="hljs-comment">#튜플의 값에 가변성을 부여하여 개수를 맞춰준다.</span><br>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>많은 내장 함수들이 가변 인수 튜플을 사용한다. 예를 들어, <code>min()</code>과 <code>max()</code>은 여러 인수들을 가져올 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; max(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>하지만 <code>sum()</code>은 작동하지 않는다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>ERROR: <span class="hljs-built_in">MethodError</span>: no method matching sum(::<span class="hljs-built_in">Int64</span>, ::<span class="hljs-built_in">Int64</span>, ::<span class="hljs-built_in">Int64</span>)<br></code></pre></td></tr></table></figure><h3 id="배열과-튜플">배열과 튜플</h3><p><code>zip()</code>은 두 개 이상의 시퀀스들을 가져온 후 시퀀스들을 요소로 가진 튜플로 반환하는 내장 함수이다. 함수의 이름은 두 줄의 치아를 연결하고 끼워 넣는 지퍼에서 가져왔다.</p><p>아래의 예시는 문자열과 배열을 <code>zip()</code>의 인수로 입력한 결과이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; s = <span class="hljs-string">&quot;abc&quot;</span>;<br><br>julia&gt; t = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br>julia&gt; zip(s, t)<br>Base.Iterators.Zip&#123;<span class="hljs-built_in">Tuple</span>&#123;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Int64</span>,<span class="hljs-number">1</span>&#125;&#125;&#125;((<span class="hljs-string">&quot;abc&quot;</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]))<br></code></pre></td></tr></table></figure><p>위의 결과는 페어 단위로 정리할 수 있는 짚(zip) 객체이다. <code>zip()</code>은 일반적으로 <code>for</code> 루프에서 사용된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-keyword">for</span> pair <span class="hljs-keyword">in</span> zip(s, t)<br>           println(pair)<br>       <span class="hljs-keyword">end</span><br>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>짚 객체는 일종의 이터레이터(iterator)이며 시퀀스를 반복하는 객체이다. 이터레이터는 몇 가지 측면에서 배열과 비슷하지만, 배열과 달리 인덱스를 사용하여 요소를 선택할 수 없다.</p><p>만약 배열 연산자나 함수를 사용하고 싶다면, 짚 객체를 이용하여 배열을 만들면 된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; collect(zip(s, t))<br><span class="hljs-number">3</span>-element <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Tuple</span>&#123;<span class="hljs-built_in">Char</span>,<span class="hljs-built_in">Int64</span>&#125;,<span class="hljs-number">1</span>&#125;:<br> (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>)<br> (<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>)<br> (<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>위의 결과는 튜플의 배열이다. 이 예시에서 각각의 튜플은 문자열에서 온 문자와 배열에서 온 요소들을 포함한다.</p><p>만약 시퀀스가 다른 길이라면, 더 짧은 시퀀스를 기준으로 결과가 출력된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; collect(zip(<span class="hljs-string">&quot;Anne&quot;</span>, <span class="hljs-string">&quot;Elk&quot;</span>))<br><span class="hljs-number">3</span>-element <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Tuple</span>&#123;<span class="hljs-built_in">Char</span>,<span class="hljs-built_in">Char</span>&#125;,<span class="hljs-number">1</span>&#125;:<br> (<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>)<br> (<span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>)<br> (<span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;k&#x27;</span>)<br></code></pre></td></tr></table></figure><p>튜플의 배열을 순회하기 위해서는 <code>for</code> 루프에서 튜플 할당을 사용할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t = [(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">3</span>)];<br><br>julia&gt; <span class="hljs-keyword">for</span> (letter, number) <span class="hljs-keyword">in</span> t<br>           println(number, <span class="hljs-string">&quot; &quot;</span>, letter)<br>       <span class="hljs-keyword">end</span><br><span class="hljs-number">1</span> a<br><span class="hljs-number">2</span> b<br><span class="hljs-number">3</span> c<br></code></pre></td></tr></table></figure><p>루프가 실행될 때마다 줄리아는 배열에서 다음 튜플을 선택하고 그 요소들을 letter와 number로 할당한다. <code>for</code> 루프에서 <code>(letter, number)</code>와 같이 괄호를 사용하는 것은 의무적이다.</p><p>만약 <code>zip()</code>, <code>for</code> 루프, 튜플 할당을 모두 결합하면, 동시에 두 개 이상의 시퀀스를 순회하는데 유용한 관용구를 얻는다. 예를 들어, <code>hasmatch()</code>는 <code>t1</code>과 <code>t2</code> 2개의 시퀀스를 가져가서 특정 인덱스 <code>i</code>가 <code>t1[i] == t2[i]</code>라면 <code>true</code>를 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> hasmatch(t1, t2)<br>    <span class="hljs-keyword">for</span> (x, y) <span class="hljs-keyword">in</span> zip(t1, t2)<br>        <span class="hljs-keyword">if</span> x == y<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-literal">false</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>시퀀스의 요소와 인덱스들을 순회해야 한다면, 내장 함수인 <code>enumerate()</code>를 사용할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-keyword">for</span> (index, element) <span class="hljs-keyword">in</span> enumerate(<span class="hljs-string">&quot;abc&quot;</span>)<br>           println(index, <span class="hljs-string">&quot; &quot;</span>, element)<br>       <span class="hljs-keyword">end</span><br><span class="hljs-number">1</span> a<br><span class="hljs-number">2</span> b<br><span class="hljs-number">3</span> c<br></code></pre></td></tr></table></figure><p><code>enumerate()</code>의 결과는 enumerate 객체이며, 일련의 쌍을 반복한다. 각 쌍에는 인덱스와 시퀀스 요소가 포함되어 있다.</p><h3 id="딕셔너리와-튜플">딕셔너리와 튜플</h3><p>딕셔너리는 키-값 페어를 반복하는 이터레이터(iterator)로 사용할 수 있다. <code>for</code> 루프에서 사용한다면 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; d = <span class="hljs-built_in">Dict</span>(<span class="hljs-string">&#x27;a&#x27;</span>=&gt;<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>=&gt;<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>=&gt;<span class="hljs-number">3</span>);<br><br>julia&gt; <span class="hljs-keyword">for</span> (key, value) <span class="hljs-keyword">in</span> d<br>           println(key, <span class="hljs-string">&quot; &quot;</span>, value)<br>       <span class="hljs-keyword">end</span><br>a <span class="hljs-number">1</span><br>c <span class="hljs-number">3</span><br>b <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>딕셔너리와 동일하게 아이템들은 특정한 순서가 없다.</p><p>또한 튜플 배열을 사용하여 새 딕셔너리로 초기화할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t = [(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">3</span>), (<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>)];<br><br>julia&gt; d = <span class="hljs-built_in">Dict</span>(t)<br><span class="hljs-built_in">Dict</span>&#123;<span class="hljs-built_in">Char</span>,<span class="hljs-built_in">Int64</span>&#125; with <span class="hljs-number">3</span> entries:<br>  <span class="hljs-string">&#x27;a&#x27;</span> =&gt; <span class="hljs-number">1</span><br>  <span class="hljs-string">&#x27;c&#x27;</span> =&gt; <span class="hljs-number">3</span><br>  <span class="hljs-string">&#x27;b&#x27;</span> =&gt; <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><code>Dict()</code>과 <code>zip()</code>을 결합하면 딕셔너리를 만드는 간결한 방법이 된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; d = <span class="hljs-built_in">Dict</span>(zip(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-number">1</span>:<span class="hljs-number">3</span>))<br><span class="hljs-built_in">Dict</span>&#123;<span class="hljs-built_in">Char</span>,<span class="hljs-built_in">Int64</span>&#125; with <span class="hljs-number">3</span> entries:<br>  <span class="hljs-string">&#x27;a&#x27;</span> =&gt; <span class="hljs-number">1</span><br>  <span class="hljs-string">&#x27;c&#x27;</span> =&gt; <span class="hljs-number">3</span><br>  <span class="hljs-string">&#x27;b&#x27;</span> =&gt; <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>이것은 튜플을 딕셔너리의 키로 사용하는 일반적인 방법이다. 예를 들어 전화 번호부는 성과 이름 쌍에서 전화 번호로 매핑될 수 있다. 우리가 이름 쌍과 전화 번호를 알고 있다면 아래와 같이 작성할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">directory[last, first] = number<br></code></pre></td></tr></table></figure><p>위의 예시에서 대활호 안에 있는 표현식은 튜플이다. 즉, 이 딕셔너리를 순회하기 위해서는 튜플 할당을 사용할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">for</span> ((last, first), number) <span class="hljs-keyword">in</span> directory<br>    println(first, <span class="hljs-string">&quot; &quot;</span>, last, <span class="hljs-string">&quot; &quot;</span>, number)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>이 루프는 <code>directory</code>에서 튜플인 키-값 페어를 순회한다. 각 튜플의 키 요소를 <code>last</code>와 <code>first</code>에, 값을 숫자에 할당한 다음 이름과 해당 전화번호를 출력한다.</p><h3 id="시퀀스의-시퀀스-sequences-of-sequences">시퀀스의 시퀀스 (Sequences of Sequences)</h3><p>지금까지는 튜플 배열(arrays of tuples)에 중점을 두었지만, 이번 장의 모든 예제들은 배열의 배열(arrays of arrays), 튜플의 튜플(tuples of tuples), 배열 튜플(tuples of arrays)에서도 작동한다. 앞과 같이 가능한 조합을 열거하지 않기 위해서 시퀀스의 시퀀스로 이야기 하는 것이 훨씬 편하다.</p><p>많은 상황에서 문자열, 배열 및 튜플 등 서로 다른 종류의 시퀀스들을 바꿔서 사용할 수 있다. 만약 바꾼다면 어떤 것을 선택해야 할까?</p><p>확실한 것부터 시작하자면, 문자열은 요소들이 문자로 이루어져야 하기 때문에 다른 시퀀스보다 제한적이다. 또한 문자열은 불변이다. 만약 문자열에서 문자를 변경하는 함수가 필요한 경우, 새 문자열을 만드는 것 대신 문자 배열을 사용할 수 있다.</p><p>배열은 대부분 변경이 가능하기 때문에 튜플보다는 일반적으로 사용된다. 그러나 튜플이 더 적합한 몇 가지의 경우가 있다.</p><ul><li>반환 구문과 같은 일부 코드에서는 배열보다 튜플을 만드는 것이 문법 상 더 간단하다.</li><li>시퀀스를 함수에 인수로 전달하는 경우 튜플을 사용하면 에일리어싱으로 인한 오류의 가능성이 줄어든다.</li><li>성능상의 이유로 컴파일러가 튜플 타입을 전문화할 수 있다.</li></ul><p>튜플은 변경할 수 없으므로 배열을 수정하는 <code>sort!()</code>나 <code>reverse!()</code>와 같은 함수를 제공하지 않는다. 그러나 줄리아는 배열의 요소들을 가져와 정렬된 상태의 새로운 배열을 반환하는 내장 함수 <code>sort()</code>를 제공하며, 시퀀스를 가져와 역순으로 반환하는 <code>reverse()</code>도 제공한다.</p><h3 id="디버깅">디버깅</h3><p>배열, 딕셔너리 그리고 튜플은 데이터 구조의 예이다. 이 장에서는 튜플 배열 또는 튜플을 키로 가진 딕셔너리와 같은 복합 데이터 구조를 보기 시작하였다. 복합 데이터 구조는 유용하지만 형태 오류(shape errors)가 나기 쉽다. 즉, 데이터 구조가 잘못된 데이터 타입이나 크기 또는 구조를 가지는 것이다. 예를 들어 함수는 하나의 정수가 있는 배열을 기대하는데 개발자가 정수 하나만 입력한다면, 그 함수는 작동하지 않는다.</p><p>줄리아는 시퀀스의 요소에 데이터 타입을 첨부할 수 있다. 이 작업을 수행하는 방법은 다중 디스패치 파트에서 자세하게 설명할 것이다. 데이터 타입을 지정하면 많은 형태 오류가 제거된다.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>think julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>줄리아</tag>
      
      <tag>Julia</tag>
      
      <tag>Think Julia</tag>
      
      <tag>기초 강의</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[10/20] 딕셔너리</title>
    <link href="/ko/ThinkJulia/Think-Julia-Chapter-10/"/>
    <url>/ko/ThinkJulia/Think-Julia-Chapter-10/</url>
    
    <content type="html"><![CDATA[<blockquote><p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p></blockquote><p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap11">Dictionaries</a>를 한글로 요약 정리한 글입니다. <span id="more"></span></p><h2 id="딕셔너리-dictionaries">딕셔너리 (Dictionaries)</h2><p>이번 장에서는 줄리아에 내장된 다른 데이터 타입인 딕셔너리에 대해서 알아볼 것이다.</p><h3 id="딕셔너리는-매핑mapping이다">딕셔너리는 매핑(mapping)이다</h3><p>딕셔너리는 배열 같지만 좀 더 일반적이다. 배열에서는 인덱스가 무조건 정수여야 하지만, 딕셔너리에서는 어떤 타입도 인덱스로 사용될 수 있다.</p><p>딕셔너리는 키(key)라고 불리는 인덱스들의 모음과 값들의 모음을 포함한다. 각각의 키는 하나의 값과 연결되어 있다. 키와 값의 연결을 키-값 페어(key-value pair) 또는 아이템(items)이라고 부른다.</p><p>수학적 용어에서 딕셔너리는 키에서 값으로의 매핑을 나타내므로 각 키가 값에 매핑한다고 말할 수도 있다. (여기서 <strong>매핑</strong>이란 원하는 데이터를 찾아주는 과정을 말한다) 예를 들어 영어에서 스페인어로 번역해주는 맵인 딕셔너리를 만든다면, 키와 값은 모두 문자열이어야 한다.</p><p><code>Dict()</code>는 아이템 없이 빈 딕셔너리를 만든다. <code>Dict</code>는 내장 함수 이름이기 때문에, 변수를 만들 때는 이 이름을 사용하면 안된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; eng2sp = <span class="hljs-built_in">Dict</span>()<br><span class="hljs-built_in">Dict</span>&#123;<span class="hljs-built_in">Any</span>,<span class="hljs-built_in">Any</span>&#125; with <span class="hljs-number">0</span> entries<br></code></pre></td></tr></table></figure><p>딕셔너리의 종류는 중괄호로 묶어서 표현된다. 위의 예시에서는 키와 값의 데이터 타입이 모두 <code>Any</code>이다.</p><p>위의 딕셔너리는 비어있다. 딕셔너리에 아이템을 추가하기 위해서는 대괄호를 사용하면 된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; eng2sp[<span class="hljs-string">&quot;one&quot;</span>] = <span class="hljs-string">&quot;uno&quot;</span>;<br></code></pre></td></tr></table></figure><p>위 코드는 "one"이라는 키에 "uno"라는 값을 매핑하여 아이템을 생성한다. 이후 딕셔너리를 출력해보면 키-값 사이에 <code>=&gt;</code> 화살표가 나타남을 볼 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; eng2sp<br><span class="hljs-built_in">Dict</span>&#123;<span class="hljs-built_in">Any</span>,<span class="hljs-built_in">Any</span>&#125; with <span class="hljs-number">1</span> entry:<br>  <span class="hljs-string">&quot;one&quot;</span> =&gt; <span class="hljs-string">&quot;uno&quot;</span><br></code></pre></td></tr></table></figure><p>위의 출력된 형태는 입력할 때도 사용할 수 있다. 예를 들어, 3개의 아이템을 딕셔너리에 추가해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; eng2sp = <span class="hljs-built_in">Dict</span>(<span class="hljs-string">&quot;one&quot;</span> =&gt; <span class="hljs-string">&quot;uno&quot;</span>, <span class="hljs-string">&quot;two&quot;</span> =&gt; <span class="hljs-string">&quot;dos&quot;</span>, <span class="hljs-string">&quot;three&quot;</span> =&gt; <span class="hljs-string">&quot;tres&quot;</span>)<br><span class="hljs-built_in">Dict</span>&#123;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">String</span>&#125; with <span class="hljs-number">3</span> entries:<br>  <span class="hljs-string">&quot;two&quot;</span>   =&gt; <span class="hljs-string">&quot;dos&quot;</span><br>  <span class="hljs-string">&quot;one&quot;</span>   =&gt; <span class="hljs-string">&quot;uno&quot;</span><br>  <span class="hljs-string">&quot;three&quot;</span> =&gt; <span class="hljs-string">&quot;tres&quot;</span><br></code></pre></td></tr></table></figure><p>모든 키와 값은 문자열이다. 따라서 <code>Dict&#123;String,String&#125;</code>으로 생성된다.</p><p><strong>WARNING</strong> 키-값 페어의 순서가 같지 않을 수 있다. 즉, 컴퓨터에 위의 동일한 예제를 입력해도 순서는 다르게 나타날 수 있다.</p><p>하지만 딕셔너리의 요소들은 정수 인덱스로 저장되지 않기 때문에 순서는 문제가 되지 않는다. 대신에 키를 통해서 값을 찾을 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; eng2sp[<span class="hljs-string">&quot;two&quot;</span>]<br><span class="hljs-string">&quot;dos&quot;</span><br></code></pre></td></tr></table></figure><p>키 "two"는 "dos"와 매핑되어 있기 때문에 항상 같은 값을 제공한다.</p><p>만약 입력한 키가 딕셔너리에 없다면, 아래와 같은 오류를 만날 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; eng2sp[<span class="hljs-string">&quot;four&quot;</span>]<br>ERROR: <span class="hljs-built_in">KeyError</span>: key <span class="hljs-string">&quot;four&quot;</span> not found<br></code></pre></td></tr></table></figure><p><code>lenth()</code>는 딕셔너리에서도 작동한다. 이 함수는 키-값 페어의 개수를 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; length(eng2sp)<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><code>keys()</code>는 딕셔너리의 키들(keys)만 보여준다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; ks = keys(eng2sp);<br><br>julia&gt; print(ks)<br>[<span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>]<br></code></pre></td></tr></table></figure><p>키들의 모음을 변수로 만들었으니, 이제는 <code>∈</code> 연산자를 사용하여 해당 키가 존재하는지 여부를 살펴볼 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-string">&quot;one&quot;</span> ∈ ks<br><span class="hljs-literal">true</span><br>julia&gt; <span class="hljs-string">&quot;uno&quot;</span> ∈ ks<br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>딕셔너리에 있는 값만을 보기 위해서는 값들의 모음을 반환하는 <code>values()</code>를 사용하면 된다. 그리고 <code>∈</code> 연산자를 사용하여 해당 값이 존재하는지 확인할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; vs = values(eng2sp);<br><br>julia&gt; <span class="hljs-string">&quot;uno&quot;</span> ∈ vs<br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><code>∈</code> 연산자는 배열과 딕셔너리에서 다른 알고리즘을 사용한다. 배열에서는 <a href="https://dev-bearabbit.github.io/2020/03/06/ThinkJulia/Think-Julia-Chapter-9/">검색</a>파트에서와 같이 배열의 요소들을 순서대로 검색한다. 따라서 배열이 길수록, 검색시간은 더 길어질 수밖에 없다.</p><p>하지만 딕셔너리에서는 줄리아가 <a href="https://ko.wikipedia.org/wiki/해시_테이블">해시테이블(hash table)</a>이라는 알고리즘을 사용한다. 따라서 딕셔너리에서 <code>∈</code> 연산자는 어떤 아이템을 요구하던 호출하는 시간이 동일하다.</p><h3 id="딕셔너리로-카운팅하기">딕셔너리로 카운팅하기</h3><p>만약 문자가 주어지고 각 문자가 몇 번 나타내는지를 세고 싶다고 가정해보자. 그렇다면 해결할 수 있는 방법으로는 몇 가지가 있다.</p><ul><li>알파벳마다 하나씩 26개의 변수를 만들고, 각 문자에 대해 조건문을 사용하고 문자열을 순회하여 카운터를 증가하기</li><li>26개의 요소로 배열을 만든 다음 내장 함수 <code>Int()</code>를 사용하여 각 문자열을 숫자로 변환한 후, 인덱스로 사용하여 카운터를 증가하기</li><li>문자를 키로, 카운터를 해당 값으로 사용하여 딕셔너리를 만들고 문자가 나올 때마다 값을 증가하기. 딕셔너리에 없는 문자가 나오면 키로 저장하게 설정하면 좋다.</li></ul><p>위의 세 가지의 방법들은 똑같은 결과를 보여주지만, 구현하는 방법은 모두 다르다.</p><p>구현(implementation)은 계산을 수행하는 방법이다. 몇몇의 구현은 다른 것들보다 더 나은 경우도 있다. 예를 들어 딕셔너리 구현의 장점은 문자열에 어떤 문자가 나타나는지 미리 알 필요가 없으며, 나타나는 문자를 위한 공간만 만들면 된다는 점이다.</p><p>아래의 코드가 그렇다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> histogram(s)<br>    d = <span class="hljs-built_in">Dict</span>()<br>    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s<br>        <span class="hljs-keyword">if</span> c ∉ keys(d)<br>            d[c] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span><br>            d[c] += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    d<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>함수 이름은 <code>histogram()</code>으로, 빈도 모음에 대한 통계 용어이다. 함수의 첫 번째 줄은 빈 딕셔너리를 만든다. <code>for</code>루프는 문자열을 통과하며, 루프는 문자 <code>c</code>가 딕셔너리에 없다면 키 <code>c</code>와 초기 값 <code>1</code>을 새 항목으로 만든다. 만약 <code>c</code>가 이미 딕셔너리에 있다면 <code>d[c]</code>를 증가시킨다.</p><p>위 함수를 실행한 결과는 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; h = histogram(<span class="hljs-string">&quot;brontosaurus&quot;</span>)<br><span class="hljs-built_in">Dict</span>&#123;<span class="hljs-built_in">Any</span>,<span class="hljs-built_in">Any</span>&#125; with <span class="hljs-number">8</span> entries:<br>  <span class="hljs-string">&#x27;n&#x27;</span> =&gt; <span class="hljs-number">1</span><br>  <span class="hljs-string">&#x27;s&#x27;</span> =&gt; <span class="hljs-number">2</span><br>  <span class="hljs-string">&#x27;a&#x27;</span> =&gt; <span class="hljs-number">1</span><br>  <span class="hljs-string">&#x27;r&#x27;</span> =&gt; <span class="hljs-number">2</span><br>  <span class="hljs-string">&#x27;t&#x27;</span> =&gt; <span class="hljs-number">1</span><br>  <span class="hljs-string">&#x27;o&#x27;</span> =&gt; <span class="hljs-number">2</span><br>  <span class="hljs-string">&#x27;u&#x27;</span> =&gt; <span class="hljs-number">2</span><br>  <span class="hljs-string">&#x27;b&#x27;</span> =&gt; <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>히스토그램은 위와 같이 문자가 사용된 개수를 정확하게 측정하였다.</p><p>딕셔너리는 키와 기본값을 사용하는 <code>get()</code>가 있다. 키가 딕셔너리에 나타나면 <code>get()</code>은 연결된 값을 보여주며, 만약 연결된 값이 없다면 기본값을 보여준다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; h = histogram(<span class="hljs-string">&quot;a&quot;</span>)<br><span class="hljs-built_in">Dict</span>&#123;<span class="hljs-built_in">Any</span>,<span class="hljs-built_in">Any</span>&#125; with <span class="hljs-number">1</span> entry:<br>  <span class="hljs-string">&#x27;a&#x27;</span> =&gt; <span class="hljs-number">1</span><br>julia&gt; get(h, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">0</span>)<br><span class="hljs-number">1</span><br>julia&gt; get(h, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">0</span>)<br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="루핑과-딕셔너리">루핑과 딕셔너리</h3><p><code>for</code>문 안에서 딕셔너리 키들을 순회할 수 있다. 예를 들어서 <code>printhist()</code>는 각 키에 연결된 값들을 출력한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> printhist(h)<br>    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> keys(h)<br>        println(c, <span class="hljs-string">&quot; &quot;</span>, h[c])<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>출력 결과는 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; h = histogram(<span class="hljs-string">&quot;parrot&quot;</span>);<br><br>julia&gt; printhist(h)<br>a <span class="hljs-number">1</span><br>r <span class="hljs-number">2</span><br>p <span class="hljs-number">1</span><br>o <span class="hljs-number">1</span><br>t <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>다시 말하지만 키는 특정한 순서를 가지고 있지 않다. 키를 순서대로 순회하기 위해서는 <code>sort()</code>와 <code>collect()</code>를 결합해야 한다. <code>collect()</code>는 키들을 문자로 변경하고, <code>sort()</code>는 문자들을 순서대로 정렬한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> sort(collect(keys(h)))<br>           println(c, <span class="hljs-string">&quot; &quot;</span>, h[c])<br>       <span class="hljs-keyword">end</span><br>a <span class="hljs-number">1</span><br>o <span class="hljs-number">1</span><br>p <span class="hljs-number">1</span><br>r <span class="hljs-number">2</span><br>t <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="역방향-조회">역방향 조회</h3><p><code>d</code>라는 딕셔너리와 <code>k</code>라는 키가 주어졌일 때, 해당된 값을 찾는 방법은 <code>v=d[k]</code>이다. 이런 작업을 조회(lookup)라고 부른다.</p><p>하지만 값을 가진 상태에서 키를 찾고 싶다면 어떻게 해야할까? 이 상황에서는 두 가지의 문제가 있다. 첫 번째 문제는 동일한 값을 매핑한 키가 두 개 이상일 수도 있다는 점이다. 프로그램에 따라 하나를 선택하거나 해당되는 모든 키가 포함된 배열을 만들어야 할 수도 있다. 두 번째는 역방향 조회를 수행하는 간단한 문법은 없다는 점이다. 따라서 우리가 직접 검색해야 한다.</p><p>아래의 함수는 값을 받아서 키를 돌려준다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> reverselookup(d, v)<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> keys(d)<br>        <span class="hljs-keyword">if</span> d[k] == v<br>            <span class="hljs-keyword">return</span> k<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    error(<span class="hljs-string">&quot;LookupError&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위 함수는 검색 패턴의 또 다른 예이지만 이전에는 볼 수 없었던 <code>error()</code>를 보여준다. <code>error()</code>는 정상적인 제어의 흐름을 방해하는 <code>ErrorException</code>을 생성하는데 사용된다. 이번 예시에서는 키가 존재하지 않음을 나타내는 <code>"LookupError"</code> 메시지가 표시된다.</p><p>루프의 마지막까지 작동된다면 값 <code>v</code>는 딕셔너리 안에 없는 것이기 때문에 오류 메시지를 전송하는 것이다.</p><p>역방향 조회를 성공한 예시는 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; h = histogram(<span class="hljs-string">&quot;parrot&quot;</span>);<br><br>julia&gt; key = reverselookup(h, <span class="hljs-number">2</span>)<br><span class="hljs-string">&#x27;r&#x27;</span>: ASCII/Unicode U+<span class="hljs-number">0072</span> (category Ll: Letter, lowercase)<br></code></pre></td></tr></table></figure><p>실패한 예시도 확인해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; key = reverselookup(h, <span class="hljs-number">3</span>)<br>ERROR: LookupError<br></code></pre></td></tr></table></figure><p>예외를 알려주는 형태는 줄리아가 예외를 알려주는 방식과 동일하다. 즉, 스택트레이스와 오류 메시지를 인쇄하는 것이다.</p><p>줄리아는 역방향 조회를 수행하는 최적화된 방법인 <code>findall(isequal(3), h)</code>을 제공한다.</p><p><strong>WARNING</strong> 역방향 조회는 순방향 조회보다 훨씬 느리다. 만약 이 방법을 자주 실행하거나 딕셔너리가 크다면, 프로그램이 성능이 저하된다.</p><h3 id="딕셔너리와-배열">딕셔너리와 배열</h3><p>배열은 딕셔너리에서 값들로 나타낼 수 있다. 예를 들어, 알파벳(키)이 몇 번 쓰였는지 나타낸 빈도(값)로 매핑되는 딕셔너리가 제공된 경우 이를 반대로도 매핑할 수 있다. 즉, 빈도에서 문자를 매핑한 딕셔너리를 만드는 것이다. 사용 빈도가 동일한 알파벳이 여러 개 있을 수 있으므로 반전된 딕셔너리의 각 값은 문자 배열이어야 한다.</p><p>아래의 함수는 딕셔너리를 뒤집어준다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> invertdict(d)<br>    inverse = <span class="hljs-built_in">Dict</span>()<br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> keys(d)<br>        val = d[key]<br>        <span class="hljs-keyword">if</span> val ∉ keys(inverse)<br>            inverse[val] = [key]<br>        <span class="hljs-keyword">else</span><br>            push!(inverse[val], key)<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    inverse<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>루프가 실행될 때마다 <code>keys</code>는 <code>d</code>에서 <code>key</code>를 얻고, <code>val</code>은 그 <code>key</code>와 매핑된 값을 얻는다. 만약에 <code>val</code>이 <code>inverse</code>에 없다면 아직 <code>val</code>과 겹치는 키가 없다는 의미이기 때문에 새 항목을 만들고 초기화한다. 그렇지 않다면 이미 동일한 키가 있는 것이기에 해당 키를 배열에 추가해준다.</p><p>예시는 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; hist = histogram(<span class="hljs-string">&quot;parrot&quot;</span>);<br><br>julia&gt; inverse = invertdict(hist)<br><span class="hljs-built_in">Dict</span>&#123;<span class="hljs-built_in">Any</span>,<span class="hljs-built_in">Any</span>&#125; with <span class="hljs-number">2</span> entries:<br>  <span class="hljs-number">2</span> =&gt; [<span class="hljs-string">&#x27;r&#x27;</span>]<br>  <span class="hljs-number">1</span> =&gt; [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>]<br></code></pre></td></tr></table></figure><figure><img src="/images/16.png" alt="state diagrams" /><figcaption aria-hidden="true">state diagrams</figcaption></figure><p>위의 상태 다이어그램은 <code>hist</code>와 <code>inverse</code>를 보여준다. 딕셔너리는 키-값 페어가 한 박스 안에서 보여진다. 따라서 만약 값이 정수이거나 소수, 문자열이라면 박스 안쪽에 그려야 한다. 하지만 배열의 경우에는 모두 분리된 박스로 그려야 한다. 위의 그림에서도 딕셔너리와 배열을 구분할 수 있다.</p><p><strong>Note</strong> 앞서 해시테이블을 사용하여 딕셔너리를 구현했으며, 키를 해시할 수 있어야 함을 언급했다. 해시는 값을 취하고 정수를 반환하는 함수이다. 딕셔너리는 이런 해시 함수의 원리를 사용하여 키-값 쌍을 저장하고 조회한다.</p><h3 id="메모">메모</h3><p>우리는 <a href="https://dev-bearabbit.github.io/2020/03/03/ThinkJulia/Think-Julia-Chapter-6/">5장 연습해보기</a>에서 피보나치 함수에 대해 살펴보았다. 위의 피보나치 함수는 인수가 클수록 함수를 실행하는 데 시간이 오래 걸린다는 걸 알 수 있다. 더욱이 런타임도 빠르게 증가한다.</p><p>왜 그런지 이해하기 위해 피보나치의 n값이 4일 때의 콜 그래프(Call graph)를 확인해보자.</p><figure><img src="/images/17.png" alt="call graph" /><figcaption aria-hidden="true">call graph</figcaption></figure><p>콜 그래프는 함수가 호출하는 흐름을 화살표로 보여준다. 그래프 맨 위에서 <code>n = 4</code>인 피보나치가 <code>n = 3</code>, <code>n = 2</code>인 피보나치를 호출한다. 그 후 <code>n = 3</code>인 피보나치가 <code>n = 2</code>와 <code>n = 1</code>인 피보나치를 호출한다. 이런 흐름이 계속된다.</p><p>결국 <code>fibonacci(0)</code>과 <code>fibonacci(1)</code>가 몇 번 호출되는지 계산한다. 이것은 문제에 대한 비효율적인 해결방법이며, 인수인 <code>n</code>이 커질수록 상황은 더욱 악화된다.</p><p>한 가지 해결책은 딕셔너리에 저장하여 이미 계산된 값을 추적하는 것이다. 나중에 사용하기 위해 이전에 계산된 값을 메모라고 한다. 피보나치의 메모가 추가된 버전은 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Julia">known = <span class="hljs-built_in">Dict</span>(<span class="hljs-number">0</span>=&gt;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>=&gt;<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">function</span> fibonacci(n)<br>    <span class="hljs-keyword">if</span> n ∈ keys(known)<br>        <span class="hljs-keyword">return</span> known[n]<br>    <span class="hljs-keyword">end</span><br>    res = fibonacci(n-<span class="hljs-number">1</span>) + fibonacci(n-<span class="hljs-number">2</span>)<br>    known[n] = res<br>    res<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>known</code>은 이미 사용된 피보나치 숫자들을 저장하는 딕셔너리이다. 두 개의 항목으로 시작하며, <code>0</code>은 <code>0</code>에 매핑되고 <code>1</code>은 <code>1</code>에 매핑된다.</p><p><code>fibonacci()</code>를 호출할 때마다 <code>known</code>을 확인한다. 만약 해당 결과가 이미 <code>known</code>에 있다면 즉시 결과를 출력한다. 결과가 없다면 새로운 값을 계산하여 딕셔너리에 추가한 후 결과를 출력한다.</p><p>메모가 추가된 <code>fibonacci()</code>와 원래 <code>fibonacci()</code>를 비교해보면, 무엇이 더 빠른지 확인할 수 있다.</p><h3 id="글로벌-변수들">글로벌 변수들</h3><p>이전의 예시에서 <code>known</code>은 함수 밖에서 만들어졌기 때문에 <code>Main</code>이라는 특별한 프레임에 속한다. <code>Main</code>의 변수는 가끔 글로벌(global)이라고 불리는데, 그 이유는 그들이 어떤 함수에서 엑세스 할 수 있기 때문이다. 함수 작동이 멈추면 사라지는 로컬(local) 변수들과 달리, 글로벌 변수는 계속 유지된다.</p><p>플래그(flags)에 글로벌 변수를 사용하는 것은 일반적이다. 즉, 조건이 참인지 여부를 나타내는 불 변수이다. 예를 들어, 몇몇의 프로그램은 출력 세부 사항의 수준을 제어하기 위해서 <code>verbose</code>라는 플래그를 사용한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia">verbose = <span class="hljs-literal">true</span><br><br><span class="hljs-keyword">function</span> example1()<br>    <span class="hljs-keyword">if</span> verbose<br>        println(<span class="hljs-string">&quot;Running example1&quot;</span>)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>글로벌 변수를 재할당하려 하면 놀랄 수 있다. 다음 예제를 확인해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">been_called = <span class="hljs-literal">false</span><br><br><span class="hljs-keyword">function</span> example2()<br>    been_called = <span class="hljs-literal">true</span>         <span class="hljs-comment"># WRONG</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 함수를 작동해도 <code>been_called</code>의 값은 변하지 않는다. 그 이유는 <code>example2()</code>가 <code>been_called</code>라는 새로운 로컬 변수를 작성하기 때문이다. 함수가 끝나면 로컬 변수는 사라지고 글로벌 변수에는 영향을 미치지 않는다.</p><p>글로벌 변수를 함수 안에서 재할당하려면 먼저 변수 앞에 <code>global</code>을 써서 선언해야 한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">been_called = <span class="hljs-literal">false</span><br><br><span class="hljs-keyword">function</span> example2()<br>    <span class="hljs-keyword">global</span> been_called<br>    been_called = <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>글로벌 명령문은 인터프리터에게 이렇게 말하는 것과 같다. "이 함수에서 사용되는 <code>been_called</code>는 글로벌 변수를 말하는 것이다. 그러니 로컬 변수를 만들지 말아라"</p><p>여기 글로벌 변수를 업데이트하려고 시도하는 예시가 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">count = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">function</span> example3()<br>    count = count + <span class="hljs-number">1</span>          <span class="hljs-comment"># WRONG</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 예시를 실행하면 아래와 같은 오류 메시지가 출력된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; example3()<br>ERROR: <span class="hljs-built_in">UndefVarError</span>: count not defined<br></code></pre></td></tr></table></figure><p>줄리아는 <code>count</code>를 로컬 변수로 가정했기 때문에 문제가 발생한 것이다. 따라서 해결책은 <code>count</code>를 글로벌 변수로 선언하는 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">count = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">function</span> example3()<br>    <span class="hljs-keyword">global</span> count<br>    count += <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>만약 글로벌 함수가 변경 가능한 값으로 제공되면, <code>global</code> 선언 없이 수정할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">known = <span class="hljs-built_in">Dict</span>(<span class="hljs-number">0</span>=&gt;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>=&gt;<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">function</span> example4()<br>    known[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>글로벌 배열이나 딕셔너리의 요소들도 추가하거나 삭제, 대체 등을 할 수 있지만, 변수를 재할당하는 것은 <code>global</code>을 선언해야 한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">known = <span class="hljs-built_in">Dict</span>(<span class="hljs-number">0</span>=&gt;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>=&gt;<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">function</span> example5()<br>    <span class="hljs-keyword">global</span> known<br>    known = <span class="hljs-built_in">Dict</span>()<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>성능상의 이유로 글로벌 변수는 <code>const</code>를 선언해야 한다. 더이상 변수를 재할당 할 수는 없지만 변경 가능한 값들 한해서는 값을 수정할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">const</span> known = <span class="hljs-built_in">Dict</span>(<span class="hljs-number">0</span>=&gt;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>=&gt;<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">function</span> example4()<br>    known[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><strong>WARNING</strong> 글로벌 변수는 유용하지만, 글로벌 변수가 너무 많고 자주 수정하면 프로그램을 디버그하는데 힘들고 성능도 저하될 수 있다.</p><h3 id="디버깅">디버깅</h3><p>큰 데이터셋으로 작업할 때, 직접 다 출력하여 확인하는 방식으로는 디버그하기 어려울 수 있다. 다음은 큰 데이터셋을 디버그하기 위한 몇 가지의 제안이다.</p><ul><li><p>입력을 축소해라 가능하다면, 데이터셋의 크기를 줄여라. 예를 들어 프로그램이 텍스트 파일을 읽은 경우 처음 10행으로 시작하는 등의 가장 작은 예를 사용하여 오류를 찾을 수 있다. 파일 자체를 편집하는 것보다 프로그램을 수정하여 첫 번째 'n'라인만 읽을 수 있도록 수정하는 것이 낫다.</p></li><li><p>요약 및 데이터 타입을 확인하라 전체 테이터셋을 인쇄하고 확인하는 대신 데이터의 요약을 인쇄해라. (예로 딕셔너리에 있는 아이템 수나 배열의 숫자 등) 런타임 오류의 일반적인 원인은 올바르지 못한 데이터 타입의 값 때문이다. 이런 종류의 오류를 디버깅하기 위해선 값 데이터 타입을 출력해보는 것만으로도 충분하다.</p></li><li><p>자가 점검을 작성하라 때로는 오류를 자동으로 확인하는 코드를 작성할 수 있다. 예를 들어 숫자 배열의 평균을 계산하는 경우 결과가 배열에서 가장 큰 요소보다 크지 않거나 가장 작은 요소보다 작지 않은지 확인할 수 있다. 이것을 분별 검사(sanity check)라고 한다. 다른 종류의 검사는 서로 다은 두 가지 계산 결과를 비교하여 일치하는지 확인한다. 이것을 일관성 검사(consistency check)라고 한다.</p></li><li><p>출력을 형식화해라 디버깅 출력 형식을 지정하면 오류를 더 쉽게 발견할 수 있다. 출력 형식을 지정하는 것을 스캐폴딩이라고 하며, 이에 대한 자세한 설명은 <a href="https://dev-bearabbit.github.io/2020/03/03/ThinkJulia/Think-Julia-Chapter-6/">해당 페이지</a> 디버깅 파트에 있다. 다시 말하지만 스캐폴딩을 구축하는 데 소요되는 시간은 디버깅에 낭비되는 시간을 줄일 수 있다.</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>think julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>줄리아</tag>
      
      <tag>Julia</tag>
      
      <tag>Think Julia</tag>
      
      <tag>기초 강의</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[9/20] 배열</title>
    <link href="/ko/ThinkJulia/Think-Julia-Chapter-9/"/>
    <url>/ko/ThinkJulia/Think-Julia-Chapter-9/</url>
    
    <content type="html"><![CDATA[<blockquote><p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p></blockquote><p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap10">Arrays</a>를 한글로 요약 정리한 글입니다. <span id="more"></span></p><h2 id="배열-arrays">배열 (Arrays)</h2><p>이번 장에서는 줄리아에서 가장 유용한 데이터 타입인 배열(Arrays)을 살펴볼 것이다. 또한 한 객체에 둘 이상의 이름이 있을 때 발생할 수 있는 작업에 대해서도 알아볼 것이다.</p><h3 id="배열은-시퀀스이다">배열은 시퀀스이다</h3><p>문자열처럼 배열은 일련의 값들이다. 문자열에서는 값들이 모두 문자이지만, 배열에서는 어떤 데이터 타입이든 값이 될 수 있다. 배열에서 값은 요소(element or item)라고 한다.</p><p>배열을 만드는 몇 가지의 방법이 있다. 가장 간단한 방법은 대괄호<code>[]</code>로 요소들을 묶는 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">[<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>]<br>[<span class="hljs-string">&quot;crunchy frog&quot;</span>, <span class="hljs-string">&quot;ram bladder&quot;</span>, <span class="hljs-string">&quot;lark vomit&quot;</span>]<br></code></pre></td></tr></table></figure><p>위의 첫 번째 예시는 4개의 정수들을 요소로 한 배열이며, 두 번째는 3개의 문자열들을 요소로 한 배열이이다. 배열의 요소들이 모두 동일한 타입일 필요는 없다. 아래의 배열은 문자열과 소수, 정수, 그리고 또 다른 배열이 요소로 구성되어 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">[<span class="hljs-string">&quot;spam&quot;</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">5</span>, [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>]]<br></code></pre></td></tr></table></figure><p>위의 예시처럼 배열은 다른 배열을 <strong>중첩</strong>하여 포함할 수 있다.</p><p>요소들을 포함하지 않은 배열은 빈 배열(empty array)이라고 부른다. 빈 배열은 대괄호<code>[]</code>만 입력해서 만들 수 있다.</p><p>예상했겠지만, 배열들은 변수의 값으로 사용할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; cheeses = [<span class="hljs-string">&quot;Cheddar&quot;</span>, <span class="hljs-string">&quot;Edam&quot;</span>, <span class="hljs-string">&quot;Gouda&quot;</span>];<br><br>julia&gt; numbers = [<span class="hljs-number">42</span>, <span class="hljs-number">123</span>];<br><br>julia&gt; empty = [];<br><br>julia&gt; print(cheeses, <span class="hljs-string">&quot; &quot;</span>, numbers, <span class="hljs-string">&quot; &quot;</span>, empty)<br>[<span class="hljs-string">&quot;Cheddar&quot;</span>, <span class="hljs-string">&quot;Edam&quot;</span>, <span class="hljs-string">&quot;Gouda&quot;</span>] [<span class="hljs-number">42</span>, <span class="hljs-number">123</span>] <span class="hljs-built_in">Any</span>[]<br></code></pre></td></tr></table></figure><p><code>typeof()</code>는 배열의 종류를 찾는 데 사용된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; typeof(cheeses)<br><span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">String</span>,<span class="hljs-number">1</span>&#125;<br>julia&gt; typeof(numbers)<br><span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Int64</span>,<span class="hljs-number">1</span>&#125;<br>julia&gt; typeof(empty)<br><span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Any</span>,<span class="hljs-number">1</span>&#125;<br></code></pre></td></tr></table></figure><p>배열의 종류는 중괄호로 표시되어 출력되며, 앞에는 요소들의 데이터 타입을 보여준다. 뒤에 나오는 숫자의 의미는 배열의 차원이다. 또한 빈 배열은 <code>Any</code>라는 데이터 타입을 가지고 있다. 즉, 모든 값들은 데이터 타입을 가질 수 있는 것이다.</p><h3 id="배열은-변할-수-있다">배열은 변할 수 있다</h3><p>배열의 요소에 접근하는 문법은 문자열에서 문자에 접근하는 문법과 동일하게 <code>[]</code>를 사용한다. 표현식은 <code>[]</code>에 특정 인덱스를 넣어서 호출한다. 인덱스는 1부터 시작한다는 것을 기억해라</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; cheeses[<span class="hljs-number">1</span>]<br><span class="hljs-string">&quot;Cheddar&quot;</span><br></code></pre></td></tr></table></figure><p>문자열과 같이 배열들 또한 변할 수 있다. 대괄호 연산자가 할당문 왼쪽에 쓰인다면, 대괄호가 지정한 인덱스에 해당하는 배열 요소의 값이 할당된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; print(numbers)<br>[<span class="hljs-number">42</span>,<span class="hljs-number">123</span>]<br>julia&gt; numbers[<span class="hljs-number">2</span>] = <span class="hljs-number">5</span><br><span class="hljs-number">5</span><br>julia&gt; print(numbers)<br>[<span class="hljs-number">42</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>위의 코드에서는 배열의 두 번째 값이 5로 재할당되었다.</p><p>배열 인덱스들은 문자열 인덱스들과 같은 방식으로 작동한다.</p><ul><li>어떤 정수 표현식이나 인덱스로 사용할 수 있다.</li><li>만약 존재하지 않는 요소를 읽거나 사용하려고 한다면, <code>BoundsError</code>가 발생한다.</li><li>키워드 <code>end</code>는 배열의 마지막 인덱스를 가져온다.</li></ul><p><code>∈</code> 연산자 또한 배열에서 작동한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-string">&quot;Edam&quot;</span> ∈ cheeses<br><span class="hljs-literal">true</span><br>julia&gt; <span class="hljs-string">&quot;Brie&quot;</span> <span class="hljs-keyword">in</span> cheeses<br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="배열-순회-traversing-an-array">배열 순회 (Traversing an Array)</h3><p>배열 요소들을 순회하는 가장 보편적인 방법은 <code>for</code>루프를 사용하는 것이다. 문법은 문자열과 동일하다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">for</span> cheese <span class="hljs-keyword">in</span> cheeses<br>    println(cheese)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>오로지 배열 요소들을 읽기만 하는 것은 위의 코드로 충분하다. 그러나 만약 요소를 다시 쓰거나 업데이트하기를 원한다면, 인덱스가 필요하다. 이를 해결하는 가장 일반적인 방법은 내장 함수인 <code>eachindex()</code>를 사용하는 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> eachindex(numbers)<br>    numbers[i] = numbers[i] * <span class="hljs-number">2</span> <span class="hljs-comment"># 기존 요소들에 2를 곱해주는 표현식</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 루프는 배열을 순회하여 요소들을 업데이트한다. <code>length()</code>는 배열에서 요소들의 길이를 반환한다. 루프가 한 번씩 작동할 때마다 <code>i</code>는 다음 요소의 인덱스로 갱신된다. 본문에서의 할당문은 <code>i</code>를 사용하여 요소의 이전 값을 가져온 후 새로운 값으로 재할당한다.</p><p>아래의 <code>for</code>루프는 절대 본문이 실행되지 않는다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> []<br>    println(<span class="hljs-string">&quot;This can never happens.&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>한 배열이 다른 배열을 포함하고 있을 때, 내부의 중첩 배열은 하나의 요소로 인식된다. 따라서 아래의 배열은 길이가 4이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">[<span class="hljs-string">&quot;spam&quot;</span>, <span class="hljs-number">1</span>, [<span class="hljs-string">&quot;Brie&quot;</span>, <span class="hljs-string">&quot;Roquefort&quot;</span>, <span class="hljs-string">&quot;Camembert&quot;</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]]<br></code></pre></td></tr></table></figure><h3 id="배열-슬라이스-array-slices">배열 슬라이스 (Array Slices)</h3><p>슬라이스 연산자 또한 배열에서 작동한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>];<br>julia&gt; print(t[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>])<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br>julia&gt; print(t[<span class="hljs-number">3</span>:<span class="hljs-keyword">end</span>])<br>[<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>]<br></code></pre></td></tr></table></figure><p>슬라이스 연산자인 <code>[:]</code>는 전체 배열의 복사본을 가져온다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; print(t[:])<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>]<br></code></pre></td></tr></table></figure><p>배열은 가변적이기 때문에, 배열을 변경하기 전에 복사본을 만드는 방법은 종종 유용하게 사용된다.</p><p>변수 왼쪽에 사용된 슬라이스 연산자는 여러 개의 요소를 업데이트할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t[<span class="hljs-number">2</span>:<span class="hljs-number">3</span>] = [<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>];<br><br>julia&gt; print(t)<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>]<br></code></pre></td></tr></table></figure><h3 id="배열-라이브러리">배열 라이브러리</h3><p>줄리아는 배열에서 작동하는 함수들을 제공한다. 예를 들어, <code>push!()</code>는 배열 끝에 새로운 요소를 추가한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br>julia&gt; push!(t, <span class="hljs-string">&#x27;d&#x27;</span>);<br><br>julia&gt; print(t)<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>]<br></code></pre></td></tr></table></figure><p><code>append!()</code>는 첫 번째 인수 배열 끝에 두 번째 인수인 배열을 추가한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t1 = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br>julia&gt; t2 = [<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>];<br><br>julia&gt; append!(t1, t2);<br><br>julia&gt; print(t1)<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>]<br></code></pre></td></tr></table></figure><p>위의 예시에서 <code>t2</code>는 수정되지 않은 채로 유지된다.</p><p><code>sort!()</code>는 낮은 단위에서 높은 단위 순으로 배열 요소들을 정리한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t = [<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>];<br><br>julia&gt; sort!(t);<br><br>julia&gt; print(t)<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>]<br></code></pre></td></tr></table></figure><p><code>sort()</code>는 배열 요소들을 순서에 맞게 정리한 복사본을 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t1 = [<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>];<br><br>julia&gt; t2 = sort(t1);<br><br>julia&gt; print(t1)<br>[<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>]<br>julia&gt; print(t2)<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>]<br></code></pre></td></tr></table></figure><p><code>sort()</code>와 <code>sort!()</code>의 차이점은 배열이 영구적으로 변하는지에 있다. 쉽게 이야기하면, <code>sort!()</code>를 사용하면 배열의 순서가 영구적으로 변하지만, <code>sort()</code>를 사용하면 기존 배열은 변하지 않고 순서가 변경된 배열만 보여준다.</p><p><strong>Note</strong> 줄리아에서 사용되는 <code>!</code>는 인수를 변경하기 위한 함수 뒤에 추가한다.</p><h3 id="맵-필터-그리고-리듀스-map-filter-and-reduce">맵, 필터 그리고 리듀스 (Map, Filter and Reduce)</h3><p>배열에 모든 숫자들을 더하기 위해서는 아래의 루프를 사용하면 된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> addall(t)<br>    total = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> t<br>        total += x<br>    <span class="hljs-keyword">end</span><br>    total<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>total</code>은 0으로 시작한다. 각 루프가 실행될 때마다 <code>+=</code>는 배열로부터 한 개의 요소를 얻는다. <code>+=</code> 연산자는 변수를 업데이트하는 간단한 방법을 제공한다. 아래의 코드는 '증강 할당문(augmented assignment statement)'이며,</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">total += x<br></code></pre></td></tr></table></figure><p>위의 코드는 아래의 코드와 같은 의미이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">total = total + x<br></code></pre></td></tr></table></figure><p>루프가 실행될 때, <code>total</code>은 요소들의 합을 누적한다. 이런 방식으로 사용되는 변수를 '누적 계산기(accumulator)'라고 부른다.</p><p>배열 요소를 합산하는 것은 줄리아가 제공하는 내장 함수인 <code>sum()</code>을 사용하면 된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><br>julia&gt; sum(t)<br><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>시퀀스로 연결되어 있는 요소들을 하나의 요소로 결합하는 작업을 리듀스 작업(reduce operation)이라고 한다.</p><p>다른 배열을 만들기 위해서 한 배열을 순회하는 경우도 있다. 예를 들어, 아래의 함수는 기존 문자열들의 대문자를 반환하여 새로운 배열을 만든다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> capitalizeall(t)<br>    res = []<br>    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> t<br>        push!(res, uppercase(s))<br>    <span class="hljs-keyword">end</span><br>    res<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>res</code>는 빈 배열을 만든다. 루프가 매번 실행될 때마다, <code>res</code>에 요소들을 추가한다. 따라서 <code>res</code>도 누적 계산기로 봐도 상관없다.</p><p><code>capitalizeall()</code>와 같은 작동방식은 가끔 <strong>맵(map)</strong>이라고 불린다. 왜냐하면 <code>uppercase()</code>처럼 순서대로 각 요소를 찾아 매핑(mapping)하는 함수가 있기 때문이다.</p><p>또다른 일반적인 작동방식은 배열에서 일부 요소를 선택하여 '하위 배열(subarray)'을 반환하는 것이다. 예를 들어 아래의 함수는 문자열 배열을 가져와서 대문자만 포함하는 하위 배열을 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> onlyupper(t)<br>    res = []<br>    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> t<br>        <span class="hljs-keyword">if</span> s == uppercase(s)<br>            push!(res, s)<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    res<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 예시처럼 조건에 적합한 요소만을 선택하여 가져오는 <code>onlyupper()</code>과 같은 작동방식을 필터(filter)라고 한다.</p><p>가장 일반적인 배열 작동방식은 맵, 필터, 리듀스의 결합으로서 표현된다.</p><h3 id="도트-문법dot-syntax">도트 문법(Dot Syntax)</h3><p><code>^</code>와 같은 모든 이항 연산자(binary operator)에는 대응하는 도트 연산자가 있다. 아래의 코드는 요소마다 <code>^</code>연산자가 자동으로 실행되도록 정의하였다. <code>[1, 2, 3] .^ 3</code>는 자체적으로 정의되지 않았지만, 컴퓨터는 뒤의 <code>.^ 3</code>가 앞의<code>[1, 2, 3]</code>에 각각 적용되어 <code>[1^3, 2^3, 3^3]</code>의 결과를 도출한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; print([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] .^ <span class="hljs-number">3</span>)<br>[<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">27</span>]<br></code></pre></td></tr></table></figure><p>모든 줄리아 함수는 어떤 배열에서든 도트 문법을 사용하여 요소별로 적용할 수 있다 예를 들어, 문자열 배열을 루프를 사용하지 않고도 대문자로 표시할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t = uppercase.([<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>]);<br><br>julia&gt; print(t)<br>[<span class="hljs-string">&quot;ABC&quot;</span>, <span class="hljs-string">&quot;DEF&quot;</span>, <span class="hljs-string">&quot;GHI&quot;</span>]<br></code></pre></td></tr></table></figure><p>이것은 더 깔끔하게 맵을 만드는 방법이다. <code>capitalizeall()</code>를 한 줄로 구현할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> capitalizeall(t)<br>    uppercase.(t)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="요소-삭제와-삽입">요소 삭제와 삽입</h3><p>배열에서 요소를 삭제하는 방법은 여러 개가 있다. 만약 삭제하고 싶은 요소의 인덱스를 알고 있다면, <code>splice!()</code>를 사용하면 된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br>julia&gt; splice!(t, <span class="hljs-number">2</span>)<br><span class="hljs-string">&#x27;b&#x27;</span>: ASCII/Unicode U+<span class="hljs-number">0062</span> (category Ll: Letter, lowercase)<br>julia&gt; print(t)<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br></code></pre></td></tr></table></figure><p><code>splice!()</code>는 배열을 수정하고 해당 요소가 제거된 배열을 반환한다.</p><p><code>pop!()</code>은 마지막 요소를 제거한 후 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br>julia&gt; pop!(t)<br><span class="hljs-string">&#x27;c&#x27;</span>: ASCII/Unicode U+<span class="hljs-number">0063</span> (category Ll: Letter, lowercase)<br>julia&gt; print(t)<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]<br></code></pre></td></tr></table></figure><p><code>popfirst!()</code>은 첫 번째 요소를 제거한 후 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br>julia&gt; popfirst!(t)<br><span class="hljs-string">&#x27;a&#x27;</span>: ASCII/Unicode U+<span class="hljs-number">0061</span> (category Ll: Letter, lowercase)<br>julia&gt; print(t)<br>[<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br></code></pre></td></tr></table></figure><p><code>pushfirst!()</code>와 <code>push!()</code>는 배열의 시작과 끝에 각각 요소를 삽입한다.</p><p>만약 제거된 요소가 필요없다면, <code>deleteat!()</code>을 사용할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br>julia&gt; print(deleteat!(t, <span class="hljs-number">2</span>))<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br></code></pre></td></tr></table></figure><p><code>insert!()</code>는 주어진 인덱스에 요소를 삽입한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br>julia&gt; print(insert!(t, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;x&#x27;</span>))<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br></code></pre></td></tr></table></figure><h3 id="배열과-문자열">배열과 문자열</h3><p>문자열을 문자의 나열이고 배열은 값들의 나열이지만, 문자 배열과 문자열은 다르다. <code>collect()</code>를 사용하면 문자열에서 문자 배열로 변환할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t = collect(<span class="hljs-string">&quot;spam&quot;</span>);<br><br>julia&gt; print(t)<br>[<span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>]<br></code></pre></td></tr></table></figure><p><code>collect()</code>는 문자열을 깨고 문자들을 각각의 요소로 변경해준다.</p><p>만약 문장을 단어 단위로 쪼개고 싶다면, <code>split()</code>를 사용하면 된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t = split(<span class="hljs-string">&quot;pining for the fjords&quot;</span>);<br><br>julia&gt; print(t)<br><span class="hljs-built_in">SubString</span>&#123;<span class="hljs-built_in">String</span>&#125;[<span class="hljs-string">&quot;pining&quot;</span>, <span class="hljs-string">&quot;for&quot;</span>, <span class="hljs-string">&quot;the&quot;</span>, <span class="hljs-string">&quot;fjords&quot;</span>]<br></code></pre></td></tr></table></figure><p><code>split()</code>에서 구분 기호 등을 추가적 인수로 사용하면 구분 기호에 따라서 단어로 나눠준다. 아래의 예시는 하이픈(-)기호를 추가 인수로 사용하였다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t = split(<span class="hljs-string">&quot;spam-spam-spam&quot;</span>, <span class="hljs-string">&#x27;-&#x27;</span>);<br><br>julia&gt; print(t)<br><span class="hljs-built_in">SubString</span>&#123;<span class="hljs-built_in">String</span>&#125;[<span class="hljs-string">&quot;spam&quot;</span>, <span class="hljs-string">&quot;spam&quot;</span>, <span class="hljs-string">&quot;spam&quot;</span>]<br></code></pre></td></tr></table></figure><p><code>join()</code>은 <code>split()</code>의 반대이다. 단어들 사이에 구분자를 넣고 싶다면 <code>join()</code>을 사용하면 된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t = [<span class="hljs-string">&quot;pining&quot;</span>, <span class="hljs-string">&quot;for&quot;</span>, <span class="hljs-string">&quot;the&quot;</span>, <span class="hljs-string">&quot;fjords&quot;</span>];<br><br>julia&gt; s = join(t, <span class="hljs-string">&#x27; &#x27;</span>)<br><span class="hljs-string">&quot;pining for the fjords&quot;</span><br></code></pre></td></tr></table></figure><p>위의 예시에서는 구분 기호로 공백을 사용하였다. 만약 공백 없이 단어를 연결하고 싶다면 구분 기호를 인수로 추가하지 않으면 된다.</p><h3 id="객체와-값">객체와 값</h3><p>객체(object)는 변수가 참고할 수 있는 어떤 것이다. 지금까지는 객체와 값을 동일시하여 사용할 수 있었다.</p><p>아래의 할당문을 실행해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">a = <span class="hljs-string">&quot;banana&quot;</span><br>b = <span class="hljs-string">&quot;banana&quot;</span><br></code></pre></td></tr></table></figure><p>위의 예시는 <code>a</code>와 <code>b</code>가 동일한 문자열을 가지고 있다는 것을 보여준다. 하지만 컴퓨터도 동일한 문자열로 인식하는지, 아니면 각각 다른 문자열로 인식하는지는 알 수 없다.</p><figure><img src="/images/chap_9.png" alt="state diagrams" /><figcaption aria-hidden="true">state diagrams</figcaption></figure><p>첫 번째의 경우는 동일한 값의 다른 객체를 <code>a</code>와 <code>b</code>가 가지고 있는 경우이며, 두 번째는 <code>a</code>와 <code>b</code>가 동일한 객체를 가지고 있는 경우이다.</p><p>두 변수가 동일한 객체를 가지고 있는지 확인하려면, <code>===</code> 또는 <code>≡</code>(<code>\equiv TAB</code>)연산자를 사용하면 된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; a = <span class="hljs-string">&quot;banana&quot;</span><br><span class="hljs-string">&quot;banana&quot;</span><br>julia&gt; b = <span class="hljs-string">&quot;banana&quot;</span><br><span class="hljs-string">&quot;banana&quot;</span><br>julia&gt; a ≡ b<br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>해당 예시에서는 줄리아가 오로지 하나의 문자열 객체를 만들었다. 하지만 배열의 경우에는 각각의 배열 객체들이 생성된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br>julia&gt; b = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br>julia&gt; a == b<br><span class="hljs-literal">true</span><br><br>julia&gt; a ≡ b<br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><code>==</code> 연산자는 불 연산자로 두 변수의 값이 같은지의 여부를 <code>ture</code> 또는 <code>false</code>로 반환한다. 위의 예시를 보면 <code>a</code>와 <code>b</code>의 값은 같기 때문에 <code>==</code> 연산자의 결과는 <code>ture</code>를 반환하지만, 객체가 동일한지 판단하는 <code>===</code> 연산자의 결과는 <code>false</code>를 반환한다.</p><figure><img src="/images/13.png" alt="state diagrams" /><figcaption aria-hidden="true">state diagrams</figcaption></figure><p>위의 예시에서 두 배열은 동일한 요소들을 가지고 있기 때문에 두 객체가 같다(same)고 설명할 수 있지만, 두 객체가 동일(identical)하다고 말할 수는 없다. 즉, 두 객체가 동일하다면 같다고 말할 수 있지만, 두 객체가 같다고 해서 동일하다고 할 수는 없다.</p><p>정확하게 설명하면 객체는 값을 가지고 있다. 예로 <code>[1,2,3]</code>는 값이 정수 시퀀스인 배열 객체를 얻는다. 만약 다른 배열에 동일한 요소가 있다면, 값은 같지만 동일한 객체라고 가정하지는 않는다.</p><h3 id="에일리어싱-aliasing">에일리어싱 (Aliasing)</h3><p>객체를 가진<code>a</code>로 <code>b=a</code>를 통해 <code>b</code>를 할당한다면, 두 변수는 같은 객체를 가진다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br>julia&gt; b = a;<br><br>julia&gt; b ≡ a<br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><figure><img src="/images/14.png" alt="state diagrams" /><figcaption aria-hidden="true">state diagrams</figcaption></figure><p>변수와 객체와의 연관성을 레퍼런스(reference)라고 한다. 이 예에서는 동일한 객체에 대한 두 개의 레퍼런스가 있다.</p><p>한 개 이상의 레퍼런스를 가진 객체는 둘 이상의 이름을 가지게 되므로 그 객체는 에일리어싱되었다고 설명한다.</p><p>에일리어싱된 객체의 값이 변하는 경우, 그 변화는 연결된 변수들에게도 적용된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; b = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>julia&gt; b[<span class="hljs-number">1</span>] = <span class="hljs-number">42</span><br><span class="hljs-number">42</span><br>julia&gt; print(a)<br>[<span class="hljs-number">42</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p><strong>WARNING</strong> 위의 방식은 유용하게 사용되지만, 동시에 오류가 발생하기 쉽다. 일반적으로 변경 가능한 객체로 작업할 때에는 에일리어싱을 피하는 것이 더 안전하다.</p><p>문자열과 같이 변경 불가능한 객체의 경우에는 에일리어싱이 큰 문제가 되지 않는다. 아래의 예시를 보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">a = <span class="hljs-string">&quot;banana&quot;</span><br>b = <span class="hljs-string">&quot;banana&quot;</span><br></code></pre></td></tr></table></figure><p>위의 예사에서는 <code>a</code>와 <code>b</code>가 동일한 객체를 가지는지 아닌지에 대한 여부는 큰 차이가 없다는 것을 볼 수 있다.</p><h3 id="배열-인수">배열 인수</h3><p>배열을 함수에 전달하면, 함수는 배열을 참조한다. 그래서 함수가 배열을 수정하면 사용자에게 변경된 내용이 표시된다. 예를 들어 <code>deletehead!()</code>를 사용하여 첫 번째 요소를 삭제해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> deletehead!(t)<br>    popfirst!(t)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>실행 흐름을 확인해보면 인수로 입력된 배열을 가져와서 <code>popfirst!()</code>로 첫 번째 요소를 삭제한다. <code>!</code>가 입력된 함수는 기존의 배열을 수정한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; letters = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br>julia&gt; deletehead!(letters);<br><br>julia&gt; print(letters)<br>[<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br></code></pre></td></tr></table></figure><p>매개변수 <code>t</code>와 변수 <code>letters</code>는 객체의 에일리어스이다. 아래의 그림에서 확인해보자.</p><figure><img src="/images/15.png" alt="state diagrams" /><figcaption aria-hidden="true">state diagrams</figcaption></figure><p>배열을 수정하는 작업과 새 배열을 만드는 작업을 구분하는 것은 매우 중요하다. 예를들어 <code>push!()</code>는 배열을 수정하지만 <code>vcat()</code>은 새로운 배열을 만든다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><br>julia&gt; t2 = push!(t1, <span class="hljs-number">3</span>);<br><br>julia&gt; print(t1)<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p><code>t2</code>는 <code>t1</code>의 에일리어스이다.</p><p>아래의 코드는 <code>vcat()</code>의 예시이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">jjulia&gt; t3 = vcat(t1, [<span class="hljs-number">4</span>]);<br><br>julia&gt; print(t1)<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>julia&gt; print(t3)<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p><code>vcat()</code>은 <code>t3</code>라는 새로운 배열을 만들었으며, <code>t1</code>은 변하지 않았다.</p><p>이런 차이점은 배열을 수정해야 하는 함수를 작성할 때 매우 중요하다.</p><p>예를 들어, 아래의 함수는 배열의 앞부분(head)을 삭제하지 않는다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> baddeletehead(t)<br>    t = t[<span class="hljs-number">2</span>:<span class="hljs-keyword">end</span>]                <span class="hljs-comment"># WRONG!</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>슬라이스 연산자는 새 배열을 만들고 할당 연산자는 해당 배열을 참조하여 새 배열의 값을 정한다. 하지만 이것들은 호출된 배열에 영향을 주지는 않는다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t4 = baddeletehead(t3);<br><br>julia&gt; print(t3)<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>julia&gt; print(t4)<br>[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p><code>baddeletehead()</code>의 시작부분에서 <code>t4</code>와 <code>t3</code>는 동일한 배열을 나타낸다. 마지막에는 <code>t4</code>는 새 배열을 나타내지만 <code>t3</code>는 이전 배열을 그대로 유지하고 있다.</p><p>대안은 새로운 배열을 생성하고 반환하는 함수를 작성하는 것이다. 예를 들어 <code>tail()</code>은 배열의 첫 번째 요소를 제외한 모든 요소를 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> tail(t)<br>    t[<span class="hljs-number">2</span>:<span class="hljs-keyword">end</span>]<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 함수는 기존의 배열을 수정하지 않은 채로 유지한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; letters = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br>julia&gt; rest = tail(letters);<br><br>julia&gt; print(rest)<br>[<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br></code></pre></td></tr></table></figure><h3 id="디버깅">디버깅</h3><p>배열 및 기타 변경 가능한 객체 등을 주의해서 사용하지 않으면 오랜 시간 디버깅 할 수 있다. 일반적인 함정을 피하는 방법은 아래와 같다.</p><ul><li>대부분의 배열 함수들은 인수를 수정한다. 이는 문자열 함수가 기존 문자열을 그대로 두고 새로운 문자열을 반환하는 것과 정확히 반대이다.</li></ul><p>문자열 코드를 작성하는 데 익숙한 경우에는</p><p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">new_word = strip(word)<br></code></pre></td></tr></table></figure></p><p>다음과 같이 배열 코드도 작성하려고 한다.</p><p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">t2 = sort!(t1)<br></code></pre></td></tr></table></figure></p><p><code>sort!()</code>은 수정된 원래 <code>t1</code>을 반환하고 <code>t2</code>는 <code>t1</code>의 에일리언스이다. 즉, <code>sort!()</code>를 사용할 때는 원본이 수정되기 때문에 새로 할당할 필요가 없다는 것이다.</p><p><strong>Tip</strong> 배열 함수와 연산자를 사용하기 전에 설명서를 주의해서 읽고 대화식 모드에서 테스트를 해보는 것이 좋다.</p><ul><li>관용구를 선택해서 붙여라 배열과 관련된 문제 중 하나는 작업을 수행하는 방법이 너무 많다는 것이다. 예를 들어 배열에서 요소를 제거하려면 <code>pop!</code>, <code>popfirst!</code>, <code>delete_at</code> 또는 슬라이스 할당을 사용할 수도 있다. 요소를 추가하는 것은 <code>push!</code>, <code>pushfirst!</code>, <code>insert!</code> 또는 <code>vcat</code>을 사용한다. <code>t</code>가 배열이고 <code>x</code>가 배열 요소라고 가정하여 배열에 추가한다면 아래의 코드와 같다.</li></ul><p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia">insert!(t, <span class="hljs-number">4</span>, x)<br>push!(t, x)<br>append!(t, [x])<br></code></pre></td></tr></table></figure></p><p>그리고 아래는 올바르지 못한 코드이다.</p><p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia">insert!(t, <span class="hljs-number">4</span>, [x])         <span class="hljs-comment"># WRONG!</span><br>push!(t, [x])              <span class="hljs-comment"># WRONG!</span><br>vcat(t, [x])               <span class="hljs-comment"># WRONG!</span><br></code></pre></td></tr></table></figure></p><ul><li>에일리언싱을 피하기 위해 복사본을 만들어라 <code>sort!</code>와 같은 함수를 사용하려면 인수를 수정하지만 원래 배열도 가지고 있어야 한다. 복사본을 만들어서 가지고 있는 것이 좋다.</li></ul><p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t = [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><br>julia&gt; t2 = t[:]; <span class="hljs-comment"># t2 = copy(t)</span><br><br>julia&gt; sort!(t2);<br><br>julia&gt; print(t)<br>[<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>julia&gt; print(t2)<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure></p><p>위의 예시에서는 내장 함수인 기존의 배열은 유지하며 새로운 배열로 반환하는 <code>sort</code>를 사용하는 것이 좋다.</p><p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; t2 = sort(t);<br><br>julia&gt; println(t)<br>[<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>julia&gt; println(t2)<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>think julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>줄리아</tag>
      
      <tag>Julia</tag>
      
      <tag>Think Julia</tag>
      
      <tag>기초 강의</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo에 NexT 테마 적용하기</title>
    <link href="/ko/AboutHexo/about_hexo-1/"/>
    <url>/ko/AboutHexo/about_hexo-1/</url>
    
    <content type="html"><![CDATA[<p>Hexo 블로그를 만든 다음 NexT 테마를 적용하고자 합니다.</p><p>아직 블로그를 만들지 않았다면 <a href="https://dev-bearabbit.github.io/2020/02/27/AboutHexo/about_hexo-0/">이전 글</a>을 참고해주시기 바랍니다.</p><span id="more"></span><hr /><p>만들어진 블로그에 테마를 적용하는 방법은 간단하다.</p><ul><li><p>우선 <a href="https://github.com/theme-next/hexo-theme-next/releases">NexT</a> 사이트에 들어가서 원하는 버전의 소스 코드(source code)를 다운받는다. <strong>Tip</strong> 다운받을 수 있는 버전 중에서 가장 최신 버전을 다운받는 것이 좋다. 글 작성 시 사용된 버전은 오늘 자로 가장 최신버전인 <code>v7.7.2</code>이다.</p></li><li><p>다운받은 알집을 풀고 폴더 명을 <code>next</code>로 변경한다.</p></li><li><p>이름을 변경한 폴더를 hexo 블로그 폴더에 있는 <code>themes</code>폴더에 넣는다.</p></li><li><p>Hexo 블로그 폴더에서 <code>/_config.yml</code>를 오픈한다 (수정할 때는 visual studio code를 사용하였다.)</p></li><li><p>파일 내부에 <code>themes</code> 설정으로 들어가서 <code>next</code>로 변경하고 저장한다.</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Extensions</span><br><span class="hljs-comment">## Plugins: https://hexo.io/plugins/</span><br><span class="hljs-comment">## Themes: https://hexo.io/themes/</span><br>theme: next<br></code></pre></td></tr></table></figure><ul><li><code>NexT</code>는 4가지의 레이아웃 테마를 가지고 있다. <a href="https://github.com/theme-next/hexo-theme-next">이 링크</a>에서 4가지를 미리 볼 수 있다. 레이아웃을 결정했다면 <code>/_config.yml</code>에서 아래의 파트를 찾고, 해당 레이아웃 이름의 주석(#)을 풀면 된다. (원래 있던 코드에는 주석인 '#'을 달아야 한다)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#scheme: Muse</span><br><span class="hljs-comment">#scheme: Mist</span><br><span class="hljs-comment">#scheme: Pisces</span><br>scheme: Gemini<br></code></pre></td></tr></table></figure><ul><li>터미널에 아래의 코드를 입력해서 잘 적용되었는지 확인해보자. 아래의 코드를 입력하면 잘 적용되었는지 확인할 수 있는 임시 사이트를 열 수 있다.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo server<br><br>INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.<br></code></pre></td></tr></table></figure><ul><li>적용이 되었다면 아래의 코드를 입력해서 적용과 배포를 진행해보자.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate<br>hexo deploy<br></code></pre></td></tr></table></figure><p>이제 NexT 테마 적용이 완료되었다! 본인의 블로그에 들어가면 테마가 변경된 것을 확인할 수 있다.</p>]]></content>
    
    
    <categories>
      
      <category>etc.</category>
      
      <category>about hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Github</tag>
      
      <tag>blog</tag>
      
      <tag>헥소</tag>
      
      <tag>깃허브</tag>
      
      <tag>블로그</tag>
      
      <tag>NexT</tag>
      
      <tag>next</tag>
      
      <tag>테마</tag>
      
      <tag>themes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[8/20] 사례 연구: 워드 플레이</title>
    <link href="/ko/ThinkJulia/Think-Julia-Chapter-8/"/>
    <url>/ko/ThinkJulia/Think-Julia-Chapter-8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p></blockquote><p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap09">Case Study: Word Play</a>를 한글로 요약 정리한 글입니다. <span id="more"></span></p><h2 id="사례-연구-워드-플레이-case-study-word-play">사례 연구: 워드 플레이 (Case Study: Word Play)</h2><p>이번 장에서는 특정 속성을 가진 단어를 검색하여 단어 퍼즐을 해결하는 사례 연구를 할 것이다. 예를 들어, 영어로 된 가장 긴 회문(palindrome)을 찾아 알파벳순으로 글자가 나타나는 단어를 검색하는 것이다. 그리고 위의 방식을 축소할 수 있는 다른 프로그램들도 제시할 것이다.</p><h3 id="단어-리스트-불러오기">단어 리스트 불러오기</h3><p>위의 연구를 시작하기에 앞서 우리는 단어 리스트들이 필요하다. 웹에는 많은 단어 리스트들이 있지만, 우리는 그 중 Moby lexicon project에서 사용된 단어 리스트인 Grady Ward를 사용할 것이다. 이 리스트에는 총 113809개의 단어가 저장되어 있으며, 우리는 이 단어들을 전부 사용할 수 있다. 파일의 이름은 113809.of.fic이며, 다운로드는 <a href="https://github.com/BenLauwens/ThinkJulia.jl/blob/master/data/words.txt">이 링크</a>에서 할 수 있다.</p><p>줄리아로 텍스트 파일을 여는 방법은 다음과 같다. 우선 내장 함수인 <code>open()</code>에 인수로 텍스트 파일 이름을 넣어서 파일을 가져올 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; fin = open(<span class="hljs-string">&quot;words.txt&quot;</span>)<br><span class="hljs-built_in">IOStream</span>(&lt;file words.txt&gt;)<br></code></pre></td></tr></table></figure><p><strong>Tip</strong> 만약 위의 코드 실행 시 오류가 발생한다면, 대부분은 디렉토리 설정 오류일 것이다. 해결 방법은 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; pwd() <span class="hljs-comment"># 현재 디렉토리 확인</span><br>julia&gt; cd ($(pwd())/단어 리스트 파일 위치)<br>julia&gt; pwd() <span class="hljs-comment"># 다시 확인</span><br></code></pre></td></tr></table></figure><p><code>fin</code>은 입력에 사용되는 파일 스트림이며, 더 이상 필요하지 않은 경우에는 <code>close(fin)</code>으로 닫아야 한다.</p><p>줄리아는 <code>readline()</code>을 포함하여 몇 가지의 읽기 함수를 제공한다. <code>readline()</code>은 <code>NEWLINE</code>에 도달할 때까지 파일에서 문자를 읽고 결과를 문자열로 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; readline(fin)<br><span class="hljs-string">&quot;aa&quot;</span><br></code></pre></td></tr></table></figure><p>가져온 단어 리스트 중에 첫 번째 단어는 "aa"이며, 용암의 이름이다. 파일 스트림은 파일에서의 위치와 경로를 파악하고 있기 때문에 <code>readline()</code>을 한번 더 호출하면 다음 단어를 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; readline(fin)<br><span class="hljs-string">&quot;aah&quot;</span><br></code></pre></td></tr></table></figure><p>다음 단어는 "aah"이다. 좀 이상하지만 실제 있는 단어이다.</p><p>또한 <code>for</code>루프를 사용하여 파일 내부의 단어들을 모두 가져올 수 있다. 아래의 프로그램은 words.txt를 읽고 한 줄에 한 단어씩 출력한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> eachline(<span class="hljs-string">&quot;words.txt&quot;</span>)<br>    println(line)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="검색-search">검색 (Search)</h3><p>검색 패턴으로 해결할 수 있는 가장 간단한 예는 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> hasno_e(word)<br>    <span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> word<br>        <span class="hljs-keyword">if</span> letter == <span class="hljs-string">&#x27;e&#x27;</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>for</code>루프는 단어의 알파벳들을 순회한다. 알파벳 <code>e</code>를 찾으면 즉시 거짓을 반환하며, 그렇지 않다면 다음 알파벳으로 이동한다. 만약 단어에서 <code>e</code>를 못찾았다면 <code>true</code>를 반환하고 종료한다.</p><p><code>∉(\notin TAB)</code> 연산자를 사용하여 위의 코드를 더 간결하게 작성할 수 있다. 다만 위의 함수는 검색 패턴이 어떻게 작동하는지 확인하기 위해서 먼저 살펴본 것이다.</p><p><code>avoids()</code>는 <code>hasno_e()</code>를 일반화시킨 함수이며, 안의 구조는 똑같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> avoids(word, forbidden)<br>    <span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> word<br>        <span class="hljs-keyword">if</span> letter ∈ forbidden<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>두 번째 인수인 <code>forbidden</code>이 <code>word</code>에 속해 있다면 <code>false</code>를 반환하며, 루프가 끝까지 진행되면 <code>true</code>가 반환된다.</p><p><code>usesonly()</code>는 <code>avoids()</code>과 조건만 반대이고 나머지 구조는 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> usesonly(word, available)<br>    <span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> word<br>        <span class="hljs-keyword">if</span> letter ∉ available<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>usesonly()</code>는 <code>forbidden</code> 문자 배열 대신에 <code>available</code> 문자 배열이 들어가며, <code>word</code> 알파벳 중에서 <code>available</code>에 속한 문자가 없다면 <code>false</code>를 반환한다.</p><p>또한 포함되어야 하는 알파벳 문자열을 사용한 <code>usesall()</code>은 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> usesall(word, required)<br>    <span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> required<br>        <span class="hljs-keyword">if</span> letter ∉ word<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>usesall()</code>은 루프에서 <code>word</code>의 알파벳을 가져오는 것이 아니라 <code>required</code>에서 알파벳을 가져온다. 만약 <code>required</code> 알파벳이 <code>word</code>에 없다면 <code>false</code>를 반환한다.</p><p>만약 실제 컴퓨터 과학자처럼 생각한다면, <code>usesall()</code>이 <code>usesonly()</code>와 인수 위치만 변화된 것을 파악할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> usesall(word, required)<br>    usesonly(required, word)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 코드는 이전에 만들었던 함수로 프로그램 개발을 축소하는 과정의 예이다. 인자 설정만 잘하면 기존 함수들을 이용하여 문제를 해결할 수 있다.</p><h3 id="인덱스를-이용한-루핑">인덱스를 이용한 루핑</h3><p>그동안은 문자열 안에 문자만 필요했기 때문에 <code>for</code> 루프를 사용해서 함수를 작성해왔다. 즉, 인덱스를 사용할 필요가 없었다.</p><p>하지만 아래의 <code>isabecedarian()</code>는 단어 안의 특정 문자와 인접한 문자들을 비교해야 하기 때문에 <code>for</code> 루프를 사용하면 함수 작성이 어려워진다. 참고로 <code>isabecedarian()</code>는 알파벳 순서로 작성된 단어인지를 판단하는 함수이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> isabecedarian(word)<br>    i = firstindex(word)<br>    previous = word[i]<br>    j = nextind(word, i)<br>    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> word[j:<span class="hljs-keyword">end</span>]<br>        <span class="hljs-keyword">if</span> c &lt; previous<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">end</span><br>        previous = c<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>재귀를 사용한 대안은 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> isabecedarian(word)<br>    <span class="hljs-keyword">if</span> length(word) &lt;= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">end</span><br>    i = firstindex(word)<br>    j = nextind(word, i)<br>    <span class="hljs-keyword">if</span> word[i] &gt; word[j]<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">end</span><br>    isabecedarian(word[j:<span class="hljs-keyword">end</span>])<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>while</code> 루프를 사용한 다른 방법은 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> isabecedarian(word)<br>    i = firstindex(word)<br>    j = nextind(word, <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">while</span> j &lt;= sizeof(word)<br>        <span class="hljs-keyword">if</span> word[j] &lt; word[i]<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">end</span><br>        i = j<br>        j = nextind(word, i)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 코드에서 루프는 <code>i=1</code> 와 <code>j=nextind(word, 1)</code>로 시작하며, <code>j&gt;sizeof(word)</code>일 때 끝난다. 각각의 루프는 <code>i</code>(현재 알파벳)와 <code>j</code>(다음 순서의 알파벳)를 비교한다.</p><p>만약 <code>j</code>보다 <code>i</code>가 더 크면, 알파벳의 순서가 깨졌기 때문에 <code>false</code>를 반환한다. 그 외에 <code>while</code> 루프가 다 끝나면 그 단어는 해당 테스트를 통과한 것이다. 루프가 잘 작동하는지 확인하기 위해서 예시인 <code>"flossy"</code>를 넣어서 실행해보자.</p><p>아래의 코드는 문자열의 처음과 끝을 인덱스로 잡아 비교하는 함수 <code>ispalindrome()</code>이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> ispalindrome(word)<br>    i = firstindex(word)<br>    j = lastindex(word)<br>    <span class="hljs-keyword">while</span> i&lt;j<br>        <span class="hljs-keyword">if</span> word[i] != word[j]<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">end</span><br>        i = nextind(word, i)<br>        j = prevind(word, j)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>또한 우리가 함수를 이용해서 더 간결하게 작성할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> ispalindrome(word)<br>    isreverse(word, word)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="디버깅">디버깅</h3><p>프로그램을 테스트하는 것은 어렵다. 이 장에서 작성한 함수들은 작성자가 직접 결과를 확인할 수 있기 때문에 테스트하기 쉽게 연결된 형태이다. 그렇지만 오류 가능성을 확인하기 위한 단어를 선택하는 것은 어렵고 거의 불가능하다.</p><p><code>hasno_e</code>를 예시로 보면, 이 함수에는 명백하게 확인해야 할 것들이 두 가지가 있다. <code>e</code> 가 들어간 단어는 무조건 <code>false</code>를 반환해야 하며, <code>true</code>를 반환해서는 안된다. 아마 단어 각각을 대입했을 때에는 문제가 없었을 것이다.</p><p>각 <code>e</code>를 포함하고 있는 단어들은 <code>e</code>의 위치를 파악하기 위해서 시작점, 끝, 그리고 중간쯤에도 확인을 해야한다. 그렇기 때문에 긴 단어, 짧은 단어, 빈 문자 등을 테스트해야 한다. 빈 문자(empty string)는 에러가 어디있는지 숨겨주기 때문에 명확하지 못한 조금 특별한 경우이다.</p><p>게다가 일반화하기 위해 실행하는 테스트의 경우, 단어 리스트 전체를 사용해서 프로그램을 테스트해야 한다. 결괏값을 출력함으로써 오류들을 확인할 수 있다. 주의해야 할 점은 실제로 오류가 없지만 오류로 파악되는 경우, 실제로 오류가 있지만 보이지 않는 경우 등이 있을 수 있다.</p><p>일반적으로 테스트하는 것은 버그를 찾는 데 도움을 주지만, 몇몇의 좋은 테스트 결과만을 가지고 코드를 일반화하기는 어렵다. 심지어 테스트를 많이 해도 프로그램이 올바르게 작동되고 있다고 확신하기는 어려울 것이다.</p><p>전설적인 컴퓨터 사이언티스트는 아래와 같이 말했다.</p><p>"프로그램 테스팅은 버그를 미리 보기 위해 사용되지만, 버그가 없다는 결론을 보여주지는 않는다."</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>think julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>줄리아</tag>
      
      <tag>Julia</tag>
      
      <tag>Think Julia</tag>
      
      <tag>기초 강의</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[7/20] 문자열</title>
    <link href="/ko/ThinkJulia/Think-Julia-Chapter-7/"/>
    <url>/ko/ThinkJulia/Think-Julia-Chapter-7/</url>
    
    <content type="html"><![CDATA[<blockquote><p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p></blockquote><p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap08">Strings</a>를 한글로 요약 정리한 글입니다. <span id="more"></span></p><h2 id="문자열-strings">문자열 (Strings)</h2><p>문자열은 정수나 소수, 불 표현식과는 다르다. 이 장에서는 문자열을 구성하는 문자에 접근하는 방법을 배우고, 줄리아가 제공하는 문자열 도우미 함수 중 일부에 대해서 알아볼 것이다.</p><h3 id="캐릭터-characters">캐릭터 (Characters)</h3><p>영어를 사용하는 사람들은 알파벳, 숫자 및 일반적인 문장 부호와 같은 문자에 익숙하다. 이런 문자들은 표준화되어 ASCII 표준에 따라 0부터 127사이의 정수 값으로 일대일 배치한다. 영어가 아닌 한국어나 중국어, 아랍어와 같아느 언어들도 ASCII 표준에 포함되어 있다.</p><p>유니 코드 표준은 복잡하게 구성된 문자들도 정확히 표현할 수 있도록 고안되었기 때문에 일반적으로 주요한 표준으로 사용되고 있으며, 전 세계적으로 모든 문자들에 고유 번호를 제공한다.</p><p><code>Char</code> 값은 단일 문자를 나타내며, 작은 따옴표로 묶는다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-string">&#x27;x&#x27;</span><br><span class="hljs-string">&#x27;x&#x27;</span>: ASCII/Unicode U+<span class="hljs-number">0078</span> (category Ll: Letter, lowercase)<br>julia&gt; &#x27;🍌&#x27;<br>&#x27;🍌&#x27;: Unicode U+<span class="hljs-number">01f34</span>c (category So: <span class="hljs-built_in">Symbol</span>, other)<br>julia&gt; typeof(<span class="hljs-string">&#x27;x&#x27;</span>)<br><span class="hljs-built_in">Char</span><br></code></pre></td></tr></table></figure><p>위의 바나나와 같은 이모티곤 또한 유니코드 표준에 포함되어 있다. (:banana: TAB)</p><h3 id="문자열은-시퀀스이다.-a-string-is-a-sequence">문자열은 시퀀스이다. (A String Is a Sequence)</h3><p>문자열은 일련의 문자이다. 대괄호 연산자를 사용하여 한 번에 하나씩 문자에 엑세스 할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; fruit = <span class="hljs-string">&quot;banana&quot;</span><br><span class="hljs-string">&quot;banana&quot;</span><br>julia&gt; letter = fruit[<span class="hljs-number">1</span>]<br><span class="hljs-string">&#x27;b&#x27;</span>: ASCII/Unicode U+<span class="hljs-number">0062</span> (category Ll: Letter, lowercase)<br></code></pre></td></tr></table></figure><p>두 번째 명령문은 <code>fruit</code>에서 첫 번째 문자를 선택하여 <code>letter</code>라는 변수에 할당한다.</p><p>위와 같이 대괄호[]를 내부에 있는 표현식을 인덱스(index)라고 부른다. 인덱스는 문자열 중에서 원하는 문자가 어느 위치에 있는지를 나타낸다.</p><p>줄리아는 모든 인덱싱을 1부터 시작한다. 즉, 첫 번째 문자는 인덱스 1로 찾을 수 있으며, 마지막 문자는 인덱스 <code>end</code>에서 찾을 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; fruit[<span class="hljs-keyword">end</span>]<br><span class="hljs-string">&#x27;a&#x27;</span>: ASCII/Unicode U+<span class="hljs-number">0061</span> (category Ll: Letter, lowercase)<br></code></pre></td></tr></table></figure><p>또한 인덱스는 변수나 연산자가 포함된 표현식들도 사용될 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; i = <span class="hljs-number">1</span><br><span class="hljs-number">1</span><br>julia&gt; fruit[i+<span class="hljs-number">1</span>]<br><span class="hljs-string">&#x27;a&#x27;</span>: ASCII/Unicode U+<span class="hljs-number">0061</span> (category Ll: Letter, lowercase)<br>julia&gt; fruit[<span class="hljs-keyword">end</span>-<span class="hljs-number">1</span>]<br><span class="hljs-string">&#x27;n&#x27;</span>: ASCII/Unicode U+<span class="hljs-number">006</span>e (category Ll: Letter, lowercase)<br></code></pre></td></tr></table></figure><p>그러나 인덱스 값이 정수가 아니라면 오류 메시지가 뜬다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; letter = fruit[<span class="hljs-number">1.5</span>]<br>ERROR: <span class="hljs-built_in">MethodError</span>: no method matching getindex(::<span class="hljs-built_in">String</span>, ::<span class="hljs-built_in">Float64</span>)<br></code></pre></td></tr></table></figure><h3 id="length"><code>length</code></h3><p><code>length</code>는 내장 함수로 문자열 안에 있는 문자들의 개수를 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; fruits = <span class="hljs-string">&quot;🍌 🍎 🍐&quot;</span><br><span class="hljs-string">&quot;🍌 🍎 🍐&quot;</span><br>julia&gt; len = length(fruits)<br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>위의 예시를 보면 <code>length</code>는 이모티콘 3개와 그 사이의 띄어쓰기를 포함하여 총 길이를 <code>5</code>라고 반환한다.</p><p>문자열의 마지막 문자를 얻고 싶다면, 아래의 코드를 입력하면 된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; last = fruits[len]<br><span class="hljs-string">&#x27; &#x27;</span>: ASCII/Unicode U+<span class="hljs-number">0020</span> (category Zs: Separator, space)<br></code></pre></td></tr></table></figure><p>하지만 기대했던 것과는 다른 결과가 나온다. 문자열은 다양한 UTF-8 인코딩을 사용하여 인코딩되었다. UTF-8은 가변적으로 폭이 변하는 인코딩 (variable-width encoding)으로 모든 문자가 동일한 바이트 수로 인코딩되지 않는다.</p><p><code>sizeof()</code>는 문자의 바이트 수를 보여준다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; sizeof(<span class="hljs-string">&quot;🍌&quot;</span>)<br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>위 이모티콘은 4바이트로 인코딩되었고 문자열 인덱싱은 바이트 기반이기 때문에 <code>fruits</code>의 5번째 요소는 띄어쓰기인 <code>SPACE</code> 이다.</p><p>이것은 UTF-8 문자열에서 모든 문자들은 정확히 몇 바이트로 인덱싱 되었는지 확인해야 한다는 것을 보여준다. 만약 눈으로 파악한 인덱스를 사용한다면, 잘못된 결과를 도출할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; fruits[<span class="hljs-number">2</span>]<br>ERROR: <span class="hljs-built_in">StringIndexError</span>(<span class="hljs-string">&quot;🍌 🍎 🍐&quot;</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p><code>fruits</code>예시에서는 <code>🍌</code>가 4바이트이기 때문에 인덱스 2,3,4는 반환되지 않으며, 그 다음 유효한 인덱스는 5이다. 다음 유효한 인덱스를 찾고 싶다면 <code>nextind(fruits, 1)</code>을 입력하면 된다. 이후 5 다음으로 유효한 인덱스를 찾고 싶다면 <code>nextind(fruits, 5)</code>를 실행하면 된다.</p><h3 id="순회-traversal">순회 (Traversal)</h3><p>많은 계산들은 한 번에 한 문자씩 문자열을 처리한다. 이때 컴퓨터는 하나의 문자를 선택하여 해당 명령들을 수행한 이후, 다른 문자를 선택하여 이를 반복한다. 이것을 순회(Traversal)이라고 하며, 순회를 작성하는 방법은 <code>while</code> 루프를 사용하는 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">index = firstindex(fruits)<br><span class="hljs-keyword">while</span> index &lt;= sizeof(fruits)<br>    letter = fruits[index]<br>    println(letter)<br>    <span class="hljs-keyword">global</span> index = nextind(fruits, index)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 코드는 변수 <code>index</code>에 <code>fruits</code>의 첫 번째 인덱스를 할당한다. 그 후 <code>while</code>루프 조건으로 넘어간다. 조건은 <code>index</code>가 <code>fruits</code>의 인덱스 총 길이보다 작으면 <code>true</code>을 도출하여 루프를 실행하거나, 크면 <code>false</code>를 도출하여 루프를 종료한다.</p><p><code>firstindex()</code>는 인수의 첫 번째 인덱스를 반환한다. 키워드 <code>global</code>는 기존에 정의했던 변수에 새로운 값을 재할당한다.</p><h3 id="문자열-슬라이스-string-slices">문자열 슬라이스 (String Slices)</h3><p>문자열의 일부를 슬라이스(Slices)라고 부른다. 슬라이스는 문자를 축출하는 것과 비슷하다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; str = <span class="hljs-string">&quot;Julius Caesar&quot;</span>;<br><br>julia&gt; str[<span class="hljs-number">1</span>:<span class="hljs-number">6</span>]<br><span class="hljs-string">&quot;Julius&quot;</span><br></code></pre></td></tr></table></figure><p>연산자 <code>[n:m]</code>은 인덱스 <code>n</code>번째 바이트부터 <code>m</code>번째 바이트까지의 문자들을 반환한다. 그렇기 때문에 인덱스 위치를 잘 파악하고 있어야 한다.</p><p>키워드 <code>end</code>는 마지막 문자를 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; str[<span class="hljs-number">8</span>:<span class="hljs-keyword">end</span>]<br><span class="hljs-string">&quot;Caesar&quot;</span><br></code></pre></td></tr></table></figure><p>만약에 첫 번째 인덱스의 수가 두 번째 인덱스의 수보다 크다면 빈 문자(empty string)를 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; str[<span class="hljs-number">8</span>:<span class="hljs-number">7</span>]<br><span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>빈 문자(empty string)는 어떤 캐릭터도 포함하지 않고 길이도 0이지만, 다른 문자열과 동일하게 사용할 수 있다.</p><h3 id="문자열은-변경-불가능-strings-are-immutable">문자열은 변경 불가능 (Strings Are Immutable)</h3><p>문자열을 변경하기 위해서 변수 옆에 연산자<code>[]</code>를 사용해보면 다음과 같은 결과를 얻을 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; greeting = <span class="hljs-string">&quot;Hello, world!&quot;</span><br><span class="hljs-string">&quot;Hello, world!&quot;</span><br>julia&gt; greeting[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;J&#x27;</span><br>ERROR: <span class="hljs-built_in">MethodError</span>: no method matching setindex!(::<span class="hljs-built_in">String</span>, ::<span class="hljs-built_in">Char</span>, ::<span class="hljs-built_in">Int64</span>)<br></code></pre></td></tr></table></figure><p>위와 같은 오류가 발생하는 이유는 기존에 있던 문자열을 변경할 수 없기 때문이다. 가장 좋은 방법은 기존에 있던 문자열을 새로운 문자열로 재할당하는 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; greeting = <span class="hljs-string">&quot;J&quot;</span> * greeting[<span class="hljs-number">2</span>:<span class="hljs-keyword">end</span>]<br><span class="hljs-string">&quot;Jello, world!&quot;</span><br></code></pre></td></tr></table></figure><p>이 예시에서는 새로운 첫 글자를 <code>greeting</code>애 연결한 후 재할당한다. 원래 문자열 내부를 변경하는 것은 아니다.</p><h3 id="문자-보간법-string-interpolation">문자 보간법 (String Interpolation)</h3><p>위의 예시처럼 곱셈 연산자인 <code>*</code>을 사용하여 연결하면 복잡한 변경이 요구될 때 번거로울 수 있다. 줄리아는 <code>$</code>을 사용하여 문자열 보간을 허용한다. 보간(Interpolation)이란 쉽게 설명하면 사이에 채워넣는 것을 의미한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; greet = <span class="hljs-string">&quot;Hello&quot;</span><br><span class="hljs-string">&quot;Hello&quot;</span><br>julia&gt; whom = <span class="hljs-string">&quot;World&quot;</span><br><span class="hljs-string">&quot;World&quot;</span><br>julia&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$greet</span>, <span class="hljs-subst">$(whom)</span>!&quot;</span><br><span class="hljs-string">&quot;Hello, World!&quot;</span><br></code></pre></td></tr></table></figure><p>위의 방법은 <code>*</code>을 사용하는 것보다 더 편리하고 읽기도 쉽다.</p><p><code>$</code>다음에 작성되는 모든 표현식들은 문자열로 간주된다. 따라서 괄호를 사용하여 모든 표현식을 문자열로 보간할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-string">&quot;1 + 2 = <span class="hljs-subst">$(<span class="hljs-number">1</span> + <span class="hljs-number">2</span>)</span>&quot;</span><br><span class="hljs-string">&quot;1 + 2 = 3&quot;</span><br></code></pre></td></tr></table></figure><h3 id="검색-searching">검색 (Searching)</h3><p>아래의 함수는 어떤 기능을 할까?</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> find(word, letter)<br>    index = firstindex(word)<br>    <span class="hljs-keyword">while</span> index &lt;= sizeof(word)<br>        <span class="hljs-keyword">if</span> word[index] == letter<br>            <span class="hljs-keyword">return</span> index<br>        <span class="hljs-keyword">end</span><br>        index = nextind(word, index)<br>    <span class="hljs-keyword">end</span><br>    -<span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>find()</code>는 <code>[]</code> 연산자의 역수와 같다. 인덱스를 받아서 해당 문자를 축출하는 대신에 해당 문자를 받아서 인덱스를 축출한다. 문자를 찾지 못하면 함수는 -1을 반환한다.</p><p>위의 <code>while</code> 루프는 <code>word[index] == letter</code>인 경우 루프를 벗어나 값을 바로 반환한다.</p><p>만약 문자열에서 찾으려는 문자를 찾지 못하면, -1을 반환한다.</p><p>위와 같이 일련의 문자열에서 특정 문자에 대한 인덱스를 반환해주는 계산 방식을 검색(Searching)이라고 한다.</p><h3 id="루핑과-카운팅-looping-and-counting">루핑과 카운팅 (Looping and Counting)</h3><p>아래의 코드는 해당 단어에서 <code>a</code>가 몇 번 있는지 세어서 반환해준다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia">word = <span class="hljs-string">&quot;banana&quot;</span><br>counter = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> word<br>    <span class="hljs-keyword">if</span> letter == <span class="hljs-string">&#x27;a&#x27;</span><br>        <span class="hljs-keyword">global</span> counter = counter + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br>println(counter)<br></code></pre></td></tr></table></figure><p>이 프로그램은 카운터(counter)라 불리는 다른 계산 방식이다. 변수 <code>counter</code>는 0으로 초기화되고, <code>a</code>가 나타날 때마다 1씩 증가한다. 루프에서 빠져나가면, <code>counter</code>가 가진 결과를 반환한다.</p><h3 id="문자열-라이브러리-string-library">문자열 라이브러리 (String Library)</h3><p>줄리아는 물자열에서 사용할 수 있는 유용한 함수들을 제공한다. 예를 들어서 <code>uppercase()</code>는 문자열들을 인수로 받아서 대문자로 변경해준다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; uppercase(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br><span class="hljs-string">&quot;HELLO, WORLD!&quot;</span><br></code></pre></td></tr></table></figure><p>또한 우리가 작성했던 <code>find()</code>와 유사한 함수인 <code>findfirst()</code>도 제공한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; findfirst(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>)<br><span class="hljs-number">2</span>:<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>사실은 <code>findfirst()</code>가 우리가 만든 함수보다 더 일반적이다. 이 함수는 캐릭터뿐만 아니라 문자열의 일부도 찾아준다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; findfirst(<span class="hljs-string">&quot;na&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>)<br><span class="hljs-number">3</span>:<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><code>findfirst()</code>는 문자열의 첫 번째부터 특정 문자들을 찾는다. 만약 특정 지점부터 문자를 찾고 싶다면 <code>findnext()</code>를 사용하면 된다. <code>findnext()</code>는 세 번째 인수에 특정 지점 인덱스를 추가하면 된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; findnext(<span class="hljs-string">&quot;na&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">4</span>)<br><span class="hljs-number">5</span>:<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h3 id="연산자"><code>∈</code> 연산자</h3><p>연산자 <code>∈(\in TAB)</code>은 불 연산자로서, 특정 문자가 문자열에 속했는지 여부를 보여준다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-string">&#x27;a&#x27;</span> ∈ <span class="hljs-string">&quot;banana&quot;</span>    <span class="hljs-comment"># &#x27;a&#x27; in &quot;banana&quot;</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>예로, 아래의 함수는 단어1과 단어2에 모두 들어 있는 문자들만 출력한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> inboth(word1, word2)<br>    <span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> word1<br>        <span class="hljs-keyword">if</span> letter ∈ word2<br>            print(letter, <span class="hljs-string">&quot; &quot;</span>)<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>변수 이름을 잘 선택하면, 코드를 자연어처럼 읽을 수 있다. "첫 번째 단어의 문자가 두 번째 단어에 속해있다면 문자를 인쇄하라"</p><p>아래의 코드는 <code>oranges</code>와 <code>apples</code>를 비교한 예시이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; inboth(<span class="hljs-string">&quot;apples&quot;</span>, <span class="hljs-string">&quot;oranges&quot;</span>)<br>a e s<br></code></pre></td></tr></table></figure><h3 id="문자열-컴포지션-string-comparison">문자열 컴포지션 (String Comparison)</h3><p>관계 연산자들은 문자열에서 작동한다. 다음은 두 문자가 동일한지 <code>==</code> 연산자를 사용한 예시이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">word = <span class="hljs-string">&quot;Pineapple&quot;</span><br><span class="hljs-keyword">if</span> word == <span class="hljs-string">&quot;banana&quot;</span><br>    println(<span class="hljs-string">&quot;All right, bananas.&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>다른 관계 연산자들도 알파벳순으로 단어를 넣을 때 사용할 수 있다. 참고로 줄리아는 대문자와 소문자를 구별하며, 알파벳 순서는 대문자가 소문자보다 앞의 글자로 인식된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Your word, Pineapple, comes before banana.<br></code></pre></td></tr></table></figure><p><strong>Tip</strong> 위의 문제를 해결하는 가장 보편적인 방법은 모든 문자열을 소문자와 같은 기준 형식으로 변경하는 것이다.</p><h3 id="디버깅">디버깅</h3><p>시퀀스에서 인덱스를 사용해 값을 순회하면 순회의 시작과 끝을 얻기가 어렵다. 다음은 두 단어를 비교하고 한 단어가 다른 단어와 반대인 경우 <code>true</code>를 반환하는 함수를 볼 것이다. 하지만 이 함수는 두 가지의 오류를 가지고 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> isreverse(word1, word2)<br>    <span class="hljs-keyword">if</span> length(word1) != length(word2)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">end</span><br>    i = firstindex(word1)<br>    j = lastindex(word2)<br>    <span class="hljs-keyword">while</span> j &gt;= <span class="hljs-number">0</span><br>        j = prevind(word2, j)<br>        <span class="hljs-keyword">if</span> word1[i] != word2[j]<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">end</span><br>        i = nextind(word1, i)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위 함수의 첫 번째 줄인 <code>if</code>문은 두 단어의 길이가 똑같지 않으면 즉시 <code>false</code>를 반환한다. 아무것도 반환되지 않는다면 두 단어의 길이가 같다고 가정할 수 있다.</p><p><code>i</code>와 <code>j</code>는 인덱스이며, <code>i</code>는 <code>word1</code>에서 앞에서 뒤로 이동하며, <code>j</code>는 <code>word2</code> 뒤에서 앞으로 이동한다. <code>i</code>와 <code>j</code>가 일치하지 않는 순간 <code>while</code>문은 <code>false</code>를 반환한다. 모든 글자가 일치하여 전체 루프를 통과하면 함수는 <code>true</code>를 반환한다.</p><p>여기서 사용된 <code>lastindex()</code>는 문자열의 마지막 인덱스를 반환하고 <code>prevind()</code>는 이후 사용될 문자의 인덱스를 미리 반환하는 것이다.</p><p>지금부터는 "pots"와 "stop" 두 단어를 사용하여 함수를 테스트 할 것이다.</p><p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; isreverse(<span class="hljs-string">&quot;pots&quot;</span>, <span class="hljs-string">&quot;stop&quot;</span>)<br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure></p><p>분명히 반대로 쓰여진 단어인데도 함수는 <code>false</code>를 반환했다. 이런 오류들을 디버깅하기 위해서 첫 번째로 할당된 인덱스들을 인쇄해볼 것이다.</p><p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> isreverse(word1, word2)<br>    <span class="hljs-keyword">if</span> length(word1) != length(word2)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">end</span><br>    i = firstindex(word1)<br>    j = lastindex(word2)<br>    <span class="hljs-keyword">while</span> j &gt;= <span class="hljs-number">0</span><br>        j = prevind(word2, j)<br>        <span class="hljs-meta">@show</span> i j<br>        <span class="hljs-keyword">if</span> word1[i] != word2[j]<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">end</span><br>        i = nextind(word1, i)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></p><p>위의 코드로 프로그램을 다시 작동해보면, 아래와 같은 정보를 얻을 수 있다.</p><p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; isreverse(<span class="hljs-string">&quot;pots&quot;</span>, <span class="hljs-string">&quot;stop&quot;</span>)<br>i = <span class="hljs-number">1</span><br>j = <span class="hljs-number">3</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure></p><p>첫 번째 루프에서 <code>j</code>의 값은 4이어야 하는데, 3이 나왔다. 이것은 <code>j = prevind(word2, j)</code>를 <code>while</code>루프 맨 끝으로 옮겨야 한다는 것을 의미한다.</p><p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> isreverse(word1, word2)<br>    <span class="hljs-keyword">if</span> length(word1) != length(word2)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">end</span><br>    i = firstindex(word1)<br>    j = lastindex(word2)<br>    <span class="hljs-keyword">while</span> j &gt;= <span class="hljs-number">0</span><br>        <span class="hljs-meta">@show</span> i j<br>        <span class="hljs-keyword">if</span> word1[i] != word2[j]<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">end</span><br>        i = nextind(word1, i)<br>        j = prevind(word2, j)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></p><p>위 코드를 작동시키면 결과는 아래와 같다.</p><p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; isreverse(<span class="hljs-string">&quot;pots&quot;</span>, <span class="hljs-string">&quot;stop&quot;</span>)<br>i = <span class="hljs-number">1</span><br>j = <span class="hljs-number">4</span><br>i = <span class="hljs-number">2</span><br>j = <span class="hljs-number">3</span><br>i = <span class="hljs-number">3</span><br>j = <span class="hljs-number">2</span><br>i = <span class="hljs-number">4</span><br>j = <span class="hljs-number">1</span><br>i = <span class="hljs-number">5</span><br>j = <span class="hljs-number">0</span><br>ERROR: <span class="hljs-built_in">BoundsError</span>: attempt to access <span class="hljs-string">&quot;pots&quot;</span><br>  at index [<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure></p><p>이번에는 <code>BoundsError</code>가 발생하였다. <code>i</code>의 값이 5가 되고 문자열 "pots"의 범위를 벗어난다.</p><p><strong>Tip</strong> 위의 오류를 해결한 코드</p><p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> isreverse(word1, word2)<br>    <span class="hljs-keyword">if</span> length(word1) != length(word2)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">end</span><br>    i = firstindex(word1)<br>    j = lastindex(word2)<br>    <span class="hljs-keyword">while</span> j &gt;= <span class="hljs-number">0</span><br>        <span class="hljs-meta">@show</span> i j<br>        <span class="hljs-keyword">if</span> word1[i] != word2[j]<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">end</span><br>        i = nextind(word1, i)<br>        j = prevind(word2, j)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>think julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>줄리아</tag>
      
      <tag>Julia</tag>
      
      <tag>Think Julia</tag>
      
      <tag>기초 강의</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[6/20] 반복</title>
    <link href="/ko/ThinkJulia/Think-Julia-Chapter-6/"/>
    <url>/ko/ThinkJulia/Think-Julia-Chapter-6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p></blockquote><p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap07">Iteration</a>를 한글로 요약 정리한 글입니다. <span id="more"></span></p><h2 id="반복-iteration">반복 (Iteration)</h2><p>이번 장에서는 명령문들을 반복해주는 반복문에 대해서 살펴볼 것이다. 우리는 이미 <a href="https://dev-bearabbit.github.io/2020/03/03/ThinkJulia/Think-Julia-Chapter-5/">조건문과 재귀</a>에서 <code>for</code>루프를 사용한 반복문을 살펴보았다. 이번 장에서는 <code>while</code>문을 사용하는 방법을 배울 것이다. 그 전에 변수 할당에 대해서 조금 더 알아보자.</p><h3 id="재할당-reassignment">재할당 (Reassignment)</h3><p>제목에서 알 수 있듯이, 한 변수에 값을 여러 번 할당하는 것은 가능하다. 새로운 할당문은 이전의 값을 제거하고 새로운 값으로 변경한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; x = <span class="hljs-number">5</span><br><span class="hljs-number">5</span><br>julia&gt; x = <span class="hljs-number">7</span><br><span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>처음 코드에서 <code>x</code>는 값으로 <code>5</code>를 할당받았지만, 두 번째 코드가 실행된 이후에는 값이 <code>7</code>로 재할당된다.</p><p>이런 재할당의 방식은 다이어그램으로 보면 아래와 같다.</p><figure><img src="/images/reassign.png" alt="state diagram" /><figcaption aria-hidden="true">state diagram</figcaption></figure><p>줄리아는 할당에 등호(<code>=</code>)를 사용하기 때문에 수학식에서의 <code>a``=``b</code>와 같은 동일성(equal)으로 이해하는 경우가 종종 있다. 하지만 이것은 잘못된 개념 정의이다.</p><p>먼저 동일성은 대칭관계이지만 할당은 그렇지 않다. 예를 들어 수학에서 <code>a``=``7</code>인 경우 <code>7``=``a</code>도 성립하지만, 줄리아에서는 <code>a``=``7</code>로 할당한다고 해서 <code>7``=``a</code>가 옳은 것은 아니다.</p><p>또한 수학에서 '동일성의 속성(a proposition of equality)'은 항상 참(true) 또는 거짓(false)이다. 예를 들어 <code>a``=``b</code>가 참이라면 <code>a</code>는 항상 <code>b</code>와 같아야 한다. 하지만 줄리아는 재할당하면 위의 참 가정이 언제든지 깨질 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; a = <span class="hljs-number">5</span><br><span class="hljs-number">5</span><br>julia&gt; b = a    <span class="hljs-comment"># a 와 b 가 현재는 동일하다.</span><br><span class="hljs-number">5</span><br>julia&gt; a = <span class="hljs-number">3</span>    <span class="hljs-comment"># a 를 재할당 하는 순간 동일성은 깨진다.</span><br><span class="hljs-number">3</span><br>julia&gt; b<br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>위의 코드에서 볼 수 있듯이 <code>a</code>을 재할당해도 <code>b</code>도 같이 재할당되지 않는다. 이는 할당과 동일성이 다르다는 것을 증명한다.</p><p><strong>주의</strong> 변수를 재할당 하는 것은 종종 유용하지만, 주의해서 사용해야 한다. 너무 자주 변경하면 이후 코드를 읽고 디버깅하기 어려울 수 있다. 또한 이미 생성된 변수와 같은 이름으로 함수를 생성할 수 없다.</p><h3 id="변수-업데이트-updating-variables">변수 업데이트 (Updating Variables)</h3><p>일반적인 재할당 유형은 업데이트이며, 변수의 새 값은 이전 값에 따라 다르다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; x = x + <span class="hljs-number">1</span><br><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>위의 코드는 <code>x</code>의 현재 값을 얻고, 1을 더한 다음 <code>x</code>를 새로운 값으로 업데이트한다.</p><p>하지만 아직 생성되지 않은 변수를 업데이트 하려고 한다면, 줄리아는 오류를 일으킨다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; y = y + <span class="hljs-number">1</span><br>ERROR: <span class="hljs-built_in">UndefVarError</span>: y not defined<br></code></pre></td></tr></table></figure><p>변수를 업데이트하기 전에, 간단하게 값을 할당하여 초기화를 해야 한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; y = <span class="hljs-number">0</span><br><span class="hljs-number">0</span><br>julia&gt; y = y + <span class="hljs-number">1</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>1을 추가하여 변수를 업데이트 하는 것을 증가(increment)라고 하며, 1을 빼는 것을 감소(decrement)라고 한다.</p><h3 id="while문"><code>while</code>문</h3><p>컴퓨터는 종종 반복적인 일들을 자동으로 사용한다. 오류 없이 동일한 일을 반복하는 것은 컴퓨터가 가장 잘하는 일이며, 사람들이 가장 못하는 일이다.</p><p>우리는 이미 재귀를 사용하여 반복하는 <code>countdown()</code>, <code>printn()</code>를 보았다. 반복문은 많이 사용되기 때문에 줄리아는 반복문을 더 쉽게 만들 수 있도록 설계되었다. 그 중 하나인 <code>for</code>문은 우리가 <a href="https://dev-bearabbit.github.io/2020/03/02/ThinkJulia/Think-Julia-Chapter-4/">간단한 반복 파트</a>에서 봤기 때문에 <code>while</code>문 먼저 볼 것이다. 아래 코드는 <code>while</code>문을 사용하여 작성한 <code>countdown()</code>이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> countdown(n)<br>    <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span><br>        print(n, <span class="hljs-string">&quot; &quot;</span>)<br>        n = n - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">end</span><br>    println(<span class="hljs-string">&quot;Blastoff!&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>while</code>문에 대해서 본 적이 없을지라도 위의 코드를 대부분 이해할 수 있을 것이다. <code>n</code>이 0보다 크다면, <code>n</code>을 보여주고 <code>n</code>에서 1을 뺀다. <code>n</code>이 0이 될 때까지 반복하다가 0이 되면, "Blastoff!"를 반환한다.</p><p>더 형식적으로, <code>while</code>문의 실행 흐름을 정리해보자.</p><ul><li><code>while</code>문의 조건이 참인지 거짓인지 판별하라</li><li>조건이 <code>true</code>인 경우 본문을 실행한 후, 다시 1단계로 돌아가라</li><li>조건이 <code>false</code>인 경우 <code>while</code>문을 종료하고 다음 명령문을 실행하라</li></ul><p>위와 같이 명령문을 실행한 후 다시 앞으로 올라가는 실행 흐름의 종류를 루프(loop)라고 한다.</p><p>루프의 본문은 조건이 결국 <code>false</code>가 되어 루프가 종료되도록 하나 이상의 변수 값을 변경해야 한다. 그러허지 않으면 루프가 영원히 반복되며, 이런 현상을 무한 루프라고 한다.</p><p><code>countdown()</code>의 경우에서는 루프 본문에서 <code>n</code>을 변경함으로써 <code>n</code>이 0이나 음수가 되면 루프가 종료되게 설정하였다. 이는 유한한 루프임이 확실하다.</p><p>이제는 다른 루프도 살펴보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> seq(n)<br>    <span class="hljs-keyword">while</span> n != <span class="hljs-number">1</span><br>        println(n)<br>        <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>        <span class="hljs-comment"># n is even</span><br>            n = n / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">else</span>                 <span class="hljs-comment"># n is odd</span><br>            n = n*<span class="hljs-number">3</span> + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위 루프의 조건은 <code>n!= 1</code>이다. 따라서 이 루프는 <code>n</code>이 1이 되어 <code>false</code>가 될 때까지 반복될 것이다.</p><p>루프가 매번 작동할 때, 프로그램은 <code>n</code>의 값을 도출한 후 해당 <code>n</code>이 짝수인지 홀수인지 확인한다. 만약에 <code>n</code>이 짝수라면 2로 나눠지며, 홀수라면 <code>n</code>은 <code>n*3 + 1</code> 값으로 대체된다. 예를 들어 <code>seq()</code>에 인수로 3을 준다면, 결괏값으로 3,10,5,16,8,4,2,1을 도출할 것이다.</p><p><code>n</code>은 증가하거나 감소하기 때문에 <code>n</code>이 1이 되어 프로그램이 종료된다는 명백한 증거는 없다. 다만 위의 예시와 같이 <code>n</code>의 특정 값에 대해서는 종료를 증명할 수 있다. 예를 들어 시작 값이 2의 거듭제곱인 경우 <code>n</code>은 루프를 통과할 때마다 짝수가 되며, 결국 1이 되어 종료될 수 있다.</p><p>여기서 어려운 질문은 과연 프로그램은 <code>n</code>이 모든 양수 값일 때 종료되는가이다. 지금가지 누구도 저 문제를 증명하거나 반증하지 못했다.</p><h3 id="break문"><code>break</code>문</h3><p>때때로 함수를 작성하다보면 루프를 끝내는 지점을 처음에 정하지 못할 수도 있다. 그런 경우에는 <code>break</code>문을 사용하여 루프를 빠져나올 수 있다.</p><p>예를 들어, 만약에 사용자가 <code>done</code>이라고 작성할 때까지 사용자로부터 입력을 받고 싶다고 가정하자. 그렇다면 아래와 같이 코드를 작성할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span><br>    print(<span class="hljs-string">&quot;&gt; &quot;</span>)<br>    line = readline()<br>    <span class="hljs-keyword">if</span> line == <span class="hljs-string">&quot;done&quot;</span><br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">end</span><br>    println(line)<br><span class="hljs-keyword">end</span><br>println(<span class="hljs-string">&quot;Done!&quot;</span>)<br></code></pre></td></tr></table></figure><p>해당 루프의 조건은 항상 <code>true</code>이기 때문에, 루프는 <code>break</code>문에 도달할 때까지 계속 반복된다.</p><p>매번 사용자에게 "&gt; "가 표시되며, 사용자가 <code>done</code>이라고 입력하는 즉시 <code>break</code>문이 루프를 종료한다. 만약 <code>done</code>을 입력하지 않으면, 사용자가 입력한 내용을 반영하고 다시 루프의 위로 올라간다.</p><p>실행한 결과는 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">&gt; not done<br>not done<br>&gt; done<br>Done!<br></code></pre></td></tr></table></figure><p>이렇게 루프를 작성하는 방법은 루프의 어느 곳에서든 조건을 확인할 수 있고, 멈춰야 하는 지점도 정확히 설정할 수 있기 때문에 일반적으로 사용된다.</p><h3 id="continue문"><code>continue</code>문</h3><p><code>break</code>문이 루프를 빠져나가게 한다면, <code>continue</code>문은 명령문들 중간에서 루프의 시작점으로 올려준다. 예를 통해 확인해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:<span class="hljs-number">10</span><br>    <span class="hljs-keyword">if</span> i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span><br>        <span class="hljs-keyword">continue</span><br>    <span class="hljs-keyword">end</span><br>    print(i, <span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위 코드 실행의 결과는 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>코드를 살펴보면, <code>i</code>가 3으로 나눠지면 <code>continue</code>문을 만나서 루프의 처음으로 돌아가며, <code>i</code>가 3으로 나눠지지 않으면 그대로 <code>print()</code>로 넘어간다. 따라서 결과에서 3으로 나눠지는 수들은 다 제외되고 출력된 것이다.</p><h3 id="제곱근-square-roots">제곱근 (Square Roots)</h3><p>루프는 반복하여 수치 결과를 개선하는 프로그램에도 자주 사용된다.</p><p>예로 제곱근을 계산하는 방법 중 하나인 뉴턴의 방법을 보자. 만약 <code>a</code>라는 수의 제곱근을 알고 싶다면, 아래의 공식을 반복하여 값을 찾을 수 있다.</p><p><span class="math display">\[\begin{equation}y= \frac{1}{2}\left(x+\frac{a}{x}\right)\end{equation}\]</span></p><p>임의로 <code>a</code>에 4을 할당하고, <code>x</code>에 3을 할당한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; a = <span class="hljs-number">4</span><br><span class="hljs-number">4</span><br>julia&gt; x = <span class="hljs-number">3</span><br><span class="hljs-number">3</span><br>julia&gt; y = (x + a/x) / <span class="hljs-number">2</span><br><span class="hljs-number">2.1666666666666665</span><br></code></pre></td></tr></table></figure><p>위 결과는 4의 제곱근인 2와 가깝다. 만약에 위 과정을 반복한다면, 2와 더 가까운 결과를 얻을 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; x = y<br><span class="hljs-number">2.1666666666666665</span><br>julia&gt; y = (x + a/x) / <span class="hljs-number">2</span><br><span class="hljs-number">2.0064102564102564</span><br></code></pre></td></tr></table></figure><p>몇 번의 업데이트 이후, 거의 2와 같은 결과를 얻었다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; x = y<br><span class="hljs-number">2.0064102564102564</span><br>julia&gt; y = (x + a/x) / <span class="hljs-number">2</span><br><span class="hljs-number">2.0000102400262145</span><br>julia&gt; x = y<br><span class="hljs-number">2.0000102400262145</span><br>julia&gt; y = (x + a/x) / <span class="hljs-number">2</span><br><span class="hljs-number">2.0000000000262146</span><br></code></pre></td></tr></table></figure><p>일반적으로 정답에 도달하는데 걸리는 반복 수를 미리 예측할 수는 없지만, 일정 구간이 지나면 값이 도달하여 변하지 않는 것을 확인할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; x = y<br><span class="hljs-number">2.0000000000262146</span><br>julia&gt; y = (x + a/x) / <span class="hljs-number">2</span><br><span class="hljs-number">2.0</span><br>julia&gt; x = y<br><span class="hljs-number">2.0</span><br>julia&gt; y = (x + a/x) / <span class="hljs-number">2</span><br><span class="hljs-number">2.0</span><br></code></pre></td></tr></table></figure><p><code>y == x</code>에 도달했을 때는 반복문을 멈출 수 있다. 위의 과정을 <code>while</code>문으로 작성하면 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span><br>    println(x)<br>    y = (x + a/x) / <span class="hljs-number">2</span><br>    <span class="hljs-keyword">if</span> y == x<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">end</span><br>    x = y<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>대부분의 값은 정상적으로 작동하지만 <span class="math display">\[\sqrt{2}\]</span> 와 같은 수들은 <code>Float64</code>로 표현되지 않기 때문에 피하는게 좋다.</p><p><code>y</code>와 <code>x</code>가 정확하게 동일한지 확인하기 위해서는 내장 함수 <code>abs()</code>를 사용하여 이들의 차이를 절대 값으로 계산하는 것이 더 안전하다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">if</span> abs(y-x) &lt; ε<br>    <span class="hljs-keyword">break</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>여기서 <code>ε</code>(<code>\varepsilon TAB</code>)은 <code>0.0000001</code>과 같이 얼마나 가까운지 결정한다.</p><h3 id="알고리즘">알고리즘</h3><p>뉴턴의 방법은 알고리즘 예시 중 하나이다. 알고리즘(Algorithms)은 제곱근 계산과 같이 문제들을 해결하는 기계적인 프로세스이다.</p><p>알고리즘이 무엇인지 이해하기 위해서는 알고리즘이 아닌 것들을 먼저 보는 것이 더 효과적일 수 있다. 예로 한 자리 숫자를 곱하는 법을 배울 때, 단순히 곱셈표를 외웠을 것이다. 이런 종류의 지식은 알고리즘이라고 할 수 없다.</p><p>그러나 게으른 사람이라면 몇 가지의 요령을 획득했을 것이다. 예를 들어 n과 9의 곱을 찾으려면 n−1을 첫 번째 숫자로, 10−n을 두 번째 숫자로 사용하여 답을 만들 수 있다. 이 식은 한자리 숫자와 9를 곱하는 일반적인 해결방안이다. 이것이 알고리즘이다.</p><p>알고리즘의 특징 중 하나는 이를 수행할 지능이 필요하지 않다는 점이다. 알고리즘들은 간단한 규칙에 따라서 진행하는 기계적인 프로세스이다.</p><p>알고리즘 실행은 지루하지만 알고리즘 설계는 흥미롭고 도전적이다. 또한 알고리즘 설계는 컴퓨터 과학의 핵심이다.</p><p>사람들이 자연스럽게 하는 것들 중 일부는 알고리즘으로 구현하기가 어렵다. 예로 자연어를 이해하는 것 등이다. 우리는 모두 자연어를 이해하고 있지만, 알고리즘적으로 어떻게 이해하는지 설명하는 것은 매우 어렵다.</p><h3 id="디버깅">디버깅</h3><p>더 큰 프로그램을 작성하기 시작하면 디버깅에 많은 시간을 투자하게 된다. 코드가 많을수록 오류가 발생할 확률도 올라가며 버그가 숨어있을 수 있는 공간도 많아진다.</p><p>디버깅 시간을 줄일 수 있는 한 가지 방법은 이분법 디버깅이다. 이분법 디버깅은 프로그램 코드를 중간 단위로 분해하여 확인하면서 문제점을 빠르게 찾는 방법이다. 예를 들어 프로그램 코드가 100줄이라면, 50줄 쯤에서 나눈 다음 그 근처를 확인하는 것이다. 확인하는 방법은 <code>print</code>문을 넣어 코드가 잘 작동하는지 보는 것이다. 이때 잘 작동한다면 프로그램 후반부에 문제가 있는 것이고, 아니라면 전반부에 문제가 있는 것이다. 이 방식으로 검사하면 100줄을 전부 다 볼 필요 없다.</p><p>하지만 실제 상황에서는 프로그램 중간이 무엇인지 명확하지 않을 수 있다. 코드 줄 개수에 맞춰 반으로 나누는 것은 합리적이지 않다. 따라서 프로그램에 오류가 있을 수 있는 장소와 코드를 먼저 점검한 후, 개발자가 생각하는 합리적인 중간점을 찾는 것이 좋다.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>think julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>줄리아</tag>
      
      <tag>Julia</tag>
      
      <tag>Think Julia</tag>
      
      <tag>기초 강의</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[5/20] 결과 있는 함수</title>
    <link href="/ko/ThinkJulia/Think-Julia-Chapter-5/"/>
    <url>/ko/ThinkJulia/Think-Julia-Chapter-5/</url>
    
    <content type="html"><![CDATA[<blockquote><p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p></blockquote><p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap06">Fruitful Functions</a>를 한글로 요약 정리한 글입니다. <span id="more"></span></p><h2 id="결과-있는-함수-fruitful-functions">결과 있는 함수 (Fruitful Functions)</h2><p>줄리아가 제공하는 많은 함수들은 반환 값을 생성한다. 하지만 우리가 사용했던 <code>Turtle()</code>과 같은 결과 없는 함수(void function)는 명령을 수행하기만 하고 반환 값을 제공하지는 않는다. 이번 장에서는 결과 있는 함수를 작성하는 법을 알아볼 것이다.</p><h3 id="반환-값">반환 값</h3><p>함수를 호출하면 일반적으로 변수에 할당하거나 표현식의 일부로 사용하는 반환 값이 생성된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">e = exp(<span class="hljs-number">1.0</span>)<br>height = radius * sin(radians)<br></code></pre></td></tr></table></figure><p>결과 없는 함수는 반환 값을 가지고 있지 않다. 정확하게는 반환 값으로 <code>nothing</code>을 가지고 있다. 결과 있는 함수의 첫 번째 예시로 원의 넓이를 반환하는 <code>area()</code>를 살펴볼 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> area(radius)<br>    a = <span class="hljs-literal">π</span> * radius^<span class="hljs-number">2</span><br>    <span class="hljs-keyword">return</span> a<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 코드는 <code>return</code>문을 사용하여 값을 보여준다. <code>return</code>문은 함수의 결괏값을 다음의 반환 값으로 사용하게 만들어주는 명령문이다. 결과 있는 함수는 <code>return</code>문을 내장하고 있기 때문에 쓸 필요가 없다. 따라서 수정된 코드는 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> area(radius)<br>    <span class="hljs-literal">π</span> * radius^<span class="hljs-number">2</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>함수 본문의 마지막에 위치해 있는 표현식의 결과가 값으로 반환된다. 반면에 함수 내부에서 정의되는 임시 변수 <code>a</code>의 경우는 <code>return</code>문을 사용해야 디버깅하기 쉽다. 때때로 조건문의 조건마다 <code>return</code>문을 가지는 것은 유용하다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> absvalue(x)<br>    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> -x<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> x<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>이런 <code>return</code>문들은 각각의 대체 조건문에 들어가 있으며, 조건에 따라 작동된다. <code>return</code>문이 실행되면 뒤의 명령문들은 실행되지 않고 종료되는데, 이때 뒤에 있던 명령문들을 데드 코드(dead code)이라고 한다.</p><p>결과 있는 함수에서는 프로그램의 모든 경로가 <code>return</code>문으로 끝나게 작성하는 것이 좋다. 아래 예시를 확인해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> absvalue(x)<br>    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> -x<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> x<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 함수는 <code>x</code>가 0이 되면 어떤 조건도 참이 아니고 반환할 <code>return</code>문도 없기 때문에 올바른 함수가 아니다. 만약 <code>x</code>가 0인채로 함수가 진행된다면 반환 값으로 <code>nothing</code>을 준다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; show(absvalue(<span class="hljs-number">0</span>))<br><span class="hljs-literal">nothing</span><br></code></pre></td></tr></table></figure><p><strong>Tip</strong> 줄리아는 절대값을 반환해주는 <code>abs()</code>를 내장하고 있다.</p><h3 id="점진적인-개발-incremental-development">점진적인 개발 (Incremental Development)</h3><p>크고 복잡한 함수들을 작성할수록 디버깅에 많은 시간을 쏟아야 할 것이다. 복잡한 프로그램들을 점점 향상시키기 위해서, 점진적인 개발이라는 과정을 배우는 것은 중요하다. 점진적인 개발의 목표는 작은 단위의 코드들을 계속 테스트해야하고 수정해야하는 디버깅에 소요되는 시간을 줄이는 것이다. 예로 두 점인 (x1,y1)와 (x2,y2)의 거리를 구하려고 한다. 피타고라스 정리에 따르면 수학식은 다음과 같다.</p><p><span class="math display">\[\begin{equation} \label{eq1}d= \sqrt{(x2-x1)^2+(y2-y1)^2}\end{equation}\]</span></p><p>위의 수학식을 줄리아에서 구현하기 위해서는 어떻게 해야할까? 첫 번째로는 무엇을 인수로 제공하며, 얻으려는 반환 값은 무엇인지 정하는 것이다. 위의 사례에서는 두 점인 (x1,y1)와 (x2,y2)을 인수로 제공하면 된다. 반환 값의 경우는 소수로 표현된 거리를 얻을 것이다. 인수와 반환 값을 결정하면 바로 아래와 같은 코드를 완성할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> distance(x₁, y₁, x₂, y₂)<br>    <span class="hljs-number">0.0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 코드는 거리를 계산하지는 않으며, 본문에 따라 항상 0을 반환한다. 그러나 본문에 다른 명령문을 추가하기 전에 코드가 작동하는지 확인할 수 있다. 작동을 확인하기 위해 아래의 코드를 입력해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">distance(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><p>위의 코드에서 두 점은 수평 거리가 3이 되고 수직 거리가 4가 되도록 선택하였다. 그 결과 두 점의 거리 값은 5이며, 반환 값도 5가 되어야 한다. 이와 같이 코드를 테스트할 때는 정답을 알고 있는 상태에서 해야 올바르게 작동하고 있는지 확인할 수 있다.</p><p>위의 테스트를 통해서 해당 함수가 문법적으로는 문제가 없다고 확인하였다. 그러면 이제부터는 본문에 명령문들을 추가해보자. 다음 단계는 <code>x2−x1</code> 과 <code>y2−y1</code> 을 설정하는 것이다. 함수 내부에 임시 변수로서 두 식의 값을 저장하도록 설정해보자. 그 다음 <code>@show</code>를 사용하여 임시 변수가 올바르게 생성되는지 확인해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> distance(x₁, y₁, x₂, y₂)<br>    dx = x₂ - x₁<br>    dy = y₂ - y₁<br>    <span class="hljs-meta">@show</span> dx dy<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 함수가 제대로 작동했다면, <code>dx = 3</code> 과 <code>dy = 4</code> 가 보였을 것이다. 만약 그렇다면 우리는 함수가 올바른 인수를 받아 제대로 작동하고 있다고 안심할 수 있다.</p><p>다음 명령문으로 <code>dx</code> 와 <code>dy</code> 을 제곱하여 더하는 계산을 추가한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> distance(x₁, y₁, x₂, y₂)<br>    dx = x₂ - x₁<br>    dy = y₂ - y₁<br>    d² = dx^<span class="hljs-number">2</span> + dy^<span class="hljs-number">2</span><br>    <span class="hljs-meta">@show</span> d²<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>다시 위의 함수를 작동했을 때에는 <code>d²</code> 값이 25로 나와야 한다. 만약 올바르게 작동한다면 마지막으로 제곱근을 계산해주는 <code>sqrt()</code>를 추가해준다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> distance(x₁, y₁, x₂, y₂)<br>    dx = x₂ - x₁<br>    dy = y₂ - y₁<br>    d² = dx^<span class="hljs-number">2</span> + dy^<span class="hljs-number">2</span><br>    sqrt(d²)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>코드가 제대로 작동했다면, 우리는 위의 수학식을 코드로 올바르게 구현한 것이다.</p><p>최종적으로 사용한 위의 함수는 반환 값을 가지고 있지만 결과를 출력하지는 않는다. 따라서 반환 값이 올바른지 체크하기 위해서는 <code>println()</code>과 같은 함수로 직접 츌력해서 확인해야 한다. 이런 작업을 스캐폴딩(scaffolding)이라고 한다. 이런 함수들은 디버깅을 할 때 도움이 되지만, 나중에 최종 프로그램을 구현할 때는 제거해야 한다.</p><p>초보자가 함수를 작성할 때는 명령문을 한 줄 또는 두 줄만을 추가하여 올바르게 작동하는지 확인해야 한다. 그 과정이 익숙해지면 더 큰 덩어리 단위로 명령문을 작성하고 디버깅할 수 있다.</p><p>요약하자면 함수를 개발하는 방법은 다음과 같다.</p><ul><li>프로그램을 작동하여 확인하면서 작은 부분들을 변경하자. 언제라도 오류가 발생하면 어느 부분에서 문제가 생긴 것인지 알고 있어야 한다.</li><li>함수 내부에 임시 변수를 사용하여 값들을 저장하면서 값이 올바른지 확인하자.</li><li>프로그램이 작동하면 스캐폴딩을 제거하고, 명령문들을 복합 표현식으로 사용하는 등 코드를 간단하게 수정하자.</li></ul><h3 id="컴포지션-composition">컴포지션 (composition)</h3><p>함수를 작성할 때, 필요하다면 미리 작성한 함수를 가져와 사용할 수 있다. 예를 들어 원의 중심과 둘레의 점을 두 점으로 하여 원의 면적을 계산하는 함수를 살펴 보자.</p><p>중심점을 변수 <code>xc</code>와 <code>yc</code>로 표현하고, 둘레점을 <code>xp</code>와 <code>yp</code>로 표현한다. 그 이후 첫 번째 단계로 두 지점 사이의 거리인 원의 반경을 찾기로 한다. 우리는 윗 장에서 두 점의 거리를 구하는 <code>distance()</code>를 작성했기 때문에 이를 이용할 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">radius = distance(xc, yc, xp, yp)<br></code></pre></td></tr></table></figure><p>다음 단계로는 우리가 만들었던 <code>area()</code>를 사용하여 원의 면적을 구한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">result = area(radius)<br></code></pre></td></tr></table></figure><p>마지막으로 위의 변수들을 하나의 함수로 캡슐화해준다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> circlearea(xc, yc, xp, yp)<br>    radius = distance(xc, yc, xp, yp)<br>    result = area(radius)<br>    <span class="hljs-keyword">return</span> result<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>임시 변수인 <code>radius</code>와 <code>result</code>는 디버깅을 할 때 유용하지만, 굳이 임시 변수를 사용하지 않고 인수 자리에 함수를 바로 입력하여 더 간결하게 표현할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> circlearea(xc, yc, xp, yp)<br>    area(distance(xc, yc, xp, yp))<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="불-함수-boolean-functions">불 함수 (Boolean Functions)</h3><p>함수는 불(true or false)를 반환할 수 있으며, 이는 종종 복잡한 테스트를 함수 내부에 숨기는데 유용하다. 예는 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> isdivisible(x, y)<br>    <span class="hljs-keyword">if</span> x % y == <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>이것은 yes/no 질문이라고 불리는 전형적인 불 함수이다. <code>isdivisible()</code>은 x값을 y값으로 나눈 나머지 값에 따라 <code>true</code> 또는 <code>false</code>를 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; isdivisible(<span class="hljs-number">6</span>, <span class="hljs-number">4</span>)<br><span class="hljs-literal">false</span><br>julia&gt; isdivisible(<span class="hljs-number">6</span>, <span class="hljs-number">3</span>)<br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><code>==</code> 연산자는 자동으로 불 표현식의 결괏값을 반환하므로 함수를 더 간결하게 작성할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> isdivisible(x, y)<br>    x % y == <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>불 함수는 종종 조건문에 사용된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">if</span> isdivisible(x, y)<br>    println(<span class="hljs-string">&quot;x is divisible by y&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>또는 다음과 같이 작성할 수도 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">if</span> isdivisible(x, y) == <span class="hljs-literal">true</span><br>    println(<span class="hljs-string">&quot;x is divisible by y&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>하지만 위의 코드에서 <code>true</code>는 불필요하다.</p><h3 id="재귀-정의-more-recursion">재귀 정의 (More Recursion)</h3><p>우리는 고작 줄리아의 작은 서브셋(subset)들을 배웠지만, 사실 이 서브셋들은 완벽한 프로그래밍 언어이다. 지금까지 습득한 언어로 대부분의 수학 계산식들을 표현할 수 있다. 즉, 프로그램을 작성하는데 어려움이 없다는 것이다.</p><p>프로그래밍 언어가 수학 계산식을 표현할 수 있다는 사실은 수학자 앨런 튜링(Alan Turing)에 의해서 증명되었으며, 해당 이론을 튜링 이론이라고 한다. 만약 튜링 이론에 관심이 있다면 Michael Sipser의 저서인 Introduction to the Theory of Computation을 추천한다.</p><p>지금부터는 우리가 배운 도구들을 사용하여 만들어진 몇 가지 재귀 함수를 살펴볼 것이다. 재귀 정의는 어떤 단어를 설명하는데 있어 그 단어를 선택한다는 점에서 순환 정의와 유사하다.</p><p><strong>vorpal</strong> An adjective used to describe something that is vorpal.</p><p>위의 예시를 보면 vorpal이란 단어를 정의하는데 vorpal이란 단어가 쓰이는 것을 볼 수 있다. 재귀함수도 이와 유사한 구조를 가지고 있다. 재귀 함수의 예로 계승 함수(factorial function)을 살펴보자.</p><p><span class="math display">\[n! = \begin{cases}1 &amp; \text{if n=0 \]</span>}\ n(n-1)! &amp; \ \end{cases} $$</p><p>위의 정의는 <code>n</code>이 0이면 1을 반환하고, 만약 <code>n</code>이 0이상이라면 <code>n</code>과 <code>(n-1)!</code>을 곱하라고 설명한다.</p><p>예를 들면 3!은 3과 2!를 곱하고, 2!는 2와 1!을 곱하며, 1!는 1과 0을 곱한다. 따라서 3!는 3<em>2</em>1<em>1</em>0이기에 6인 것이다.</p><p>재귀 정의를 이용하여 위의 수학식을 함수로 작성할 수 있다. 첫 번째 단계는 인수가 무엇인지 결정하는 것이다. 이 경우에서는 정수가 인수로 사용된다는 것이 명확하다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> fact(n) <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>만약 인수가 0이라면, 1을 반환해야 하므로 조건문을 사용한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> fact(n)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>이 부분이 가장 흥미로운데, 만약 인수가 0이 아니라면 우리는 <code>n</code>과 <code>(n-1)!</code>를 곱하기 위해서 재귀 함수을 사용해야 한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> fact(n)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span><br>        recurse = fact(n-<span class="hljs-number">1</span>)<br>        result = n * recurse<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>n</code>에 3을 부여한 위 코드의 진행 과정은 다음과 같다.</p><ul><li><code>3</code>은 <code>0</code>이 아니기 때문에, <code>else</code>문으로 넘어가 <code>3</code>과 <code>2!</code>을 곱하려고 한다.</li><li><code>2</code>은 <code>0</code>이 아니기 때문에, <code>else</code>문으로 넘어가 <code>2</code>과 <code>1!</code>을 곱하려고 한다.</li><li><code>1</code>은 <code>0</code>이 아니기 때문에, <code>else</code>문으로 넘어가 <code>1</code>과 <code>0!</code>을 곱하려고 한다.</li><li><code>n</code>이 <code>0</code>이기 때문에, <code>0!</code>은 첫 번째 코드를 따라 1을 반환한다.</li><li><code>0!</code>가 <code>1</code>을 반환했기 때문에 <code>1</code>과 곱해져 <code>1!</code>을 반환한다.</li><li><code>1!</code>가 <code>1</code>을 반환했기 때문에 <code>2</code>과 곱해져 <code>2!</code>을 반환한다.</li><li><code>2!</code>가 <code>2</code>을 반환했기 때문에 <code>3</code>과 곱해져 <code>6</code>을 반환한다.</li></ul><p>결국 마지막으로 작동된 명령문의 결과값인 6이 반환 값으로 보여준다. 또한 로컬 변수인 <code>result</code>나 <code>recurse</code>도 함수가 작동을 멈추는 동시에 사라진다.</p><p><strong>Tip</strong> 줄리아는 계승 함수(factorial function)를 제공한다.</p><h3 id="믿음의-도약-leap-of-faith">믿음의 도약 (Leap of Faith)</h3><p>실행 흐름을 따르는 것은 프로그램을 읽는 하나의 방법이다. 그러나 때에 따라선 믿음의 도약이라고 부르는 방법도 사용할 수 있다. 믿음의 도약이란 함수가 어떻게 작동하는지를 파악하기 전에 함수를 호출하여 올바른 결괏값을 도출하는지 확인하여 그 함수가 잘 작동하고 있다고 믿는 것이다. 즉, 프로그램의 실행 흐름을 보는 것이 아니라 결괏값만을 보고 프로그램이 올바르게 작동하고 있는지 파악하는 것이다.</p><p>실제로 내장 함수를 사용할 때 우리는 이 방법을 많이 사용한다. 예를 들어 <code>cos()</code>나 <code>exp()</code>를 사용할 때, 해당 함수의 본문을 검사하지 않으며, 결괏값만 보고 믿음을 주는 것이다. 재귀 프로그램 또한 실행 흐름을 따르는 대신에 재귀 호출이 되었다고 가정하여 결괏값을 확인한다.</p><h3 id="연습해보기">연습해보기</h3><p>가장 재귀적으로 정의된 가장 보편적인 수학 표현식 중 하나인 피보나치를 작성해보자. 피보나치에 대한 정의는 <a href="https://en.wikipedia.org/wiki/Fibonacci_number">이 링크</a>를 확인하면 된다.</p><p><span class="math display">\[fib(n) = \begin{cases}0 &amp; \text{if n=0 \]</span>}\ 1 &amp; \ fib(n-1)+fib(n-2) &amp; \ \end{cases} $$</p><p>위 식을 줄리아 코드로 표현하면 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> fib(n)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">elseif</span> n == <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> fib(n-<span class="hljs-number">1</span>) + fib(n-<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>이 함수에서 실행 흐름대로 파악하려면 <code>n</code>이 아주 작은 경우에도 머리가 복잡하다. 그렇기 때문에 믿음의 도약에 따라 재귀 함수가 올바르게 작동한다고 가정한후 <code>n</code>에 3 정도를 넣어보면 빠르게 좋은 결과를 얻을 수 있다.</p><h3 id="데이터-타입-확인하기">데이터 타입 확인하기</h3><p>민약에 <code>fact()</code>에 인수로 <code>1.5</code>를 넣으면 어떻게 될까?</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; fact(<span class="hljs-number">1.5</span>)<br>ERROR: <span class="hljs-built_in">StackOverflowError</span>:<br>Stacktrace:<br> [<span class="hljs-number">1</span>] fact(::<span class="hljs-built_in">Float64</span>) at ./REPL[<span class="hljs-number">3</span>]:<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>무한 재귀로 작동된 에러 결과가 나왔다. 어떻게 그게 가능할까? <code>fact()</code>는 <code>n</code>이 <code>0</code>일때 함수 작동이 끝나는 재귀 정의를 가지고 있다. <code>1.5</code>는 <code>0</code>이 아니기 때문에 <code>else</code>문으로 실행되며 첫 번째 실행 이후 <code>n</code>값이 <code>0.5</code>가 된다. 그 다음 두 번째 실행에서는 <code>n</code>값이 <code>-0.5</code>가 된다. 결국 <code>n</code>값이 <code>0</code>이 되지 못하기 때문에 무한대로 재귀가 작동하는 결과가 초래된 것이다.</p><p>따라서 이 문제를 해결하기 위해서는 소수점 숫자도 인수로 받을 수 있게 <code>fact()</code>를 일반화하거나, 데이터 타입을 미리 확인하라는 명령문을 추가할 수 있다. 첫 번째 방법은 <strong>감마 함수</strong>라고 하며 이 책의 범위를 벗어나기 때문에, 우리는 두 번째 방법을 선택할 것이다.</p><p>내장 연산자인 <code>isa</code>를 이용하여 인수 유형을 확인할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> fact(n)<br>    <span class="hljs-keyword">if</span> !(n <span class="hljs-keyword">isa</span> <span class="hljs-built_in">Int64</span>)<br>        error(<span class="hljs-string">&quot;Factorial is only defined for integers.&quot;</span>)<br>    <span class="hljs-keyword">elseif</span> n &lt; <span class="hljs-number">0</span><br>        error(<span class="hljs-string">&quot;Factorial is not defined for negative integers.&quot;</span>)<br>    <span class="hljs-keyword">elseif</span> n == <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> n * fact(n-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>첫 번째 <code>if</code>문은 정수가 아닌 수들에 대한 에러 메시지를 도출하며, 두 번째 <code>elseif</code>문은 음수에 대한 에러 메시지를 도출한다. 에러 메시지가 출력될 경우 그 함수의 결과는 <code>nothing</code>을 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; fact(<span class="hljs-string">&quot;fred&quot;</span>)<br>ERROR: Factorial is only defined <span class="hljs-keyword">for</span> integers.<br>julia&gt; fact(-<span class="hljs-number">2</span>)<br>ERROR: Factorial is not defined <span class="hljs-keyword">for</span> negative integers.<br></code></pre></td></tr></table></figure><p>두 검사를 모두 통과하면 <code>n</code>이 양수이거나 0임이 증명되기 때문에, 바로 재귀 함수로 넘어갈 수 있다.</p><p>이런 프로그램 구조는 가이드라인을 보여준다. 처음 두 조건이 가이드 역할을 하여 오류를 일으킬 수 있는 값에서 구출하고 오류를 막아준다.</p><h3 id="디버깅">디버깅</h3><p>큰 프로그램들을 작은 함수들로 분해하는 것은 자연스러운 디버깅 포인트들을 만들어준다. 만약 함수가 작동하고 있지 않다면, 아래의 세 가지 가능성을 고려야봐야 한다.</p><ul><li>함수의 인수가 잘못 배정된 경우 (전제조건 오류)</li><li>함수 자체에 오류가 있는 경우 (사후조건 오류)</li><li>반환 값이나 사용되는 방식에 문제가 있는 경우 (함수의 연결부분)</li></ul><p>첫 번째의 가능성을 배제하기 위해, <code>println()</code>을 추가하고 나오는 결괏값을 확인하여 데이터 타입을 정확히 확인하라. 아니면 해당 함수의 전제 조건을 다시 정확히 확인하라. 인수가 양호하다면 각 <code>return</code>문 앞에 <code>println()</code>을 추가하고 반환 값을 표시해서 가능하면 결과값을 확인하라. 옳은 결과인지 확인하기 쉬운 값을 인수로 주는 것이 좋다. 함수가 작동하는 것 같으면 함수 호출을 보고 반환 값이 올바르게 사용되는지 확인하라. 함수의 시작과 끝에 <code>println()</code>을 추가하면 실행 흐름을 더 잘 볼 수 있다. 예로 아래의 함수는 <code>println()</code>문이 포함된 <code>fact()</code> 코드 이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> fact(n)<br>    space = <span class="hljs-string">&quot; &quot;</span> ^ (<span class="hljs-number">4</span> * n)<br>    println(space, <span class="hljs-string">&quot;factorial &quot;</span>, n)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span><br>        println(space, <span class="hljs-string">&quot;returning 1&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span><br>        recurse = fact(n-<span class="hljs-number">1</span>)<br>        result = n * recurse<br>        println(space, <span class="hljs-string">&quot;returning &quot;</span>, result)<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>space</code>는 출력의 들여 쓰기를 제어하는 공백 문자열이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; fact(<span class="hljs-number">4</span>)<br>                factorial <span class="hljs-number">4</span><br>            factorial <span class="hljs-number">3</span><br>        factorial <span class="hljs-number">2</span><br>    factorial <span class="hljs-number">1</span><br>factorial <span class="hljs-number">0</span><br>returning <span class="hljs-number">1</span><br>    returning <span class="hljs-number">1</span><br>        returning <span class="hljs-number">2</span><br>            returning <span class="hljs-number">6</span><br>                returning <span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><p>만약에 실행 흐름이 헷갈리면, 위와 같은 출력들이 도움이 될 것이다. 효과적인 스캐폴딩을 개발하는 것은 조금 시간이 걸리겠지만, 작은 스캐폴딩으로도 많은 디버깅 요소들을 찾을 수 있다.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>think julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>줄리아</tag>
      
      <tag>Julia</tag>
      
      <tag>Think Julia</tag>
      
      <tag>기초 강의</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[4/20] 조건문과 재귀</title>
    <link href="/ko/ThinkJulia/Think-Julia-Chapter-4/"/>
    <url>/ko/ThinkJulia/Think-Julia-Chapter-4/</url>
    
    <content type="html"><![CDATA[<blockquote><p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p></blockquote><p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap05">Conditionals and Recursion</a>를 한글로 요약 정리한 글입니다. <span id="more"></span></p><h2 id="조건문과-재귀">조건문과 재귀</h2><p>이번 장의 가장 핵심적인 주제는 <code>if</code>문이지만, 그 전에 간단한 연산자 두 개를 먼저 소개하려고 한다.</p><h3 id="버림-나눗셈floor-division과-나머지modulus">버림 나눗셈(floor division)과 나머지(Modulus)</h3><p>버림 나눗셈(floor division)이란 두 수를 나눈 후 나머지를 버리는 계산을 의미하며, 연산자 기호는 <code>÷</code>이다. 예를 들어, 105분동안 상영하는 영화가 있다고 해보자. 우리는 영화가 대략 몇 시간이 걸리는지 알기 위해 60분으로 나누지만, 일반적인 나눗셈은 소수점까지 모두 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; minutes = <span class="hljs-number">105</span><br><span class="hljs-number">105</span><br>julia&gt; minutes / <span class="hljs-number">60</span><br><span class="hljs-number">1.75</span><br></code></pre></td></tr></table></figure><p>그러나 우리는 일반적으로 시간을 소수점으로 표현하지는 않는다. 버림 나눗셈은 나머지인 소수점을 모두 버리고 정수만 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; hours = minutes ÷ <span class="hljs-number">60</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>위의 1시간을 제외하고 남은 시간이 몇 분인지 알고 싶다면 105분에서 1시간을 빼면 된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; remainder = minutes - hours * <span class="hljs-number">60</span><br><span class="hljs-number">45</span><br></code></pre></td></tr></table></figure><p>이외에도 나눗셈에서 나머지만 반환해주는 나머지 연산자 <code>%</code>를 사용할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; remainder = minutes % <span class="hljs-number">60</span><br><span class="hljs-number">45</span><br></code></pre></td></tr></table></figure><p><strong>Tip</strong> 나머지 연산자는 생각보다 유용하다, 예로 한 숫자를 다른 숫자로 나눌 수 있는지 파악해야 할 때, 두 수의 나머지 연산 결과가 0인지로 확인할 수 있다. 또한 정수에서 가장 오른쪽의 숫자만 추출할 때도 사용가능하다. 이 경우, <code>%10</code>을 사용하면 된다.</p><h3 id="불-표현식">불 표현식</h3><p>불 표현식(Boolean Expressions)은 <code>true</code> 또는 <code>false</code>를 나타내는 식이며, 연산자는 <code>==</code>이다. 불 표현식의 예시를 보면, 연산자는 <code>==</code>를 기분으로 양 옆의 두 피연산자들을 비교한 후 같으면 <code>true</code>를, 다르면 <code>false</code>를 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-number">5</span> == <span class="hljs-number">5</span><br><span class="hljs-literal">true</span><br>julia&gt; <span class="hljs-number">5</span> == <span class="hljs-number">6</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><code>true</code>와 <code>false</code>은 문자열이 아니라 <code>Bool</code>이라는 데이터 타입에 속한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; typeof(<span class="hljs-literal">true</span>)<br><span class="hljs-built_in">Bool</span><br>julia&gt; typeof(<span class="hljs-literal">false</span>)<br><span class="hljs-built_in">Bool</span><br></code></pre></td></tr></table></figure><p>사용된 <code>==</code> 연산자는 관계 연산자들 중 하나이다. 다른 관계 연산자들은 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia">x != y               <span class="hljs-comment"># x is not equal to y</span><br>x ≠ y                <span class="hljs-comment"># (\ne TAB)</span><br>x &gt; y                <span class="hljs-comment"># x is greater than y</span><br>x &lt; y                <span class="hljs-comment"># x is less than y</span><br>x &gt;= y               <span class="hljs-comment"># x is greater than or equal to y</span><br>x ≥ y                <span class="hljs-comment"># (\ge TAB)</span><br>x &lt;= y               <span class="hljs-comment"># x is less than or equal to y</span><br>x ≤ y                <span class="hljs-comment"># (\le TAB)</span><br></code></pre></td></tr></table></figure><p><strong>주의</strong> 줄리아 기호는 일반적인 수학 기호와는 조금 다르다. 줄리아에서 <code>=</code>는 대입 연산자이고, <code>==</code>는 관계 연산자이다. 두 기호는 비슷해 보이지만 완전히 다르다.</p><h3 id="논리-연산자">논리 연산자</h3><p>논리 연산자는 and 연산자인 <code>&amp;&amp;</code>, or 연산자인 <code>||</code>, not 연산자인 <code>!</code> 총 세 가지가 있다. 논리 연산자들의 사용방법은 아래의 코드에서 확인해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">x &gt; <span class="hljs-number">0</span> &amp;&amp; x &lt; <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>위의 코드는 <code>&amp;&amp;</code> 연산자이다. 위의 예시는 x가 0보다 크고 10보다 작으면 이 문장은 <code>true</code>를 반환하는 것을 의미한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> || n % <span class="hljs-number">3</span> == <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>다음 코드는 <code>||</code> 연산자이다. 위의 코드를 해석한다면, n값이 2나 3으로 나누었을 때 나머지가 0인 숫자면 해당 코드는 <code>true</code>를 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">!(x &gt; y)<br></code></pre></td></tr></table></figure><p>마지막으로 <code>!</code> 연산자이며, 이는 불 표현식을 무효화한다. 따라서 위의 예시를 본다면 x가 y보다 작거나 같은 경우에 <code>true</code> 를 반환하고, x가 y보다 크다면 <code>false</code>를 반환한다.</p><h3 id="조건문conditional-실행">조건문(Conditional) 실행</h3><p>유용한 프로그램을 작성하려면 우리는 프로그램의 상태를 확인하고 그에 따라 알맞게 변경하는 기능이 필요하다. 조건문은 우리에게 이런 기능을 제공한다. 가장 간단한 형식은 <code>If</code>문이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">0</span><br>    println(<span class="hljs-string">&quot;x is positive&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>If</code>문 뒤에 쓰여 있는 불 표현식을 조건이라고 한다. 해당 조건이 참이라면 밑의 명령문이 작동되지만, 조건이 참이 아니라면 아무 일도 일어나지 않는다.</p><p><code>If</code>문이 함수 정의와 동일한 구조를 가진 경우를 복합 구문(compound statements)이라고 한다. 여기서 함수 정의를 다시 상기해본다면 헤더로 시작하여 본문을 작성 한후 마지막에 키워드 <code>end</code> 끝나는 구조이다.</p><p>복합 구문에 들어가는 명령문의 수는 제한이 없으며, 명령문이 아예 없는 본문도 작성이 가능하다 (하지만 본문이 없으면 어떤 변화도 일어나지는 않는다).</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span><br>    <span class="hljs-comment"># TODO: need to handle negative values!</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="대체alternative-실행">대체(Alternative) 실행</h3><p><code>If</code>문의 두 번째 형식은 대체 실행(Alternative Execution)이다. 이 구조에서는 두 가지의 조건이 있으며, 각각의 조건에 따라 실행되는 코드가 결정된다. 해당 예시는 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span><br>    println(<span class="hljs-string">&quot;x is even&quot;</span>)<br><span class="hljs-keyword">else</span><br>    println(<span class="hljs-string">&quot;x is odd&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 코드는 숫자인 x가 짝수인지 홀수인지 구분하여 알려주는 프로그램이다. x를 2로 나누어 나머지가 0이 된다면 짝수이고, 0이 아니라면 홀수이다. 이 간단한 원리를 사용하여 조건에 충족하면 <code>true</code>가 되어 첫 번째 본문을 실행하고, <code>false</code>라면 두 번째 본문을 실행한다.</p><h3 id="연결-조건문chained-conditionals">연결 조건문(Chained Conditionals)</h3><p>때로는 두 개 이상의 조건이 주어지는 경우도 있다. 이럴 때에는 조건을 연결하는 연결조건문 구조가 사용된다. 해당 구조의 코드는 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">if</span> x &lt; y<br>    println(<span class="hljs-string">&quot;x is less than y&quot;</span>)<br><span class="hljs-keyword">elseif</span> x &gt; y<br>    println(<span class="hljs-string">&quot;x is greater than y&quot;</span>)<br><span class="hljs-keyword">else</span><br>    println(<span class="hljs-string">&quot;x and y are equal&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위에 사용한 <code>elseif</code>문의 수는 제한이 없다. 또한 <code>else</code>문을 쓰려면 반드시 끝에 입력해야 하지만, 필요없다면 작성하지 않아도 된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">if</span> choice == <span class="hljs-string">&quot;a&quot;</span><br>    draw_a()<br><span class="hljs-keyword">elseif</span> choice == <span class="hljs-string">&quot;b&quot;</span><br>    draw_b()<br><span class="hljs-keyword">elseif</span> choice == <span class="hljs-string">&quot;c&quot;</span><br>    draw_c()<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>각 조건들은 순서대로 작동한다. 예를 들어 첫 번째 조건이 거짓이면 다음 조건으로 넘어가며, 만약 참인 조건을 찾으면 해당 본문이 실행되며 <code>If</code>문은 종료된다. 그렇기 때문에 만약 2개 이상의 조건이 참인 경우에도 더 위에 작성되어 있는 조건만 실행된다.</p><h3 id="중첩-조건문nested-conditionals">중첩 조건문(Nested Conditionals)</h3><p>하나의 <code>If</code>문에도 다른 <code>If</code>문이 중첩될 수 있다. 이전 예제를 가져와서 확인하면 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">if</span> x == y<br>    println(<span class="hljs-string">&quot;x and y are equal&quot;</span>)<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">if</span> x &lt; y<br>        println(<span class="hljs-string">&quot;x is less than y&quot;</span>)<br>    <span class="hljs-keyword">else</span><br>        println(<span class="hljs-string">&quot;x is greater than y&quot;</span>)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>겉에 있는 <code>If</code>문은 간단한 구조를 가지고 있다. 하지만 <code>else</code>문에 또 다시 <code>If</code>문을 작성함으로서 두 개의 조건문을 중첩시킨 것을 확인할 수 있다.</p><p>이럽 중첩 조건문은 들여쓰기를 통해서 연결지점들을 구분해두지만, 코드를 빠르게 이해하기는 어렵다. 그렇기에 코드를 작성할 때 중첩 조건문은 피하는 것이 좋다.</p><p>논리 연산자를 이용하여 중첩 조건문을 단순화할 수 있다. 아래 예시를 보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt; x<br>    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">10</span><br>        println(<span class="hljs-string">&quot;x is a positive single-digit number.&quot;</span>)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 조건문은 중첩 조건문으로서 두 개의 조건을 모두 충족해야만 실행된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt; x &amp;&amp; x &lt; <span class="hljs-number">10</span><br>    println(<span class="hljs-string">&quot;x is a positive single-digit number.&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>하지만 <code>&amp;&amp;</code> 연산자를 사용하면 단일 조건문으로 해결할 수 있다. 또한 줄리아는 아래와 같이 더 간결한 구문도 제공한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt; x &lt; <span class="hljs-number">10</span><br>    println(<span class="hljs-string">&quot;x is a positive single-digit number.&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="재귀recursion">재귀(Recursion)</h3><p>한 함수가 다른 함수를 호출하는 것은 충분히 가능한 일이다. 그렇다면 함수가 자기 자신을 호출하는 것도 가능할까? 위 질문에 대한 답은 가능하다는 것이다. 어떻게 가능한지 아래의 예시로 확인해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> countdown(n)<br>    <span class="hljs-keyword">if</span> n ≤ <span class="hljs-number">0</span><br>        println(<span class="hljs-string">&quot;Blastoff!&quot;</span>)<br>    <span class="hljs-keyword">else</span><br>        print(n, <span class="hljs-string">&quot; &quot;</span>)<br>        countdown(n-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 함수는 <code>n</code>이 0이거나 음수인 경우 "Blastoff!"를 출력하며, 아닌 경우에는 <code>n</code>을 출역한 후 <code>n-1</code>을 인수로 갖는 <code>countdown()</code>를 호출한다.</p><p>위의 함수는 어떤 결과를 보여줄까?</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; countdown(<span class="hljs-number">3</span>)<br><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> Blastoff!<br></code></pre></td></tr></table></figure><p>위의 예시를 보면, 조건문 원리를 이해할 수 있다.</p><ul><li>3은 0보다 크기 때문에 <code>else</code>문으로 넘어가서 3을 출력한 후 자기 자신을 호출하여 2를 인수로 제공한다.</li><li>2 또한 0보다 크기 때문에 <code>else</code>문으로 넘어가고 위와 같은 과정을 반복한다.</li><li>1 또한 0보다 크기 때문에 위와 같다.</li><li>0은 <code>If</code>문 조건에 해당하기 때문에 해당 본문이 실행된다. ("Blastoff!"를 호출한다.)</li></ul><p>스스로를 호출하는 함수를 실행하는 과정을 재귀(Recursion)라고 한다. 다른 예로 문자열을 <code>n</code>번 출력하는 함수를 만들어보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> printn(s, n)<br>    <span class="hljs-keyword">if</span> n ≤ <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">end</span><br>    println(s)<br>    printn(s, n-<span class="hljs-number">1</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>해당 예시는 <code>n</code>이 <code>n &lt;= 0</code>이면 함수를 종료한다. 함수가 종료되면 그 결과가 사용자에게 반환되며, 나머지 명령문들은 실행되지 않는다. <code>n</code>이 양수라면 나머지 명령문들이 실행되며, 해당 명령문의 작동방식은 <code>countdown()</code>과 유사하다.</p><h3 id="무한-재귀infinite-recursion">무한 재귀(infinite recursion)</h3><p>도착점이 제공되지 않은 재귀는 함수 호출을 계속하며 종료되지 않는다. 이런 현상을 무한 재귀(infinite recursion)라고 한다. 실제로 무한 재귀는 일반적으로 잘 사용되지 않는다. 아래 코드는 무한재귀의 간단한 예시이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> recurse()<br>    recurse()<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>대부분의 프로그래밍 환경에서 무한 재귀가 있는 프로그램이 영원히 실행되지는 않는다. 줄리아는 최대 재귀 수준에 도달하면 오류 메시지를 보낸 후 실행을 중단한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; recurse()<br>ERROR: <span class="hljs-built_in">StackOverflowError</span>:<br>Stacktrace:<br> [<span class="hljs-number">1</span>] recurse() at ./REPL[<span class="hljs-number">1</span>]:<span class="hljs-number">2</span> (repeats <span class="hljs-number">80000</span> times)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 오류를 보면 해당 함수는 80000번을 반복했다. 대부분 무한 재귀는 함수를 잘못 사용해서 발생하기 때문에 해당 오류를 만난다면 함수의 사용법을 확인해야 한다.</p><h3 id="키보드-입력keyboard-input">키보드 입력(Keyboard Input)</h3><p>줄리아는 <code>readline()</code>이라는 내장 함수를 제공하여 프로그램을 중지하고 사용자가 무언가를 입력할 때까지 기다린다. 사용자가 내용을 입력하고 <code>RETURN</code> 또는 <code>ENTER</code>를 누르면 해당 변수에 값이 적용된다. 이후 <code>readline()</code>은 사용자가 문자열로 입력한 내용을 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; text = readline()<br>What are you waiting <span class="hljs-keyword">for</span>? <span class="hljs-comment"># 내용 입력 후 `RETURN` 또는 `ENTER`를 누르기</span><br><span class="hljs-string">&quot;What are you waiting for?&quot;</span><br></code></pre></td></tr></table></figure><p>세미 콜론(;)을 사용하면 같은 줄에 여러 문장을 넣을 수 있다. REPL에서는 마지막 명령문의 결괏값만을 호출한다. 또한 사용자가 정수를 입력할 것으로 예상되면, 반환 값을 정수로 변환하여 가져올 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; println(<span class="hljs-string">&quot;What...is the airspeed velocity of an unladen swallow?&quot;</span>); speed = readline()<br>What...is the airspeed velocity of an unladen swallow?<br><span class="hljs-number">42</span><br><span class="hljs-string">&quot;42&quot;</span><br>julia&gt; parse(<span class="hljs-built_in">Int64</span>, speed)<br><span class="hljs-number">42</span><br></code></pre></td></tr></table></figure><p>하지만 만약 사용자가 입력한 데이터 타입과 다른 형태로 변환하면, 오류가 발생한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; println(<span class="hljs-string">&quot;What...is the airspeed velocity of an unladen swallow? &quot;</span>); speed = readline()<br>What...is the airspeed velocity of an unladen swallow?<br>What <span class="hljs-keyword">do</span> you mean, an African or a European swallow?<br><span class="hljs-string">&quot;What do you mean, an African or a European swallow?&quot;</span><br>julia&gt; parse(<span class="hljs-built_in">Int64</span>, speed)<br>ERROR: <span class="hljs-built_in">ArgumentError</span>: invalid base <span class="hljs-number">10</span> digit <span class="hljs-string">&#x27;W&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;What do you mean, an African or a European swallow?&quot;</span><br>[...]<br></code></pre></td></tr></table></figure><p>나중에 위와 같은 종류의 오류들을 처리하는 방법을 살펴볼 것이다.</p><h3 id="디버깅">디버깅</h3><p>문법이나 런타임 오류가 발생하면, 오류 메시지는 과도하게 많은 정보들을 제공한다. 따라서 오류 메시지를 정확하게 파악하는 것도 중요하다. 가장 유용한 부분들은 다음과 같다.</p><ul><li>오류의 종류는 무엇인가?</li><li>어디서 발생한 오류인가?</li></ul><p>문법 오류는 찾기 쉽지만 몇 가지 문제가 있다. 일반적으로 오류 메시지들은 문제가 발견된 위치를 제공하지만, 실제 오류가 일어난 위치와 다를 수 있다.</p><p>런타임 오류도 마찬가지이다. 다음 예시로 확인해보자. 다음 예시는 신호 대 잡음비를 데시벨로 계산하는 공식을 구현한 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">signal_power = <span class="hljs-number">9</span><br>noise_power = <span class="hljs-number">10</span><br>ratio = signal_power ÷ noise_power<br>decibels = <span class="hljs-number">10</span> * log10(ratio)<br>print(decibels)<br></code></pre></td></tr></table></figure><p>위의 코드를 수행하면 결과는 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">-<span class="hljs-literal">Inf</span><br></code></pre></td></tr></table></figure><p>해당 결과는 예상했던 것과 다르다.</p><p>오류를 찾기 위해서, 변수인 <code>ratio</code>의 값을 확인해보는 것이 좋을 것이다. 확인해보니 <code>ratio</code>는 0으로 밝혀졌다. 문제는 3번째 줄에서 버림 나눗셈을 하여 나머지들을 제거해버리는 데서 온 것으로 확인되었다.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>think julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>줄리아</tag>
      
      <tag>Julia</tag>
      
      <tag>Think Julia</tag>
      
      <tag>기초 강의</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[3/20] 사례 연구: 인터페이스 디자인</title>
    <link href="/ko/ThinkJulia/Think-Julia-Chapter-3/"/>
    <url>/ko/ThinkJulia/Think-Julia-Chapter-3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p></blockquote><p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap04">Case Study: Interface Design</a>를 한글로 요약 정리한 글입니다. <span id="more"></span></p><h2 id="사례-연구-인터페이스-디자인">사례 연구: 인터페이스 디자인</h2><p>이번 장에서는 함수들을 설계하는 과정들을 볼 수 있는 사례 연구를 살펴볼 것이다.</p><p>이를 진행하기 위해서는 그림을 생성하는 거북이 그래픽(turtle graphics)을 사용해야 한다. 거북이 그래픽은 표준 라이브러리에 포함되어 있지 않기 때문에 해당 모듈을 줄리아 설정에 추가해야 한다.</p><h3 id="거북이">거북이</h3><p>모듈(module)은 관련 함수들을 모아 놓은 파일이다. 줄리아는 표준 라이브러리에서 몇 가지 모듈을 제공하고 있으며, 다른 패키지들도 모듈로 추가할 수 있다.</p><p>패키지를 추가하는 방법은 다음과 같다. 먼저 REPL 창에 엔터 키를 눌러서 시작한다. 이후 REPL에서 <code>]</code>를 입력하면 패키지 설정 모드로 변환된다. 거북이 그래픽을 사용하기 위해서는 아래의 코드를 입력한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">(v1<span class="hljs-number">.0</span>) pkg&gt; add https://github.com/BenLauwens/ThinkJulia.jl<br></code></pre></td></tr></table></figure><p>모듈에 포함되어 있는 함수를 사용하려면, 먼저 <code>using</code>이라는 명령어를 사용하여 모듈을 가져와야 한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-keyword">using</span> ThinkJulia<br>julia&gt; 🐢 = Turtle()<br>Luxor.Turtle(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">0.0</span>, (<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>))<br></code></pre></td></tr></table></figure><p><code>ThinkJulia</code> 모듈은 <code>Luxor.Turtle</code>이라는 객체를 생성하는 <code>Turtle</code> 함수를 제공하며, 해당 객체는 <code>🐢</code>라는 변수에 할당된다.</p><p>거북이를 만든 후에는 함수를 호출하여 거북이를 이동할 수 있다. 예를 들어 거북이를 앞으로 움직이려면 다음과 같은 코드를 입력하면 된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-meta">@svg</span> <span class="hljs-keyword">begin</span><br>    forward(🐢, <span class="hljs-number">100</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>@svg</code> 키워드는 SVG그림을 그리는 매크로를 실행한다. 매크로는 줄리아의 고급 기능 중 하나이다. <code>forword</code>의 인수는 🐢와 픽셀 단위의 거리이므로 실제 크기는 각자 디스플레이에 따라 결정된다. 거북이와 함께 호출할 수 있는 다른 함수로는 거북이를 회전시키는 <code>turn</code>이 있으며, 해당 함수의 첫 번째 인수는 🐢가, 두 번째 인수에는 회전 각도가 들어간다.</p><p>또한 각각의 거북이들은 내리거나 올릴 수 있는 펜을 잡고 있다. 펜을 내린다면 거북이가 움직였던 경로들을 남기며, 반대로 펜을 올리면 경로들을 남기지 않는다. 즉, 펜이 내려간 상태에서 거북이가 앞으로 움직이면 거북이가 앞으로 간 경로가 남겨지는 것이다. 이런 함수를 <code>penup</code>, <code>pendown</code>이라고 부른다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">🐢 = Turtle()<br><span class="hljs-meta">@svg</span> <span class="hljs-keyword">begin</span><br>    forward(🐢, <span class="hljs-number">100</span>)<br>    turn(🐢, -<span class="hljs-number">90</span>)<br>    forward(🐢, <span class="hljs-number">100</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="간단한-반복">간단한 반복</h3><p>다음과 같이 한번 써보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Julia">🐢 = Turtle()<br><span class="hljs-meta">@svg</span> <span class="hljs-keyword">begin</span><br>    forward(🐢, <span class="hljs-number">100</span>)<br>    turn(🐢, -<span class="hljs-number">90</span>)<br>    forward(🐢, <span class="hljs-number">100</span>)<br>    turn(🐢, -<span class="hljs-number">90</span>)<br>    forward(🐢, <span class="hljs-number">100</span>)<br>    turn(🐢, -<span class="hljs-number">90</span>)<br>    forward(🐢, <span class="hljs-number">100</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 예시는 사각형을 그리는 코드이다. 우리는 <code>for</code>문을 사용하여 위의 예시와 같은 똑같은 작업을 더 간단하게 수행할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:<span class="hljs-number">4</span><br>          println(<span class="hljs-string">&quot;Hello!&quot;</span>)<br>       <span class="hljs-keyword">end</span><br>Hello!<br>Hello!<br>Hello!<br>Hello!<br></code></pre></td></tr></table></figure><p>해당 예시는 <code>for</code>문의 가장 간단한 예시이다. <code>for</code>문에 대한 자세한 내용은 다른 장에서 더 살펴볼 예정이다. 지금부터 위의 간단한 <code>for</code>문을 이용해서 사각형을 그려보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia">🐢 = Turtle()<br><span class="hljs-meta">@svg</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:<span class="hljs-number">4</span><br>        forward(🐢, <span class="hljs-number">100</span>)<br>        turn(🐢, -<span class="hljs-number">90</span>)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>for</code>문의 문법은 함수를 정의하는 것과 비슷하다. 헤더(header)와 본문이 있으며, 마지막에는 키워드 <code>end</code>를 사용한다.</p><p>또한 <code>for</code>문은 본문을 헤더에 지정된 수만큼 반복하므로 루프(loop)라고도 부른다. 위의 예시의 경우는 (<code>i in 1:4</code>처럼 4번이라고 지정했음) 4번 반복 실행한다.</p><h3 id="예시-풀어보기">예시 풀어보기</h3><p>이번 장에서는 거북이를 사용하여 여러 가지 연습을 해볼 것이다.</p><ul><li>거북이를 <code>t</code> 매개 변수로 사용하는 <code>square()</code>를 작성하시오.</li></ul><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> square()<br>       t=Turtle()<br>       <span class="hljs-meta">@svg</span> <span class="hljs-keyword">begin</span><br>           <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:<span class="hljs-number">4</span><br>               forward(t,<span class="hljs-number">100</span>)<br>               turn(t,-<span class="hljs-number">90</span>)<br>           <span class="hljs-keyword">end</span><br>       <span class="hljs-keyword">end</span><br>       <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><ul><li><code>t</code>를 <code>sqaure()</code>의 인수로 전달하는 함수를 작성한 후, 매크로를 실행하시오.</li></ul><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> square(t)<br>           <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:<span class="hljs-number">4</span><br>               forward(t,<span class="hljs-number">100</span>)<br>               turn(t,-<span class="hljs-number">90</span>)<br>           <span class="hljs-keyword">end</span><br>       <span class="hljs-keyword">end</span><br>🐢=Turtle()<br><span class="hljs-meta">@svg</span> <span class="hljs-keyword">begin</span><br>           square(🐢)<br>       <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><ul><li>변의 길이가 <code>len</code>이 되도록 본문을 수정한 후, <code>len</code>이라는 다른 매개 변수를 <code>square()</code>에 추가하시오.</li></ul><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> square(t, len)<br>           <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:<span class="hljs-number">4</span><br>               forward(t, len)<br>               turn(t, -<span class="hljs-number">90</span>)<br>           <span class="hljs-keyword">end</span><br>       <span class="hljs-keyword">end</span><br><span class="hljs-meta">@svg</span> <span class="hljs-keyword">begin</span><br>           square(🐢,<span class="hljs-number">200</span>)<br>       <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><ul><li><code>square()</code>의 복사본을 만들고 이름을 <code>polygon()</code>으로 변경하시오. 그 후 새로운 매개변수 <code>n</code>을 추가하고 본문을 수정하시오. (n의 외부각도는 360/n 으로 수정하면 된다.)</li></ul><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> polygon(t,len,n)<br>           <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:n<br>               forward(t,len)<br>               turn(t,-<span class="hljs-number">360</span>/n)<br>           <span class="hljs-keyword">end</span><br>       <span class="hljs-keyword">end</span><br><span class="hljs-meta">@svg</span> <span class="hljs-keyword">begin</span><br>           polygon(🐢,<span class="hljs-number">100</span>,<span class="hljs-number">5</span>)<br>       <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><ul><li><code>t</code> 와 반지름 <code>r</code>를 매개 변수로 하는 <code>circle()</code>를 작성하시오.</li></ul><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> circle(t, r)<br>    circum = <span class="hljs-number">2</span>* <span class="hljs-literal">π</span> *r<br>    n=<span class="hljs-number">20</span><br>    len=circum/n<br>    polygon(t, len, n)<br><span class="hljs-keyword">end</span><br><span class="hljs-meta">@svg</span> <span class="hljs-keyword">begin</span><br>           circle(🐢,<span class="hljs-number">50</span>)<br>       <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="캡슐화">캡슐화</h3><p>첫 번째 연습에서는 사각형 그리기 코드를 함수 정의에 넣은 후 거북이를 매개 변수를 전달하여 함수를 호출하도록 요청한다. 해당 코드는 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> square(t)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:<span class="hljs-number">4</span><br>        forward(t, <span class="hljs-number">100</span>)<br>        turn(t, -<span class="hljs-number">90</span>)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br>🐢 = Turtle()<br><span class="hljs-meta">@svg</span> <span class="hljs-keyword">begin</span><br>    square(🐢)<br><span class="hljs-keyword">end</span><br>       <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>square()</code> 가장 안쪽에 있는 명령문 <code>forward</code>와 <code>turn</code>은 <code>for</code>문에 속해있다는 것을 나타내기 위해 두 번 들여쓰기로 작성한다.</p><p>위의 예시와 같이 코드 조각들을 함수로 감싸는 것을 캡슐화(Encapsulation)라고 한다. 캡슐화의 이점 중 하나는 코드에 이름을 첨부하여 프로그램 과정을 명확하게 정리할 수 있다는 것이다. 또한 한 번 캡슐화를 진행한 이후에는 코드를 재사용할 때 함수 하나만 호출하면 되기 때문에 간편하다.</p><h3 id="일반화">일반화</h3><p>다음으로는 <code>len</code>이라는 매개 변수를 추가하는 것이다. 코드는 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> square(t, len)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:<span class="hljs-number">4</span><br>        forward(t, len)<br>        turn(t, -<span class="hljs-number">90</span>)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br>🐢 = Turtle()<br><span class="hljs-meta">@svg</span> <span class="hljs-keyword">begin</span><br>    square(🐢, <span class="hljs-number">100</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>함수에 매개 변수를 추가하는 것은 해당 함수를 보다 다양한 환경에서 일반적으로 사용할 수 있게 만들어주기 때문에 일반화(Generalization)라고 한다. 매개 변수 <code>len</code>을 추가함으로써 <code>square()</code>는 이제 사각형의 길이를 조정할 수 있게 되었다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> polygon(t, n, len)<br>    angle = <span class="hljs-number">360</span> / n<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:n<br>        forward(t, len)<br>        turn(t, -angle)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br>🐢 = Turtle()<br><span class="hljs-meta">@svg</span> <span class="hljs-keyword">begin</span><br>    polygon(🐢, <span class="hljs-number">7</span>, <span class="hljs-number">70</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 코드는 칠각형을 그리는 코드 예시이다.</p><h3 id="인터페이스-디자인">인터페이스 디자인</h3><p>다음 단계는 반지름 <code>r</code>를 매개 변수로 하는 <code>circle()</code>를 작성하는 것이다. 다음은 다각형 함수인 <code>polygon()</code>을 사용하여 20면 다각형을 그리는 코드이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> circle(t, r)<br>    circumference = <span class="hljs-number">2</span> * <span class="hljs-literal">π</span> * r<br>    n = <span class="hljs-number">20</span><br>    len = circumference / n<br>    polygon(t, n, len)<br><span class="hljs-keyword">end</span><br><span class="hljs-meta">@svg</span> <span class="hljs-keyword">begin</span><br>    circle(t, r)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>첫 번째 줄은 반지름이 <code>r</code>인 원의 둘레를 계산한다. <code>n</code>은 각도가 변형되는 수이며, <code>len</code>은 선분의 길이이기 때문에 둘레를 <code>n</code>으로 나눠 정의한다. 그러면 20면 다각형을 그릴 수 있다.</p><p>위의 해결안은 문제는 <code>n</code>이 상수라는 것이다. 즉, 매우 큰 원의 경우 선분이 너무 길고 작은 원의 경우는 작은 선분을 그리는데 시간이 낭비된다. 따라서 <code>n</code>을 매개 변수로 사용하여 일반화한다면, 이 문제를 해결할 수 있다. 하지만 이런 일반화는 사용자에게 더 많은 제어권을 부여하지만 인터페이스는 덜 깨끗해진다.</p><p>함수의 인터페이스(interface)는 어떻게 사용되는지에 대한 요약이다. 구체적으로 인터페이스는 매개 변수는 무엇인지, 반환 값은 무엇인지 등의 내용들을 포함하고 있다고 보면 된다. 보통 사용자가 불필요한 세부 사항을 처리할 필요 없이 작업이 수행되는 함수들을 인터페이스가 깨끗하다고 말한다.</p><p>예를 들어, 위의 예제에서 <code>r</code>은 그릴 원을 지정하므로 인터페이스에 속한다. 하지만 <code>n</code>은 원을 그리는 방법에 대한 세부 사항과 관련이 있기 때문에 인터페이스에 속하지 않는다. 따라서 인터페이스를 어지럽히지 말고 둘레에 따라 적절한 <code>n</code>값을 선택하는게 좋다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> circle(t, r)<br>    circumference = <span class="hljs-number">2</span> * <span class="hljs-literal">π</span> * r<br>    n = trunc(circumference / <span class="hljs-number">3</span>) + <span class="hljs-number">3</span><br>    len = circumference / n<br>    polygon(t, n, len)<br><span class="hljs-keyword">end</span><br><span class="hljs-meta">@svg</span> <span class="hljs-keyword">begin</span><br>    circle(t, r)<br><span class="hljs-keyword">end</span><br><br></code></pre></td></tr></table></figure><p>위의 코드는 <code>len</code>의 값이 3에 가까울 수 있도록 <code>n</code>을 자동 설정한 코드다. <code>len</code>의 값은 호선의 길이로서 3정도가 원 크기와 상관없이 가장 적합하기에 3으로 결정하였다.</p><p><code>n</code>값에 3을 더해준 것은 다각형의 선분이 적어도 3 이상이라는 것을 보장한다.</p><h3 id="리팩토링">리팩토링</h3><p>이전 장에서 <code>circle()</code>를 설계할 때는 <code>polygon()</code>를 재사용할 수 있었다. 하지만 <code>arc()</code>는 지금까지 만들었던 함수들을 이용할 수 없다. 한가지 대안으로는 다각형의 사본을 만들고, 호선으로 변환하는 것이다. 결과는 다음 코드와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> arc(t, r, angle)<br>    arc_len = <span class="hljs-number">2</span> * <span class="hljs-literal">π</span> * r * angle / <span class="hljs-number">360</span><br>    n = trunc(arc_len / <span class="hljs-number">3</span>) + <span class="hljs-number">1</span><br>    step_len = arc_len / n<br>    step_angle = angle / n<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:n<br>        forward(t, step_len)<br>        turn(t, -step_angle)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>이 함수의 후반부는 <code>polygon()</code>와 유사해보이지만 핵심요소인 인터페이스를 변경했기 때문에 재사용한 것이라고 볼 수는 없다. 따라서 위의 예시는 <code>angle</code>이라는 변수를 추가하여 <code>polygon()</code>을 일반화하였기 때문에 해당 함수는 더 이상 <code>다각형(polygon)</code>라는 이름을 가질 수 없다.</p><p>지금부터는 더 일반적으로 사용할 수 있는 <code>polyline()</code>을 만들어보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> polyline(t, n, len, angle)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:n<br>        forward(t, len)<br>        turn(t, -angle)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 <code>polyline()</code>을 이용하여 <code>polygon()</code>과 <code>arc()</code>을 더 간단하게 캡슐화할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> polygon(t, n, len)<br>    angle = <span class="hljs-number">360</span> / n<br>    polyline(t, n, len, angle)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> arc(t, r, angle)<br>    arc_len = <span class="hljs-number">2</span> * <span class="hljs-literal">π</span> * r * angle / <span class="hljs-number">360</span><br>    n = trunc(arc_len / <span class="hljs-number">3</span>) + <span class="hljs-number">1</span><br>    step_len = arc_len / n<br>    step_angle = angle / n<br>    polyline(t, n, step_len, step_angle)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>마지막으로 <code>arc()</code>을 이용하여 <code>circle()</code>를 간단하게 표현할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> circle(t, r)<br>    arc(t, r, <span class="hljs-number">360</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>지금까지 복잡했던 코드들을 일반화하고 캡슐화하여 정리하였다. 이와같이 인터페이스를 개선하고 코드 재사용을 위해 프로그램을 정리하는 과정을 리팩토링이라고 한다. 이 경우는 호를 구하는 <code>arc()</code>과 다각형을 구하는 <code>polygon()</code>의 유사점을 발견하여 <code>polyline()</code>으로 정리하였다.</p><p>프로그램을 미리 계획한 경우에는 먼저 <code>polyline()</code>을 작성하여 리팩토링을 생략했겠지만, 대부분 프로젝트 시작시에 모든 인터페이스를 설계하지 못한다. 따라서 리팩토링을 하는 법을 알아두는 것도 중요하다.</p><h3 id="개발-계획">개발 계획</h3><p>개발 계획은 프로그램을 만드는 프로세스이다. 이 사례 연구에서 사용한 프로세스는 “캡슐화 및 일반화”이며, 이 프로세스의 단계는 다음과 같다.</p><ol type="1"><li>함수 정의 없이 작은 프로그램을 작성하기.</li><li>일단 프로그램이 작동하면, 일관된 부분을 찾아서 함수로 캡슐화하고 이름을 지정하기</li><li>함수에 적절한 매개 변수를 추가하여 함수를 일반화하기</li><li>프로그램 기능이 원하는만큼 나올 때까지 1-3단계를 반복하기</li><li>리팩토링을 통해 프로그램을 개선하기 (캡슐화와 일반화 다시 점검)</li></ol><p>이 프로세스에는 몇 가지 단점이 있기 때문에, 이후 단점에 대해 알아보고 대안을 논의할 것이다. 하지만 프로그램을 함수로 설정하는 방법을 모르는 경우에는 유용하게 사용할 수 있는 방법이다.</p><h3 id="독스트링docstring">독스트링(Docstring)</h3><p>독스트링(Docstring)의 ‘Doc’은 ‘documentation’의 줄임말이며, 이는 함수 앞에 인터페이스를 설명하는 설명을 의미한다. 아래 예시를 보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">polyline(t, n, len, angle)</span><br><span class="hljs-string"></span><br><span class="hljs-string">Draws n line segments with the given length and</span><br><span class="hljs-string">angle (in degrees) between them.  t is a turtle.</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">function</span> polyline(t, n, len, angle)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:n<br>        forward(t, len)<br>        turn(t, -angle)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 예시와 같은 문법(<code>“””</code>)을 사용하여 함수 앞에 작성하며, 이후 REPL에서 <code>?</code>를 입력하고 함수의 이름을 치면 문서를 확인할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">help?&gt; polyline<br>search:<br><br>  polyline(t, n, len, angle)<br><br>  Draws n line segments with the given length and angle (<span class="hljs-keyword">in</span> degrees) between them. t is a turtle.<br></code></pre></td></tr></table></figure><p>독스트링에는 해당 함수를 사용하기 위한 필수적인 정보가 포함되어 있다. 따라서 팀 단위로 개발을 하는 경우에는 만든 함수에 독스트링을 붙여 다른 사람들도 쉽게 사용할 수 있도록 하는 것이 좋다.</p><h3 id="디버깅">디버깅</h3><p>인터페이스는 함수와 사용자 사이의 계약과 같다. 사용자는 특정 매개 변수를 제공하고 함수는 특정 작업을 수행한다. 예를 들어 <code>polyline()</code>에서는 4개의 인수가 필요하다. t는 <code>Turtle()</code>이어야 하며 <code>n</code>은 정수여야 하고, <code>len</code>은 양수여야 한다. <code>angle</code>은 각도로 인식되어야 하며, 도 단위로 설정되어 있다.</p><p>이런 요구사항들은 함수가 실행되기 전에 <code>true</code>로 간주되기 때문에 전제조건(preconditions)이라고 한다. 반대로 함수 작동 끝에 생성되는 결과 등을 사후 조건(postconditions)라고 한다.</p><p>전제 조건의 오류는 사용자의 책임이다. 사용자들이 전제 조건을 어겨서 함수가 제대로 작동하지 않는다면 이는 사용자측에 버그가 있는 것이다. (함수에는 버그가 없다.)</p><p>하지만 만약 전제 조건은 알맞게 작성했는데 사후 조건이 이상하다면, 이것은 함수에 버그가 있는 것이다. 따라서 해당 함수의 전제 조건과 사후 조건을 명확하게 아는 것은 디버깅에 많은 도움을 준다.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>think julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>줄리아</tag>
      
      <tag>Julia</tag>
      
      <tag>Think Julia</tag>
      
      <tag>기초 강의</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[2/20] 함수</title>
    <link href="/ko/ThinkJulia/Think-Julia-Chapter-2/"/>
    <url>/ko/ThinkJulia/Think-Julia-Chapter-2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist를 바탕으로 작성된 글임을 알려드립니다.</p></blockquote><p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap03">Functions</a>를 한글로 요약 정리한 글입니다. <span id="more"></span></p><h2 id="함수">함수</h2><p>프로그래밍에서 함수는 특정 계산을 수행하는 일련의 명령문이다. 함수를 정의할 때에는 이름과 명령문의 순서를 정하며, 이후 해당 이름을 통해서 함수를 호출할 수 있다.</p><h3 id="함수-호출">함수 호출</h3><p>우리는 이미 함수를 호출해 본 경험이 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; println(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br>Hello, World!<br></code></pre></td></tr></table></figure><p>이 함수의 이름은 <code>println()</code>이다. 또한 괄호 안에 들어가는 표현식은 함수의 인수(argument)라고 부른다. 함수가 작동하는 과정은 일반적으로 인수를 받은 후 결과를 반환한다고 설명하며, 이런 결과를 반환 값이라고 한다.</p><p>줄리아는 데이터 타입을 바꿔주는 함수도 제공한다. 예로 <code>parse()</code>는 숫자로 구성된 문자열을 인수로 받은 후, 정수나 소수로 변환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; parse(<span class="hljs-built_in">Int64</span>, <span class="hljs-string">&quot;32&quot;</span>)<br><span class="hljs-number">32</span><br>julia&gt; parse(<span class="hljs-built_in">Float64</span>, <span class="hljs-string">&quot;3.14159&quot;</span>)<br><span class="hljs-number">3.14159</span><br>julia&gt; parse(<span class="hljs-built_in">Int64</span>, <span class="hljs-string">&quot;Hello&quot;</span>)<br>ERROR: <span class="hljs-built_in">ArgumentError</span>: invalid base <span class="hljs-number">10</span> digit <span class="hljs-string">&#x27;H&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;Hello&quot;</span><br></code></pre></td></tr></table></figure><p>또한 <code>trunc()</code>는 소수를 인수로 받아 나머지들을 제거한 후, 남은 정수만을 반환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; trunc(<span class="hljs-built_in">Int64</span>, <span class="hljs-number">3.99999</span>)<br><span class="hljs-number">3</span><br>julia&gt; trunc(<span class="hljs-built_in">Int64</span>, -<span class="hljs-number">2.3</span>)<br>-<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><code>float()</code>는 정수를 소수로 변환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; float(<span class="hljs-number">32</span>)<br><span class="hljs-number">32.0</span><br></code></pre></td></tr></table></figure><p>마지막으로, <code>string()</code>는 인수들을 모두 문자로 변환한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; string(<span class="hljs-number">32</span>)<br><span class="hljs-string">&quot;32&quot;</span><br>julia&gt; string(<span class="hljs-number">3.14159</span>)<br><span class="hljs-string">&quot;3.14159&quot;</span><br></code></pre></td></tr></table></figure><h3 id="수학-함수">수학 함수</h3><p>줄리아는 대부분의 기본적인 수학 함수들이 내장되어 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">ratio = signal_power / noise_power<br>decibels = <span class="hljs-number">10</span> * log10(ratio)<br></code></pre></td></tr></table></figure><p>위의 예시에서는 <code>log10</code>을 사용하여 신호와 잡음의 비율을 데시벨 단위로 계산한다. (신호 변수인 <code>signal_power</code>과 잡음 변수인<code>noise_power</code>가 정의되었다는 전제 하에) 또한 자연로그를 계산하는 <code>log</code> 또한 제공된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">radians = <span class="hljs-number">0.7</span><br>height = sin(radians)<br></code></pre></td></tr></table></figure><p>다음의 예시는 해당 <code>radians</code>을 <code>sin()</code>에 적용한다. 위의 예시에서 볼 수 있듯이 줄리아는 <code>sin()</code> 및 기타 삼각 함수 (cos, tan 등) 또한 제공한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; degrees = <span class="hljs-number">45</span><br><span class="hljs-number">45</span><br>julia&gt; radians = degrees / <span class="hljs-number">180</span> * <span class="hljs-literal">π</span><br><span class="hljs-number">0.7853981633974483</span><br>julia&gt; sin(radians)<br><span class="hljs-number">0.7071067811865475</span><br></code></pre></td></tr></table></figure><p>각도(degree)를 통해 <code>radians</code>을 구하기 위해서는 각도를 180으로 나누고 <code>π</code>를 곱해야 한다. 줄리아에서는 <code>π</code>도 바로 사용할 수 있으며, 소수점 16자리까지 정확하다.</p><h3 id="컴포지션composition">컴포지션(composition)</h3><p>지금까지 우리는 변수, 표현식, 명령문과 같은 프로그램의 요소들이 어떻게 결합하는지에 대해서 이야기하고자 한다. 프로그래밍 언어의 가장 유용한 특징 중 하나는 작은 요소들을 가져와서 프로그램을 구성할 수 있다는 것이다. 예를 들어 함수의 인수로 산술연산자를 포함한 모든 종류의 표현식들을 사용할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">x = sin(degrees / <span class="hljs-number">360</span> * <span class="hljs-number">2</span> * <span class="hljs-literal">π</span>)<br>x = exp(log(x+<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><p>할당문의 왼쪽은 무조건 변수 이름이 와야 한다. 이 한 가지의 규칙만 어기지 않는다면, 표현식 대부분에 값을 넣을 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; minutes = hours * <span class="hljs-number">60</span> <span class="hljs-comment"># right</span><br><span class="hljs-number">120</span><br>julia&gt; hours * <span class="hljs-number">60</span> = minutes <span class="hljs-comment"># wrong!</span><br>ERROR: syntax: <span class="hljs-string">&quot;60&quot;</span> is not a valid <span class="hljs-keyword">function</span> argument name<br></code></pre></td></tr></table></figure><h3 id="새로운-함수-만들기">새로운 함수 만들기</h3><p>지금까지 우리는 줄리아가 제공하는 함수들을 사용해왔다. 하지만 그외에도 새로운 함수를 만들어 사용할 수 있다. 새로운 함수를 만드는 방법은 새로운 함수의 이름을 설정하고 실행될 일련의 명령문들의 순서를 설정하는 것이다. 예를 들면 아래와 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> printlyrics()<br>    println(<span class="hljs-string">&quot;I&#x27;m a lumberjack, and I&#x27;m okay.&quot;</span>)<br>    println(<span class="hljs-string">&quot;I sleep all night and I work all day.&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>function</code>은 함수를 정의하는 키워드이다. 위의 예시에서 함수의 이름은 <code>printlyrics</code>이다. 함수 이름에 대한 규칙은 변수 이름 만드는 규칙과 동일하다. (거의 모든 유니코드는 사용가능하지만 숫자를 이름의 첫 번째 문자로 사용할 수는 없다. 키워드 이름은 사용할 수 없다.) 이름 뒤의 빈 괄호는 함수가 인수를 가지지 않는다는 것을 나타낸다. 지금까지 설명한 함수의 첫 번째 줄은 헤더(header)라고 부르며, 그 외 나머지는 본문(body)라고 부른다. 본문에는 여러 명령문들이 포함되어 있으며, 함수는 키워드 <code>end</code>로 종료된다. 또한 가독성을 위해서 본문은 들여 쓰기로 작성해야 한다.</p><p>대화식 모드에서 함수를 정의한다면 헤더부터 본문까지 한 줄씩 작성하면 된다. 본문 작성이 끝나고 난 후에는 <code>end</code>를 입력하여 함수 정의를 끝내주어야 한다. 새로 만든 함수를 사용하는 방법은 기존에 있던 함수와 같이 이름을 사용하여 호출하는 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; printlyrics()<br>I&#x27;m a lumberjack, and I&#x27;m okay.<br>I sleep all night and I work all day.<br></code></pre></td></tr></table></figure><p>새로 만든 함수는 다른 함수 본문에 넣어서 사용할 수도 있다. 아래의 예시를 보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> repeatlyrics()<br>    printlyrics()<br>    printlyrics()<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>repeatlyrics()</code>는 앞서 만들었던 <code>printlyrics()</code>를 두 번 실행하도록 정의하였다. 이후 <code>repeatlyrics()</code>를 호출한다면 다음과 같은 결과를 얻을 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; repeatlyrics()<br>I&#x27;m a lumberjack, and I&#x27;m okay.<br>I sleep all night and I work all day.<br>I&#x27;m a lumberjack, and I&#x27;m okay.<br>I sleep all night and I work all day.<br></code></pre></td></tr></table></figure><h3 id="함수-정의와-사용">함수 정의와 사용</h3><p>앞 장에서 만들었던 함수 정의와 사용 코드를 결합한 전체 프로그램은 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> printlyrics()<br>    println(<span class="hljs-string">&quot;I&#x27;m a lumberjack, and I&#x27;m okay.&quot;</span>)<br>    println(<span class="hljs-string">&quot;I sleep all night and I work all day.&quot;</span>)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> repeatlyrics()<br>    printlyrics()<br>    printlyrics()<br><span class="hljs-keyword">end</span><br><br>repeatlyrics()<br></code></pre></td></tr></table></figure><p>위의 프로그램은 <code>repeatlyrics()</code>와 <code>printlyrics()</code>를 정의한다. 함수를 정의하는 코드는 오로지 함수 객체를 만드는 역할만 하며, 함수가 호출되기 전까지는 함수 본문의 코드가 진행되지 않는다. 따라서 특정 함수를 사용하고 싶다면, 함수를 먼저 정의한 후에 함수를 호출해야 한다.</p><h3 id="실행-과정">실행 과정</h3><p>함수의 정의와 사용을 올바르게 사용하기 위해서는 실행 과정을 정확히 알고 있어야 한다. 실행은 항상 첫 번째 문장에서 시작하며, 명령문은 위에서 아래로 한 번씩만 작동한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> printlyrics()<br>    println(<span class="hljs-string">&quot;I&#x27;m a lumberjack, and I&#x27;m okay.&quot;</span>)<br>    println(<span class="hljs-string">&quot;I sleep all night and I work all day.&quot;</span>)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> repeatlyrics()<br>    printlyrics()<br>    printlyrics()<br><span class="hljs-keyword">end</span><br><br>repeatlyrics()<br></code></pre></td></tr></table></figure><p>이 예시를 통해 실행과정을 본다면, 줄리아는 먼저 <code>printlyrics()</code>를 정의한다. 그 후 <code>repeatlyrics()</code>를 정의한 후 호출한다. 호출된 <code>repeatlyrics()</code>는 위에 정의된 본문으로 돌아가 <code>printlyrics()</code>를 호출하는 명령문을 수행한다. 다음으로 호출된 <code>printlyrics()</code>는 해당 함수의 정의된 본문으로 돌아가 명령문을 수행한다. 그 결과가 <code>repeatlyrics()</code>를 호출한 결과로 도출되는 것이다.</p><h3 id="매개-변수와-인수">매개 변수와 인수</h3><p>몇 몇의 함수들은 인수를 필요로 한다. 예를 들어 <code>sin()</code>를 호출하기 위해서는 숫자 한 개를 인수로 입력해야 하며, <code>parse()</code>의 경우 숫자 유형과 문자열 두 개를 인수로 입력해야 한다.</p><p>함수 내부에서 인수는 매개 변수라는 변수에 할당된다. 다음 예시는 인수를 취하는 함수에 대한 정의이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> printtwice(bruce)<br>    println(bruce)<br>    println(bruce)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>이 함수는 인수를 <code>bruce</code>라는 매개 변수에 지정하였기 때문에 함수가 호출되면 매개 변수 값을 두 번 인쇄한다. 또한 위의 함수는 인수에 어떤 값이 들어가든 인쇄한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; printtwice(<span class="hljs-string">&quot;Spam&quot;</span>)<br>Spam<br>Spam<br>julia&gt; printtwice(<span class="hljs-number">42</span>)<br><span class="hljs-number">42</span><br><span class="hljs-number">42</span><br>julia&gt; printtwice(<span class="hljs-literal">π</span>)<br><span class="hljs-literal">π</span> = <span class="hljs-number">3.1415926535897</span>...<br><span class="hljs-literal">π</span> = <span class="hljs-number">3.1415926535897</span>...<br></code></pre></td></tr></table></figure><p><code>printtwice()</code>에 내장되어 있는 <code>println()</code>는 모든 표현식들을 인수로 받으므로 <code>printtwice()</code> 또한 모든 표현식들을 인수로 사용할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; printtwice(<span class="hljs-string">&quot;Spam &quot;</span>^<span class="hljs-number">4</span>)<br>Spam Spam Spam Spam<br>Spam Spam Spam Spam<br>julia&gt; printtwice(cos(<span class="hljs-literal">π</span>))<br>-<span class="hljs-number">1.0</span><br>-<span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure><p>인수는 함수가 호출되기 전에 우선적으로 값을 도출된다. 따라서 위의 예시에서 인수로 쓰인 표현식들은 먼저 값으로 정리 된 후 함수에 적용된다. <code>"Spam "^4</code>인수의 경우, 먼저 <code>Spam Spam Spam Spam</code>으로 도출된 다음에 함수의 인자로 적용된다.</p><p>또한 변수도 함수의 인자로 사용할 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; michael = <span class="hljs-string">&quot;Eric, the half a bee.&quot;</span><br><span class="hljs-string">&quot;Eric, the half a bee.&quot;</span><br>julia&gt; printtwice(michael)<br>Eric, the half a bee.<br>Eric, the half a bee.<br></code></pre></td></tr></table></figure><h3 id="로컬-변수">로컬 변수</h3><p>로컬 변수(local)는 함수 정의 안에서 만들어진 변수를 의미한다. 예를 들면,</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> cattwice(part1, part2)<br>    concat = part1 * part2<br>    printtwice(concat)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>위의 함수는 두 개의 인수를 사용하여 곱한 다음에 그 결과를 두 번 인쇄한다. 이 함수에서 <code>conat</code>은 함수 내부에서 만들어진 로컬 변수이다. 위의 함수를 사용한 예시는 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; line1 = <span class="hljs-string">&quot;Bing tiddle &quot;</span><br><span class="hljs-string">&quot;Bing tiddle &quot;</span><br>julia&gt; line2 = <span class="hljs-string">&quot;tiddle bang.&quot;</span><br><span class="hljs-string">&quot;tiddle bang.&quot;</span><br>julia&gt; cattwice(line1, line2)<br>Bing tiddle tiddle bang.<br>Bing tiddle tiddle bang.<br></code></pre></td></tr></table></figure><p>위의 실행에서 <code>cattwice()</code>가 종료되는 순간 로컬 변수 <code>conat</code>은 삭제된다. 그렇기 때문에 <code>conat</code>을 인쇄하려고 하면 아래와 같은 오류를 만날 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; println(concat)<br>ERROR: <span class="hljs-built_in">UndefVarError</span>: concat not defined<br></code></pre></td></tr></table></figure><p>매개 변수 또한 로컬 변수이다. 즉, <code>printtwice()</code> 정의에 사용된 매개 변수 <code>bruce</code> 또한 인쇄할 수 없다.</p><h3 id="스택-다이어그램">스택 다이어그램</h3><p>어디에서 어떤 변수를 사용했는지 추척하려면 스택 다이어그램을 그리는 것이 유용하다. 스택 다이어그램에는 각 변수의 값과 그 값이 속한 함수도 표시된다. 각 함수는 프레임 단위로 그리며, 프레임 안에는 함수의 매개 변수와 로컬 변수를 쓴다.</p><p>예시는 다음과 같다.</p><figure><img src="/images/stack.png" alt="stack diagram" /><figcaption aria-hidden="true">stack diagram</figcaption></figure><p>프레임은 함수가 호출되는 순서대로 배열한다. 위의 예에서는 <code>Main</code>이 <code>cattwice()</code>를 호출하며, <code>cattwice()</code>는 <code>printtwice()</code>를 호출한다. 함수 외부에서 변수를 만들면, 이는 <code>Main</code>에 속한다.</p><p>각 매개 변수는 해당 인수와 동일한 값을 나타낸다. 따라서 <code>part1</code>은 <code>line1</code>과 같고 <code>part2</code>는 <code>line2</code>와 같으며, <code>bruce</code>는 <code>conat</code>과 같다.</p><p>함수 호출 도중에 오류가 발생가면 줄리아는 해당 오류의 위치를 알려 준다. 예를 들어, <code>printtwice()</code>에서 <code>concat</code>에 액세스하려고하면 <code>UndefVarError</code>가 발생한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">ERROR: <span class="hljs-built_in">UndefVarError</span>: concat not defined<br>Stacktrace:<br> [<span class="hljs-number">1</span>] printtwice at ./REPL[<span class="hljs-number">1</span>]:<span class="hljs-number">2</span> [inlined]<br> [<span class="hljs-number">2</span>] cattwice(::<span class="hljs-built_in">String</span>, ::<span class="hljs-built_in">String</span>) at ./REPL[<span class="hljs-number">2</span>]:<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>위처럼 함수 목록들을 통해 오류가 발생한 프로그램 파일과 함수를 알려주는 것을 스택 추적이라고 한다 스택 추척의 함수 목록 순서는 스택 다이어그램의 프레임 순서와 반대이다.</p><h3 id="결과-있는-함수와-결과-없는-함수">결과 있는 함수와 결과 없는 함수</h3><p>우리가 사용하는 어떤 함수는 결괏값을 반환하지만 어떤 함수는 결과를 반환하지 않는다. 우리는 전자를 결과 있는 함수(fruitful function)이라고 하며, 후자를 결과 없는 함수(void function)이라고 한다.</p><p>예로 결과 있는 함수를 먼저 본다면,</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">golden = (sqrt(<span class="hljs-number">5</span>) + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>위의 예시의 <code>sqrt()</code>는 유익한 함수로서 반환 값을 가지고 있기 때문에 바로 계산이 가능하다. 대화식 모드에서 함수를 호출하면, 다음과 같은 결과를 도출한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; sqrt(<span class="hljs-number">5</span>)<br><span class="hljs-number">2.23606797749979</span><br></code></pre></td></tr></table></figure><p>하지만 스크립트 모드에서는 위의 예시처럼 함수를 호출하면 반환 값은 손실된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">sqrt(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>위의 스크립트는 아래의 값은 산출만 한다. (저장하지 않는다.)</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-number">2.23606797749979</span><br></code></pre></td></tr></table></figure><p>따라서 스크립트 모드에서는 그다지 유익한 함수로서 작동하지 않는다.</p><p>결과 없는 함수는 화면에 값을 표시하거나 다른 영향을 줄 수는 있지만 반환 값은 없다. 아래의 예시를 보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; result = printtwice(<span class="hljs-string">&quot;Bing&quot;</span>)<br>Bing<br>Bing<br>julia&gt; show(result)<br><span class="hljs-literal">nothing</span><br></code></pre></td></tr></table></figure><p>위의 예시는 변수 <code>result</code>에 함수의 값을 할당하였지만, 밑에 결과를 보면 아무것도 없는 것을 확인할 수 있다. 두번째 코드의 결과인 <code>nothing</code>은 그 자체로 특수한 데이터 타입이며, 문자열인 <code>”nothing”</code>과는 구분된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; typeof(<span class="hljs-literal">nothing</span>)<br><span class="hljs-built_in">Nothing</span><br></code></pre></td></tr></table></figure><h3 id="왜-함수인가">왜 함수인가</h3><p>프로그램을 만드는데 있어 함수가 왜 유용한지 궁금할 것이다. 이에 대한 몇 가지 이유를 보자.</p><ul><li>함수는 명령문들을 묶어서 사용할 수 있으므로, 이후 프로그램을 쉽게 파악하고 디버깅을 할 수 있다.</li><li>함수는 반복적인 코드들을 대체하여 프로그램 코드를 더 짧게 만들어준다.</li><li>한번에 긴 프로그램을 설계하는 것보다 함수 단위로 나누어 설계하고 조립하는 것이 더 쉽다.</li><li>잘 설계된 함수는 여러 프로그램에서 사용할 수 있다. (재사용 가능)</li><li>줄리아에서는 함수들이 성능을 크게 향상시킬 수 있다.</li></ul><h3 id="디버깅">디버깅</h3><p>디버깅은 가장 중요한 기술 중 하나이다. 그 이유는 프로그램 진행과정을 완벽히 알고 있어야 가능한 기술이기 때문이다. 프로그램에 문제가 생긴다면 개발자는 프로그램의 진행과정에서 문제와 관련된 단서를 찾고, 해결방안을 모색해야 한다. 이런 과정들은 매우 어렵고 힘들지만, 꼭 필요한 능력이다.</p><p>어떤 사람들에게는 프로그래밍과 디버깅은 동일하다. 즉, 프로그래밍은 원하는 작업이 수행될 때까지 코드들을 점검하고 디버깅하는 과정이기 때문이다.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>think julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>줄리아</tag>
      
      <tag>Julia</tag>
      
      <tag>Think Julia</tag>
      
      <tag>기초 강의</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[1/20] 변수, 표현식과 명령문</title>
    <link href="/ko/ThinkJulia/Think-Julia-Chapter-1/"/>
    <url>/ko/ThinkJulia/Think-Julia-Chapter-1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist를 바탕으로 작성된 글임을 알려드립니다.</p></blockquote><p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap02">Variables, Expressions and Statements</a>를 한글로 요약 정리한 글입니다. <span id="more"></span></p><hr /><h2 id="변수-표현식과-명령문">변수 , 표현식과 명령문</h2><p>프로그래밍 언어의 가장 큰 특징 중 하나는 변수를 설정할 수 있다는 것이다. 변수(variables)란 값(values)을 나타내는 이름으로서, 개발자가 특정 변수에 직접 값을 할당하여 사용할 수 있다.</p><h3 id="할당문">할당문</h3><p>할당문이란 새로운 변수를 만들고, 그 변수에 값을 주는 코드를 말한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; message = <span class="hljs-string">&quot;And now for something completely different&quot;</span><br><span class="hljs-string">&quot;And now for something completely different&quot;</span><br>julia&gt; n = <span class="hljs-number">17</span><br><span class="hljs-number">17</span><br>julia&gt; π_val = <span class="hljs-number">3.141592653589793</span><br><span class="hljs-number">3.141592653589793</span><br></code></pre></td></tr></table></figure><p>위의 예시는 3개의 할당문을 보여준 것이다. 첫 번째 코드는 <code>message</code>라는 변수를 만들어 등호 뒤의 문자열을 할당한다. 두 번째 코드는 정수 <code>17</code>을 변수 <code>n</code>에 할당하며, 세 번째는 π의 근사값을 변수 <code>π_val</code>에 할당한다.</p><h3 id="변수-이름">변수 이름</h3><p>변수 이름은 길이에 제약 없이 설정할 수 있으며, 프로그래머들은 일반적으로 변수 이름에 특정 의미(변수의 목적 등)를 담아 사용한다. 변수 이름은 거의 모든 유니코드 글자들을 포함하지만, 숫자를 이름의 시작으로는 사용할 수 없다. 또한 대문자를 사용하는 것이 문제가 되지는 않지만 주로 소문자를 이용하여 변수 이름을 만든다.</p><p>밑줄문자(_)도 변수 이름에 사용할 수 있다. 이 문자는 your_name 이나 airspeed_of_unladen_swallow 와 같이 여러 단어가 연결된 이름에 단어들을 구분하는 구분자로서 사용된다.</p><p>만약 위의 내용을 어긴 변수 이름을 사용하여 변수를 만든다면, 문법 에러(syntax error)가 나올 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-number">76</span>trombones = <span class="hljs-string">&quot;big parade&quot;</span><br>ERROR: syntax: <span class="hljs-string">&quot;76&quot;</span> is not a valid <span class="hljs-keyword">function</span> argument name<br>julia&gt; more@ = <span class="hljs-number">1000000</span><br>ERROR: syntax: extra token <span class="hljs-string">&quot;@&quot;</span> after <span class="hljs-keyword">end</span> of expression<br>julia&gt; <span class="hljs-keyword">struct</span> = <span class="hljs-string">&quot;Advanced Theoretical Zymurgy&quot;</span><br>ERROR: syntax: unexpected <span class="hljs-string">&quot;=&quot;</span><br></code></pre></td></tr></table></figure><p><code>76trombones</code>는 숫자로 시작했기 때문에 변수 이름으로 사용할 수 없으며, <code>more@</code>는 마지막 <span class="citation" data-cites="기호로">@기호로</span> 인해서 변수 이름으로 사용할 수 없다. 그렇다면 <code>struct</code>는 뭐가 문제일까?</p><p>사실 <code>struct</code>은 줄리아의 키워드이다. REPL에서는 프로그램의 구조를 이해하기 위해서 몇 가지의 키워드를 사용하는데, 이 키워드 또한 변수 이름으로 사용할 수 없다. 줄리아는 아래의 그림과 같은 키워드들을 가지고 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">abstract type</span>     <span class="hljs-keyword">baremodule</span>     <span class="hljs-keyword">begin</span>       <span class="hljs-keyword">break</span>         <span class="hljs-keyword">catch</span><br><span class="hljs-keyword">const</span>             <span class="hljs-keyword">continue</span>       <span class="hljs-keyword">do</span>          <span class="hljs-keyword">else</span>          <span class="hljs-keyword">elseif</span><br><span class="hljs-keyword">end</span>               <span class="hljs-keyword">export</span>         <span class="hljs-keyword">finally</span>     <span class="hljs-keyword">for</span>           <span class="hljs-keyword">function</span><br><span class="hljs-keyword">global</span>            <span class="hljs-keyword">if</span>             <span class="hljs-keyword">import</span>      importall     <span class="hljs-keyword">in</span><br><span class="hljs-keyword">let</span>               <span class="hljs-keyword">local</span>          <span class="hljs-keyword">macro</span>       <span class="hljs-keyword">module</span>        <span class="hljs-keyword">mutable struct</span><br><span class="hljs-keyword">primitive type</span>    <span class="hljs-keyword">quote</span>          <span class="hljs-keyword">return</span>      <span class="hljs-keyword">try</span>           <span class="hljs-keyword">using</span><br><span class="hljs-keyword">struct</span>            <span class="hljs-keyword">where</span>          <span class="hljs-keyword">while</span><br></code></pre></td></tr></table></figure><p>위의 키워드들을 모두 외울 필요는 없다. 만약 키워드로 변수 이름을 설정하려고 해도 대부분의 개발 환경에서는 키워드들을 다른 색깔로 보여주기 때문에 키워드임을 알 수 있다.</p><h3 id="표현식과-명령문들">표현식과 명령문들</h3><p>표현식(expression)은 값, 변수 및 연산자들의 조합이다. 값이나 변수 그자체는 모두 표현식으로 간주되기 때문에 아래의 코드들은 모두 표현식이라고 볼 수 있다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-number">42</span><br><span class="hljs-number">42</span><br>julia&gt; n<br><span class="hljs-number">17</span><br>julia&gt; n + <span class="hljs-number">25</span><br><span class="hljs-number">42</span><br></code></pre></td></tr></table></figure><p>위의 세 번째 코드와 같은 표현식을 작동시키면, REPL은 변수인 <code>n</code>의 값을 찾아서 연산을 진행한다. <code>n</code>의 값은 17이기 때문에 <code>n + 25</code>의 표현식 값은 12+25인 42이다.</p><p>명령문(statement)은 변수를 작성하거나 변수를 보여주는 등의 특정 효과를 가지는 코드를 말한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; n = <span class="hljs-number">17</span><br><span class="hljs-number">17</span><br>julia&gt; println(n)<br><span class="hljs-number">17</span><br></code></pre></td></tr></table></figure><p>첫 번째 코드는 변수 <code>n</code>에 17이라는 값을 할당하는 명령문이며, 두 번째 코드는 변수 <code>n</code>의 값을 보여주는 함수를 가진 명령문이다.</p><p>명령문을 입력하면, REPL이 명령문이 요청하는대로 수행한다.</p><h3 id="스크립트-모드">스크립트 모드</h3><p>지금까지는 REPL에 코드를 한 줄씩 직접 입력하여 실행하는 대화식 모드를 사용해왔다. 하지만 이 방법은 긴 코드를 작업하는 경우에는 매우 불편할 것이다. 그렇기에 대안으로서 스크립트 모드를 사용하고자 한다. <strong>스크립트 모드</strong>란 코드들을 파일에 저장한 후, 줄리아를 실행하여 한번에 작동시키는 것이다. 줄리아의 스크립트 파일은 <code>.ji</code>이라는 확장자명을 가진다.</p><p>줄리아는 두 모드를 모두 제공하기 때문에 스크립트에 배치하기 전에 대화식 모드에서 코드를 테스트 해볼 수 있다.</p><p>하지만 두 모드 사이에는 혼동하기 쉬운 차이점이 있다. 예를 들어 만약 줄리아를 계산기로 사용하여 아래 코드와 같이 입력하면,</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; miles = <span class="hljs-number">26.2</span><br><span class="hljs-number">26.2</span><br>julia&gt; miles * <span class="hljs-number">1.61</span><br><span class="hljs-number">42.182</span><br></code></pre></td></tr></table></figure><p>첫 번째 코드에서는 변수 <code>miles</code>에 값을 할당하고 보여준다. 그리고 두 번째는 표현식이기 때문에 REPL은 변수<code>miles</code>의 값을 찾아 계산을 한 뒤에 결괏값을 보여 준다. 그러나 위의 코드를 스크립트로 입력하여 작동시키면, 어떠한 결괏값도 나오지 않는다. 그 이유는 스크립트 모드에서는 표현식 그 자체가 결과를 보여주는 기능을 가지고 있지 않기 때문이다. 즉, 아래의 코드와 같이 입력하지 않으면 값을 표시하지 않는다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">miles = <span class="hljs-number">26.2</span><br>println(miles * <span class="hljs-number">1.61</span>)<br></code></pre></td></tr></table></figure><p>이런 규칙은 초반에 헷갈릴 수 있다.</p><p>스크립트는 보통 일련의 명령문들을 포함한다. 명령문이 둘 이상의 요청을 가진 경우에는 보통 명령문 하나당 하나의 요청만 실행된다. 예로, 아래의 코드를 스크립트 모드로 작동시킨다면,</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia">println(<span class="hljs-number">1</span>)<br>x = <span class="hljs-number">2</span><br>println(x)<br></code></pre></td></tr></table></figure><p>결과는 다음과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>두번째 줄 코드인 할당문은 2라는 결과를 도출하지 않았다. 할당문은 단지 변수에 값은 할당해주는 한 가지 역할만 한 것이다.</p><h3 id="연산자-우선순위">연산자 우선순위</h3><p>만약 표현식이 많은 연산자들은 포함하고 있다면, 그 결괏값은 연산자 우선순위에 따라서 결정된다. 줄리아는 수학연산자의 규칙을 따른다. 약어인 PEMDAS는 규칙을 기억하는 유용한 방법이다.</p><ul><li>괄호(Parentheses)가장 높은 우선순위를 가지며 원하는 순서를 표현하는데 사용할 수 있다.</li><li>지수(Exponentiation)가 그 다음으로 높은 우선순위를 가진다.</li><li>곱셈(Multiplication)과 나눗셈(Division)이 그 다음으로 작동된다.</li><li>마지막으로 덧셈(Addition)과 뺄셈(Subtraction)이 작동한다. -우선순위가 동일한 연산자의 경우 왼쪽에서 오른쪽으로 진행된다.</li></ul><h3 id="문자열-연산">문자열 연산</h3><p>일반적으로 수학 연산자들은 문자열에 사용할 수 없다. 심지어 그 문자가 숫자처럼 보일지라도 데이터 타입이 문자열이라면 불가능하다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-string">&quot;2&quot;</span> - <span class="hljs-string">&quot;1&quot;</span>    <span class="hljs-string">&quot;eggs&quot;</span> / <span class="hljs-string">&quot;easy&quot;</span>    <span class="hljs-string">&quot;third&quot;</span> + <span class="hljs-string">&quot;a charm&quot;</span><br></code></pre></td></tr></table></figure><p>그러나 예외로 <code>*</code>와 <code>^</code>는 사용할 수 있다.</p><p><code>*</code> 연산자는 문자를 연결해준다. 즉, 문자열 2개의 끝과 끝을 연결하여 하나의 문자열로 만드는 것을 의미한다. 예로 아래의 코드를 확인해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; first_str = <span class="hljs-string">&quot;throat&quot;</span><br><span class="hljs-string">&quot;throat&quot;</span><br>julia&gt; second_str = <span class="hljs-string">&quot;warbler&quot;</span><br><span class="hljs-string">&quot;warbler&quot;</span><br>julia&gt; first_str * second_str<br><span class="hljs-string">&quot;throatwarbler&quot;</span><br></code></pre></td></tr></table></figure><p><code>^</code>연산자는 해당 문자열을 반복한다. 예를 들어서 <code>”Spam”^3</code>는 <code>”SpamSpamSpam”</code>로 작동한다. 즉 문자열에서 <code>^</code>연산자는 지수와 유사하게 작동하는 것을 알 수 있다.</p><h3 id="주석">주석</h3><p>프로그램이 커지고 복잡해지면, 코드를 보고 어떤 작업을 하는지 또는 왜 그 작업을 하는지 알아내기 어려울 때가 많다. 그렇기 때문에 프로그램을 수행함에 있어서 각각의 작업에 대한 설명을 메모해두는 것이 좋다. 이러한 메모를 주석(comment)라고 하며 <code>#</code>기호를 사용한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-comment"># compute the percentage of the hour that has elapsed</span><br>percentage = (minute * <span class="hljs-number">100</span>) / <span class="hljs-number">60</span><br></code></pre></td></tr></table></figure><p>위의 경우는 주석이 한 줄을 차지하고 있다. 만약 코드와 같은 줄에 주석을 작성하고 싶다면 코드 끝에 쓰면 된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">percentage = (minute * <span class="hljs-number">100</span>) / <span class="hljs-number">60</span>   <span class="hljs-comment"># percentage of an hour</span><br></code></pre></td></tr></table></figure><h3 id="디버깅">디버깅</h3><p>프로그램에서는 세 가지 종류의 오류가 발생할 수 있다. 오류를 빠르게 파악하기 위해서는 이 세 가지 오류에 대해서 알아두는 편이 좋다.</p><p><strong>문법 오류(syntax error)</strong> 문법은 프로그램 구조에 대한 규칙을 나타낸다. 예를 들어서 괄호는 쌍을 이뤄야 하므로 (1+2)는 올바르지만 8)은 문법 오류이다. 프로그램 어딘가에 문법오류가 있는 경우 줄리아는 오류 메시지를 도출하고 종료 되며 프로그램은 실행되지 않는다. 문법 오류를 추적하는 것은 많은 시간이 필요하지만, 경험이 쌓이면 오류를 빠르게 찾을 수 있다.</p><p><strong>런타임 오류(runtime error)</strong> 런타임 오류는 프로그램이 실행되기 전까지는 나타나지 않는다. 그렇기 때문에 프로그램을 테스트 할 때 파악할 수 있으며, 대부분 인지하지 못한 예외적인 문제들이 이 오류에 포함된다. 간단한 프로그램에서 해당 오류는 드물다.</p><p><strong>의미 오류(semantic error)</strong> 의미 오류는 개발자의 의도와는 다른 방향으로 프로그램이 작동되는 현상이다. 이는 문법오류와 같이 컴퓨터가 파악할 수 있는 오류가 아니기 때문에 오류 메시지가 나타나지 않는다. 그렇기에 해당 오류를 찾기 위해서는 프로그램의 출력을 보고 수행중인 작업에서 예측가능한 결과인지를 파악하여 역으로 찾는 수밖에 없다.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>think julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>줄리아</tag>
      
      <tag>Julia</tag>
      
      <tag>Think Julia</tag>
      
      <tag>기초 강의</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github Page와 Hexo를 이용하여 블로그 만들기</title>
    <link href="/ko/AboutHexo/about-hexo-0/"/>
    <url>/ko/AboutHexo/about-hexo-0/</url>
    
    <content type="html"><![CDATA[<p>Hexo 블로그를 만들기 위해서는 Github계정을 사용하는 것이 가장 편합니다. Github계정이 없는 분들은 <a href="https://github.com">Github</a>에서 만들어 주세요! Github계정이 있는 분들이라면 바로 Hexo 블로그를 만들 수 있습니다</p><span id="more"></span><hr /><p>Hexo 블로그를 만들기 위해서는 크게 2가지의 과정이 필요하다.</p><h2 id="github-repository-만들기">Github repository 만들기</h2><p>Github repository 만드는 방법은 다음과 같다.</p><ul><li><p>Github계정에 들어가면 상단바에서 <code>Repositories</code>를 클릭한 후, <code>New</code>를 누른다.</p></li><li><p>그 다음 <code>Repository name</code>에 <code>사용자이름.github.io</code>로 작성하고, <code>Public 모드</code>으로 설정한 다음 <code>create repository</code>를 누른다.</p></li><li><p><code>repository</code>생성이 완료되면, 터미널을 켜서 원하는 디렉토리에 아래의 코드를 입력한다.</p><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/사용자이름/사용자이름.github.io<br></code></pre></td></tr></table></figure></p></li><li><p>디렉토리를 설정하는 방법은 터미널에 <code>pwd</code>를 입력하여 현재 위치를 파악하고, <code>cd 이동하려는 위치 이름</code>을 입력하여 이동하면 된다. (Mac 기준)</p></li><li><p>해당 디렉토리에 <code>사용자이름.github.io</code> 파일이 생성되었다면, 아래의 코드를 입력한다.</p><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> 사용자이름.github.io<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello World&quot;</span> &gt; index.html<br>git add --all<br>git commit -m <span class="hljs-string">&quot;Initial commit&quot;</span><br>git push -u origin master<br></code></pre></td></tr></table></figure></p></li></ul><p>완성되었다! 마지막으로 브라우저에서 <code>https://USERNAME.github.io</code>에 접속되는지 확인해보자.</p><h2 id="hexo-만들기">Hexo 만들기</h2><p>Hexo 셋팅을 하는 것은 몇 줄의 코드면 끝난다. 이제부터 아래의 코드를 순서대로 입력한다.</p><h3 id="설치-전-준비해야-할-것">설치 전 준비해야 할 것</h3><p>Hexo를 설치하기 전에 아래의 요소들을 다운로드 해야 한다. 이미 다운되어 있다면 다시 받을 필요는 없다. <a href="https://nodejs.org/en/">Node.js</a> <a href="https://git-scm.com">Git</a></p><h3 id="hexo-설치-코드">Hexo 설치 코드</h3><p>설치를 시작하기에 앞서 터미널에서 Hexo파일을 저장할 디렉토리를 먼저 설정해야 한다. 디렉토리를 설정하는 방법은 <code>Github repository 만들기</code>에 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-cli -g<br>hexo init myBlog <span class="hljs-comment">#`myBlog`라는 파일을 만들기</span><br><span class="hljs-built_in">cd</span> myBlog <span class="hljs-comment">#myBlog로 디렉토리 설정</span><br>npm install<br></code></pre></td></tr></table></figure><p>설치가 완료되었다.</p><h3 id="블로그-기본-설정">블로그 기본 설정</h3><p>Hexo를 설치하면서 생성한 폴더를 오픈한다. 그 다음 블로그의 기본적인 설정을 바꾸기 위해서 <code>_config.yml</code>를 열어준다. 텍스트 파일로 오픈해도 되지만 개인적으로는 <a href="https://code.visualstudio.com">Visual studio code</a>을 사용하였다. 해당 파일에서 아래와 같은 부분을 수정하고 저장하면 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># site 정보 수정</span><br>title: DEV AnythinG <span class="hljs-comment"># 블로그 이름</span><br>subtitle:<br>description:<br>author: Hyeonji Ryu <span class="hljs-comment"># 사용자 이름</span><br><br><span class="hljs-comment"># URL 정보 수정</span><br>url: https://사용자이름.github.io <span class="hljs-comment"># 이 부분 수정</span><br>root: /<br>permalink: :year/:month/:day/:title/<br>permalink_defaults:<br><br><span class="hljs-comment"># Deployment</span><br>deploy:<br>  <span class="hljs-built_in">type</span>: git<br>  repo: https://github.com/사용자이름/사용자이름.github.io.git<br></code></pre></td></tr></table></figure><h3 id="테스트-및-배포하기">테스트 및 배포하기</h3><p>테스트를 위해서 터미널에 아래의 코드를 입력해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 테스트</span><br>hexo server<br></code></pre></td></tr></table></figure><p>서버가 작동된 후에는 <code>http://localhost:4000</code>에서 변경사항이 적용된 블로그를 미리 볼 수 있다. 테스트 완료 후 Github repository에서 배포하면 블로그가 완성된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 해당 리소스 생성</span><br>hexo generate<br><br><span class="hljs-comment"># 배포하기</span><br>hexo deploy<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>etc.</category>
      
      <category>about hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Github</tag>
      
      <tag>blog</tag>
      
      <tag>헥소</tag>
      
      <tag>깃허브</tag>
      
      <tag>블로그</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[0/20] Why Julia?</title>
    <link href="/ko/ThinkJulia/Think-Julia-Chapter-0/"/>
    <url>/ko/ThinkJulia/Think-Julia-Chapter-0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist를 바탕으로 작성된 글임을 알려드립니다.</p></blockquote><p>이 포스트는 <a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#_why_julia">Why Julia?</a>를 한글로 요약 정리한 글입니다. <span id="more"></span></p><hr /><h2 id="introduction">introduction</h2><p>Julia(이하 줄리아)는 2012년에 개발되었으며, 무료로 사용할 수 있는 오픈소스 프로그래밍 언어 중 하나이다. 사실 프로그래밍 언어를 선택하는 것은 부차적인 문제지만, 이 언어는 선택할만한 가치가 있다. 다음으로 해당 언어의 장점에 대해서 알아보자.</p><ul><li>줄리아는 높은 성능을 위해 개발된 프로그래밍 언어이다.</li><li>줄리아는 다른 데이터 타입에 대한 함수나 메서드도 동적으로 사용 가능한 다중 디스패치(multiple dispatch)를 사용한다. (다중 디스패치는 이후 17장에서 자세히 다룰 예정입니다.)</li><li>줄리아는 상호작용하기 쉬운 동적 타입의 언어이다.</li><li>줄리아는 배우기 쉬운 수준의 문법을 가진다.</li><li>줄리아는 데이터 타입이 정의된 언어(typed programming language)이기 때문에, 사용자의 코드를 더욱 깔끔하고 견고하게 만들어준다.</li><li>줄리아는 확장된 표준 라이브러리들이 있으며, 수많은 다른 패키지들도 사용할 수 있다.</li></ul><p>특히 줄리아는 "두 개의 언어 문제(two language problem)"를 해결하기 때문에 매우 독특한 프로그래밍 언어이다.</p><p><strong>두 개의 언어 문제란?</strong> R과 Python과 같은 고수준 언어들은 성능(속도 등)이 떨어지기 때문에, 결국 실용화하기 위에서는 C나 C++로 다시 코드를 작성해야 하는 문제를 말한다.</p><p>줄리아는 고성능 코드를 작성하기 위해서 다른 프로그래밍 언어가 필요하지 않다. 즉, 줄리아는 병목현상을 자동으로 최적화해줌으로써 프로그래머들의 어려움을 덜어준다.</p><h2 id="프로그램의-방식">프로그램의 방식</h2><p>이 책은 독자들이 '컴퓨터 사이언티스트'처럼 생각할 수 있도록 안내한다. 그들처럼 생각하는 방식은 수학, 공학, 자연과학 등의 특징들을 결합하는 것이다. 구체적인 방식을 확인해보자. 먼저 컴퓨터 사이언티스트들은 수학자처럼 공식을 사용하여 아이디어(구체적인 계산들)를 표현한다. 그 이후 엔지니어와 마찬가지로 필요한 부품을 시스템에 조립하고 여러 대안들의 장단점을 평가하여 해당 아이디어를 설계한다. 마지막으로 과학자처럼 그들은 복잡한 시스템들의 작동을 관찰하고, 가설을 형성하며 검증한다.</p><p>컴퓨터 사이언티스트에게 가장 중요한 능력은 바로 "문제해결(problem solving)" 이다. 문제해결이란 문제를 형식화하고 창의적으로 생각하여 문제에 대한 정확하고 명확한 해결방안을 표현할 수 있는 능력을 말한다. 결론적으로 프로그램을 배우는 과정은 문제해결기술을 연습하는 데 매우 훌륭한 기회라는 것이다. 이것이 이번 챕터의 제목을 "프로그램의 방식"이라고 정한 이유이다.</p><h3 id="프로그램이란">프로그램이란</h3><p>프로그램은 계산을 수행하는 방법을 구체화하는 연속적인 명령이다. 계산은 방정식을 풀거나 다항식의 근을 찾는 것과 같이 수학적인 의미도 있지만, 동시에 문서에서 텍스트를 검색하거나 이미지 처리와 같은 상징적인 의미도 가지고 있다. 명령문 코드의 세부적인 요소들은 언어마다 다르지만, 몇 개의 기본 명령은 모든 언어에서 똑같이 나타난다.</p><ul><li>Input : 파일이나 인터넷, 다른 디바이스 등에서 데이터를 가져오는 것</li><li>Output: 데이터를 스크린에 띄우거나 파일을 저장하는 것, 네트워크를 통해 보내는 것 등을 의미</li><li>Math: 덧셈이나 곱셈처럼 기본적인 수학 작동들을 수행하는 것.</li><li>Conditional execution: 특정 환경들을 확인하고 알맞은 코드를 적용하는 것.</li><li>Repetition: 약간의 변화를 주고 작업을 반복하는 것</li></ul><p>믿거나 말거나 이것이 프로그램의 거의 전부이다. 당신이 사용해왔던 모든 프로그램은 얼마나 복잡한지와는 상관없이 위와 같은 명령들로 만들어졌다. 따라서 프로그래밍은 크고 복잡한 기본 명령들을 충분히 수행될 할 수 있을만한 하위 작업들로 나누어 가는 과정으로 생각할 수 있다.</p><h3 id="줄리아-시작하기">줄리아 시작하기</h3><p>줄리아를 배우기 전에, 먼저 해당 소프트웨어를 설치해야 한다. 만약 당신이 컴퓨터의 OS체제를 알고 있다면, 홈페이지에 들어가 알맞은 소프트웨어를 다운로드 받으면 된다.</p><p>Julia의 REPL(Read-Eval-Print-Loop)는 Julia 코드를 읽고 실행하는 프로그램이다. 해당 창에 Enter키를 입력하면 아래와 같은 그림이 나타난다.</p><figure><img src="/images/2020-02-25.png" alt="julia intro" /><figcaption aria-hidden="true">julia intro</figcaption></figure><p>해당 그림의 마지막 줄에 있는 <code>Julia&gt;</code>는 명령을 입력하는 프롬프트(prompt)이며, 이곳에 코드를 입력하면 결괏값(Output)을 받을 수 있다.</p><h3 id="첫-번째-프로그램">첫 번째 프로그램</h3><p>첫 번째 프로그램으로 우리가 작성할 코드는 "Hello, World!" 이다. 코드는 아래 그림과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; println(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br>Hello, World!<br></code></pre></td></tr></table></figure><p>위 그림은 <code>print</code>코드의 예시이다. 여기서 <code>print</code>코드는 종이에 글씨를 복사하는 것이 아니라, 단지 입력한 코드에 대한 결괏값을 스크린에 보여주는 것을 의미한다. 인용구 기호("")는 글자의 시작과 끝에 사용하며, 결괏값에는 나타나지 않는다. 또한 괄호는 <code>println</code>이 함수라는 것을 알려준다. 함수에 대해서는 3장에서 배울 것이다.</p><h3 id="산술-연산자">산술 연산자</h3><p>"Hello, world!" 다음으로는 사칙연산이다. 줄리아는 덧셈이나 곱셈과 같은 기본적인 연산자들을 제공한다. 연산자 기호들은 <code>+</code>는 덧셈, <code>-</code>는 뺄셈, <code>*</code>는 곱셈, <code>/</code>는 나눗셈이다. 해당 기호들을 사용한 예시는 아래의 그림과 같다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-number">40</span>+<span class="hljs-number">2</span><br><span class="hljs-number">42</span><br><br>julia&gt; <span class="hljs-number">43</span>-<span class="hljs-number">1</span><br><span class="hljs-number">42</span><br><br>julia&gt; <span class="hljs-number">6</span>*<span class="hljs-number">7</span><br><span class="hljs-number">42</span><br><br>julia&gt; <span class="hljs-number">84</span>/<span class="hljs-number">2</span><br><span class="hljs-number">42.0</span><br></code></pre></td></tr></table></figure><p>위의 계산식에서 유일하게 나눗셈만 답이 소수점으로 나오는데, 그 이유는 바로 다음 글인 데이터 타입에서 설명할 것이다.</p><p>마지막으로 연산자 <code>^</code>는 거듭제곱에 대한 기호이다. 즉, 앞의 수를 뒤의 수만큼 제곱하는 것이다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-number">6</span>^<span class="hljs-number">2</span>+<span class="hljs-number">6</span><br><span class="hljs-number">42</span><br><br>julia&gt; <span class="hljs-number">2</span>^<span class="hljs-number">5</span>+<span class="hljs-number">10</span><br><span class="hljs-number">42</span><br></code></pre></td></tr></table></figure><h3 id="값-그리고-데이터-타입들">값 그리고 데이터 타입들</h3><p>값(value)은 프로그램이 일할 때 사용하는 가장 기본적인 문자나 숫자를 말한다. 예로 우리가 이미 본 "Hello, World!"나 42.0, 2 등이 있다.</p><p>위에서 제시한 3개의 값은 모두 다른 데이터 타입을 가지고 있다. 각각의 데이터 타입을 살펴보면2는 정수(integer)이며, 42.0은 소수(floating-point number), "Hello, World!"는 문자(string)이다. 위의 데이터 타입을 영어로 기재한 이유는 코드에서 영어의 축약으로 사용되기에 영어로 알아두는 것이 더 편리하기 때문이다.</p><p>만약에 해당 값이 어떤 데이터 타입인지 모르겠다면, REPL에 아래의 코드를 입력해보자.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; typeof(<span class="hljs-number">2</span>)<br><span class="hljs-built_in">Int64</span><br><br>julia&gt; typeof(<span class="hljs-number">42.0</span>)<br><span class="hljs-built_in">Float64</span><br><br>julia&gt; typeof(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br><span class="hljs-built_in">String</span><br></code></pre></td></tr></table></figure><p>정수는 <code>int64</code>로 표시되며, 소수는 <code>float64</code>로 표현된다. 또한 문자의 경우는<code>string</code>로 표시된다.</p><p>그렇다면 값 "2"나 "42.0" 의 데이터 타입은 어떨까? 두 값은 숫자처럼 보이지만 인용구를 사용했기 때문에 문자로 인식된다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; typeof(<span class="hljs-string">&quot;2&quot;</span>)<br><span class="hljs-built_in">String</span><br><br>julia&gt; typeof(<span class="hljs-string">&quot;42.0&quot;</span>)<br><span class="hljs-built_in">String</span><br></code></pre></td></tr></table></figure><p>큰 정수를 값으로 사용할 때 자연스럽게 1,000,000와 같이 콤마를 넣어 수를 사용한다면, 줄리아에서는 이를 정수로 인식하지 못한다. 줄리아는 콤마를 연속된 정수들을 분리하는 기호로서 인식한다. 그렇기 때문에 만약 위와 같은 효과를 주고 싶다면 1_000_000 와 같이 언더바를 사용해야 한다.</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-number">1</span>,<span class="hljs-number">000</span>,<span class="hljs-number">000</span><br>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><br>julia&gt; typeof(<span class="hljs-number">1</span>,<span class="hljs-number">000</span>,<span class="hljs-number">000</span>)<br>ERROR: <span class="hljs-built_in">ArgumentError</span>: typeof: too many arguments (expected <span class="hljs-number">1</span>)<br>Stacktrace:<br> [<span class="hljs-number">1</span>] top-level scope at none:<span class="hljs-number">0</span><br><br>julia&gt; <span class="hljs-number">1_000_000</span><br><span class="hljs-number">1000000</span><br><br>julia&gt; typeof(<span class="hljs-number">1_000_000</span>)<br><span class="hljs-built_in">Int64</span><br></code></pre></td></tr></table></figure><h3 id="형식-언어와-자연어">형식 언어와 자연어</h3><p>자연어는 영어, 스페인어, 한국어와 같이 사람들이 사용하는 언어를 말한다. 이런 언어들은 특정 사람들로부터 인위적으로 발명된 것이 아니라 자연스럽게 진화된 형태이다.</p><p>형식 언어는 특정 필요에 의해서 사람들이 고안한 언어들을 의미한다. 예를 들어, 수학자들이 사용하는 표기법은 숫자와 기호 사이의 관계를 나타내는 데 적합한 형식 언어이며, 화학자들은 형식 언어를 사용하여 분자의 화학구조를 나타낸다. 이와 같이 프로그래밍 언어 또한 계산을 표현하도록 설계된 형식 언어이다.</p><p>형식 언어는 엄격한 문법을 가진다. 예를 들어서 3+3=6은 올바른 구문이지만, 3+=3$6은 올바르지 않다. 또한</p><p>문법은 크게 토큰과 구조로 구성되어 있는데, 토큰은 단어나 숫자, 화학 원소와 같은 언어의 기본 요소이며 구조는 토큰 간의 올바른 연결이 전제된 문장을 의미한다.</p><p>즉, 올바른 문법을 사용했는지 확인하려면,</p><p>적절한 토큰을 사용하였는가?</p><p>올바른 연결로 적절한 구조를 설정였는가?</p><p>위의 두 질문을 잊지 말자.</p><h3 id="디버깅">디버깅</h3><p>프로그래머들은 실수를 하며, 각가지의 이유로 인해 버그(bug)라고 불리는 프로그래밍 에러가 발생한다. 이런 버그들을 추적하는 과정을 디버깅이라고 한다.</p><p>디버깅을 할 때 어려운 버그를 만난다면, 컴퓨터에 대한 분노로 인해 개발자를 그만두고 싶을 수 있다. 하지만 디버깅을 배우는 것은 어렵지만 프로그래밍 이외의 많은 활동에도 유용한 기술이기에 포기하지 않기를 바란다.</p>]]></content>
    
    
    <categories>
      
      <category>SeriesHub</category>
      
      <category>think julia</category>
      
    </categories>
    
    
    <tags>
      
      <tag>줄리아</tag>
      
      <tag>Julia</tag>
      
      <tag>Think Julia</tag>
      
      <tag>기초 강의</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
