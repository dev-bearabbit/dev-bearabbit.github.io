

<!DOCTYPE html>
<html lang="ko" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="alternate" hreflang="ko" href="https://dev-bearabbit.github.io/" />
  <link rel="alternate" hreflang="en" href="https://dev-bearabbit.github.io/en/" />  
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" href="/img/favicon.ico">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#000">
  <meta name="author" content="Jess">
  <meta name="keywords" content="">
  
    <meta name="description" content="해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다.">
<meta property="og:type" content="article">
<meta property="og:title" content="[1&#x2F;18] 행렬과 벡터의 곱">
<meta property="og:url" content="https://dev-bearabbit.github.io/ko/DeeplearningJulia/Deeplearning-1/index.html">
<meta property="og:site_name" content="DEV AnythinG">
<meta property="og:description" content="해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다.">
<meta property="og:locale" content="ko_KR">
<meta property="og:image" content="https://dev-bearabbit.github.io/images/31.png">
<meta property="article:published_time" content="2020-03-25T20:37:08.000Z">
<meta property="article:modified_time" content="2025-01-27T20:55:31.517Z">
<meta property="article:author" content="Jess">
<meta property="article:tag" content="딥러닝">
<meta property="article:tag" content="머신러닝">
<meta property="article:tag" content="Deeplearning">
<meta property="article:tag" content="줄리아">
<meta property="article:tag" content="벡터">
<meta property="article:tag" content="내적">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://dev-bearabbit.github.io/images/31.png">
  
  
  
  <title>[1/18] 행렬과 벡터의 곱 - DEV AnythinG</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"dev-bearabbit.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":"G-QW3E4LZZNF"},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=G-QW3E4LZZNF", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', 'G-QW3E4LZZNF');
        });
      }
    </script>
  

  

  

  



  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>DEV AnythinG</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="javascript:;" id="languageDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <i class="iconfont icon-globe"></i> <span id="current-lang"></span>
          </a>
          <div class="dropdown-menu" aria-labelledby="languageDropdown">
            <a class="dropdown-item" href="/">한국어</a>
            <a class="dropdown-item" href="/en/">English</a>
          </div>
        </li>
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    // 현재 언어를 URL 기반으로 감지
    const path = window.location.pathname;
    const currentLang = path.startsWith('/en/') ? 'English' : '한국어';

    // 선택된 언어를 버튼에 표시
    const currentLangElement = document.getElementById('current-lang');
    currentLangElement.textContent = currentLang;
  });
</script>

  

<div id="banner" class="banner" parallax=true
  style="background: url('/img/background.gif') no-repeat center center; background-size: cover;">
  <canvas id="canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></canvas>
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="[1/18] 행렬과 벡터의 곱"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2020-03-26 05:37" pubdate>
          2020년 3월 26일 오전
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          1.5k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          13 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // 캔버스 크기를 배너 크기와 동기화
    const banner = document.getElementById('banner');
    canvas.width = banner.offsetWidth;
    canvas.height = banner.offsetHeight;

    const cols = Math.floor(canvas.width / 20) + 1;
    const ypos = Array(cols).fill(0);

    function matrix() {
      ctx.fillStyle = '#0001'; // 배경 페이드 효과
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = '#009600'; // 텍스트 색상
      ctx.font = '14pt monospace';

      ypos.forEach((y, index) => {
        const text = String.fromCharCode(33 + Math.random() * 94); // 랜덤 ASCII 문자
        const x = index * 20;
        ctx.fillText(text, x, y);

        if (y > canvas.height + Math.random() * 10000) ypos[index] = 0;
        else ypos[index] = y + 20;
      });
    }

    setInterval(matrix, 60);

    // 창 크기 조정 시 캔버스 크기 업데이트
    window.addEventListener('resize', () => {
      canvas.width = banner.offsetWidth;
      canvas.height = banner.offsetHeight;
    });
  });
</script>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">[1/18] 행렬과 벡터의 곱</h1>
            
            
              <div class="markdown-body">
                
                <p>해당 시리즈는 프로그래밍 언어 중 하나인 줄리아(Julia)로 딥러닝(Deep learning)을 구현하면서 원리를 설명합니다. <span id="more"></span></p>
<hr />
<h2 id="벡터란">벡터란</h2>
<p>벡터(Vector)는 '크기'와 '방향'을 모두 나타낸다. 예를 들어, 자동차가 시속 5마일로 달린다고 해보자. 여기서 5마일은 단순히 크기일뿐 방향을 나타내고 있지 않으므로 벡터라고 할 수 없다. 벡터로 나타내기 위해서는 5마일에 동쪽으로 향하는 '크기'와 '방향'까지 포함된 개념이어야 한다.</p>
<p>벡터의 기호는 <span class="math inline">\(\overrightarrow{a}\)</span>이며, 아래와 같은 '열벡터'가 기본 형태이다.</p>
<p><span class="math display">\[\overrightarrow{a}=
\begin{bmatrix}
X \\
Y \\
\end{bmatrix}\]</span></p>
<p>벡터의 성분 개수와 차원은 동일하기 때문에 위의 열벡터는 성분 <code>x</code>와 <code>y</code> 를 가진 2차원 벡터이다.</p>
<p>행벡터는 기본형인 열벡터를 '전치'한 형태이다. 여기서 전치란 주대각선(Main diagonal)을 대칭한 것이며, 보통 행렬에서 많이 사용된다.</p>
<p><span class="math display">\[\overrightarrow{a}^T=
\begin{bmatrix}
X&amp;Y
\end{bmatrix}\]</span></p>
<p>행렬의 경우 아래의 행렬과 벡터의 곱에서 더 자세하게 설명할 것이다.</p>
<h2 id="벡터의-내적">벡터의 내적</h2>
<p>벡터의 곱셈은 크게 '외적(Cross product)'과 '내적(Dot product)' 2가지의 방법이 사용되며, 우리는 그 중 딥러닝에서 사용하는 내적에 대해 살펴볼 것이다.</p>
<p>내적을 수학식으로 표현하면 아래와 같다.</p>
<p><span class="math display">\[\overrightarrow{a}\cdot\overrightarrow{b}=\sum_{i=1}^n a_ib_i=a_1b_1+a_2b_2+a_3b_3+\cdots+a_nb_n\]</span></p>
<p>열벡터 a와 b를 내적하면 같은 위치에 있는 성분끼리 곱한 수들을 더한다. 즉, 열벡터 당 하나의 스칼라가 값으로 나오는 것이다.</p>
<p><span class="math display">\[\overrightarrow{a}=\begin{bmatrix}a_1\\a_2\\a_3\\\vdots\\a_n\end{bmatrix}\quad
\overrightarrow{b}=\begin{bmatrix}b_1\\b_2\\b_3\\\vdots\\b_n\end{bmatrix}\quad
\overrightarrow{a}\cdot\overrightarrow{b}=a_1b_1+a_2b_2+a_3b_3\cdots a_nb_n\]</span></p>
<p>이와 같은 과정을 벡터의 내적이라고 한다.</p>
<h2 id="행렬과-벡터의-곱">행렬과 벡터의 곱</h2>
<p>행렬이란 <span class="math inline">\(m \times n\)</span>의 2차원 배열이다. 여기서 <span class="math inline">\(m\)</span>은 행의 개수이고 <span class="math inline">\(n\)</span>은 열의 개수이다. 아래는 <span class="math inline">\(m \times n\)</span>의 행렬을 시각화한 것이다.</p>
<p><span class="math display">\[A=
\begin{bmatrix}
a_{11} &amp; \cdots &amp; a_{1n} \\
\vdots &amp; \ddots &amp; \vdots \\
a_{m1} &amp; \cdots &amp; a_{mn}
\end{bmatrix}\]</span></p>
<p>그렇다면 위와 같은 행렬을 벡터와 곱하는 것이 가능할까?</p>
<p><strong>NOTE</strong> 앞의 질문에 대답하기 전에 행렬과 벡터의 관계를 명확히 하려고 한다. 앞서 백터를 설명하는 섹션에서 봤던 열벡터 <span class="math inline">\(\overrightarrow{a}\)</span>는 <span class="math inline">\(2 \times 1\)</span> 행렬이라고 할 수 있으며, <span class="math inline">\(\overrightarrow{a}^T\)</span>는 <span class="math inline">\(1 \times 2\)</span> 행렬이라고 할 수 있다. 즉, 열벡터와 행벡터 모두 행렬로서 바라볼 수 있으며 그 반대도 가능하다.</p>
<p>행렬과 벡터를 곱하는 방법은 2가지가 있다.</p>
<h3 id="행-단위를-행벡터로-가정하여-내적한다">행 단위를 행벡터로 가정하여 내적한다</h3>
<p><span class="math display">\[A\overrightarrow{x}=
 \begin{bmatrix}
 a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\
 a_{21} &amp; a_{22} &amp; \cdots &amp; \vdots \\
 \vdots &amp; \cdots &amp; \ddots &amp; \vdots \\
 a_{m1} &amp; \cdots &amp; \cdots &amp; a_{mn}
 \end{bmatrix}
 \cdot
 \begin{bmatrix}
 x_1\\
 x_2\\
 \vdots\\
 x_n\\
 \end{bmatrix}
 =
 \begin{bmatrix}
 a_{11}x_1 + a_{12}x_2 + \cdots + a_{1n}x_n \\
 a_{12}x_1 + a_{22}x_2 + \cdots\cdots\cdot\ \vdots\ \\
 \ \vdots\ \\
 a_{m1}x_1 + \cdots\cdots\cdots\cdot + a_{mn}x_n
 \end{bmatrix}
 =\overrightarrow{b}\]</span></p>
<p>위의 공식은 행렬 A의 각 행을 행벡터로 인식하여 <span class="math inline">\(A\)</span>와 <span class="math inline">\(\overrightarrow{x}\)</span>가 내적한다. 즉, 전치행렬 <span class="math inline">\(A^T\)</span>의 열들을 벡터로 내적하는 것과 같다. 그렇기에 <span class="math inline">\(\overrightarrow{x}\)</span>의 길이는 행렬 A의 열 개수인 <span class="math inline">\(n\)</span>이어야 하며, 결과값인 <span class="math inline">\(\overrightarrow{b}\)</span>는 길이가 <span class="math inline">\(m\)</span>이다.</p>
<p><span class="math display">\[A\overrightarrow{x}= A(m \times n) \cdot \overrightarrow{x}(n \times 1) = \overrightarrow{b}(m \times 1)\]</span></p>
<p>직접 숫자를 넣어 예시를 풀어보자.</p>
<p><span class="math display">\[A\overrightarrow{x}=
 \begin{bmatrix}
 3 &amp; 1 &amp; 0 &amp; 3 \\
 2 &amp; 4 &amp; 7 &amp; 0 \\
 -1 &amp; 2 &amp; 3 &amp; 4 \\
 \end{bmatrix}
 \cdot
 \begin{bmatrix}
 1\\
 2\\
 3\\
 4\\
 \end{bmatrix}
 =
 \begin{bmatrix}
 3\times1+1\times2+0\times3+3\times4 \\
 2\times1+4\times2+7\times3+0\times4 \\
 -1\times1+2\times2+3\times3+4\times4\quad
 \end{bmatrix}
 =
 \begin{bmatrix}
 17\\
 31\\
 28\\
 \end{bmatrix}\]</span></p>
<p>위의 예시를 살펴보면 행렬 A의 각각의 행벡터와 <span class="math inline">\(\overrightarrow{x}\)</span>를 내적하여 나온 스칼라 값이 결과값인 것을 확인할 수 있다. 결국 위의 식을 정리한다면 다음와 같다.</p>
<p><span class="math display">\[A\overrightarrow{x}=
 \begin{bmatrix}
 \ \overrightarrow{a_1^T}\ \\
 \ \overrightarrow{a_2^T}\ \\
 \ \vdots\ \\
 \ \overrightarrow{a_n^T}\ \\
 \end{bmatrix}
 \cdot
 \overrightarrow{x}
 \ =
 \begin{bmatrix}
 \ \overrightarrow{a_1} \cdot\overrightarrow{x}\\
 \ \overrightarrow{a_2} \cdot\overrightarrow{x}\\
 \ \vdots\\
 \ \overrightarrow{a_n} \cdot\overrightarrow{x}\\
 \end{bmatrix}\]</span></p>
<h3 id="행렬을-열벡터의-모음으로-가정하여-내적한-후-각-행들을-더해준다">행렬을 열벡터의 모음으로 가정하여 내적한 후, 각 행들을 더해준다</h3>
<p>다음으로는 '열벡터' 개념만으로 행렬 벡터 곱을 이해하는 방법이다. 어떤 방법을 사용하든 결과는 동일하지만 진행되는 논리구조는 다르다. 둘 중 어느 방법을 사용해도 상관없지만 개인적으로는 이 방법이 더 편하다고 생각한다. 먼저 아래의 행렬을 각각의 열벡터의 모음이라고 생각해보자.</p>
<p><span class="math display">\[\begin{matrix}
 \overrightarrow{v_1}\ &amp; \overrightarrow{v_2}\ &amp; \cdots &amp; \overrightarrow{v_n}
 \end{matrix}\]</span> <span class="math display">\[\begin{bmatrix}
 a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\
 a_{21} &amp; a_{22} &amp; \cdots &amp; \vdots \\
 \vdots &amp; \cdots &amp; \ddots &amp; \vdots \\
 a_{m1} &amp; \cdots &amp; \cdots &amp; a_{mn}
 \end{bmatrix}\]</span></p>
<p>위의 도식처럼 행렬 A의 각 열들은 <span class="math inline">\(v_1\)</span>, <span class="math inline">\(v_2\)</span>, <span class="math inline">\(\cdots\)</span> <span class="math inline">\(v_n\)</span>인 열벡터로 분리되었다. <span class="math inline">\(v\)</span>의 개수는 행렬 A의 열 개수와 동일하며, 여기서는 n을 4라고 가정하자. 그 다음 <span class="math inline">\(\overrightarrow{v}\)</span> 백터들을 각각 <span class="math inline">\(\overrightarrow{x}\)</span>와 내적한 후, 결과로 나온 값들을 행 단위로 더해주면 된다.</p>
<p><span class="math display">\[A\overrightarrow{x}=\begin{bmatrix}
 \overrightarrow{v_1}\\
 \overrightarrow{v_2}\\
 \overrightarrow{v_3}\\
 \overrightarrow{v_4}\\
 \end{bmatrix}
 \begin{bmatrix}
 x_1\\
 x_2\\
 x_3\\
 x_4\\
 \end{bmatrix}
 =
 \begin{matrix}[x_1\overrightarrow{v_1}+x_2\overrightarrow{v_2}+x_3\overrightarrow{v_3}+x_4\overrightarrow{v_4}]\end{matrix}\]</span></p>
<p>따라서 <span class="math inline">\(A\overrightarrow{x}\)</span>는 <span class="math inline">\(\overrightarrow{v}\)</span> 벡터들에 <span class="math inline">\(\overrightarrow{x}\)</span>의 스칼라(상수)를 곱해준 것이다. 이는 <span class="math inline">\(\overrightarrow{v}\)</span> 벡터들의 값들을 <strong>가중</strong>해준다는 의미와 같다. 마지막으로 <span class="math inline">\(\overrightarrow{x}\)</span>의 스칼라(상수)를 곱해진 <span class="math inline">\(\overrightarrow{v}\)</span> 백터들을 행 단위로 더해주면 된다.</p>
<p>이제는 원리는 파악했으니 아래의 문제를 풀어보도록 하자.</p>
<p><span class="math display">\[A\overrightarrow{x}=
 \begin{bmatrix}
 3 &amp; 1 &amp; 0 &amp; 3 \\
 2 &amp; 4 &amp; 7 &amp; 0 \\
 -1 &amp; 2 &amp; 3 &amp; 4 \\
 \end{bmatrix}
 \cdot
 \begin{bmatrix}
 1\\
 2\\
 3\\
 4\\
 \end{bmatrix}\]</span></p>
<p>보다시피 위의 문제와 동일하다. 다만 답이 어떻게 도출되는지 과정의 차이를 집중적으로 살펴볼 것이다.</p>
<p><span class="math display">\[\begin{matrix}
 \overrightarrow{v_1}\ &amp;\overrightarrow{v_2}\ &amp; \overrightarrow{v_3}\ &amp; \overrightarrow{v_4}
 \end{matrix}\]</span> <span class="math display">\[ \begin{bmatrix}
 3\\
 2\\
 -1\\
 \end{bmatrix}
  \begin{bmatrix}
 1\\
 4\\
 2\\
 \end{bmatrix}
  \begin{bmatrix}
 0\\
 7\\
 3\\
 \end{bmatrix}
  \begin{bmatrix}
 3\\
 0\\
 4\\
 \end{bmatrix}\]</span></p>
<p><span class="math display">\[\begin{matrix}[x_1\overrightarrow{v_1}+x_2\overrightarrow{v_2}+x_3\overrightarrow{v_3}+x_4\overrightarrow{v_4}]\end{matrix}\]</span></p>
<p>위의 도식처럼 열벡터 단위로 분리한 후, 아래의 공식에 대입한다.</p>
<p><span class="math display">\[\begin{bmatrix}
3\times1+1\times2+0\times3+3\times4 \\
 2\times1+4\times2+7\times3+0\times4 \\
 -1\times1+2\times2+3\times3+4\times4\quad
 \end{bmatrix}
 =
 \begin{bmatrix}
 3 &amp; 2 &amp; 0 &amp; 12 \\
 2 &amp; 8 &amp; 21 &amp; 0 \\
 -1 &amp; 4 &amp; 9 &amp; 16 \\
 \end{bmatrix}\]</span></p>
<p>위의 결과를 행 단위로 더해준다.</p>
<p><span class="math display">\[\begin{bmatrix}
 3 + 2 + 0 + 12 \\
 2 + 8 + 21 + 0 \\
 -1 + 4 + 9 + 16 \\
 \end{bmatrix}
 =
 \begin{bmatrix}
 17 \\
 31 \\
 28 \\
 \end{bmatrix}\]</span></p>
<p>보다시피 첫 번째 방법과 결과는 같다. 위의 예시들은 모두 행렬과 열벡터 한 개를 내적하였다. 만약 행렬과 열벡터 여러 개를 한 번에 내적하고 싶다면 어떻게 해야 하는가? 벡터를 하나씩 행렬과 내적한 결과를 순서대로 나열하면 될 것이다. 이를 한번에 진행해주는 연산방법을 '행렬곱'이라고 한다.</p>
<h2 id="행렬곱">행렬곱</h2>
<p>행렬곱은 여러 개의 벡터를 한번에 행렬과 곱하는 것과 동일한 결과를 제공한다. 즉, 위에서 봤던 행렬과 벡터의 곱을 여러 번 진행한 것이라고 볼 수 있다. 만약 행렬 A와 행렬 B를 곱하여 행렬 C를 도출한다고 가정해보자.</p>
<p><span class="math display">\[ C = A*B \rightarrow c_{mn}=a_m^T \cdot b_n \]</span></p>
<p>행렬 C의 요소 <span class="math inline">\(c_{mn}\)</span>는 행렬 A의 <span class="math inline">\(m\)</span>번째 행과 행렬 B의 <span class="math inline">\(n\)</span>번째 열을 내적한 값이다. 이를 도식으로 나타내면 다음과 같다.</p>
<p><span class="math display">\[\begin{bmatrix}
 a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\
 a_{21} &amp; a_{22} &amp; \cdots &amp; \vdots \\
 \vdots &amp; \cdots &amp; \ddots &amp; \vdots \\
 a_{m1} &amp; \cdots &amp; \cdots &amp; a_{mn}
 \end{bmatrix}
 \begin{bmatrix}
 b_{11} &amp; b_{12} &amp; \cdots &amp; b_{1n} \\
 b_{21} &amp; b_{22} &amp; \cdots &amp; \vdots \\
 \vdots &amp; \cdots &amp; \ddots &amp; \vdots \\
 b_{m1} &amp; \cdots &amp; \cdots &amp; b_{mn}
 \end{bmatrix}\]</span> <span class="math display">\[=
 \begin{bmatrix}
 (a_{11}b_{11}+a_{12}b_{21}\cdots+a_{1n}b_{m1}) &amp;  \cdots &amp; (a_{11}b_{m1}+a_{12}b_{m2}\cdots+a_{1n}b_{mn}) \\
 (a_{21}b_{11}+a_{22}b_{21}\cdots+a_{2n}b_{m1}) &amp;  \cdots &amp; (a_{21}b_{m1}+a_{22}b_{m2}\cdots+a_{2n}b_{mn}) \\
 \vdots &amp;  &amp; \vdots \\
 (a_{m1}b_{11}+a_{m2}b_{21}\cdots+a_{mn}b_{m1}) &amp; \cdots &amp; (a_{m1}b_{m1}+a_{m2}b_{m2}\cdots+a_{mn}b_{mn})
 \end{bmatrix}\]</span></p>
<p>행렬곱에서는 행렬 두 개가 계산되는 것이므로 결과 또한 행렬의 형태를 가진다.</p>
<p><span class="math display">\[A*B= A(m \times n)*(n \times o) = C(m \times o)\]</span></p>
<p>이제 예시를 풀어보자.</p>
<p><span class="math display">\[\begin{bmatrix}
 1 &amp; 4 \\
 2 &amp; 5 \\
 3 &amp; 6 \\
 \end{bmatrix}
*
 \begin{bmatrix}
 1 &amp; 2 &amp; 3\\
 4 &amp; 5 &amp; 6\\
 \end{bmatrix}\]</span></p>
<p>위의 행렬들은 <span class="math inline">\(3\times2\)</span>와 <span class="math inline">\(2\times3\)</span>이므로 결과값 행렬은 <span class="math inline">\(3\times3\)</span>행렬이어야 한다.</p>
<p><span class="math display">\[\begin{bmatrix}
 (1\times1+4\times4) &amp; (1\times2+4\times5) &amp; (1\times3+4\times6) \\
 (2\times1+5\times4) &amp; (2\times2+5\times5) &amp; (2\times3+5\times6) \\
 (3\times1+6\times4) &amp; (3\times2+6\times5) &amp; (3\times3+6\times6) \\
 \end{bmatrix}\]</span> <span class="math display">\[=\]</span> <span class="math display">\[\begin{bmatrix}
 17 &amp; 22 &amp; 27 \\
 22 &amp; 29 &amp; 36 \\
 27 &amp; 36 &amp; 45 \\
 \end{bmatrix}\]</span></p>
<p>문제의 답으로 <span class="math inline">\(3\times3\)</span> 행렬이 나온 것을 확인할 수 있다. 이런 행렬곱은 신경망 계산에서 벡터의 단위로 내적 계산을 한번에 하기 위해 사용된다.</p>
<h2 id="줄리아에서의-곱셈">줄리아에서의 곱셈</h2>
<p>줄리아에서 내적을 사용하기 위해서는 아래의 코드를 입력하여 해당 패키지를 다운로드해야 한다. <code>LinearAlgebra</code> 사용법에 대해 자세히 알고 싶다면 <a target="_blank" rel="noopener" href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/">이 링크</a>에서 확인할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; <span class="hljs-keyword">import</span> Pkg<br>Julia&gt; Pkg.add(<span class="hljs-string">&quot;LinearAlgebra&quot;</span>)<br>Julia&gt; <span class="hljs-keyword">using</span> LinearAlgebra<br></code></pre></td></tr></table></figure>
<p>준비가 끝났다면 줄리아에서 내적을 어떻게 계산하는지 살펴보자. 줄리아에서 함수 <code>dot()</code>은 두 개의 백터를 내적한다. 아래의 예시를 통해 확인해보자.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; a = ones(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)<br>Julia&gt; a<br><br><span class="hljs-number">1</span>×<span class="hljs-number">3</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-number">2</span>&#125;:<br> <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span><br><br>Julia&gt; b = a&#x27;<br>Julia&gt; b<br><br><span class="hljs-number">3</span>×<span class="hljs-number">1</span> Adjoint&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-number">2</span>&#125;&#125;:<br> <span class="hljs-number">1.0</span><br> <span class="hljs-number">1.0</span><br> <span class="hljs-number">1.0</span><br><br>Julia&gt; dot(a,b)<br><span class="hljs-number">3.0</span><br></code></pre></td></tr></table></figure>
<p>위의 코드는 <span class="math inline">\(1\times3\)</span> 행렬인 a와, a의 전치행렬인 b를 생성하고 두 벡터를 내적한다. 그 결과로는 3이 도출되었다. 그렇다면 모든 신경망 계산에 <code>dot()</code>만을 사용하면 되는 것일까? 그렇지 않다. <code>dot()</code>은 모든 배열들을 하나의 벡터로 벡터화하는 문제가 있다. 아래의 예시를 통해서 알아보자.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; a = ones(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>Julia&gt; a<br><span class="hljs-number">2</span>×<span class="hljs-number">3</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-number">2</span>&#125;:<br> <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span><br> <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span><br><br>Julia&gt; b = a&#x27;<br>Julia&gt; b<br><span class="hljs-number">3</span>×<span class="hljs-number">2</span> Adjoint&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-number">2</span>&#125;&#125;:<br> <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span><br> <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span><br> <span class="hljs-number">1.0</span>  <span class="hljs-number">1.0</span><br><br>Julia&gt; dot(a,b)<br><span class="hljs-number">6.0</span><br></code></pre></td></tr></table></figure>
<p>위의 예시는 <span class="math inline">\(2\times3\)</span> 행렬인 a와 a의 전치행렬을 생성한다는 점에서 같지만, 각 변수들이 2차원 배열인 매트릭스(Matrix)라는 점에서 다르다. 즉, 첫 번째 예시는 1차 배열을 다루기 때문에 벡터화되어도 상관없는 반면 두 번째 예시는 2차원 배열이기 때문에 행과 열을 보존하여 내적을 해야 하는 것이다. 따라서 이는 행렬곱을 사용하여 처리해주어야 한다. 행렬곱 연산자는 <code>*(a,b)</code>이다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; a = ones(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>Julia&gt; b = a&#x27;<br>Julia&gt; *(a,b)<br><span class="hljs-number">2</span>×<span class="hljs-number">2</span> <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">Float64</span>,<span class="hljs-number">2</span>&#125;:<br> <span class="hljs-number">3.0</span>  <span class="hljs-number">3.0</span><br> <span class="hljs-number">3.0</span>  <span class="hljs-number">3.0</span><br></code></pre></td></tr></table></figure>
<h2 id="신경망-계산">신경망 계산</h2>
<p>신경망은 입력층, 은닉층, 출력층으로 구분되며 가중치와 편향을 사용하여 계산한다. 이제 신경망에서 사용되는 계산법을 모두 배웠으므로 위의 지식을 바탕으로 신경망이 어떻게 작동하는지 알아보자. 아래의 그림은 신경망 구조의 예시이다. 참고로 아래의 그림은 하나의 예시일 뿐이며, 각 층 변수의 개수는 가변적으로 설정할 수 있다.</p>
<figure>
<img src="/images/31.png" srcset="/img/loading.gif" lazyload alt="신경망 구조" /><figcaption aria-hidden="true">신경망 구조</figcaption>
</figure>
<p>위의 그림은 2층 신경망 구조이다. 위 그림에서 동그라미는 각 층의 성분으로 <strong>노드</strong>라고 하며, 노드끼리 연결된 화살표는 가중치인 <strong>엣지</strong>라고 한다. 지금부터는 위 신경망 구조를 코드로 구현하여 '행렬과 벡터 곱', '행렬곱'을 사용해볼 것이다.</p>
<p>먼저 위 구조를 분해해보도록 하자.</p>
<p>입력층(<span class="math inline">\(1\times4\)</span> 행렬), 은닉층(<span class="math inline">\(1\times2\)</span> 행렬), 출력층(<span class="math inline">\(1\times3\)</span> 행렬)은 다음과 같다.</p>
<p>입력층: <span class="math inline">\(X=[x_1,x_2,x_3,x_4]\quad\)</span> 은닉층: <span class="math inline">\(H=[h_1,h_2]\quad\)</span> 출력층: <span class="math inline">\(Y=[y_1,y_2,y_3]\quad\)</span></p>
<p>신경망을 계산하기 위해서는 가중치와 편향이 필요하다. 가중치는 각 층 사이에서 곱해지는 행렬이며, 편향은 각 층의 계산마다 더해지는 상수이다. 가중치와 편향에 대한 정의는 4장인 경사하강법에서 자세히 다룰 것이다.</p>
<p>각 층은 가중치인 <span class="math inline">\(W\)</span>를 곱하고 편향 <span class="math inline">\(B\)</span>를 더하여 다음 층으로 넘어간다. 이를 수학식으로 표현하면 아래와 같다.</p>
<p><span class="math inline">\(H=(X*W)+B\)</span></p>
<p>위의 신경망 구조에서 가중치와 편향은 총 2개가 필요하다. 먼저 가중치부터 살펴본다면, 첫 번째 가중치는 입력층과 은닉층 사이에 있으므로 <span class="math inline">\(4\times2\)</span> 행렬이어야 한다. 또한 두 번째는 은닉층과 출력층 사이에 있으므로 <span class="math inline">\(2\times3\)</span> 행렬이다.</p>
<p><span class="math display">\[가중치 행렬 1:
\begin{bmatrix}
 w_{11} &amp; w_{12} \\
 w_{21} &amp; w_{22} \\
 w_{31} &amp; w_{32} \\
 w_{41} &amp; w_{42}
 \end{bmatrix}\quad
가중치 행렬 2:
\begin{bmatrix}
 w_{51} &amp; w_{52} &amp; w_{53}\\
 w_{61} &amp; w_{62} &amp; w_{63}\\
 \end{bmatrix}\]</span></p>
<p>다음은 편향이다. 편향은 각 층과 가중치가 곱해진 결과에 더하므로 입력층에서 은닉층 사이의 첫 번째 편향은 <span class="math inline">\(1\times2\)</span> 행렬이며, 두 번째 편향은 <span class="math inline">\(1\times3\)</span> 행렬이다.</p>
<p><span class="math display">\[ 편향1:
\begin{bmatrix}
b_1 &amp; b_2
 \end{bmatrix}\quad
편향 2:
\begin{bmatrix}
 b_3 &amp; b_4 &amp; b_5
 \end{bmatrix}\]</span></p>
<p>입력층에서 은닉층까지의 계산을 순서대로 나타내면 아래의 수학식과 같다.</p>
<p><span class="math display">\[h_1=w_{11}x_1+w_{21}x_2+w_{31}x_3+w_{41}x_4+b_1\\
h_2=w_{12}x_1+w_{22}x_2+w_{32}x_3+w_{42}x_4+b_2\]</span></p>
<p>다음은 은닉층에서 출력층의 계산을 수학식으로 작성한 것이다.</p>
<p><span class="math display">\[y_1=w_{51}h_1+w_{61}h_2+b_3\\
y_2=w_{52}h_1+w_{62}h_2+b_4\\
y_3=w_{53}h_1+w_{63}h_2+b_5
\]</span></p>
<p>이제 준비가 완료되었다. 위의 수학식들을 코드로 구현해보자.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs julia">Julia&gt; X = [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>]<br>Julia&gt; W1 = [<span class="hljs-number">1</span> <span class="hljs-number">2</span>; <span class="hljs-number">3</span> <span class="hljs-number">4</span>;<span class="hljs-number">5</span> <span class="hljs-number">6</span>;<span class="hljs-number">7</span> <span class="hljs-number">8</span>]<br>Julia&gt; W2 = [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>; <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>]<br>Julia&gt; B1 = [<span class="hljs-number">1</span> <span class="hljs-number">2</span>]<br>Julia&gt; B2 = [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure>
<p>먼저 입력층 행렬과 가중치 행렬, 편향을 할당해준다. 그 후 위의 수학공식을 구현하여 은닉층을 구현해보자.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; H = *(X,W1)+B1<br><span class="hljs-number">51</span>  <span class="hljs-number">62</span><br></code></pre></td></tr></table></figure>
<p>은닉층은 입력층의 값에 가중치 W1을 곱한 후, 편향 B1을 더하였다. 마지막으로 출력층을 구현하면 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Julia&gt; Y = *(H,W2)+B2<br><span class="hljs-number">300</span>  <span class="hljs-number">414</span>  <span class="hljs-number">528</span><br></code></pre></td></tr></table></figure>
<p>사실 신경망을 구현하는 것은 위의 설명보다 더 복잡하다. 하지만 위의 원리를 이해하지 못한다면 신경망 자체를 파악할 수 없다. 다음 글에서는 신경망에 쓰이는 활성화 함수들을 살펴보고 줄리아로 구현할 것이다.</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/serieshub/" class="category-chain-item">SeriesHub</a>
  
  
    <span>></span>
    
  <a href="/categories/serieshub/deep-learning-in-julia/" class="category-chain-item">deep learning in julia</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%EB%94%A5%EB%9F%AC%EB%8B%9D/" class="print-no-link">#딥러닝</a>
      
        <a href="/tags/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D/" class="print-no-link">#머신러닝</a>
      
        <a href="/tags/deeplearning/" class="print-no-link">#Deeplearning</a>
      
        <a href="/tags/%EC%A4%84%EB%A6%AC%EC%95%84/" class="print-no-link">#줄리아</a>
      
        <a href="/tags/%EB%B2%A1%ED%84%B0/" class="print-no-link">#벡터</a>
      
        <a href="/tags/%EB%82%B4%EC%A0%81/" class="print-no-link">#내적</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>[1/18] 행렬과 벡터의 곱</div>
      <div>https://dev-bearabbit.github.io/ko/DeeplearningJulia/Deeplearning-1/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Jess</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>2020년 3월 26일</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/ko/DeeplearningJulia/Deeplearning-2/" title="[2/18] 활성화 함수">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">[2/18] 활성화 함수</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/ko/DeeplearningJulia/Deeplearning-0/" title="[0/18] 줄리아로 딥러닝 구현하기">
                        <span class="hidden-mobile">[0/18] 줄리아로 딥러닝 구현하기</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://dev-bearabbit.github.io" target="_blank" rel="nofollow noopener"><span>Jess</span></a>
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
