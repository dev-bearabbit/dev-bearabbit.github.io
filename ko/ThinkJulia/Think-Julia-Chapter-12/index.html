

<!DOCTYPE html>
<html lang="ko" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="alternate" hreflang="ko" href="https://dev-bearabbit.github.io/" />
  <link rel="alternate" hreflang="en" href="https://dev-bearabbit.github.io/en/" />  
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" href="/img/favicon.ico">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#000">
  <meta name="author" content="Jess">
  <meta name="keywords" content="">
  
    <meta name="description" content="글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.  이 포스트는 Case Study: Data Structure Selection를 한글로 요약 정리한 글입니다.">
<meta property="og:type" content="article">
<meta property="og:title" content="[12&#x2F;20] 사례 연구: 데이터 구조 선택">
<meta property="og:url" content="https://dev-bearabbit.github.io/ko/ThinkJulia/Think-Julia-Chapter-12/index.html">
<meta property="og:site_name" content="DEV AnythinG">
<meta property="og:description" content="글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.  이 포스트는 Case Study: Data Structure Selection를 한글로 요약 정리한 글입니다.">
<meta property="og:locale" content="ko_KR">
<meta property="article:published_time" content="2020-03-12T09:31:08.000Z">
<meta property="article:modified_time" content="2025-01-27T20:59:14.697Z">
<meta property="article:author" content="Jess">
<meta property="article:tag" content="줄리아">
<meta property="article:tag" content="Julia">
<meta property="article:tag" content="Think Julia">
<meta property="article:tag" content="기초 강의">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>[12/20] 사례 연구: 데이터 구조 선택 - DEV AnythinG</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"dev-bearabbit.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":"G-QW3E4LZZNF"},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=G-QW3E4LZZNF", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', 'G-QW3E4LZZNF');
        });
      }
    </script>
  

  

  

  



  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>DEV AnythinG</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="javascript:;" id="languageDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <i class="iconfont icon-globe"></i> <span id="current-lang"></span>
          </a>
          <div class="dropdown-menu" aria-labelledby="languageDropdown">
            <a class="dropdown-item" href="/">한국어</a>
            <a class="dropdown-item" href="/en/">English</a>
          </div>
        </li>
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    // 현재 언어를 URL 기반으로 감지
    const path = window.location.pathname;
    const currentLang = path.startsWith('/en/') ? 'English' : '한국어';

    // 선택된 언어를 버튼에 표시
    const currentLangElement = document.getElementById('current-lang');
    currentLangElement.textContent = currentLang;
  });
</script>

  

<div id="banner" class="banner" parallax=true
  style="background: url('/img/background.gif') no-repeat center center; background-size: cover;">
  <canvas id="canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></canvas>
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="[12/20] 사례 연구: 데이터 구조 선택"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2020-03-12 18:31" pubdate>
          2020년 3월 12일 오후
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          858 words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          8 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // 캔버스 크기를 배너 크기와 동기화
    const banner = document.getElementById('banner');
    canvas.width = banner.offsetWidth;
    canvas.height = banner.offsetHeight;

    const cols = Math.floor(canvas.width / 20) + 1;
    const ypos = Array(cols).fill(0);

    function matrix() {
      ctx.fillStyle = '#0001'; // 배경 페이드 효과
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = '#009600'; // 텍스트 색상
      ctx.font = '14pt monospace';

      ypos.forEach((y, index) => {
        const text = String.fromCharCode(33 + Math.random() * 94); // 랜덤 ASCII 문자
        const x = index * 20;
        ctx.fillText(text, x, y);

        if (y > canvas.height + Math.random() * 10000) ypos[index] = 0;
        else ypos[index] = y + 20;
      });
    }

    setInterval(matrix, 60);

    // 창 크기 조정 시 캔버스 크기 업데이트
    window.addEventListener('resize', () => {
      canvas.width = banner.offsetWidth;
      canvas.height = banner.offsetHeight;
    });
  });
</script>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">[12/20] 사례 연구: 데이터 구조 선택</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p>
</blockquote>
<p>이 포스트는 <a target="_blank" rel="noopener" href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap13">Case Study: Data Structure Selection</a>를 한글로 요약 정리한 글입니다. <span id="more"></span></p>
<h2 id="사례-연구-데이터-구조-선택">사례 연구: 데이터 구조 선택</h2>
<p>지금까지 줄리아의 핵심 데이터 구조에 대해서 배우고 이를 사용하는 일부 알고리즘 살펴보았다. 이번 장에서는 사례 연구를 통해서 데이터 구조를 선택하고 사용하는 방법을 연습할 것이다.</p>
<h3 id="단어-빈도-분석-word-frequency-analysis">단어 빈도 분석 (Word Frequency Analysis)</h3>
<p>가능하다면, 해결책을 살펴보기 전에 아래의 연습문제를 풀어보자.</p>
<p><strong>연습문제 1</strong> 파일을 읽고, 각 줄을 단어로 나누고, 단어에서 공백과 문장부호를 제거한 후 소문자로 변환하는 프로그램을 작성해라.</p>
<p><strong>Tip</strong> <code>isletter()</code>은 문자를 알파벳인지 테스트한다.</p>
<p><strong>연습문제 2</strong> <a target="_blank" rel="noopener" href="https://gutenberg.org">Project Gutenberg</a>로 가서 저작권이 없는 책을 일반 텍스트 형식으로 다운로드해라. 이전에 사용했던 프로그램을 수정하여 다운로드한 책을 읽어온 후, 파일 시작 부분의 헤더 정보를 건너 뛰고 위의 프로그램을 실행하라. 그 다음 책의 총 단어 수와 각 단어가 사용된 횟수를 계산하도록 프로그램을 수정해라.</p>
<p><strong>연습문제 3</strong> 책에서 가장 자주 사용되는 20개의 단어를 인쇄하도록 이전 연습문제의 프로그램을 수정해라.</p>
<p><strong>연습문제 4</strong> 이전 프로그램을 수정하여 단어 목록을 읽은 후, 단어 목록에 없는 단어를 인쇄해라. 오타는 몇 개인가? 단어 목록에 있어야 하는 일반적인 단어는 몇 개이며, 실제로 모호한 단어는 몇 개인가?</p>
<h3 id="랜덤-숫자">랜덤 숫자</h3>
<p>대부분의 컴퓨터 프로그램은 같은 입력이 주어지면 똑같은 결과를 출력한다. 그래서 이런 실행 흐름을 결정론적이라고 말할 수 있다. 결정론은 동일한 계산이 동일한 결과를 산출한다고 가정하기 때문에 일반적으로 좋은 이론이다. 하지만 일부 응용 프로그램의 경우 컴퓨터가 예측할 수 없는 형태이기를 원한다. 게임은 확실한 예이며, 다른 예들도 있다.</p>
<p>프로그램을 비결정론적으로 만드는 것은 어렵지만, 적어도 비결정론적으로 보이게 하는 방법은 있다. 그 중 하나는 '의사 난수 (pseudorandom numbers)' 생성하는 알고리즘을 사용하는 것이다. 의사 난수는 결정론적 계산에 의해 생성되기 때문에 실제로 완벽한 무작위는 아니지만, 마치 랜덤 숫자와 같은 결과를 제공한다.</p>
<p><code>rand()</code>는 <code>0.0</code>과 <code>1.0</code>사이의 랜덤 소수를 반환한다. (0.0은 포함하지만 1.0은 포함하지 않는다) <code>rand()</code>를 호출할 때마다, 긴 배열 중에 다음 소수가 반환된다. 아래의 코드를 통해 결과를 확인해보자.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:<span class="hljs-number">10</span><br>    x = rand()<br>    println(x)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p>또한 <code>rand()</code>는 이터레이터나 배열을 인수로서 가져올 수 있으며 결과로 랜덤 요소를 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:<span class="hljs-number">10</span><br>    x = rand(<span class="hljs-number">1</span>:<span class="hljs-number">6</span>)<br>    print(x, <span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<h3 id="단어-히스토그램">단어 히스토그램</h3>
<p>이 장을 진행하기 전에 앞에서 제시했던 연습문제를 풀어봐야 한다. 그 다음 <a target="_blank" rel="noopener" href="https://github.com/BenLauwens/ThinkJulia.jl/blob/master/data/emma.txt">해당 링크</a>에 가서 텍스트를 다운로드해라.</p>
<p>아래의 코드는 파일을 읽고 파일에 있는 단어의 히스토그램을 작성하는 프로그램이다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> processfile(filename)<br>    hist = <span class="hljs-built_in">Dict</span>()<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> eachline(filename)<br>        processline(line, hist)<br>    <span class="hljs-keyword">end</span><br>    hist<br><span class="hljs-keyword">end</span>;<br><br><span class="hljs-keyword">function</span> processline(line, hist)<br>    line = replace(line, <span class="hljs-string">&#x27;-&#x27;</span> =&gt; <span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> split(line)<br>        word = string(filter(isletter, [word...])...)<br>        word = lowercase(word)<br>        hist[word] = get!(hist, word, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span>;<br></code></pre></td></tr></table></figure>
<p>위의 프로그램은 위의 링크에서 다운받은 'emma.txt'을 읽어온다.</p>
<p><code>processfile()</code>은 파일의 줄을 읽어오고 <code>processline()</code>으로 한 줄씩 보낸다. 히스토그램인 <code>hist</code>는 누적기(accumulator)로 사용된다.</p>
<p><code>processline()</code>은 줄을 단어로 분리하고 문자 배열로 변경하는 <code>split()</code>을 사용하기 전에 <code>-</code>을 공백으로 바꾸기 위해서 <code>replace()</code>를 사용한다. 그리고 단어 배열은 <code>filter()</code>와 <code>isletter</code>로 마침표와 기타 문장기호들을 제거하고 <code>lowercase()</code>로 소문자로 변경한다.(정확히 말하면, 문자열은 변경된 것이 아니라 소문자로 구성된 새 문자열을 반환한 것이다)</p>
<p>마지막으로, <code>processline()</code>은 새로운 항목을 만들거나 기존 항목을 증가시켜 히스토그램을 업데이트한다.</p>
<p>파일의 단어가 총 몇 개인지 세어보려면 히스토그램에서 빈도가 합쳐져야 한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> totalwords(hist)<br>    sum(values(hist))<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p>다른 단어들의 수는 딕셔너리에서 아이템의 수이다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> differentwords(hist)<br>    length(hist)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p>결과는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; println(<span class="hljs-string">&quot;Total number of words: &quot;</span>, totalwords(hist))<br>Total number of words: <span class="hljs-number">162742</span><br><br>julia&gt; println(<span class="hljs-string">&quot;Number of different words: &quot;</span>, differentwords(hist))<br><span class="hljs-built_in">Number</span> of different words: <span class="hljs-number">7380</span><br></code></pre></td></tr></table></figure>
<h3 id="가장-일반적인-단어">가장 일반적인 단어</h3>
<p>가장 일반적인 단어들을 찾기 위해서는 각각의 튜플이 단어와 빈도를 포함한 튜플 배열을 만들고 그 배열을 정리하면 된다. 아래의 함수는 히스토스램을 가져와 단어-빈도 튜플 배열로 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> mostcommon(hist)<br>    t = []<br>    <span class="hljs-keyword">for</span> (key, value) <span class="hljs-keyword">in</span> hist<br>        push!(t, (value, key))<br>    <span class="hljs-keyword">end</span><br>    reverse!(sort(t))<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p>위의 튜플은 빈도가 첫 번째 값이기 때문에 정렬도 빈도를 기준으로 배치된다. 아래의 코드는 10개의 가장 일반적인 단어를 반환한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia">t = mostcommon(hist)<br>println(<span class="hljs-string">&quot;The most common words are:&quot;</span>)<br><span class="hljs-keyword">for</span> (freq, word) <span class="hljs-keyword">in</span> t[<span class="hljs-number">1</span>:<span class="hljs-number">10</span>]<br>    println(word, <span class="hljs-string">&quot;\t&quot;</span>, freq)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p>위의 코드에서는 <code>\t</code>인 줄내림 분리기호를 사용하였다. 그 결과 단어들은 아래로 정렬된다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Julia">The most common words are:<br>to  <span class="hljs-number">5295</span><br>the <span class="hljs-number">5266</span><br>and <span class="hljs-number">4931</span><br>of  <span class="hljs-number">4339</span><br>i   <span class="hljs-number">3191</span><br>a   <span class="hljs-number">3155</span><br>it  <span class="hljs-number">2546</span><br>her <span class="hljs-number">2483</span><br>was <span class="hljs-number">2400</span><br>she <span class="hljs-number">2364</span><br></code></pre></td></tr></table></figure>
<p><strong>Tip</strong> 위 코드는 <code>sort()</code>의 <code>rev</code> 키워드 인수를 사용하여 단순화할 수 있다. <code>rev</code>에 대해서는 <a target="_blank" rel="noopener" href="https://docs.julialang.org/en/v1/base/sort/#Base.sort.">이 링크</a>에서 읽을 수 있다.</p>
<h3 id="선택적-매개-변수-optional-parameters">선택적 매개 변수 (Optional Parameters)</h3>
<p>지금까지는 선택적 인수를 가진 내장 함수들을 보았다. 물론 프로그래머가 직접 정의하는 함수 또한 선택적 인수를 사용하여 작성할 수 있다. 예를 들어 가장 일반적인 단어를 히스토그램으로 출력하는 함수는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> printmostcommon(hist, num=<span class="hljs-number">10</span>)<br>    t = mostcommon(hist)<br>    println(<span class="hljs-string">&quot;The most common words are: &quot;</span>)<br>    <span class="hljs-keyword">for</span> (freq, word) <span class="hljs-keyword">in</span> t[<span class="hljs-number">1</span>:num]<br>        println(word, <span class="hljs-string">&quot;\t&quot;</span>, freq)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p>첫 번째 매개 변수는 필수적으로 들어가야 하지만, 두 번째 매개 변수는 선택적이다. 위 코드에서 선택적 매개 변수의 기본값은 <code>num=10</code>이다.</p>
<p>만약 하나의 인수만 넣어 실행하면</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">printmostcommon(hist)<br></code></pre></td></tr></table></figure>
<p><code>num</code>은 자동으로 기본값이 입력된다. 만약 두 개의 인수를 모두 넣으면</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">printmostcommon(hist,<span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure>
<p><code>num</code>은 기본값 대신 입력한 새로운 값을 사용한다.</p>
<p>만약 함수에 필수적(required) 매개 변수와 선택적(optional) 매개 변수를 모두 입력하고 싶다면, 필수적 변수는 첫 번째로 입력하고 선택적 변수는 그 뒤에 써야 한다.</p>
<h3 id="딕셔너리-뺄셈-dictionary-subtraction">딕셔너리 뺄셈 (Dictionary Subtraction)</h3>
<p>책에서 words.txt 단어 리스트에 없는 단어를 찾는 것은 두 딕셔너리를 빼는 것 처럼 인식된다. 즉, 책에는 있지만 단어 리스트에는 없는 단어를 찾으려는 것이다.</p>
<p><code>subtract()</code>은 딕셔너리 <code>d1</code>과 <code>d2</code>를 가져와서 <code>d1</code>는 있지만 <code>d2</code>에는 없는 키들을 포함한 새로운 딕셔너리를 반환한다. 값은 필요 없기 때문에 <code>nothing</code>으로 설정했다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> subtract(d1, d2)<br>    res = <span class="hljs-built_in">Dict</span>()<br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> keys(d1)<br>        <span class="hljs-keyword">if</span> key ∉ keys(d2)<br>            res[key] = <span class="hljs-literal">nothing</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    res<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p>책에는 있지만 단어 리스트에 없는 단어를 찾기 위해서는 words.txt 또한 <code>processfile()</code>를 사용해서 히스토그램으로 만들어야 한다. 그리고 <code>subtract()</code>를 사용하자.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia">words = processfile(<span class="hljs-string">&quot;words.txt&quot;</span>)<br>diff = subtract(hist, words)<br><br>println(<span class="hljs-string">&quot;Words in the book that aren&#x27;t in the word list:&quot;</span>)<br><span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> keys(diff)<br>    print(word, <span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p>그 결과는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Words <span class="hljs-keyword">in</span> the book that aren&#x27;t <span class="hljs-keyword">in</span> the word list:<br>outree quicksighted outwardly adelaide rencontre jeffereys unreserved dixons betweens ...<br></code></pre></td></tr></table></figure>
<p>위의 단어들 중에서 일부는 사람 이름과 소유물이다. 또한 "rencontre"와 같은 단어는 더이상 사용하지 않는 용어이다. 그러나 몇 개의 단어는 일반적인 단어로서 리스트에 있어야 한다.</p>
<h3 id="랜덤-단어-random-words">랜덤 단어 (Random Words)</h3>
<p>히스토그램으로부터 랜덤 단어를 선택하기 위해서 사용되는 가장 간편한 알고리즘은 각 단어의 복사본을 빈도만큼 만든 후 배열을 생성하여 선택하게 하는 것이다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> randomword(h)<br>    t = []<br>    <span class="hljs-keyword">for</span> (word, freq) <span class="hljs-keyword">in</span> h<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:freq<br>            push!(t, word)<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    rand(t)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p>위의 알고리즘은 작동하지만, 효율적이지는 않다. 랜덤 단어를 선택할 때마다 책만큼 큰 크기의 배열을 다시 만든다. 효율을 향상시키기 위해서 배열을 한번만 만들고 여러 번 선택하는 방법도 좋지만, 배열의 크기는 여전히 크다.</p>
<p>대안으로는 다음과 같다.</p>
<ul>
<li>책에 있는 단어의 배열을 가져와라.</li>
<li>단어 빈도의 누적 합계를 요소로 하는 배열을 만들어라. 이 배열의 마지막 요소는 책의 총 단어 수가 되어야 한다.</li>
<li>1부터 n사이의 난수를 선택하라. 난수가 있는 위치를 찾기 위해 이분법 검색(bisection search)를 사용하여 해당 인덱스를 얻어라.</li>
<li>인덱스를 사용하여 연결되어 있는 단어를 찾아라.</li>
</ul>
<p><strong>대안 해결 코드</strong> 아래의 코드는 제가 직접 작성한 코드입니다. 필요하신 분들만 참고해주세요 :)</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> cumulsum(t)<br>    cumul=[]<br>    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:length(t)<br>        temp= sum(t[<span class="hljs-number">1</span>:n])<br>        cumul=push!(cumul,temp)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> cumul<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> searching_word(t)<br>    words=collect(keys(t))<br>    addnum=cumulsum(collect(values(t)))<br>    random=rand(<span class="hljs-number">1</span>:length(t))<br>    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:(length(addnum)-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> addnum[n] &lt; random &lt; addnum[n+<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">return</span> words[n]<br>        <span class="hljs-keyword">elseif</span> n+<span class="hljs-number">1</span> == addnum[<span class="hljs-keyword">end</span>]<br>            <span class="hljs-keyword">return</span> words[<span class="hljs-keyword">end</span>]<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<h3 id="마르코프-분석-markov-analysis">마르코프 분석 (Markov Analysis)</h3>
<p>책에서 무작위로 단어를 선택하면, 어휘는 알 수 있지만 문장은 얻지 못할 것이다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia">this the small regard harriet which knightley&#x27;s it most things<br></code></pre></td></tr></table></figure>
<p>위의 문장처럼 무작위로 단어를 배열하면 문법적인 문제로 어떤 의미도 갖지 못하는 경우가 많다. 예를 들어, 의미를 가진 문장이라면 "the" 다음에 명사나 형용사가 올 것으로 예상할 수 있으며 동사나 부사는 사용할 수 없다.</p>
<p>이런 관계를 파악하는 한 가지 방법은 특정 단어 이후에 나올 단어의 확률을 분석하는 마르코프 분석을 사용하는 것이다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia">Half a bee, philosophically,<br>Must, ipso facto, half not be.<br>But half the bee has got to be<br>Vis a vis, its entity. D’you see?<br><br>But can a bee be said to be<br>Or not to be an entire bee<br>When half the bee is not a bee<br>Due to some ancient injury?<br></code></pre></td></tr></table></figure>
<p>위의 글에서 "half the"라는 구문 뒤에는 항상 "bee"이라는 단어가 쓰이며, "bee" 뒤에는 "has"나 "is"가 쓰이는 것을 알 수 있다.</p>
<p>마르코프 분석에서는 각 접두사("half the","bee")에서 가능한 모든 접미사("has","is")로 매핑한다.</p>
<p>이 맵이 있으면 랜덤 접두사로 시작한 후 가능한 접미사에서 임의로 선택하고 이를 반복하여 글을 생성할 수 있다.</p>
<p>예를 들어, 접두사 "half a"로 시작하는 경우 다음 단어는 "bee"이여야 한다. 왜냐하면 접두사 "half a"가 글에 딱 한번 나왔기 때문에 다른 확률이 없다. 다음 접두사는 "bee"이기 때문에 그 뒤에는 접미사 “philosophically”, “be” 또는 “due”가 올 수 있다.</p>
<p>위의 예시는 접두사 길이를 두 단어로 한정시켰다. 이처럼 마르코프 분석은 접두사 길이를 사용해서도 활용할 수 있다.</p>
<p><strong>마르코프 분석 연습문제</strong> 다음 장으로 가기 전에 해당 연습문제를 꼭 시도해보기를 추천한다.</p>
<ul>
<li><p>파일에서 텍스트를 읽고 마르코프 분석을 수행하는 프로그램을 작성하라. 결과는 접두사에서 가능한 접미사 모음으로 매핑되는 딕셔너리어야 한다. 모음은 배열, 튜플 또는 딕셔너리 어떤 것을 사용해도 상관없다. 접두사 길이와 상관없이 사용할 수 있는 프로그램을 작성하라.</p></li>
<li><p>마르코프 분석을 기반으로 임의의 텍스트를 생성하려면 이전 프로그램에 함수를 추가하라. 다음은 접두사 길이가 2인 Emma의 예이다.</p></li>
</ul>
<p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">“He was very clever, be it sweetness or be angry,<br>ashamed or only amused, at such a stroke.<br>She had never thought of Hannah till you were never meant <span class="hljs-keyword">for</span> me?<span class="hljs-string">&quot;</span><br><span class="hljs-string"> &quot;I</span> cannot make speeches, Emma:<span class="hljs-string">&quot; he soon cut it all himself.”</span><br></code></pre></td></tr></table></figure></p>
<p>이 예시에서는 마침표를 단어로 포함했다. 결과는 거의 문법적으로 정확하지만 완벽하지는 않으며, 의미도 어느정도 있는 것 같지만 완벽하게 이해되지는 않는다. 만약 접두사의 길이를 늘리면 어떤 결과가 나오는가? 문장이 더 의미있는가?</p>
<ul>
<li>프로그램이 작동한다면, '매쉬 업(mash-up)'을 시도할 수 있다. 두 권 이상의 책을 결합하여 생성한 랜덤 텍스트는 더 흥미로운 어휘와 문장을 보여줄 것이다.</li>
</ul>
<h3 id="데이터-구조-data-structures">데이터 구조 (Data Structures)</h3>
<p>마르코프 분석을 사용하여 랜덤 텍스트를 만드는 것은 재미있지만 사실 연습문제에는 '데이터 구조 선택(data structure selection)'이라는 중요한 핵심이 있다. 위의 연습문제를 풀기 위해서는 아래의 내용들을 결정해야 한다.</p>
<ul>
<li>접두사를 나타내는 방법</li>
<li>가능한 접미사 모음을 나타내는 방법</li>
<li>각 접두사에서 가능한 접미사 모음으로 매핑을 나타내는 방법</li>
</ul>
<p>마지막 문제를 해결하는 방법은 쉽다. 딕셔너리 키에서 해당 값으로 매핑해주면 끝이다. 접두사의 경우 가장 좋은 방법은 문자열, 문자열 배열, 또는 문자열 튜플이다. 접미사는 배열이나 히스토그램(딕셔너리)이 적절하다.</p>
<p>어떻게 선택해야 할까? 첫 번째 단계는 각 데이터 구조를 위해 구현해야 하는 작업에 대해 생각하는 것이다. 접두사의 경우 사용한 접두사를 제거하고 새로운 접두사를 추가할 수 있어야 한다. 예를 들어 현재 접두사가 "half a"이고 다음 단어가 "bee"인 경우 다음 접두사 "bee"를 생성할 수 있어야 한다.</p>
<p>배열은 요소를 쉽게 추가하고 제거할 수 있기 때문에 사용하기 적절하다.</p>
<p>접미사 모음의 경우, 새 접미사 추가 및 기존 접미사 빈도 증가, 랜덤 접미사 선택 등의 일들을 수행해야 한다.</p>
<p>새 접미사를 추가하는 것은 배열 구현이나 히스토그램 둘 다 쉽다. 하지만 랜덤 요소를 선택하는 것은 히스토그램보다 배열이 더 쉽다.</p>
<p>지금까지는 어떤 구조가 구현하기 편한지에 대해서 이야기했지만 사실 데이터 구조를 선택할 때 고려해야 할 다른 중요한 부분들이 있다. 첫 번째는 런타임이다. 각각의 데이터 구조마다 소요되는 시간은 이론적으로 차이가 있다. 예를 들어 <code>in</code> 연산자는 요소가 많을 때 배열보다 딕셔너리에서 더 빠르다.</p>
<p>그러나 어떤 구현이 더 빠른지 미리 알지 못하는 경우가 종종 있다. 이럴 경우 두 가지의 선택으로 나뉘는데, 그 중 하나는 모두 구현해본 다음에 어느 것이 더 나은지를 경험해보는 것이다. 이 접근법을 벤치마킹(benchmarking)이라고 한다. 또 다른 실용적인 대안은 구현하기 가장 쉬운 데이터 구조를 선택한 다음 프로그램에 적합한 속도인지를 확인하는 것이다. 만약 적합하다면, 굳이 다른 데이터 구조를 만들 필요가 없다. 적합하지 않다면, 시간이 가장 많이 걸리는 프로그램 위치를 알려주는 <code>Profile</code> 모듈과 같은 도구들을 사용하면 된다.</p>
<p>고려해야 할 두번째 요소는 저장 공간이다. 예를 들어, 접미사 모음에 히스토그램을 사용하면 텍스트에 여러 번 나타나는지에 관계없이 각 단어를 한 번만 저장하면 되므로 저장 공간을 덜 차지할 수 있다. 경우에 따라 저장 공간을 절약하면 프로그램 실행 속도가 빨라질 수 있으며, 메모리가 부족할 경우에는 프로그램이 실행되지 않을 수 있다. 하지만 많은 응용프로그램들에서는 런타임을 우선적으로 고려한다.</p>
<p>지금까지는 마르코프 분석과 텍스트 생성을 동시에 하는 데이터 구조를 생각했다. 하지만 분석과 텍스트 생성을 별도의 단계로 나눈 각각의 데이터 구조를 사용하는 것도 가능하다. 만약 통합된 데이터 구조보다 별도로 나눈 데이터 구조가 더 빠르다면 나누는 것이 바람직하다.</p>
<p><strong>Tip</strong> 줄리아 패키지 <a target="_blank" rel="noopener" href="https://github.com/JuliaCollections/DataStructures.jl"><code>DataStructures</code></a>는 다양한 데이터 구조를 구현한다.</p>
<h3 id="디버깅">디버깅</h3>
<p>프로그램을 디버깅할 때, 특히 어려운 버그를 만났을 때 아래의 5가지를 시도해보라.</p>
<ul>
<li><p>읽기(Reading) 코드를 검사하고 스스로 다시 코드를 읽은 후 무엇을 원하는지 확인하라.</p></li>
<li><p>실행(Running) 변경한 다른 버전을 실행하면서 실험해보라. 코드를 올바른 위치에 잘 작성하면 문제가 명확하게 보이지만, 때로는 스캐폴딩을 만들어 문제를 확인해야 한다.</p></li>
<li><p>반추(Ruminating) 시간을 두고 생각해보라. 문법, 런타임, 의미 오류가 무엇인가? 오류 메시지 또는 프로그램 출력에서 무엇을 얻을 수 있나? 어떤 종류의 문제가 발생할 수 있는가? 문제가 나타나기 전에 변경한 사항은 무엇인가?</p></li>
<li><p>고무오리(Rubberducking) 다른 사람에게 문제를 설명하면, 말이 끝나기도 전에 답을 찾을 때가 있다. 만약 다른 사람이 없다면, 우리는 고무오리와도 대화할 수 있다. 이 전략을 고무오리 디버깅이라고 한다. 이 전략을 자세히 알고 싶다면 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Rubber_duck_debugging">이 링크</a>를 참고해라.</p></li>
<li><p>후진(Retreating) 어떨 때는 오류가 나기 전의 프로그램으로 돌아오는 것이 가장 좋은 방법이다. 즉, 변경사항들을 취소한 후 프로그램을 다시 구현하는 것이다.</p></li>
</ul>
<p>초보 프로그래머들은 위의 5가지 방법 중 하나에 갇혀서 다른 방법들을 잊어버리곤 한다. 상황에 따라 문제에 최적화된 방법은 다르다는 것을 기억하자.</p>
<p>예를 들어, 문제가 인쇄상의 오류인 경우에는 코드를 읽는 것이 도움이 될 수 있지만 개념 오해로 비롯된 문제라면 읽는 방법은 도움이 되지 않는다. 프로그램이 어떻게 작동하는지 이해하지 못하면, 100번을 읽어도 오류를 찾을 수 없다.</p>
<p>실험 방법은 작고 간단한 테스트일 때 도움이 된다. 하지만 코드를 생각하거나 읽지 않고 실험만 진행하면 아무거나 바꿔보는 랜덤 워크 프로그래밍(random walk programming)에 빠질 수 있다. 이것은 시간이 오래 걸린다.</p>
<p>생각하려면 시간이 소요된다. 디버깅은 실험과학과 같다. 문제가 무엇인지에 대한 가설이 하나 이상은 있어야 한다. 둘 이상의 가능성이 있다면, 그 중 하나를 제거할 수 있는 테스트를 생각해보라.</p>
<p>그러나 오류가 너무 많거나 수정하려는 코드가 너무 크고 복잡하면 최고의 디버깅 기술조차 실패한다. 때로는 후진하는 것이 최선의 방법이며, 프로그램이 이해되고 작동될 때까지 단순화해야 한다.</p>
<p>초보 프로그래머는 종종 코드 라인을 삭제하는 후퇴를 꺼려한다. 불안하다면 프로그램 코드를 복사해둔 후 하나씩 수정해보라.</p>
<p>어려운 버그를 찾으려면 읽고, 실행하고, 반추하고 때로는 후진해야 한다. 한 가지 방법에서 막힌다면 다양한 방법을 시도해보라.</p>
<p><strong>연습문제 코드</strong> 아래의 코드는 제가 직접 작성한 코드입니다. 필요하신 분들만 참고해주세요 :)</p>
<ul>
<li>연습문제 1</li>
</ul>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> letterfilter(f)<br>    words=[]<br>    <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> split(f)<br>        word=lowercase(word)<br>        word=string(filter(isletter, word))<br>        push!(words,word)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> words<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> sentencetoword(t)<br>    fin = open(t)<br>    temp = []<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> eachline(t)<br>    f=readline(fin)<br>    replace(f,<span class="hljs-string">&quot;-&quot;</span> =&gt; <span class="hljs-string">&quot; &quot;</span>)<br>    replace(f,<span class="hljs-string">&quot;,&quot;</span> =&gt; <span class="hljs-string">&quot; &quot;</span>)<br>    t=letterfilter(f)<br>    temp=append!(temp,t)<br>    temp[<span class="hljs-string">&quot;&quot;</span>]=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> temp<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<ul>
<li>연습문제 2</li>
</ul>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> sentencetoword(t)<br>    fin = open(t)<br>    temp = <span class="hljs-built_in">Dict</span>()<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> eachline(t)<br>    f=readline(fin)<br>    replace(f,<span class="hljs-string">&quot;-&quot;</span> =&gt; <span class="hljs-string">&quot; &quot;</span>)<br>    replace(f,<span class="hljs-string">&quot;,&quot;</span> =&gt; <span class="hljs-string">&quot; &quot;</span>)<br>    letterfilter(f,temp)<br>    temp[<span class="hljs-string">&quot;&quot;</span>]=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> temp<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> letterfilter(f,temp)<br>    <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> split(f)<br>        word=lowercase(word)<br>        word=string(filter(isletter, word))<br>        temp[word]=get!(temp,word,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> numofword(t)<br>    ml= sentencetoword(t)<br>    wordnum=sum(values(ml))<br>    print(wordnum)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<ul>
<li>연습문제 3</li>
</ul>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> change(t)<br>    m=[]<br>    <span class="hljs-keyword">for</span> (key,value) <span class="hljs-keyword">in</span> t<br>        push!(m,(value,key))<br>    <span class="hljs-keyword">end</span><br>    reverse!(sort(m))<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> topword(t, n)<br>    words=change(t)<br>    top=words[<span class="hljs-number">1</span>:n]<br>    print(top)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<ul>
<li>연습문제 4</li>
</ul>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Julia">wordlist=sentencetoword(<span class="hljs-string">&quot;words.txt&quot;</span>)<br><br><span class="hljs-keyword">function</span> findweird(t1,t2)<br>    word1=keys(t1)<br>    word2=keys(t2)<br>    final=[]<br>    <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> word1<br>        <span class="hljs-keyword">if</span> word ∉ word2<br>        push!(final,word)<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> final<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/serieshub/" class="category-chain-item">SeriesHub</a>
  
  
    <span>></span>
    
  <a href="/categories/serieshub/think-julia/" class="category-chain-item">think julia</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%EC%A4%84%EB%A6%AC%EC%95%84/" class="print-no-link">#줄리아</a>
      
        <a href="/tags/julia/" class="print-no-link">#Julia</a>
      
        <a href="/tags/think-julia/" class="print-no-link">#Think Julia</a>
      
        <a href="/tags/%EA%B8%B0%EC%B4%88-%EA%B0%95%EC%9D%98/" class="print-no-link">#기초 강의</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>[12/20] 사례 연구: 데이터 구조 선택</div>
      <div>https://dev-bearabbit.github.io/ko/ThinkJulia/Think-Julia-Chapter-12/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Jess</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>2020년 3월 12일</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/ko/ThinkJulia/Think-Julia-Chapter-13/" title="[13/20] 파일">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">[13/20] 파일</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/ko/ThinkJulia/Think-Julia-Chapter-11/" title="[11/20] 튜플">
                        <span class="hidden-mobile">[11/20] 튜플</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://dev-bearabbit.github.io" target="_blank" rel="nofollow noopener"><span>Jess</span></a>
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
