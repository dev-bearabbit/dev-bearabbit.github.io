

<!DOCTYPE html>
<html lang="ko" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="alternate" hreflang="ko" href="https://dev-bearabbit.github.io/" />
  <link rel="alternate" hreflang="en" href="https://dev-bearabbit.github.io/en/" />  
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" href="/img/favicon.ico">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#000">
  <meta name="author" content="Jess">
  <meta name="keywords" content="">
  
    <meta name="description" content="글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.  이 포스트는 Subtyping를 한글로 요약 정리한 글입니다.">
<meta property="og:type" content="article">
<meta property="og:title" content="[17&#x2F;20] 서브타이핑">
<meta property="og:url" content="https://dev-bearabbit.github.io/ko/ThinkJulia/Think-Julia-Chapter-17/index.html">
<meta property="og:site_name" content="DEV AnythinG">
<meta property="og:description" content="글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.  이 포스트는 Subtyping를 한글로 요약 정리한 글입니다.">
<meta property="og:locale" content="ko_KR">
<meta property="og:image" content="https://dev-bearabbit.github.io/images/24.png">
<meta property="article:published_time" content="2020-03-17T17:02:40.000Z">
<meta property="article:modified_time" content="2025-02-08T14:08:19.471Z">
<meta property="article:author" content="Jess">
<meta property="article:tag" content="줄리아">
<meta property="article:tag" content="Julia">
<meta property="article:tag" content="Think Julia">
<meta property="article:tag" content="기초 강의">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://dev-bearabbit.github.io/images/24.png">
  
  
  
  <title>[17/20] 서브타이핑 - DEV AnythinG</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"dev-bearabbit.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":"G-QW3E4LZZNF"},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=G-QW3E4LZZNF", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', 'G-QW3E4LZZNF');
        });
      }
    </script>
  

  

  

  



  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>DEV AnythinG</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="javascript:;" id="languageDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <i class="iconfont icon-globe"></i> <span id="current-lang"></span>
          </a>
          <div class="dropdown-menu" aria-labelledby="languageDropdown">
            <a class="dropdown-item" href="/">한국어</a>
            <a class="dropdown-item" href="/en/">English</a>
          </div>
        </li>
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    // 현재 언어를 URL 기반으로 감지
    const path = window.location.pathname;
    const currentLang = path.startsWith('/en/') ? 'English' : '한국어';

    // 선택된 언어를 버튼에 표시
    const currentLangElement = document.getElementById('current-lang');
    currentLangElement.textContent = currentLang;
  });
</script>

  

<div id="banner" class="banner" parallax=true
  style="background: url('/img/background.gif') no-repeat center center; background-size: cover;">
  <canvas id="canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></canvas>
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="[17/20] 서브타이핑"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2020-03-18 02:02" pubdate>
          2020년 3월 18일 오전
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          1.1k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          10 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // 캔버스 크기를 배너 크기와 동기화
  const banner = document.getElementById('banner');

  function updateCanvasSize() {
    // 1️⃣ 먼저 블랙으로 채운 후 크기 변경 (리사이징 깜빡임 방지)
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // 2️⃣ 크기 변경 후 다시 블랙으로 덮기
    canvas.width = banner.offsetWidth;
    canvas.height = banner.offsetHeight;

    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  updateCanvasSize(); // 초기에 캔버스 크기 설정

  const cols = Math.floor(canvas.width / 20) + 1;
  const ypos = Array(cols).fill(0);

  function matrix() {
    // ✅ 페이드 효과 유지 (배경을 점점 지우는 효과)
    ctx.fillStyle = '#0001'; // 배경 페이드 효과
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = '#009600'; // 텍스트 색상
    ctx.font = '14pt monospace';

    ypos.forEach((y, index) => {
      const text = String.fromCharCode(33 + Math.random() * 94); // 랜덤 ASCII 문자
      const x = index * 20;
      ctx.fillText(text, x, y);

      if (y > canvas.height + Math.random() * 10000) ypos[index] = 0;
      else ypos[index] = y + 20;
    });
  }

  setInterval(matrix, 60);

  // ✅ 화면에 다시 나타날 때 검은색 유지 (모바일 스크롤 최적화)
  const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
      });
    }, { threshold: 0.1 });

  observer.observe(canvas);

  // 창 크기 조정 시 캔버스 크기 업데이트
  let isTouching = false;

  // 터치 이벤트 중에는 resize 실행 방지
  window.addEventListener('touchstart', () => { isTouching = true; });
  window.addEventListener('touchend', () => {
    setTimeout(() => { isTouching = false; }, 500); // 터치 종료 후 500ms 후 재활성화
  });

  window.addEventListener('resize', () => {
    if (isTouching) return; // 터치 중이면 resize 무시
    updateCanvasSize(); // 리사이징 시 블랙 유지
  });
});
</script>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">[17/20] 서브타이핑</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>글을 시작하기에 앞서 해당 시리즈는 Allen Downey, Ben Lauwens의 저서인 Think Julia: How to Think Like a Computer Scientist 를 바탕으로 작성된 글임을 알려드립니다.</p>
</blockquote>
<p>이 포스트는 <a target="_blank" rel="noopener" href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#chap18">Subtyping</a>를 한글로 요약 정리한 글입니다. <span id="more"></span></p>
<h2 id="서브타이핑-subtyping">서브타이핑 (Subtyping)</h2>
<p>이전 장에서는 다중 디스패치 매커니즘과 폴리모픽 메서드에 대해서 알아보았다. 인수 데이터 타입을 지정하지 않으면 모든 데이터 타입이 인수로 사용가능한 메서드가 생성된다. 메서드에서 허용된 데이터 타입의 서브셋(subset)을 지정하는 것은 다음 단계이다.</p>
<p>이번 장에서는 카드 놀이에서의 카드 덱 및 포커 패를 나타내는 데이터 타입을 사용한 서브타이핑을 볼 것이다. 만약 포커를 해본 적이 없다면, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Poker">해당 링크</a>에서 관련 정보를 읽을 수 있다.</p>
<h3 id="카드">카드</h3>
<p>덱에 4개의 모양과 13개의 순위로 조합된 52개의 카드가 있다. 모양은 하트(<code>♥</code>), 스페이드(<code>♠</code>), 다이아몬드(<code>♦</code>), 클로버(<code>♣</code>)으로 구성되어 있다. 순위는 에이스(A), 2, 3, 4, 5, 6, 7, 8, 9, 10, 잭(J), 퀸(Q), 킹(K)으로 나눠져있다. 게임을 진행할 때는 에이스가 킹보다 높으며 2보다는 낮다.</p>
<p>카드를 표현하기 위해 새로운 객체를 정의한다면, 객체는 무슨 속성을 가져야 하는지가 명확하다. 바로 모양과 순위이다. 하지만 이 사실이 어떤 데이터 타입의 속성이어야 하는지와 연결되지는 않는다. 한 가지 방안은 <code>"Spade"</code>와 <code>"Queen"</code>처럼 문자열을 사용하는 것이다. 이런 구현의 문제점은 카드들의 순위와 모양을 비교하는 것이 어렵다는 점이다.</p>
<p>대안으로는 모양과 순위를 인코드(encode)하기 위해 정수를 사용하는 것이다. 인코드(encode)란 숫자와 모양 또는 숫자와 순위 사이에 매핑을 정의하는 것을 의미한다. 이런 종류의 인코딩은 암호화(encryption)이다.</p>
<p>예를 들어 아래의 정보는 각 모양과 이에 연결되는 정수 코드를 보여준다.</p>
<ul>
<li><code>♠</code> -&gt; 4</li>
<li><code>♥</code> -&gt; 3</li>
<li><code>♦</code> -&gt; 2</li>
<li><code>♣</code> -&gt; 1</li>
</ul>
<p>이 코드는 높은 값의 모양은 높은 숫자에 매핑했기 때문에 카드들을 비교하기가 더 쉽다. 우리는 카드들의 정수 코드를 사용하여 비교할 수 있다.</p>
<p>위에서 사용한 <code>-&gt;</code> 기호는 줄리아 프로그램에서 사용하는 것은 아니지만 매핑을 명확히 보여주기 위해서 사용한 것이다. 이와 같은 기호들은 프로그램 디자인의 일부이며, 코드에는 나타나지 않는다.</p>
<p><code>Card</code> 구조체의 정의는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">struct</span> Card<br>    suit :: <span class="hljs-built_in">Int64</span><br>    rank :: <span class="hljs-built_in">Int64</span><br>    <span class="hljs-keyword">function</span> Card(suit::<span class="hljs-built_in">Int64</span>, rank::<span class="hljs-built_in">Int64</span>)<br>        <span class="hljs-meta">@assert</span>(<span class="hljs-number">1</span> ≤ suit ≤ <span class="hljs-number">4</span>, <span class="hljs-string">&quot;suit is not between 1 and 4&quot;</span>)<br>        <span class="hljs-meta">@assert</span>(<span class="hljs-number">1</span> ≤ rank ≤ <span class="hljs-number">13</span>, <span class="hljs-string">&quot;rank is not between 1 and 13&quot;</span>)<br>        new(suit, rank)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p><code>Card</code>를 만들기 위해서는 <code>Card()</code>에 원하는 모양과 순위를 넣어 호출해야 한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; queen_of_diamonds = Card(<span class="hljs-number">2</span>, <span class="hljs-number">12</span>)<br>Card(<span class="hljs-number">2</span>, <span class="hljs-number">12</span>)<br></code></pre></td></tr></table></figure>
<h3 id="글로벌-변수-global-variables">글로벌 변수 (Global Variables)</h3>
<p>사람들이 쉽게 읽을 수 있도록 하는 <code>Card</code> 객체를 출력하기 위해서는 정수 코드로 매핑된 모양과 순위가 필요하다. 보편적인 방법은 문자열 배열로 만드는 것이다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">const</span> suit_names = [<span class="hljs-string">&quot;♣&quot;</span>, <span class="hljs-string">&quot;♦&quot;</span>, <span class="hljs-string">&quot;♥&quot;</span>, <span class="hljs-string">&quot;♠&quot;</span>]<br><span class="hljs-keyword">const</span> rank_names = [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>, <span class="hljs-string">&quot;7&quot;</span>, <span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-string">&quot;9&quot;</span>, <span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;J&quot;</span>, <span class="hljs-string">&quot;Q&quot;</span>, <span class="hljs-string">&quot;K&quot;</span>]<br></code></pre></td></tr></table></figure>
<p><code>suit_names</code>과 <code>rank_names</code>은 글로벌 변수이다. <code>const</code> 선언은 변수가 오직 하나에만 할당되도록 한다. 이것은 글로벌 변수들의 실행 문제들을 해결해준다.</p>
<p>이제 우리는 적절한 <code>show</code> 메서드를 구현할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> Base.show(io::<span class="hljs-built_in">IO</span>, card::Card)<br>    print(io, rank_names[card.rank], suit_names[card.suit])<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p><code>rank_names[card.rank]</code> 표현식은 "<code>rank_names</code> 배열의 인덱스로 <code>Card</code> 객체의 <code>rank</code>필드를 사용하라 그리고 알맞은 인수를 선택하라" 를 표현한 것이다.</p>
<p>지금까지 완성한 메서드를 사용하면, 우리는 출력된 카드를 얻을 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; Card(<span class="hljs-number">3</span>, <span class="hljs-number">11</span>)<br>J♥<br></code></pre></td></tr></table></figure>
<h3 id="카드-비교하기-comparing-cards">카드 비교하기 (Comparing Cards)</h3>
<p>내장 데이터 타입에서는 관계 연산자(<code>&lt;</code>, <code>&gt;</code>, <code>==</code>, etc.)가 값들을 비교하여 큰지, 작은지 또는 같은지를 결정한다. 하지만 개발자가 정의한 고유 데이터 타입에서는 <code>&lt;</code> 메서드를 제공하여 내장 연산자들의 실행을 가져올 수 있다.</p>
<p>카드를 정확하게 순서대로 나열하는 것은 명확하지 않다. 예를 들어 3 클로버와 2 다이아몬드 중에 무엇이 더 나은가? 하나는 보다 높은 순위지만 낮은 모양이고, 다른 것은 낮은 순위지만 높은 모양이다. 카드들을 비교하기 위해서는 순위와 모양 중 무엇이 더 중요한지를 결정해야 한다.</p>
<p>답은 아마 게임을 어떤 게임을 하고 있는지에 따라서 나뉘겠지만, 간단하게 하기 위해서 우리는 모양이 더 중요하다고 임의로 선택할 것이다. 따라서 모든 스페이드는 모든 다이아몬드보다 더 중요하다.</p>
<p>해당 사항을 <code>&lt;</code>로 작성할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">import</span> Base.&lt;<br><br><span class="hljs-keyword">function</span> &lt;(c1::Card, c2::Card)<br>    (c1.suit, c1.rank) &lt; (c2.suit, c2.rank)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<h3 id="유닛-테스팅-unit-testing">유닛 테스팅 (Unit Testing)</h3>
<p>유닛 테스팅은 코드가 예상했던 대로 정확하게 작동하는지 확인해준다. 이 방법은 코드 수정 후에도 제대로 작동하는지 확인하기 위해서 사용하며, 또한 개발 중에도 코드 실행이 잘 작동하는지 미리 정의해볼 수 있다.</p>
<p>간단한 유닛 테스팅은 <code>@test</code>메크로로 실행된다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-keyword">using</span> Test<br><br>julia&gt; <span class="hljs-meta">@test</span> Card(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>) &lt; Card(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)<br>Test Passed<br>julia&gt; <span class="hljs-meta">@test</span> Card(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) &lt; Card(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)<br>Test Passed<br></code></pre></td></tr></table></figure>
<p>만약 따라오는 표현식이 <code>true</code>라면 <code>@test</code>는 <code>"Test Passed"</code>를 반환하고 <code>false</code>라면 <code>"Test Failed"</code>를 반환한다 그리고 표현식이 아예 평가될 수 없다면 <code>"error result"</code>를 반환한다.</p>
<h3 id="덱-decks">덱 (Decks)</h3>
<p>지금까지는 카드를 만들었으며, 다음 단계로는 덱을 정의하는 것이다. 덱은 카드로 만들어졌기 때문에 각각의 덱은 카드 배열을 속성으로서 포함하는 것이 당연하다.</p>
<p>아래는 <code>Deck</code> 구조체 정의이다. 생성자는 필드로 <code>cards</code>를 가지며, 52개 카드의 기본 세트를 일반화한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">struct</span> Deck<br>    cards :: <span class="hljs-built_in">Array</span>&#123;Card, <span class="hljs-number">1</span>&#125;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> Deck()<br>    deck = Deck(Card[])<br>    <span class="hljs-keyword">for</span> suit <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:<span class="hljs-number">4</span><br>        <span class="hljs-keyword">for</span> rank <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:<span class="hljs-number">13</span><br>            push!(deck.cards, Card(suit, rank))<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    deck<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p>덱을 채우는 가장 쉬운 방법은 '중첩 루프(nested loop)'를 사용하는 것이다. 바깥의 루프는 1부터 4까지의 모양을 열거하며, 내부의 루프는 1부터 13의 순위를 열거한다. 각 반복은 최신의 모양과 순위를 포함한 새로운 <code>Card</code>를 생성하여 <code>deck.cards</code>에 밀어넣는다.</p>
<p>아래는 <code>Deck</code>을 보여주는 <code>show</code>메서드이다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> Base.show(io::<span class="hljs-built_in">IO</span>, deck::Deck)<br>    <span class="hljs-keyword">for</span> card <span class="hljs-keyword">in</span> deck.cards<br>        print(io, card, <span class="hljs-string">&quot; &quot;</span>)<br>    <span class="hljs-keyword">end</span><br>    println()<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p>결과는 아래와 같다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; Deck()<br>A♣ <span class="hljs-number">2</span>♣ <span class="hljs-number">3</span>♣ <span class="hljs-number">4</span>♣ <span class="hljs-number">5</span>♣ <span class="hljs-number">6</span>♣ <span class="hljs-number">7</span>♣ <span class="hljs-number">8</span>♣ <span class="hljs-number">9</span>♣ <span class="hljs-number">10</span>♣ J♣ Q♣ K♣ A♦ <span class="hljs-number">2</span>♦ <span class="hljs-number">3</span>♦ <span class="hljs-number">4</span>♦ <span class="hljs-number">5</span>♦ <span class="hljs-number">6</span>♦ <span class="hljs-number">7</span>♦ <span class="hljs-number">8</span>♦ <span class="hljs-number">9</span>♦ <span class="hljs-number">10</span>♦ J♦ Q♦ K♦ A♥ <span class="hljs-number">2</span>♥ <span class="hljs-number">3</span>♥ <span class="hljs-number">4</span>♥ <span class="hljs-number">5</span>♥ <span class="hljs-number">6</span>♥ <span class="hljs-number">7</span>♥ <span class="hljs-number">8</span>♥ <span class="hljs-number">9</span>♥ <span class="hljs-number">10</span>♥ J♥ Q♥ K♥ A♠ <span class="hljs-number">2</span>♠ <span class="hljs-number">3</span>♠ <span class="hljs-number">4</span>♠ <span class="hljs-number">5</span>♠ <span class="hljs-number">6</span>♠ <span class="hljs-number">7</span>♠ <span class="hljs-number">8</span>♠ <span class="hljs-number">9</span>♠ <span class="hljs-number">10</span>♠ J♠ Q♠ K♠<br></code></pre></td></tr></table></figure>
<h3 id="추가-제거-셔플-그리고-정렬">추가, 제거, 셔플 그리고 정렬</h3>
<p>카드를 다루려면 덱으로부터 카드를 제거하고 반환하는 함수가 필요하다. <code>pop!()</code>은 편리하게 이를 수행할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> Base.pop!(deck::Deck)<br>    pop!(deck.cards)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p><code>pop!()</code>은 배열에서 마지막 카드를 제거하기 때문에</p>
<p>카드를 추가하기 위해서는 <code>push!()</code>를 사용하면 된다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> Base.push!(deck::Deck, card::Card)<br>    push!(deck.cards, card)<br>    deck<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p>한번에 많은 작업들을 수행하지 않고 다른 메서드를 사용하는 방식을 '비니어(veneer)'라고도 부른다. 비니어는 원래 목공에서 사용되는 단어이며, 고급스럽게 보이기 위해 싼 목재 표면에 비싼 목재를 붙일 때 사용되는 고품질의 얇은 층을 의미한다. 이 예시에서 <code>push!</code>는 덱에 알맞는 배열 작동을 표현하는 얇은 메서드이며, 이 방식은 구현의 인터페이스나 외관을 향상시킨다.</p>
<p>또 다른 예시로서, <code>Random</code>을 사용하여 <code>suffle!()</code>이라는 함수를 작성해보자.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">using</span> Random<br><br><span class="hljs-keyword">function</span> Random.shuffle!(deck::Deck)<br>    shuffle!(deck.cards)<br>    deck<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<h3 id="추상-데이터-타입과-서브타이핑">추상 데이터 타입과 서브타이핑</h3>
<p>우리는 카드를 들고 있는 '손'을 표현하는 데이터 타입을 원한다. 손과 덱은 카드 모음을 만들고 추가 및 제거 작동이 필요하다는 점에서 비슷하다. 하지만 손과 덱은 다른 점도 분명히 있다. 예를 들어 포커에서는 두 손을 비교하여 누가 이길지를 비교해야 하고, 각 손의 점수를 계산해야 한다.</p>
<p>그래서 구체적인 데이터 타입을 그룹화하는 방법이 필요하다. 줄리아에서는 덱과 손의 부모처럼 제공하는 '추상 데이터 타입(abstract type)'을 정의하여 제공한다. 이를 '서브타이핑(subtyping)'이라고 한다.</p>
<p>추상 데이터 타입인 <code>CardSet</code>을 불러오자.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">abstract type</span> CardSet <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p>새로운 추상 데이터 타입은 <code>abstract type</code>으로 생성된다. 선택적인 "부모" 데이터 타입도 존재하는 추상 데이터 타입을 <code>&lt;:</code> 뒤에 작성함으로써 구체회될 수 있다.</p>
<p><code>supretype</code>이 주어지지 않으면, 기본 <code>supretype</code>은 <code>Any</code>로 지정된다. <code>Any</code>는 모든 객체가 인스턴스이고 모든 데이터 타입이 서브타입인 추상 데이터 타입이다.</p>
<p>지금부터는 <code>CardSet</code>의 자식인 <code>Deck</code>읖 나타낼 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">struct</span> Deck &lt;: CardSet<br>    cards :: <span class="hljs-built_in">Array</span>&#123;Card, <span class="hljs-number">1</span>&#125;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> Deck()<br>    deck = Deck(Card[])<br>    <span class="hljs-keyword">for</span> suit <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:<span class="hljs-number">4</span><br>        <span class="hljs-keyword">for</span> rank <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:<span class="hljs-number">13</span><br>            push!(deck.cards, Card(suit, rank))<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    deck<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p><code>isa</code>연산자는 해당 객체가 주어진 데이터 타입이 맞는지 확인해준다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; deck = Deck();<br><br>julia&gt; deck <span class="hljs-keyword">isa</span> CardSet<br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
<p>또한 손도 <code>CardSet</code>의 종류 중 하나이다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">struct</span> Hand &lt;: CardSet<br>    cards :: <span class="hljs-built_in">Array</span>&#123;Card, <span class="hljs-number">1</span>&#125;<br>    label :: <span class="hljs-built_in">String</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> Hand(label::<span class="hljs-built_in">String</span>=<span class="hljs-string">&quot;&quot;</span>)<br>    Hand(Card[], label)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p>52개의 새로운 카드를 손에 채우는 대신, <code>Hand</code> 생성자는 <code>cards</code>를 빈 배열과 함께 초기화한다. 선택적 인수는 생성자에 전달되어 <code>Hand</code>에 라벨을 제공한다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; hand = Hand(<span class="hljs-string">&quot;new hand&quot;</span>)<br>Hand(Card[], <span class="hljs-string">&quot;new hand&quot;</span>)<br></code></pre></td></tr></table></figure>
<h3 id="추상-데이터-타입과-함수">추상 데이터 타입과 함수</h3>
<p>이제부터는 <code>CardSet</code>을 인수로 가진 함수를 통해 <code>Deck</code>과 <code>Hand</code> 사이의 공통 작업을 표현할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> Base.show(io::<span class="hljs-built_in">IO</span>, cs::CardSet)<br>    <span class="hljs-keyword">for</span> card <span class="hljs-keyword">in</span> cs.cards<br>        print(io, card, <span class="hljs-string">&quot; &quot;</span>)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> Base.pop!(cs::CardSet)<br>    pop!(cs.cards)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> Base.push!(cs::CardSet, card::Card)<br>    push!(cs.cards, card)<br>    <span class="hljs-literal">nothing</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p>카드를 다루기 위해 <code>pop!()</code>과 <code>push!()</code>를 사용할 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; deck = Deck()<br>A♣ <span class="hljs-number">2</span>♣ <span class="hljs-number">3</span>♣ <span class="hljs-number">4</span>♣ <span class="hljs-number">5</span>♣ <span class="hljs-number">6</span>♣ <span class="hljs-number">7</span>♣ <span class="hljs-number">8</span>♣ <span class="hljs-number">9</span>♣ <span class="hljs-number">10</span>♣ J♣ Q♣ K♣ A♦ <span class="hljs-number">2</span>♦ <span class="hljs-number">3</span>♦ <span class="hljs-number">4</span>♦ <span class="hljs-number">5</span>♦ <span class="hljs-number">6</span>♦ <span class="hljs-number">7</span>♦ <span class="hljs-number">8</span>♦ <span class="hljs-number">9</span>♦ <span class="hljs-number">10</span>♦ J♦ Q♦ K♦ A♥ <span class="hljs-number">2</span>♥ <span class="hljs-number">3</span>♥ <span class="hljs-number">4</span>♥ <span class="hljs-number">5</span>♥ <span class="hljs-number">6</span>♥ <span class="hljs-number">7</span>♥ <span class="hljs-number">8</span>♥ <span class="hljs-number">9</span>♥ <span class="hljs-number">10</span>♥ J♥ Q♥ K♥ A♠ <span class="hljs-number">2</span>♠ <span class="hljs-number">3</span>♠ <span class="hljs-number">4</span>♠ <span class="hljs-number">5</span>♠ <span class="hljs-number">6</span>♠ <span class="hljs-number">7</span>♠ <span class="hljs-number">8</span>♠ <span class="hljs-number">9</span>♠ <span class="hljs-number">10</span>♠ J♠ Q♠ K♠<br>julia&gt; shuffle!(deck)<br>J♦ <span class="hljs-number">10</span>♣ <span class="hljs-number">8</span>♠ <span class="hljs-number">9</span>♥ <span class="hljs-number">5</span>♠ <span class="hljs-number">7</span>♣ <span class="hljs-number">6</span>♦ A♠ J♣ <span class="hljs-number">7</span>♠ <span class="hljs-number">5</span>♦ <span class="hljs-number">10</span>♥ <span class="hljs-number">3</span>♦ <span class="hljs-number">9</span>♦ <span class="hljs-number">9</span>♣ <span class="hljs-number">4</span>♣ <span class="hljs-number">8</span>♦ <span class="hljs-number">8</span>♥ <span class="hljs-number">5</span>♣ A♥ K♥ K♦ K♠ <span class="hljs-number">4</span>♦ A♦ Q♥ <span class="hljs-number">6</span>♠ <span class="hljs-number">2</span>♦ <span class="hljs-number">6</span>♥ <span class="hljs-number">2</span>♣ <span class="hljs-number">10</span>♠ <span class="hljs-number">3</span>♥ <span class="hljs-number">2</span>♥ J♥ Q♣ <span class="hljs-number">5</span>♥ <span class="hljs-number">2</span>♠ <span class="hljs-number">9</span>♠ <span class="hljs-number">10</span>♦ Q♠ <span class="hljs-number">3</span>♠ <span class="hljs-number">8</span>♣ K♣ <span class="hljs-number">7</span>♥ <span class="hljs-number">3</span>♣ J♠ <span class="hljs-number">4</span>♥ <span class="hljs-number">6</span>♣ <span class="hljs-number">7</span>♦ <span class="hljs-number">4</span>♠ A♣ Q♦<br>julia&gt; card = pop!(deck)<br>Q♦<br>julia&gt; push!(hand, card)<br></code></pre></td></tr></table></figure>
<p>자연스러운 다음 단계는 <code>move!()</code>에서 해당 코드를 캡슐화하는 것이다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> move!(cs1::CardSet, cs2::CardSet, n::<span class="hljs-built_in">Int</span>)<br>    <span class="hljs-meta">@assert</span> <span class="hljs-number">1</span> ≤ n ≤ length(cs1.cards)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:n<br>        card = pop!(cs1)<br>        push!(cs2, card)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-literal">nothing</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p><code>move!()</code>는 두 개의 <code>CardSet</code> 객체와 카드를 처리할 수까지 총 세 개의 인수를 가져간다. 두 개의 <code>CardSet</code> 객체는 변경가능하며, <code>nothing</code>을 반환한다.</p>
<p>게임에서 카드들은 한 손에서 다른 손으로 가거나 손에서 덱으로 이동한다. 이런 작동들은 모두 <code>move!()</code>를 사용하면 된다. 즉, <code>cs1</code>과 <code>cs2</code>는 <code>Deck</code>이나 <code>hand</code>일 수 있다.</p>
<h3 id="데이터-타입-다이어그램">데이터 타입 다이어그램</h3>
<p>지금까지는 프로그램의 상태를 보여주는 스택 다이어그램과 객체와 값의 속성을 보여주는 객체 다이어그램을 살펴보았다. 이런 다이어그램들은 프로그램 실행에서 스냅샷을 나타내므로 프로그램이 실행되면 이들도 변한다.</p>
<p>또한 다이어그램은 가끔 과도하게 상세하다. '데이터 타입 다이어그램(type diagram)'은 프로그램 구조를 더 추상적으로 표현한다. 개별적인 객체를 모두 보여주는 것 대신에 데이터 타입의 관계만을 보여준다.</p>
<p>데이터 타입 사이의 관계의 종류는 여러 가지이다.</p>
<ul>
<li><p>구체적인 데이터 타입의 객체는 다른 데이터 타입의 객체로부터 참조를 포함할 수 있다. 에를 들어, 각 직사각형은 Point의 참조를 포함하고, 덱은 카드 배열의 참조를 포함한다. 이런 관계의 종류는 "HAS-A"라고 한다. 즉, “직사각형은 포인트를 참조한다 (a Rectangle has a Point)” 인 것이다.</p></li>
<li><p>구체적인 데이터 타입은 서브데이터 타입으로서 추상 데이터 타입을 가진다. 이런 관계의 종류를 "IS-A"이다. 즉, "손은 Cardset의 종류이다.(a Hand is a kind of a CardSet)" 이다.</p></li>
<li><p>한 데이터 타입의 객체는 다른 데이터 타입의 객체를 매개 변수로 사용하거나 계산의 일부로 사용한다는 점에서 다른 데이터 타입에 따라 달라질 수 있다. 이런 관계를 "종속성(dependency)"이라고 한다.</p></li>
</ul>
<figure>
<img src="/images/24.png" srcset="/img/loading.gif" lazyload alt="type diagram" /><figcaption aria-hidden="true">type diagram</figcaption>
</figure>
<p>위의 다이어그램에서 속인 빈 화살표는 IS-A 관계를 보여준다. Hand는 CardSet의 서브데이터 타입을 가지고 있다.</p>
<p>일반적인 화살표는 HAS-A 관계를 보여준다. Deck은 Card객체를 참조한다.</p>
<p>옆에 *를 가진 화살표는 다수(multiplicity)이다. 이것은 Deck이 얼마나 많은 카드를 가지고 있는지를 표시한다. 다수(multiplicity)는 <code>52</code>와 같은 간단한 숫자나 <code>like 5:7</code>같은 범위, Deck이 여러 개의 Cards를 가진다는 별 표시 등으로 표현된다.</p>
<p>종속성은 위의 다이어그램에 없다. 일반적으로 종속성은 점선 화살표로 표시되며, 종속성이 많을 때에는 생략되기도 한다.</p>
<p>다이어그램의 세부사항들은 Deck이 카드들의 배열을 포함한다는 것을 보여주지만, 배열이나 딕셔너리같은 내장 데이터 타입들은 보통 타입 다이어그램에 포함되지 않는다.</p>
<h3 id="디버깅">디버깅</h3>
<p>서브타이핑은 객체를 인수로 가진 함수를 호출할 때 어떤 메서드가 호출되는지 파악하기 힘드므로 디버깅하기 어렵게 만든다.</p>
<p><code>Hand</code>객체에서 작동하는 함수를 작성한다고 가정해보자. 그러면 <code>+PokerHand+s</code>, <code>+BridgeHand+s</code>와 같은 <code>hand+s</code>의 모든 종류들에 작동할 수 있도록 만들고 싶을 것이다. <code>+sort!</code>와 같은 메서드를 호출하면 추상 데이터 타입인 <code>Hand</code>에 대해 정의된 메서드를 얻을 수 있다. 하지만 서브데이터 타입 중 하나를 인수로 사용하는 <code>sort!</code>메서드가 존재한다면, 아레의 버전을 얻게 될 것이다. 이런 방식은 보통 좋지만, 때로는 헷갈릴 수 있다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> Base.sort!(hand::Hand)<br>    sort!(hand.cards)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p>프로그램을 통한 실행 흐름에 대해 확실할 수 없는 경우 가장 간단한 해결책은 관련 메서드 시작부분에 <code>print</code>문을 추가하는 것이다. <code>shuffle!</code>이 <code>Running shuffle! Deck</code>과 같은 메시지를 출력하면, 프로그램이 작동할 때 실행 흐름을 추적한다.</p>
<p>더 나은 대안으로는 <code>@which</code> 매크로를 사용하는 것이다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; <span class="hljs-meta">@which</span> sort!(hand)<br>sort!(hand::Hand) <span class="hljs-keyword">in</span> Main at REPL[<span class="hljs-number">5</span>]:<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>그러면 <code>Hand</code>의 <code>sort!</code> 메서드는 인수로서 <code>Hand</code> 데이터 타입의 객체 하나를 가진다.</p>
<p>설계 제안은 다음과 같다. 메서드를 재정의(override)할 때, 새로운 메서드의 인터페이스는 이전 메서드와 동일해야 한다. 동일한 매개 변수를 가져가고 동일한 데이터 타입을 반환하며 동이란 전제 조건 및 사후 조건을 준수해야 한다. 이 조건을 따른다면, <code>CardSet</code>과 같은 supertype의 인스턴스와 같이 작동하도록 설계된 함수가 서브데이터 타입인 <code>Deck</code>과 <code>Hand</code>의 인스턴스에도 작동한다는 것을 알 수 있다.</p>
<p>이와 같은 '리스코프 치환 규칙(Liskov substitution principle)'을 어긴다면, 해당 코드는 아마 붕괴할 것이다.</p>
<p><code>supertype()</code>은 데이터 타입의 supertype을 찾아준다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">julia&gt; supertype(Deck)<br>CardSet<br></code></pre></td></tr></table></figure>
<h3 id="데이터-캡슐화">데이터 캡슐화</h3>
<p>이전 섹션에서는 '데이터 타입 지향 디자인 (type-oriented design)'이라는 개발 계획을 보여줬다. 우리는 <code>Point</code>,<code>Rectangle</code>,<code>MyTime</code>과 같이 필요한 객체들을 확인하고, 그들을 표현하기 위해 구조체를 정의하였다. 각각의 경우에는 객체와 현실세계의 실체 사이에 명백한 대응 관계가 있다.</p>
<p>그러나 때로는 어떤 객체가 필요한지, 어떻게 상호작용해야 하는지 명확하지 않다. 이 경우에는 다른 개발 계획이 필요하다. 캡슐화와 일반화를 통해 함수 인터페이스로 발견한 것과 같은 방식으로 우리는 데이터 캡슐화를 통해 데이터 타입 인터페이스를 발견할 수 있다.</p>
<p><a href="https://dev-bearabbit.github.io/ko/ThinkJulia/Think-Julia-Chapter-12/">12장</a>에서 본 마르코프 분석이 좋은 예시이다. 아래의 코드는 글로벌 변수인 <code>prefix</code>와 <code>suffixes</code>를 정의한 것이다. 이 변수들은 여러 함수에서 사용될 것이다.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Julia">suffixes = <span class="hljs-built_in">Dict</span>()<br>prefix = []<br></code></pre></td></tr></table></figure>
<p>위의 변수들은 글로벌 변수이기 때문에 한 번에 하나의 분석만 실행할 수 있다. 두 개의 텍스트를 읽으면 접두사와 접미사가 동일한 데이터 구조에 추가되어 흥미로운 생성 텍스트가 만들어진다.</p>
<p>여러 분석을 실행하고, 별도로 유지하기 위해서는 각 분석의 상태를 객체에 캡슐화할 수 있다. 아래의 코드를 통해 확인하자.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">struct</span> Markov<br>    order :: <span class="hljs-built_in">Int64</span><br>    suffixes :: <span class="hljs-built_in">Dict</span>&#123;<span class="hljs-built_in">Tuple</span>&#123;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">Vararg</span>&#123;<span class="hljs-built_in">String</span>&#125;&#125;, <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">String</span>, <span class="hljs-number">1</span>&#125;&#125;<br>    prefix :: <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">String</span>, <span class="hljs-number">1</span>&#125;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> Markov(order::<span class="hljs-built_in">Int64</span>=<span class="hljs-number">2</span>)<br>    new(order, <span class="hljs-built_in">Dict</span>&#123;<span class="hljs-built_in">Tuple</span>&#123;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">Vararg</span>&#123;<span class="hljs-built_in">String</span>&#125;&#125;, <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">String</span>, <span class="hljs-number">1</span>&#125;&#125;(), <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">String</span>, <span class="hljs-number">1</span>&#125;())<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p>그 다음, 함수를 메서드를 변환한다. 예를 들어 아래의 <code>processword</code>를 보자.</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Julia"><span class="hljs-keyword">function</span> processword(markov::Markov, word::<span class="hljs-built_in">String</span>)<br>    <span class="hljs-keyword">if</span> length(markov.prefix) &lt; markov.order<br>        push!(markov.prefix, word)<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">end</span><br>    get!(markov.suffixes, (markov.prefix...,), <span class="hljs-built_in">Array</span>&#123;<span class="hljs-built_in">String</span>, <span class="hljs-number">1</span>&#125;())<br>    push!(markov.suffixes[(markov.prefix...,)], word)<br>    popfirst!(markov.prefix)<br>    push!(markov.prefix, word)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p>작동을 변경하지 않고 디자인만 변경하는 프로그램 변환은 <a href="https://dev-bearabbit.github.io/ko/ThinkJulia/Think-Julia-Chapter-3/#%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81">리팩토링</a>의 또 다른 예시이다.</p>
<p>이 예시는 데이터 타입 설계를 위한 개발 계획을 제시한다.</p>
<ul>
<li><p>글로벌 변수를 읽고 쓰는 함수를 시작하시오.</p></li>
<li><p>프로그램이 작동하면 전역 변수들과 그들을 사용하는 함수 사이의 연관성을 찾으시오.</p></li>
<li><p>관련 변수를 구조체의 필드로서 캡슐화하시오.</p></li>
<li><p>연관된 함수들을 새로운 데이터 타입의 객체가 인수인 메서드로 변환하시오.</p></li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/serieshub/" class="category-chain-item">SeriesHub</a>
  
  
    <span>></span>
    
  <a href="/categories/serieshub/think-julia/" class="category-chain-item">think julia</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%EC%A4%84%EB%A6%AC%EC%95%84/" class="print-no-link">#줄리아</a>
      
        <a href="/tags/julia/" class="print-no-link">#Julia</a>
      
        <a href="/tags/think-julia/" class="print-no-link">#Think Julia</a>
      
        <a href="/tags/%EA%B8%B0%EC%B4%88-%EA%B0%95%EC%9D%98/" class="print-no-link">#기초 강의</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>[17/20] 서브타이핑</div>
      <div>https://dev-bearabbit.github.io/ko/ThinkJulia/Think-Julia-Chapter-17/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Jess</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>2020년 3월 18일</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/ko/Algorithms/Algorithms-0/" title="Big-O 표기법">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Big-O 표기법</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/ko/ThinkJulia/Think-Julia-Chapter-16/" title="[16/20] 다중 디스패치">
                        <span class="hidden-mobile">[16/20] 다중 디스패치</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://dev-bearabbit.github.io" target="_blank" rel="nofollow noopener"><span>Jess</span></a>
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
